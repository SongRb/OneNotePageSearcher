<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICU4N</name>
    </assembly>
    <members>
        <member name="M:ICU4N.Globalization.CharSequences.Equals``1(``0,``0)">
            <summary>
            Utility function for comparing objects that may be null
            string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.String,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.String,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Text.StringBuilder,System.String,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Text.StringBuilder,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Text.StringBuilder,System.Char[],System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Char[],System.String,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Char[],System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Char[],System.Char[],System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(System.Char[],ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(ICU4N.Support.Text.ICharSequence,System.String,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(ICU4N.Support.Text.ICharSequence,System.Char[],System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.MatchAfter(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePointLength(System.String)">
            <summary>
            Count the code point length. Unpaired surrogates count as 1.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePointLength(System.Text.StringBuilder)">
            <summary>
            Count the code point length. Unpaired surrogates count as 1.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePointLength(System.Char[])">
            <summary>
            Count the code point length. Unpaired surrogates count as 1.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePointLength(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Count the code point length. Unpaired surrogates count as 1.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Equals(System.Int32,System.String)">
            <summary>
            Utility function for comparing codepoint to string without generating new
            string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Equals(System.Int32,System.Text.StringBuilder)">
            <summary>
            Utility function for comparing codepoint to string without generating new
            string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Equals(System.Int32,System.Char[])">
            <summary>
            Utility function for comparing codepoint to string without generating new
            string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Equals(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility function for comparing codepoint to string without generating new
            string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.String,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Text.StringBuilder,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Char[],System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Int32,System.String)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Int32,System.Text.StringBuilder)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Int32,System.Char[])">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.GetSingleCodePoint(System.String)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.GetSingleCodePoint(System.Text.StringBuilder)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.GetSingleCodePoint(System.Char[])">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.GetSingleCodePoint(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.String,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.String,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.String,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.String,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Text.StringBuilder,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Text.StringBuilder,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Char[],System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Char[],System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Char[],System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(System.Char[],ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(ICU4N.Support.Text.ICharSequence,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(ICU4N.Support.Text.ICharSequence,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.Compare(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.String,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.String,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.String,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.String,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Text.StringBuilder,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Text.StringBuilder,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Char[],System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Char[],System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Char[],System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(System.Char[],ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(ICU4N.Support.Text.ICharSequence,System.String)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(ICU4N.Support.Text.ICharSequence,System.Char[])">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.EqualsChars(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing the contents of character sequences.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.OnCharacterBoundary(System.String,System.Int32)">
            <summary>
            Are we on a character boundary?
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.OnCharacterBoundary(System.Text.StringBuilder,System.Int32)">
            <summary>
            Are we on a character boundary?
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.OnCharacterBoundary(System.Char[],System.Int32)">
            <summary>
            Are we on a character boundary?
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.OnCharacterBoundary(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Are we on a character boundary?
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.IndexOf(System.String,System.Int32)">
            <summary>
            Find code point in string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.IndexOf(System.Text.StringBuilder,System.Int32)">
            <summary>
            Find code point in string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.IndexOf(System.Char[],System.Int32)">
            <summary>
            Find code point in string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.IndexOf(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Find code point in string.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePoints(System.String)">
            <summary>
            Utility function for simplified, more robust loops, such as:
            <code>
                foreach (int codePoint in CharSequences.CodePoints(string)) 
                {
                    DoSomethingWith(codePoint);
                }
            </code>
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePoints(System.Text.StringBuilder)">
            <summary>
            Utility function for simplified, more robust loops, such as:
            <code>
                foreach (int codePoint in CharSequences.CodePoints(string)) 
                {
                    DoSomethingWith(codePoint);
                }
            </code>
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePoints(System.Char[])">
            <summary>
            Utility function for simplified, more robust loops, such as:
            <code>
                foreach (int codePoint in CharSequences.CodePoints(string)) 
                {
                    DoSomethingWith(codePoint);
                }
            </code>
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.CharSequences.CodePoints(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility function for simplified, more robust loops, such as:
            <code>
                foreach (int codePoint in CharSequences.CodePoints(string)) 
                {
                    DoSomethingWith(codePoint);
                }
            </code>
            </summary>
        </member>
        <member name="T:ICU4N.Globalization.FoldCase">
            <summary>
            Option values for case folding
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.FoldCase.Default">
            <icu/>
            <summary>
            Option value for case folding: use default mappings defined in
            CaseFolding.txt.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI">
            <icu/>
            <summary>
            Option value for case folding:
            Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
            and dotless i appropriately for Turkic languages (tr, az).
            </summary>
            <remarks>
            Before Unicode 3.2, CaseFolding.txt contains mappings marked with 'I' that
            are to be included for default mappings and
            excluded for the Turkic-specific mappings.
            <para/>
            Unicode 3.2 CaseFolding.txt instead contains mappings marked with 'T' that
            are to be excluded for default mappings and
            included for the Turkic-specific mappings.
            </remarks>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Globalization.UUnicodeCategory">
            <summary>
            Enum for the CharacterCategory constants.  These constants are
            compatible in name <b>but not in value</b> with those defined in
            <see cref="T:System.Globalization.UnicodeCategory"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.Unassigned">
            <summary>
            Unassigned character type.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.OtherNotAssigned"/>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.GeneralOtherTypes"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OtherNotAssigned">
            <summary>
            Unassigned character type.
            This name is compatible with <see cref="T:System.Globalization.UnicodeCategory"/>'s name for this type.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.Unassigned"/>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.GeneralOtherTypes"/>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.GeneralOtherTypes">
            <summary>
            Character type Cn.
            Not Assigned (no characters in [UnicodeData.txt] have this property)
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.Unassigned"/>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.OtherNotAssigned"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.UppercaseLetter">
            <summary>
            Character type Lu.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.LowercaseLetter">
            <summary>
            Character type Ll.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.TitlecaseLetter">
            <summary>
            Character type Lt.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.ModifierLetter">
            <summary>
            Character type Lm.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OtherLetter">
            <summary>
            Character type Lo.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.NonSpacingMark">
            <summary>
            Character type Mn.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.EnclosingMark">
            <summary>
            Character type Me.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.CombiningSpacingMark">
            <summary>
            Character type Mc.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.SpacingCombiningMark"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.SpacingCombiningMark">
            <summary>
            Character type Mc.
            This name is compatible with <see cref="T:System.Globalization.UnicodeCategory"/>'s name for this type.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.CombiningSpacingMark"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.DecimalDigitNumber">
            <summary>
            Character type Nd.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.LetterNumber">
            <summary>
            Character type Nl.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OtherNumber">
            <summary>
            Character type No.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.SpaceSeparator">
            <summary>
            Character type Zs.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.LineSeparator">
            <summary>
            Character type Zl.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.ParagraphSeparator">
            <summary>
            Character type Zp.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.Control">
            <summary>
            Character type Cc.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.Format">
            <summary>
            Character type Cf.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.PrivateUse">
            <summary>
            Character type Co.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.Surrogate">
            <summary>
            Character type Cs.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.DashPunctuation">
            <summary>
            Character type Pd.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OpenPunctuation">
            <summary>
            Character type Ps.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.ClosePunctuation">
            <summary>
            Character type Pe.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.ConnectorPunctuation">
            <summary>
            Character type Pc.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OtherPunctuation">
            <summary>
            Character type Po.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.MathSymbol">
            <summary>
            Character type Sm.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.CurrencySymbol">
            <summary>
            Character type Sc.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.ModifierSymbol">
            <summary>
            Character type Sk.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.OtherSymbol">
            <summary>
            Character type So.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.InitialPunctuation">
            <summary>
            Character type Pi.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.InitialQuotePunctuation"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.InitialQuotePunctuation">
            <summary>
            Character type Pi.
            This name is compatible with <see cref="T:System.Globalization.UnicodeCategory"/>'s name for this type.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.InitialPunctuation"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.FinalPunctuation">
            <summary>
            Character type Pf.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.FinalQuotePunctuation"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UUnicodeCategory.FinalQuotePunctuation">
            <summary>
            Character type Pf.
            This name is compatible with <see cref="T:System.Globalization.UnicodeCategory"/>'s name for this type.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UUnicodeCategory.FinalPunctuation"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Globalization.UCharacterCategoryExtensions">
            <summary>
            Extension methods for <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterCategoryExtensions.AsString(ICU4N.Globalization.UUnicodeCategory)">
            <summary>
            Gets the name of the argument category.
            </summary>
            <param name="category">Category to retrieve name.</param>
            <returns>Category name.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterCategoryExtensions.ToInt32(ICU4N.Globalization.UUnicodeCategory)">
            <summary>
            Converts a <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> to an <see cref="T:System.Int32"/>.
            Same as <c>(int)<paramref name="characterCategory"/></c>.
            </summary>
            <param name="characterCategory">This <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.</param>
            <returns>This category as <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterCategoryExtensions.CharCategoryCount">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> value.
            This numeric value is stable (will not change), see
            <a href="http://www.unicode.org/policies/stability_policy.html#Property_Value">
            http://www.unicode.org/policies/stability_policy.html#Property_Value</a>
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="T:ICU4N.Globalization.UCharacterDirection">
            <summary>
            <see cref="T:System.Enum"/> for the CharacterDirection constants. Some constants are
            compatible in name <b>but not in value</b> with those defined in
            <see cref="T:ICU4N.Support.Text.Character"/>.
            </summary>
            <seealso cref="T:ICU4N.Globalization.UCharacterDirectionExtensions"/>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.LeftToRight">
            <summary>
            Directional type L
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityLeftToRight">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.LeftToRight"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.RightToLeft">
            <summary>
            Directional type R
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityRightToLeft">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.RightToLeft"/>
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumber">
            <summary>
            Directional type EN
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityEuropeanNumber">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumber"/>
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumberSeparator">
            <summary>
            Directional type ES
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityEuropeanNumberSeparator">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumberSeparator"/>
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumberTerminator">
            <summary>
            Directional type ET
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityEuropeanNumberTerminator">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.EuropeanNumberTerminator"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.ArabicNumber">
            <summary>
            Directional type AN
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityArabicNumber">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.ArabicNumber"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.CommonNumberSeparator">
            <summary>
            Directional type CS
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityCommonNumberSeparator">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.CommonNumberSeparator"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.BlockSeparator">
            <summary>
            Directional type B
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityParagraphSeparator">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.BlockSeparator"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.SegmentSeparator">
            <summary>
            Directional type S
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalitySegmentSeparator">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.SegmentSeparator"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.WhiteSpaceNeutral">
            <summary>
            Directional type WS
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityWhiteSpace">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.WhiteSpaceNeutral"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.OtherNeutral">
            <summary>
            Directional type ON
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityOtherNeutrals">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.OtherNeutral"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.LeftToRightEmbedding">
            <summary>
            Directional type LRE
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityLeftToRightEmbedding">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.LeftToRightEmbedding"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.LeftToRightOverride">
            <summary>
            Directional type LRO
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityLeftToRightOverride">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.LeftToRightOverride"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.RightToLeftArabic">
            <summary>
            Directional type AL
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityRightToLeftArabic">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.RightToLeftArabic"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.RightToLeftEmbedding">
            <summary>
            Directional type RLE
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityRightToLeftEmbedding">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.RightToLeftEmbedding"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.RightToLeftOverride">
            <summary>
            Directional type RLO
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityRightToLeftOverride">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.RightToLeftOverride"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.PopDirectionalFormat">
            <summary>
            Directional type PDF
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityPopDirectionalFormat">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.PopDirectionalFormat"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirNonSpacingMark">
            <summary>
            Directional type NSM
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityNonSpacingMark">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.DirNonSpacingMark"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.BoundaryNeutral">
            <summary>
            Directional type BN
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityBoundaryNeutral">
            <summary>
            Synonym of <see cref="F:ICU4N.Globalization.UCharacterDirection.BoundaryNeutral"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.FirstStrongIsolate">
            <summary>
            Directional type FSI
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.LeftToRightIsolate">
            <summary>
            Directional type LRI
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.RightToLeftIsolate">
            <summary>
            Directional type RLI
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.PopDirectionalIsolate">
            <summary>
            Directional type PDI
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.CharDirectionCount">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.Globalization.UCharacterDirection"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.BiDi_Class"/>.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterDirection.DirectionalityUndefined">
            <summary>
            Undefined bidirectional character type. Undefined <see cref="T:System.Char"/>
            values have undefined directionality in the Unicode specification.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="T:ICU4N.Globalization.UCharacterDirectionExtensions">
            <summary>
            Enumerated Unicode character linguistic direction values.
            Used as return results from <see cref="T:ICU4N.UChar"/>.
            <para/>
            This class is not subclassable.
            </summary>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterDirectionExtensions.AsString(ICU4N.Globalization.UCharacterDirection)">
            <summary>
            Gets the name of the argument direction.
            </summary>
            <param name="dir">Direction type to retrieve name.</param>
            <returns>Directional name.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterDirectionExtensions.ToInt32(ICU4N.Globalization.UCharacterDirection)">
            <summary>
            Converts a <see cref="T:ICU4N.Globalization.UCharacterDirection"/> to an <see cref="T:System.Int32"/>.
            Same as <c>(int)<paramref name="characterDirection"/></c>.
            </summary>
            <param name="characterDirection">This <see cref="T:ICU4N.Globalization.UCharacterDirection"/>.</param>
            <returns>This direction as <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="T:ICU4N.Globalization.UCharacterNameEnumerator">
            <summary>
            Class enabling iteration of the codepoints and their names.
            <para/>
            Result of each iteration contains a valid codepoint that has valid
            name.
            <para/>
            See <see cref="M:ICU4N.UChar.GetNameEnumerator"/> for an example of use.
            </summary>
            <remarks>
            NOTE: This is equivalent to UCharacterNameIterator in ICU4J.
            </remarks>
            <author>synwee</author>
            <since>release 2.1, March 5 2002</since>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.Next(ICU4N.Util.ValueEnumeratorElement)">
            <summary>
            Gets the next result for this iteration and returns
            true if we are not at the end of the iteration, false otherwise.
            <para/>
            If the return boolean is a false, the contents of elements will not
            be updated.
            </summary>
            <param name="element">Element for storing the result codepoint and name.</param>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.ValueEnumeratorElement"/>
        </member>
        <member name="P:ICU4N.Globalization.UCharacterNameEnumerator.Current">
            <summary>
            Gets the current <see cref="T:ICU4N.Util.RangeValueEnumeratorElement"/> in the iteration.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.MoveNext">
            <summary>
            Gets the next result for this iteration and returns
            true if we are not at the end of the iteration, false otherwise.
            </summary>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.ValueEnumeratorElement"/>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.Reset">
            <summary>
            Resets the iterator to start iterating from the integer index
            <see cref="F:ICU4N.UChar.MinValue"/> or X if a <c>SetRange(X, Y)</c> has been called previously.
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.SetRange(System.Int32,System.Int32)">
            <summary>
            Restricts the range of integers to iterate and resets the iteration
            to begin at the index argument start.
            </summary>
            <remarks>
            If <see cref="M:ICU4N.Globalization.UCharacterNameEnumerator.SetRange(System.Int32,System.Int32)"/> is not performed before <see cref="M:ICU4N.Globalization.UCharacterNameEnumerator.MoveNext"/> is
            called, the iteration will start from the integer index
            <see cref="F:ICU4N.UChar.MinValue"/> and end at <see cref="F:ICU4N.UChar.MaxValue"/>.
            <para/>
            If this range is set outside the range of <see cref="F:ICU4N.UChar.MinValue"/> and 
            <see cref="F:ICU4N.UChar.MaxValue"/>, <see cref="M:ICU4N.Globalization.UCharacterNameEnumerator.MoveNext"/> will always return false.
            </remarks>
            <param name="start">First integer in range to iterate.</param>
            <param name="limit">1 integer after the last integer in range.</param>
            <exception cref="T:System.ArgumentException">Thrown when attempting to set an
            illegal range. E.g limit &lt;= start.</exception>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.#ctor(ICU4N.Impl.UCharacterName,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name data.</param>
            <param name="choice">Name choice from the class <see cref="T:ICU4N.Impl.UCharacterNameChoice"/>.</param>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_name_">
            <summary>
            Name data
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_choice_">
            <summary>
            Name choice
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_start_">
            <summary>
            Start iteration range
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_limit_">
            <summary>
            End + 1 iteration range
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_current_">
            <summary>
            Current codepoint
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_groupIndex_">
            <summary>
            Group index
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.m_algorithmIndex_">
            <summary>
            Algorithm index
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.GROUP_OFFSETS_">
            <summary>
            Group use
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UCharacterNameEnumerator.current">
            <summary>
            Current enumerator element
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.IterateSingleGroup(ICU4N.Util.ValueEnumeratorElement,System.Int32)">
            <summary>
            Group name iteration, iterate all the names in the current 32-group and
            returns the first codepoint that has a valid name.
            </summary>
            <param name="result">Stores the result codepoint and name.</param>
            <param name="limit">Last codepoint + 1 in range to search.</param>
            <returns>false if a codepoint with a name is found in group and we can
            bail from further iteration, true to continue on with the
            iteration.</returns>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.IterateGroup(ICU4N.Util.ValueEnumeratorElement,System.Int32)">
            <summary>
            Group name iteration, iterate all the names in the current 32-group and
            returns the first codepoint that has a valid name.
            </summary>
            <param name="result">Stores the result codepoint and name.</param>
            <param name="limit">Last codepoint + 1 in range to search.</param>
            <returns>false if a codepoint with a name is found in group and we can
            bail from further iteration, true to continue on with the
            iteration.</returns>
        </member>
        <member name="M:ICU4N.Globalization.UCharacterNameEnumerator.IterateExtended(ICU4N.Util.ValueEnumeratorElement,System.Int32)">
            <summary>
            Iterate extended names.
            </summary>
            <param name="result">Stores the result codepoint and name.</param>
            <param name="limit">Last codepoint + 1 in range to search.</param>
            <returns>false if a codepoint with a name is found and we can
            bail from further iteration, true to continue on with the
            iteration (this will always be false for valid codepoints).</returns>
        </member>
        <member name="T:ICU4N.Globalization.UProperty">
            <summary>
            Selection values for Unicode properties.
            <para/>
            These values are used in functions like
            <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> to select one of the Unicode properties.
            </summary>
            <remarks>
            The properties APIs are intended to reflect Unicode properties as
            defined in the Unicode Character Database (UCD) and Unicode Technical
            Reports (UTR).
            <para/>
            For details about the properties see
            <a href="http://www.unicode.org/reports/tr44/">UAX #44: Unicode Character Database</a>.
            <para/>
            Important: If ICU is built with UCD files from Unicode versions below
            3.2, then properties marked with "new" are not or not fully
            available. Check <see cref="P:ICU4N.UChar.UnicodeVersion"/> to be sure.
            </remarks>
            <seealso cref="T:ICU4N.UChar"/>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Undefined">
            <summary>
            Special value indicating undefined property.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Alphabetic">
            <summary>
            Binary property Alphabetic.
            <para/>
            Property for <see cref="M:ICU4N.UChar.IsUAlphabetic(System.Int32)"/>, different from the property
            in <see cref="M:ICU4N.UChar.IsUAlphabetic(System.Int32)"/>.
            <para/>
            Lu + Ll + Lt + Lm + Lo + Nl + Other_Alphabetic.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Binary_Start">
            <summary>
            First constant for binary Unicode properties.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.ASCII_Hex_Digit">
            <summary>
            Binary property ASCII_Hex_Digit (0-9 A-F a-f).
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Bidi_Control">
            <summary>
            Binary property Bidi_Control.
            <para/>
            Format controls which have specific functions in the Bidi Algorithm.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Bidi_Mirrored">
            <summary>
            Binary property Bidi_Mirrored.
            <para/>
            Characters that may change display in RTL text.
            <para/>
            Property for <see cref="M:ICU4N.UChar.IsMirrored(System.Int32)"/>.
            <para/>
            See Bidi Algorithm, UTR 9.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Dash">
            <summary>
            Binary property Dash.
            <para/>
            Variations of dashes.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Default_Ignorable_Code_Point">
            <summary>
            Binary property Default_Ignorable_Code_Point (new).
            <para/>
            Property that indicates codepoint is ignorable in most processing.
            <para/>
            Codepoints (2060..206F, FFF0..FFFB, E0000..E0FFF) +
            Other_Default_Ignorable_Code_Point + (Cf + Cc + Cs - White_Space)
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Deprecated">
            <summary>
            Binary property Deprecated (new).
            <para/>
            The usage of deprecated characters is strongly discouraged.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Diacritic">
            <summary>
            Binary property Diacritic.
            <para/>
            Characters that linguistically modify the meaning of another
            character to which they apply.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Extender">
            <summary>
            Binary property Extender.
            <para/>
            Extend the value or shape of a preceding alphabetic character, e.g.
            length and iteration marks.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Full_Composition_Exclusion">
            <summary>
            Binary property Full_Composition_Exclusion.
            <para/>
            CompositionExclusions.txt + Singleton Decompositions +
            Non-Starter Decompositions.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Grapheme_Base">
            <summary>
            Binary property Grapheme_Base (new).
            <para/>
            For programmatic determination of grapheme cluster boundaries.
            [0..10FFFF]-Cc-Cf-Cs-Co-Cn-Zl-Zp-Grapheme_Link-Grapheme_Extend-CGJ
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Grapheme_Extend">
            <summary>
            Binary property Grapheme_Extend (new).
            <para/>
            For programmatic determination of grapheme cluster boundaries.
            <para/>
            Me+Mn+Mc+Other_Grapheme_Extend-Grapheme_Link-CGJ
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Grapheme_Link">
            <summary>
            Binary property Grapheme_Link (new).
            <para/>
            For programmatic determination of grapheme cluster boundaries.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Hex_Digit">
            <summary>
            Binary property Hex_Digit.
            <para/>
            Characters commonly used for hexadecimal numbers.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Hyphen">
            <summary>
            Binary property Hyphen.
            <para/>
            Dashes used to mark connections between pieces of words, plus the
            Katakana middle dot.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.ID_Continue">
            <summary>
            Binary property ID_Continue.
            <para/>
            Characters that can continue an identifier.
            <para/>
            ID_Start+Mn+Mc+Nd+Pc
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.ID_Start">
            <summary>
            Binary property ID_Start.
            <para/>
            Characters that can start an identifier.
            <para/>
            Lu+Ll+Lt+Lm+Lo+Nl
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Ideographic">
            <summary>
            Binary property Ideographic.
            <para/>
            CJKV ideographs.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.IDS_Binary_Operator">
            <summary>
            Binary property IDS_Binary_Operator (new).
            <para/>
            For programmatic determination of Ideographic Description Sequences.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.IDS_Trinary_Operator">
            <summary>
            Binary property IDS_Trinary_Operator (new).
            <para/>
            For programmatic determination of Ideographic Description
            Sequences.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Join_Control">
            <summary>
            Binary property Join_Control.
            <para/>
            Format controls for cursive joining and ligation.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Logical_Order_Exception">
            <summary>
            Binary property Logical_Order_Exception (new).
            <para/>
            Characters that do not use logical order and require special
            handling in most processing.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Lowercase">
            <summary>
            Binary property Lowercase.
            <para/>
            Same as <see cref="M:ICU4N.UChar.IsULower(System.Int32)"/>, different from
            <see cref="M:ICU4N.UChar.IsLower(System.Int32)"/>.
            <para/>
            Ll+Other_Lowercase
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Math">
            <summary>
            Binary property Math.
            <para/>
            Sm+Other_Math
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Noncharacter_Code_Point">
            <summary>
            Binary property Noncharacter_Code_Point.
            <para/>
            Code points that are explicitly defined as illegal for the encoding
            of characters.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Quotation_Mark">
            <summary>
            Binary property Quotation_Mark.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Radical">
            <summary>
            Binary property Radical (new).
            <para/>
            For programmatic determination of Ideographic Description
            Sequences.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Soft_Dotted">
            <summary>
            Binary property Soft_Dotted (new).
            <para/>
            Characters with a "soft dot", like i or j.
            <para/>
            An accent placed on these characters causes the dot to disappear.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Terminal_Punctuation">
            <summary>
            Binary property Terminal_Punctuation.
            <para/>
            Punctuation characters that generally mark the end of textual
            units.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Unified_Ideograph">
            <summary>
            Binary property Unified_Ideograph (new).
            <para/>
            For programmatic determination of Ideographic Description
            Sequences.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Uppercase">
            <summary>
            Binary property Uppercase.
            <para/>
            Same as <see cref="M:ICU4N.UChar.IsUUpper(System.Int32)"/>, different from
            <see cref="M:ICU4N.UChar.IsUpper(System.Int32)"/>.
            <para/>
            Lu+Other_Uppercase
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.White_Space">
            <summary>
            Binary property White_Space.
            <para/>
            Same as <see cref="M:ICU4N.UChar.IsUWhiteSpace(System.Int32)"/>, different from
            <see cref="M:ICU4N.UChar.IsSpace(System.Int32)"/> and <see cref="M:ICU4N.UChar.IsWhiteSpace(System.Int32)"/>.
            Space characters+TAB+CR+LF-ZWSP-ZWNBSP
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.XID_Continue">
            <summary>
            Binary property XID_Continue.
            <para/>
            ID_Continue modified to allow closure under normalization forms
            NFKC and NFKD.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.XID_Start">
            <summary>
            Binary property XID_Start.
            <para/>
            ID_Start modified to allow closure under normalization forms NFKC
            and NFKD.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Case_Sensitive">
            <summary>
            Binary property Case_Sensitive.
            <para/>
            Either the source of a case
            mapping or _in_ the target of a case mapping. Not the same as
            the general category Cased_Letter.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.STerm">
            <summary>
            Binary property STerm (new in Unicode 4.0.1).
            Sentence Terminal. Used in UAX #29: Text Boundaries
            (<a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>)
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Variation_Selector">
            <summary>
            Binary property Variation_Selector (new in Unicode 4.0.1).
            Indicates all those characters that qualify as Variation Selectors.
            For details on the behavior of these characters,
            see StandardizedVariants.html and 15.6 Variation Selectors.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFD_Inert">
            <summary>
            Binary property NFD_Inert.
            ICU-specific property for characters that are inert under NFD,
            i.e., they do not interact with adjacent characters.
            Used for example in normalizing transforms in incremental mode
            to find the boundary of safely normalizable text despite possible
            text additions.
            <para/>
            There is one such property per normalization form.
            These properties are computed as follows - an inert character is:
            a) unassigned, or ALL of the following:
            b) of combining class 0.
            c) not decomposed by this normalization form.
            AND if NFC or NFKC,
            d) can never compose with a previous character.
            e) can never compose with a following character.
            f) can never change if another character is added.
            Example: a-breve might satisfy all but f, but if you
            add an ogonek it changes to a-ogonek + breve
            <para/>
            See also com.ibm.text.UCD.NFSkippable in the ICU4J repository,
            and icu/source/common/unormimp.h .
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFKD_Inert">
            <summary>
            Binary property NFKD_Inert.
            ICU-specific property for characters that are inert under NFKD,
            i.e., they do not interact with adjacent characters.
            Used for example in normalizing transforms in incremental mode
            to find the boundary of safely normalizable text despite possible
            text additions.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.NFD_Inert"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFC_Inert">
            <summary>
            Binary property NFC_Inert.
            ICU-specific property for characters that are inert under NFC,
            i.e., they do not interact with adjacent characters.
            Used for example in normalizing transforms in incremental mode
            to find the boundary of safely normalizable text despite possible
            text additions.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.NFD_Inert"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFKC_Inert">
            <summary>
            Binary property NFKC_Inert.
            ICU-specific property for characters that are inert under NFKC,
            i.e., they do not interact with adjacent characters.
            Used for example in normalizing transforms in incremental mode
            to find the boundary of safely normalizable text despite possible
            text additions.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.NFD_Inert"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Segment_Starter">
            <summary>
            Binary Property Segment_Starter.
            ICU-specific property for characters that are starters in terms of
            Unicode normalization and combining character sequences.
            They have ccc=0 and do not occur in non-initial position of the
            canonical decomposition of any character
            (like " in NFD(a-umlaut) and a Jamo T in an NFD(Hangul LVT)).
            ICU uses this property for segmenting a string for generating a set of
            canonically equivalent strings, e.g. for canonical closure while
            processing collation tailoring rules.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Pattern_Syntax">
            <summary>
            Binary property Pattern_Syntax (new in Unicode 4.1).
            See UAX #31 Identifier and Pattern Syntax
            (<a href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a>)
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Pattern_White_Space">
            <summary>
            Binary property Pattern_White_Space (new in Unicode 4.1).
            See UAX #31 Identifier and Pattern Syntax
            (<a href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a>)
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.POSIX_Alnum">
            <summary>
            Binary property alnum (a C/POSIX character class).
            Implemented according to the UTS #18 Annex C Standard Recommendation.
            See the <see cref="T:ICU4N.UChar"/> class documentation.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.POSIX_Blank">
            <summary>
            Binary property blank (a C/POSIX character class).
            Implemented according to the UTS #18 Annex C Standard Recommendation.
            See the <see cref="T:ICU4N.UChar"/> class documentation.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.POSIX_Graph">
            <summary>
            Binary property graph (a C/POSIX character class).
            Implemented according to the UTS #18 Annex C Standard Recommendation.
            See the <see cref="T:ICU4N.UChar"/> class documentation.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.POSIX_Print">
            <summary>
            Binary property print (a C/POSIX character class).
            Implemented according to the UTS #18 Annex C Standard Recommendation.
            See the <see cref="T:ICU4N.UChar"/> class documentation.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.POSIX_XDigit">
            <summary>
            Binary property xdigit (a C/POSIX character class).
            Implemented according to the UTS #18 Annex C Standard Recommendation.
            See the <see cref="T:ICU4N.UChar"/> class documentation.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Cased">
            <summary>
            Binary property Cased.
            For Lowercase, Uppercase and Titlecase characters.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Case_Ignorable">
            <summary>
            Binary property Case_Ignorable.
            Used in context-sensitive case mappings.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_Lowercased">
            <summary>
            Binary property Changes_When_Lowercased.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_Uppercased">
            <summary>
            Binary property Changes_When_Uppercased.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_Titlecased">
            <summary>
            Binary property Changes_When_Titlecased.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_Casefolded">
            <summary>
            Binary property Changes_When_Casefolded.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_Casemapped">
            <summary>
            Binary property Changes_When_Casemapped.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Changes_When_NFKC_Casefolded">
            <summary>
            Binary property Changes_When_NFKC_Casefolded.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Emoji">
            <summary>
            Binary property Emoji.
            See <a href="http://www.unicode.org/reports/tr51/#Emoji_Properties">http://www.unicode.org/reports/tr51/#Emoji_Properties</a>
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Emoji_Presentation">
            <summary>
            Binary property Emoji_Presentation.
            See <a href="http://www.unicode.org/reports/tr51/#Emoji_Properties">http://www.unicode.org/reports/tr51/#Emoji_Properties</a>
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Emoji_Modifier">
            <summary>
            Binary property Emoji_Modifier.
            See <a href="http://www.unicode.org/reports/tr51/#Emoji_Properties">http://www.unicode.org/reports/tr51/#Emoji_Properties</a>
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Emoji_Modifier_Base">
            <summary>
            Binary property Emoji_Modifier_Base.
            See <a href="http://www.unicode.org/reports/tr51/#Emoji_Properties">http://www.unicode.org/reports/tr51/#Emoji_Properties</a>
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Emoji_Component">
            <summary>
            Binary property Emoji_Component.
            See <a href="http://www.unicode.org/reports/tr51/#Emoji_Properties">http://www.unicode.org/reports/tr51/#Emoji_Properties</a>
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Regional_Indicator">
            <summary>
            Binary property Regional_Indicator.
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Prepended_Concatenation_Mark">
            <summary>
            Binary property Prepended_Concatenation_Mark.
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Binary_Limit">
            <summary>
            One more than the last constant for binary Unicode properties.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.BiDi_Class">
            <summary>
            Enumerated property Bidi_Class.
            Same as <see cref="M:ICU4N.UChar.GetDirection(System.Int32)"/>, returns <see cref="T:ICU4N.Globalization.UCharacterDirection"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Int_Start">
            <summary>
             First constant for enumerated/integer Unicode properties.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Block">
            <summary>
            Enumerated property Block.
            Same as <see cref="M:ICU4N.UChar.UnicodeBlock.Of(System.Int32)"/>, returns <see cref="T:ICU4N.UChar.UnicodeBlock"/>
            values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Canonical_Combining_Class">
            <summary>
            Enumerated property Canonical_Combining_Class.
            Same as <see cref="M:ICU4N.UChar.GetCombiningClass(System.Int32)"/>, returns 8-bit numeric values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Decomposition_Type">
            <summary>
            Enumerated property Decomposition_Type.
            Returns <see cref="T:ICU4N.UChar.DecompositionType"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.East_Asian_Width">
            <summary>
            Enumerated property East_Asian_Width.
            See <a href="http://www.unicode.org/reports/tr11/">http://www.unicode.org/reports/tr11/</a>.
            Returns <see cref="T:ICU4N.UChar.EastAsianWidth"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.General_Category">
            <summary>
            Enumerated property General_Category.
            Same as <see cref="!:UChar.GetType(int)"/>, returns <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Joining_Group">
            <summary>
            Enumerated property Joining_Group.
            Returns <see cref="T:ICU4N.UChar.JoiningGroup"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Joining_Type">
            <summary>
            Enumerated property Joining_Type.
            Returns <see cref="T:ICU4N.UChar.JoiningType"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Line_Break">
            <summary>
            Enumerated property Line_Break.
            Returns <see cref="T:ICU4N.UChar.LineBreak"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Numeric_Type">
            <summary>
            Enumerated property Numeric_Type.
            Returns <see cref="T:ICU4N.UChar.NumericType"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Script">
            <summary>
            Enumerated property Script.
            Same as <see cref="M:ICU4N.Globalization.UScript.GetScript(System.Int32)"/>, returns <see cref="T:ICU4N.Globalization.UScript"/> values.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Hangul_Syllable_Type">
            <summary>
            Enumerated property Hangul_Syllable_Type, new in Unicode 4.
            Returns <see cref="T:ICU4N.UChar.HangulSyllableType"/> values.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFD_Quick_Check">
            <summary>
            Enumerated property NFD_Quick_Check.
            Returns numeric values compatible with <see cref="T:ICU4N.Text.QuickCheckResult"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFKD_Quick_Check">
            <summary>
            Enumerated property NFKD_Quick_Check.
            Returns numeric values compatible with <see cref="T:ICU4N.Text.QuickCheckResult"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFC_Quick_Check">
            <summary>
            Enumerated property NFC_Quick_Check.
            Returns numeric values compatible with <see cref="T:ICU4N.Text.QuickCheckResult"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.NFKC_Quick_Check">
            <summary>
            Enumerated property NFKC_Quick_Check.
            Returns numeric values compatible with <see cref="T:ICU4N.Text.QuickCheckResult"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Lead_Canonical_Combining_Class">
            <summary>
            Enumerated property Lead_Canonical_Combining_Class.
            ICU-specific property for the ccc of the first code point
            of the decomposition, or lccc(c)=ccc(NFD(c)[0]).
            Useful for checking for canonically ordered text,
            see <see cref="F:ICU4N.Text.Normalizer.FCD"/> and 
            <a href="http://www.unicode.org/notes/tn5/#FCD">http://www.unicode.org/notes/tn5/#FCD</a>.
            Returns 8-bit numeric values like <see cref="F:ICU4N.Globalization.UProperty.Canonical_Combining_Class"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Trail_Canonical_Combining_Class">
            <summary>
            Enumerated property Trail_Canonical_Combining_Class.
            ICU-specific property for the ccc of the last code point
            of the decomposition, or lccc(c)=ccc(NFD(c)[last]).
            Useful for checking for canonically ordered text,
            see <see cref="F:ICU4N.Text.Normalizer.FCD"/> and 
            <a href="http://www.unicode.org/notes/tn5/#FCD">http://www.unicode.org/notes/tn5/#FCD</a>.
            Returns 8-bit numeric values like <see cref="F:ICU4N.Globalization.UProperty.Canonical_Combining_Class"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Grapheme_Cluster_Break">
            <summary>
            Enumerated property Grapheme_Cluster_Break (new in Unicode 4.1).
            Used in UAX #29: Text Boundaries
            (<a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>).
            Returns <see cref="T:ICU4N.UChar.GraphemeClusterBreak"/> values.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Sentence_Break">
            <summary>
            Enumerated property Sentence_Break (new in Unicode 4.1).
            Used in UAX #29: Text Boundaries
            (<a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>).
            Returns <see cref="T:ICU4N.UChar.SentenceBreak"/> values.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Word_Break">
            <summary>
            Enumerated property Word_Break (new in Unicode 4.1).
            Used in UAX #29: Text Boundaries
            (<a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>).
            Returns <see cref="T:ICU4N.UChar.WordBreak"/> values.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type">
            <summary>
            Enumerated property Bidi_Paired_Bracket_Type (new in Unicode 6.3).
            Used in UAX #9: Unicode Bidirectional Algorithm
            (<a href="http://www.unicode.org/reports/tr9/">http://www.unicode.org/reports/tr9/</a>).
            Returns <see cref="T:ICU4N.UChar.BidiPairedBracketType"/> values.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Int_Limit">
            <summary>
            One more than the last constant for enumerated/integer Unicode properties.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.General_Category_Mask">
            <summary>
            Bitmask property General_Category_Mask.
            This is the <see cref="F:ICU4N.Globalization.UProperty.General_Category"/> property returned as a bit mask.
            When used in <see cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/>,
            returns bit masks for <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values where exactly one bit is set.
            When used with <see cref="M:ICU4N.UChar.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/> 
            and <see cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String)"/>,
            a multi-bit mask is used for sets of categories like "Letters".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Mask_Start">
            <summary>
            First constant for bit-mask Unicode properties.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Mask_Limit">
            <summary>
            One more than the last constant for bit-mask Unicode properties.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Numeric_Value">
            <summary>
            Double property Numeric_Value.
            Corresponds to <see cref="M:ICU4N.UChar.GetUnicodeNumericValue(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Double_Start">
            <summary>
            First constant for double Unicode properties.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Double_Limit">
            <summary>
            One more than the last constant for double Unicode properties.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Age">
            <summary>
            String property Age.
            Corresponds to <see cref="M:ICU4N.UChar.GetAge(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.String_Start">
            <summary>
            First constant for string Unicode properties.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Bidi_Mirroring_Glyph">
            <summary>
            String property Bidi_Mirroring_Glyph.
            Corresponds to <see cref="M:ICU4N.UChar.GetMirror(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Case_Folding">
            <summary>
            String property Case_Folding.
            Corresponds to <see cref="M:ICU4N.UChar.FoldCase(System.String,System.Boolean)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.ISO_Comment">
            <summary>
            Deprecated string property ISO_Comment.
            Corresponds to <see cref="M:ICU4N.UChar.GetISOComment(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Lowercase_Mapping">
            <summary>
            String property Lowercase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToLower(System.String)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Name">
            <summary>
            String property Name.
            Corresponds to <see cref="M:ICU4N.UChar.GetName(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Simple_Case_Folding">
            <summary>
            String property Simple_Case_Folding.
            Corresponds to <see cref="M:ICU4N.UChar.FoldCase(System.Int32,System.Boolean)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Simple_Lowercase_Mapping">
            <summary>
            String property Simple_Lowercase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToLower(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Simple_Titlecase_Mapping">
            <summary>
            String property Simple_Titlecase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToTitleCase(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Simple_Uppercase_Mapping">
            <summary>
            String property Simple_Uppercase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToUpper(System.Int32)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Titlecase_Mapping">
            <summary>
            String property Titlecase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToTitleCase(System.String,ICU4N.Text.BreakIterator)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Unicode_1_Name">
            <summary>
            String property Unicode_1_Name.
            This property is of little practical value.
            Beginning with ICU 49, ICU APIs return null or an empty string for this property.
            Corresponds to <see cref="M:ICU4N.UChar.GetName1_0(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Uppercase_Mapping">
            <summary>
            String property Uppercase_Mapping.
            Corresponds to <see cref="M:ICU4N.UChar.ToUpper(System.String)"/>.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket">
            <summary>
            String property Bidi_Paired_Bracket (new in Unicode 6.3).
            Corresponds to <see cref="M:ICU4N.UChar.GetBidiPairedBracket(System.Int32)"/>.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.String_Limit">
            <summary>
            One more than the last constant for string Unicode properties.
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Script_Extensions">
            <summary>
            Miscellaneous property Script_Extensions (new in Unicode 6.0).
            Some characters are commonly used in multiple scripts.
            For more information, see UAX #24: <a href="http://www.unicode.org/reports/tr24/">http://www.unicode.org/reports/tr24/</a>.
            Corresponds to <see cref="M:ICU4N.Globalization.UScript.HasScript(System.Int32,System.Int32)"/> and <see cref="M:ICU4N.Globalization.UScript.GetScriptExtensions(System.Int32,ICU4N.Support.Collections.BitSet)"/>.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Other_Property_Start">
            <summary>
            First constant for Unicode properties with unusual value types.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UProperty.Other_Property_Limit">
            <summary>
            One more than the last constant for Unicode properties with unusual value types.
            </summary>
        </member>
        <member name="T:ICU4N.Globalization.NameChoice">
            <summary>
            Selector constants for <see cref="M:ICU4N.UChar.GetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice)"/> and
            <see cref="M:ICU4N.UChar.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/>.  These selectors are used to
            choose which name is returned for a given property or value.
            All properties and values have a long name.  Most have a short
            name, but some do not.  Unicode allows for additional names,
            beyond the long and short name, which would be indicated by
            LONG + i, where i=1, 2,...
            </summary>
            <seealso cref="M:ICU4N.UChar.GetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice)"/>
            <seealso cref="M:ICU4N.UChar.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.NameChoice.Short">
            <summary>
            Selector for the abbreviated name of a property or value.
            Most properties and values have a short name, those that do
            not return null.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.NameChoice.Long">
            <summary>
            Selector for the long name of a property or value.  All
            properties and values have a long name.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.NameChoice.Count">
            <summary>
            The number of predefined property name choices.  Individual
            properties or values may have more than <see cref="F:ICU4N.Globalization.NameChoice.Count"/> aliases.
            </summary>
        </member>
        <member name="T:ICU4N.Globalization.UScript">
            <summary>
            Constants for ISO 15924 script codes.
            </summary>
            <remarks>
            The current set of script code constants supports at least all scripts
            that are encoded in the version of Unicode which ICU currently supports.
            The names of the constants are usually derived from the
            Unicode script property value aliases.
            See UAX #24 Unicode Script Property (<a href="http://www.unicode.org/reports/tr24/">http://www.unicode.org/reports/tr24/</a>)
            and <a href="http://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt">ttp://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt</a>.
            <para/>
            In addition, constants for many ISO 15924 script codes
            are included, for use with language tags, CLDR data, and similar.
            Some of those codes are not used in the Unicode Character Database (UCD).
            For example, there are no characters that have a UCD script property value of
            Hans or Hant. All Han ideographs have the Hani script property value in Unicode.
            <para/>
            Private-use codes Qaaa..Qabx are not included, except as used in the UCD or in CLDR.
            <para/>
            Starting with ICU 55, script codes are only added when their scripts
            have been or will certainly be encoded in Unicode,
            and have been assigned Unicode script property value aliases,
            to ensure that their script names are stable and match the names of the constants.
            Script codes like Latf and Aran that are not subject to separate encoding
            may be added at any time.
            </remarks>
            <stable>ICU 2.2</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.InvalidCode">
            <summary>
            Invalid code
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Common">
            <summary>
            Common
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Inherited">
            <summary>
            Inherited
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Arabic">
            <summary>
            Arabic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Armenian">
            <summary>
            Armenian
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Bengali">
            <summary>
            Bengali
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Bopomofo">
            <summary>
            Bopomofo
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cherokee">
            <summary>
            Cherokee
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Coptic">
            <summary>
            Coptic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cyrillic">
            <summary>
            Cyrillic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Deseret">
            <summary>
            Deseret
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Devanagari">
            <summary>
            Devanagari
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Ethiopic">
            <summary>
            Ethiopic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Georgian">
            <summary>
            Georgian
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Gothic">
            <summary>
            Gothic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Greek">
            <summary>
            Greek
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Gujarati">
            <summary>
            Gujarati
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Gurmukhi">
            <summary>
            Gurmukhi
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Han">
            <summary>
            Han
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Hangul">
            <summary>
            Hangul
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Hebrew">
            <summary>
            Hebrew
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Hiragana">
            <summary>
            Hiragana
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Kannada">
            <summary>
            Kannada
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Katakana">
            <summary>
            Katakana
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Khmer">
            <summary>
            Khmer
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lao">
            <summary>
            Lao
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Latin">
            <summary>
            Latin
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Malayalam">
            <summary>
            Malayalam
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mongolian">
            <summary>
            Mongolian
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Myanmar">
            <summary>
            Myanmar
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Ogham">
            <summary>
            Ogham
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldItalic">
            <summary>
            Old Italic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Oriya">
            <summary>
            Oriya
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Runic">
            <summary>
            Runic
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Sinhala">
            <summary>
            Sinhala
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Syriac">
            <summary>
            Syriac
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tamil">
            <summary>
            Tamil
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Telugu">
            <summary>
            Telugu
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Thaana">
            <summary>
            Thaana
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Thai">
            <summary>
            Thai
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tibetan">
            <summary>
            Tibetan
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.CanadianAboriginal">
            <summary>
            Unified Canadian Aboriginal Symbols
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.UCAS">
            <summary>
            Unified Canadian Aboriginal Symbols (alias)
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Yi">
            <summary>
            Yi syllables
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tagalog">
            <summary>
            Tagalog
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Hanunoo">
            <summary>
            Hanunoo
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Buhid">
            <summary>
            Buhid
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tagbanwa">
            <summary>
            Tagbanwa
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Braille">
            <summary>
            Braille
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cypriot">
            <summary>
            Cypriot
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Limbu">
            <summary>
            Limbu
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.LinearB">
            <summary>
            Linear B
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Osmanya">
            <summary>
            Osmanya
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Shavian">
            <summary>
            Shavian
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.TaiLe">
            <summary>
            Tai Le
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Ugaritic">
            <summary>
            Ugaritic
            Script in Unicode 4
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.KatakanaOrHiragana">
            <summary>
            Japanese syllabaries (alias for Hiragana + Katakana)
            Script in Unicode 4.0.1
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Buginese">
            <summary>
            Buginese
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Glagolitic">
            <summary>
            Glagolitic
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Kharoshthi">
            <summary>
            Kharoshthi
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.SylotiNagri">
            <summary>
            Syloti Nagri
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.NewTaiLue">
            <summary>
            New Tai Lue
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tifinagh">
            <summary>
            Tifinagh
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldPersian">
            <summary>
            Old Persian
            Script in Unicode 4.1
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Balinese">
            <summary>
            Balinese
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Batak">
            <summary>
            Batak
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Blissymbols">
            <summary>
            Blissymbols
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Brahmi">
            <summary>
            Brahmi
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cham">
            <summary>
            Cham
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cirth">
            <summary>
            Cirth
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldChurchSlavonicCyrillic">
            <summary>
            Cyrillic (Old Church Slavonic variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.DemoticEgyptian">
            <summary>
            Egyptian demotic
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.HieraticEgyptian">
            <summary>
            Egyptian hieratic
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.EgyptianHieroglyphs">
            <summary>
            Egyptian hieroglyphs
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Khutsuri">
            <summary>
            Khutsuri
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.SimplifiedHan">
            <summary>
            Han (Simplified variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.TraditionalHan">
            <summary>
            Han (Traditional variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.PahawhHmong">
            <summary>
            Pahawh Hmong
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldHungarian">
            <summary>
            Old Hungarian
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.HarappanIndus">
            <summary>
            Indus (Harappan)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Javanese">
            <summary>
            Javanese
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.KayahLi">
            <summary>
            Kayah Li
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.LatinFraktur">
            <summary>
            Latin (Fraktur variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.LatinGaelic">
            <summary>
            Latin (Gaelic variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lepcha">
            <summary>
            Lepcha (Rng)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.LinearA">
            <summary>
            Linear A
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mandaic">
            <summary>
            Mandaic
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mandaean">
            <summary>
            Mandaean
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MayanHieroglyphs">
            <summary>
            Mayan hieroglyphs
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MeroiticHieroglyphs">
            <summary>
            Meroitic Hieroglyphs
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Meroitic">
            <summary>
            Meroitic
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.NKo">
            <summary>
            NKo
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Orkhon">
            <summary>
            Orkhon
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldPermic">
            <summary>
            Old Permic
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.PhagsPa">
            <summary>
            Phags-pa
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Phoenician">
            <summary>
            Phoenician
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Miao">
            <summary>
            Miao (Pollard)
            ISO 15924 script code
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.PhoneticPollard">
            <summary>
            Miao (Pollard)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Rongorongo">
            <summary>
            Rongorongo
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Sarati">
            <summary>
            Sarati
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.EstrangeloSyriac">
            <summary>
            Syriac (Estrangelo variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.WesternSyriac">
            <summary>
            Syriac (Western variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.EasternSyriac">
            <summary>
            Syriac (Eastern variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tengwar">
            <summary>
            Tengwar
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Vai">
            <summary>
            Vai
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.VisibleSpeech">
            <summary>
            Visible Speech
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Cuneiform">
            <summary>
            Cuneiform; Sumero-Akkadian
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.UnwrittenLanguages">
            <summary>
            Code for unwritten documents
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Unknown">
            <summary>
            Unknown
            ISO 15924 script code
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Carian">
            <summary>
            Carian
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Japanese">
            <summary>
            Japanese
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lanna">
            <summary>
            Tai Tham (Lanna)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lycian">
            <summary>
            Lycian
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lydian">
            <summary>
            Lydian
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OlChiki">
            <summary>
            Ol Chiki (Ol Cemet; Ol; Santali)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Rejang">
            <summary>
            Rejang (Redjang; Kaganga)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Saurashtra">
            <summary>
            Saurashtra
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.SignWriting">
            <summary>
            ISO 15924 script code for Sutton SignWriting
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Sundanese">
            <summary>
            Sundanese
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Moon">
            <summary>
            Moon (Moon code; Moon script; Moon type)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MeiteiMayek">
            <summary>
            Meitei Mayek (Meithei; Meetei)
            ISO 15924 script code
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.ImperialAramaic">
            <summary>
            Imperial Aramaic
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Avestan">
            <summary>
            Avestan
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Chakma">
            <summary>
            Chakma
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Korean">
            <summary>
            Korean
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Kaithi">
            <summary>
            Kaithi
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Manichaean">
            <summary>
            Manichaean
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.InscriptionalPahlavi">
            <summary>
            Inscriptional Pahlavi
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.PsalterPahlavi">
            <summary>
            Psalter Pahlavi
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.BookPahlavi">
            <summary>
            Book Pahlavi
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.InscriptionalParthian">
            <summary>
            Inscriptional Parthian
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Samaritan">
            <summary>
            Samaritan
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.TaiViet">
            <summary>
            Tai Viet
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MathematicalNotation">
            <summary>
            Mathematical notation
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Symbols">
            <summary>
            Symbols
            ISO 15924 script code
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Bamum">
            <summary>
            Bamum
            ISO 15924 script code
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Lisu">
            <summary>
            Lisu (Fraser)
            ISO 15924 script code
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.NakhiGeba">
            <summary>
            Nakhi Geba
            ISO 15924 script code
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldSouthArabian">
            <summary>
            Old South Arabian
            ISO 15924 script code
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.BassaVah">
            <summary>
            Bassa Vah
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Duployan">
            <summary>
            Duployan shorthand; Duployan stenography
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.DuployanShorthand">
            <summary>
            Typo; use DUPLOYAN
            </summary>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Elbasan">
            <summary>
            Elbasan
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Grantha">
            <summary>
            Grantha
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Kpelle">
            <summary>
            Kpelle
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Loma">
            <summary>
            Loma
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mende">
            <summary>
            Mende Kikakui
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MeroiticCursive">
            <summary>
            Meroitic Cursive
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.OldNorthArabian">
            <summary>
            Old North Arabian (Ancient North Arabian)
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Nabataean">
            <summary>
            Nabataean
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Palmyrene">
            <summary>
            Palmyrene
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Khudawadi">
            <summary>
            Khudawadi; Sindhi
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Sindhi">
            <summary>
            Khudawadi; Sindhi
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.WarangCiti">
            <summary>
            Warang Citi (Varang Kshiti)
            ISO 15924 script code
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Afaka">
            <summary>
            Afaka
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Jurchen">
            <summary>
            Jurchen
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mro">
            <summary>
            Mro; Mru
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Nushu">
            <summary>
            Nshu
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Sharada">
            <summary>
            Sharada; rad
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.SoraSompeng">
            <summary>
            Sora Sompeng
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Takri">
            <summary>
            Takri; kr; kr
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tangut">
            <summary>
            Tangut
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Woleai">
            <summary>
            Woleai
            ISO 15924 script code
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.AnatolianHieroglyphs">
            <summary>
            Anatolian Hieroglyphs (Luwian Hieroglyphs; Hittite Hieroglyphs)
            ISO 15924 script code
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Khojki">
            <summary>
            Khojki
            ISO 15924 script code
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Tirhuta">
            <summary>
            Tirhuta
            ISO 15924 script code
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.CaucasianAlbanian">
            <summary>
            Caucasian Albanian
            ISO 15924 script code
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Mahajani">
            <summary>
            Mahajani
            ISO 15924 script code
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Ahom">
            <summary>
            Ahom; Tai Ahom
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Hatran">
            <summary>
            Hatran
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Modi">
            <summary>
            Modi; Mo
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Multani">
            <summary>
            Multani
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.PauCinHau">
            <summary>
            Pau Cin Hau
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Siddham">
            <summary>
            Siddham; Siddha; Siddhamtk
            ISO 15924 script code
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Adlam">
            <summary>
            Adlam
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Bhaiksuki">
            <summary>
            Bhaiksuki
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Marchen">
            <summary>
            Marchen
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Newa">
            <summary>
            Newa; Newar; Newari; Nepla lipi
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Osage">
            <summary>
            Osage
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.HanWithBopomofo">
            <summary>
            Han with Bopomofo (alias for Han + Bopomofo)
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Jamo">
            <summary>
            Jamo (alias for Jamo subset of Hangul)
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.SymbolsEmoji">
            <summary>
            Symbols (Emoji variant)
            ISO 15924 script code
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.MasaramGondi">
            <summary>
            Masaram Gondi
            ISO 15924 script code
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.Soyombo">
            <summary>
            Soyombo
            ISO 15924 script code
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.ZanabazarSquare">
            <summary>
            Zanabazar Square (Zanabazarin Drbljin Useg; Xewtee Drbljin Bicig; Horizontal Square Script)
            ISO 15924 script code
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Globalization.UScript.CodeLimit">
            <summary>
            One more than the highest normal Script code.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/> (passing <see cref="F:ICU4N.Globalization.UProperty.Script"/>).
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UScript.FindCodeFromLocale(ICU4N.Util.ULocale)">
            <summary>
            Helper function to find the code from locale.
            </summary>
            <param name="locale">The locale.</param>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetCode(System.Globalization.CultureInfo)">
            <summary>
            Gets a script codes associated with the given locale or ISO 15924 abbreviation or name.
            Returns <see cref="F:ICU4N.Globalization.UScript.Malayalam"/> given "Malayam" OR "Mlym".
            Returns <see cref="F:ICU4N.Globalization.UScript.Latin"/> given "en" OR "en_US"
            </summary>
            <param name="locale"><see cref="T:System.Globalization.CultureInfo"/>.</param>
            <returns>The script codes array. null if the the code cannot be found.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetCode(ICU4N.Util.ULocale)">
            <summary>
            Gets a script codes associated with the given locale or ISO 15924 abbreviation or name.
            Returns <see cref="F:ICU4N.Globalization.UScript.Malayalam"/> given "Malayam" OR "Mlym".
            Returns <see cref="F:ICU4N.Globalization.UScript.Latin"/> given "en" OR "en_US"
            </summary>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/>.</param>
            <returns>The script codes array. null if the the code cannot be found.</returns>
            <stable>ICU 3.0.</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetCode(System.String)">
            <summary>
            Gets the script codes associated with the given locale or ISO 15924 abbreviation or name.
            Returns <see cref="F:ICU4N.Globalization.UScript.Malayalam"/> given "Malayam" OR "Mlym".
            Returns <see cref="F:ICU4N.Globalization.UScript.Latin"/> given "en" OR "en_US"
            <para/>
            Note: To search by short or long script alias only, use
            <see cref="M:ICU4N.Globalization.UScript.GetCodeFromName(System.String)"/> instead.
            That does a fast lookup with no access of the locale data.
            </summary>
            <param name="nameOrAbbrOrLocale">Name of the script or ISO 15924 code or locale.</param>
            <returns>The script codes array. null if the the code cannot be found.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetCodeFromName(System.String)">
            <summary>
            Returns the script code associated with the given Unicode script property alias
            (name or abbreviation).
            Short aliases are ISO 15924 script codes.
            Returns <see cref="F:ICU4N.Globalization.UScript.Malayalam"/> given "Malayam" OR "Mlym".
            </summary>
            <param name="nameOrAbbr">Name of the script or ISO 15924 code.</param>
            <returns>The script code value, or <see cref="F:ICU4N.Globalization.UScript.InvalidCode"/> if the code cannot be found.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetScript(System.Int32)">
            <summary>
            Gets the script code associated with the given codepoint.
            Returns <see cref="F:ICU4N.Globalization.UScript.Malayalam"/> given 0x0D02
            </summary>
            <param name="codepoint">UChar32 codepoint.</param>
            <returns>The script code.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.HasScript(System.Int32,System.Int32)">
            <summary>
            Do the Script_Extensions of code point <paramref name="c"/> contain script <paramref name="sc"/>?
            If <paramref name="c"/> does not have explicit Script_Extensions, then this tests whether
            <paramref name="c"/> has the Script property value <paramref name="sc"/>.
            <para/>
            Some characters are commonly used in multiple scripts.
            For more information, see UAX #24: <a href="http://www.unicode.org/reports/tr24/">http://www.unicode.org/reports/tr24/</a>.
            </summary>
            <param name="c">Code point.</param>
            <param name="sc">Script code.</param>
            <returns>true if <paramref name="sc"/> is in Script_Extensions(<paramref name="c"/>).</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetScriptExtensions(System.Int32,ICU4N.Support.Collections.BitSet)">
            <summary>
            Sets code point <paramref name="c"/>'s Script_Extensions as script code integers into the output <see cref="T:ICU4N.Support.Collections.BitSet"/>.
            </summary>
            <remarks>
            <list type="bullet">
                <item><description>
                    If <paramref name="c"/> does have Script_Extensions, then the return value is
                    the negative number of Script_Extensions codes (= -set.Cardinality());
                    in this case, the Script property value
                    (normally Common or Inherited) is not included in the set.
                </description></item>
                <item><description>
                    If <paramref name="c"/> does not have Script_Extensions, then the one Script code is put into the set
                    and also returned.
                </description></item>
                <item><description>
                    If <paramref name="c"/> is not a valid code point, then the one <see cref="F:ICU4N.Globalization.UScript.Unknown"/> code is put into the set
                    and also returned.
                </description></item>
            </list>
            In other words, if the return value is non-negative, it is <paramref name="c"/>'s single Script code
            and the set contains exactly this Script code.
            If the return value is -n, then the set contains <paramref name="c"/>'s n&gt;=2 Script_Extensions script codes.
            <para/>
            Some characters are commonly used in multiple scripts.
            For more information, see UAX #24: <a href="http://www.unicode.org/reports/tr24/">http://www.unicode.org/reports/tr24/</a>.
            </remarks>
            <param name="c">Code point.</param>
            <param name="set">Set of script code integers; will be cleared, then bits are set
            corresponding to <paramref name="c"/>'s Script_Extensions.</param>
            <returns>Negative number of script codes in c's Script_Extensions,
            or the non-negative single Script value.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetName(System.Int32)">
            <summary>
            Returns the long Unicode script name, if there is one.
            Otherwise returns the 4-letter ISO 15924 script code.
            Returns "Malayam" given <see cref="F:ICU4N.Globalization.UScript.Malayalam"/>.
            </summary>
            <param name="scriptCode">int script code.</param>
            <returns>Long script name as given in PropertyValueAliases.txt, or the 4-letter code.</returns>
            <exception cref="T:System.ArgumentException">If the script code is not valid.</exception>
            <seealso cref="M:ICU4N.Globalization.UScript.TryGetName(System.Int32,System.String@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.TryGetName(System.Int32,System.String@)">
            <summary>
            Gets the long Unicode script name, if there is one.
            Otherwise returns the 4-letter ISO 15924 script code.
            Returns "Malayam" given <see cref="F:ICU4N.Globalization.UScript.Malayalam"/>.
            </summary>
            <param name="scriptCode">Script code.</param>
            <param name="result">Long script name as given in PropertyValueAliases.txt, or the 4-letter code.</param>
            <returns>true if the script code is valid, otherwise false.</returns>
            <seealso cref="M:ICU4N.Globalization.UScript.GetName(System.Int32)"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetShortName(System.Int32)">
            <summary>
            Returns the 4-letter ISO 15924 script code,
            which is the same as the short Unicode script name if Unicode has names for the script.
            Returns "Mlym" given <see cref="F:ICU4N.Globalization.UScript.Malayalam"/>.
            </summary>
            <param name="scriptCode">int script code</param>
            <returns>Short script name (4-letter code).</returns>
            <exception cref="T:System.ArgumentException">If the script code is not valid.</exception>
            <seealso cref="M:ICU4N.Globalization.UScript.TryGetShortName(System.Int32,System.String@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.TryGetShortName(System.Int32,System.String@)">
            <summary>
            Gets the 4-letter ISO 15924 script code,
            which is the same as the short Unicode script name if Unicode has names for the script.
            Returns "Mlym" given <see cref="F:ICU4N.Globalization.UScript.Malayalam"/>.
            </summary>
            <param name="scriptCode">int script code</param>
            <param name="result">Short script name (4-letter code).</param>
            <returns>true if the name was retrieved, otherwise false.</returns>
            <exception cref="T:System.ArgumentException">If the script code is not valid.</exception>
            <seealso cref="M:ICU4N.Globalization.UScript.GetShortName(System.Int32)"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="T:ICU4N.Globalization.UScript.ScriptMetadata">
            <summary>
            Script metadata (script properties).
            See <a href="http://unicode.org/cldr/trac/browser/trunk/common/properties/scriptMetadata.txt">
            http://unicode.org/cldr/trac/browser/trunk/common/properties/scriptMetadata.txt</a>
            </summary>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetSampleString(System.Int32)">
            <summary>
            Returns the script sample character string.
            This string normally consists of one code point but might be longer.
            The string is empty if the script is not encoded.
            </summary>
            <param name="script">Script code.</param>
            <returns>The sample character string.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.GetUsage(System.Int32)">
            <summary>
            Returns the script usage according to UAX #31 Unicode Identifier and Pattern Syntax.
            Returns <see cref="F:ICU4N.Globalization.ScriptUsage.NotEncoded"/> if the script is not encoded in Unicode.
            </summary>
            <param name="script">Script code.</param>
            <returns>Script usage.</returns>
            <seealso cref="T:ICU4N.Globalization.ScriptUsage"/>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.IsRightToLeft(System.Int32)">
            <summary>
            Returns true if the script is written right-to-left.
            For example, Arab and Hebr.
            </summary>
            <param name="script">Script code.</param>
            <returns>true if the script is right-to-left.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.BreaksBetweenLetters(System.Int32)">
            <summary>
            Returns true if the script allows line breaks between letters (excluding hyphenation).
            Such a script typically requires dictionary-based line breaking.
            For example, Hani and Thai.
            </summary>
            <param name="script">Script code.</param>
            <returns>true if the script allows line breaks between letters.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Globalization.UScript.IsCased(System.Int32)">
            <summary>
            Returns true if in modern (or most recent) usage of the script case distinctions are customary.
            For example, Latn and Cyrl.
            </summary>
            <param name="script">Script code.</param>
            <returns>true if the script is cased.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="T:ICU4N.Globalization.ScriptUsage">
            <summary>
            Script usage constants.
            See UAX #31 Unicode Identifier and Pattern Syntax.
            <a href="http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers">
            http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers</a>
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.NotEncoded">
            <summary>
            Not encoded in Unicode.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.Unknown">
            <summary>
            Unknown script usage.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.Excluded">
            <summary>
            Candidate for Exclusion from Identifiers.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.LimitedUse">
            <summary>
            Limited Use script.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.Aspirational">
            <summary>
            Aspirational Use script.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Globalization.ScriptUsage.Recommended">
            <summary>
            Recommended script.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="T:ICU4N.UChar">
            <icuenhanced cref="T:System.Char"/>.<icu>_usage_</icu>
            <summary>
            The <see cref="T:ICU4N.UChar"/> class provides extensions to the <see cref="T:System.Char"/> class.
            These extensions provide support for more Unicode properties.
            Each ICU release supports the latest version of Unicode available at that time.
            </summary>
            <remarks>
            Code points are represented in these API using <see cref="T:System.Int32"/>s. While it would be
            more convenient in .NET to have a separate primitive datatype for them,
            <see cref="T:System.Int32"/>s suffice in the meantime.
            <para/>
            Aside from the additions for UTF-16 support, and the updated Unicode
            properties, the main differences between <see cref="T:ICU4N.UChar"/> and <see cref="T:System.Char"/> are:
            <list type="bullet">
                <item><description>
                    <see cref="T:ICU4N.UChar"/> is not designed to be a struct and does not have
                    APIs to which involves management of that single <see cref="T:System.Char"/>.
                    These include:
                    <list type="bullet">
                        <item><description><see cref="T:System.IConvertible"/> members.</description></item>
                        <item><description><see cref="M:System.Char.CompareTo(System.Char)"/>, etc.</description></item>
                    </list>
                </description></item>
                <item><description>
                    <see cref="T:System.Char"/>'s API uses single <see cref="T:System.Char"/> values and/or <see cref="T:System.String"/>
                    values to cover surrogate pairs. However, this API uses single <see cref="T:System.Int32"/> code points, 
                    which can represent the entire Unicode range of values using a single value.
                </description></item>
            </list>
            <para/>
            In addition to .NET compatibility functions, which calculate derived properties,
            this API provides low-level access to the Unicode Character Database.
            <para/>
            Unicode assigns each code point (not just assigned character) values for
            many properties.
            Most of them are simple boolean flags, or constants from a small enumerated list.
            For some properties, values are strings or other relatively more complex types.
            <para/>
            For more information see
            <a href="http://www.unicode/org/ucd/">"About the Unicode Character Database"</a>
            (http://www.unicode.org/ucd/)
            and the <a href="http://www.icu-project.org/userguide/properties.html">ICU
            User Guide chapter on Properties</a>
            (http://www.icu-project.org/userguide/properties.html).
            <para/>
            There are also functions that provide easy migration from C/POSIX functions. 
            Their use is generally discouraged because the C/POSIX
            standards do not define their semantics beyond the ASCII range, which means
            that different implementations exhibit very different behavior.
            Instead, Unicode properties should be used directly.
            <para/>
            There are also only a few, broad C/POSIX character classes, and they tend
            to be used for conflicting purposes. For example, the "isalpha()" class
            is sometimes used to determine word boundaries, while a more sophisticated
            approach would at least distinguish initial letters from continuation
            characters (the latter including combining marks).
            (In ICU, <see cref="T:ICU4N.Text.BreakIterator"/> is the most sophisticated API for word boundaries.)
            Another example: There is no "istitle()" class for titlecase characters.
            <para/>
            ICU 3.4 and later provides API access for all twelve C/POSIX character classes.
            ICU implements them according to the Standard Recommendations in
            Annex C: Compatibility Properties of UTS #18 Unicode Regular Expressions
            (http://www.unicode.org/reports/tr18/#Compatibility_Properties).
            <para/>
            API access for C/POSIX character classes is as follows:
            <code>
            - alpha:     IsUAlphabetic(c) or HasBinaryProperty(c, UProperty.Alphabetic)
            - lower:     IsULower(c) or HasBinaryProperty(c, UProperty.Lowercase)
            - upper:     IsUUpper(c) or HasBinaryProperty(c, UProperty.Uppercase)
            - punct:     ((1&lt;&lt;GetUnicodeCategory(c)) &amp; ((1&lt;&lt;ECharacterCategory.DashPunctuation)|(1&lt;&lt;CharacterCategory.StartPunctuation)|
                          (1&lt;&lt;CharacterCategory.EndPunctuation)|(1&lt;&lt;CharacterCategory.ConnectorPunctuation)|(1&lt;&lt;CharacterCategory.OtherPunctuation)|
                          (1&lt;&lt;CharacterCategory.InitialPunctuation)|(1&lt;&lt;CharacterCategory.FinalPunctuation)))!=0
            - digit:     IsDigit(c) or GetUnicodeCategory(c)==CharacterCategory.DecimalDigitNumber
            - xdigit:    HasBinaryProperty(c, UProperty.POSIX_XDigit)
            - alnum:     HasBinaryProperty(c, UProperty.POSIX_Alnum)
            - space:     IsUWhiteSpace(c) or HasBinaryProperty(c, UProperty.White_Space)
            - blank:     HasBinaryProperty(c, UProperty.POSIX_Blank)
            - cntrl:     GetUnicodeCategory(c)==CharacterCategory.Control
            - graph:     HasBinaryProperty(c, UProperty.POSIX_Graph)
            - print:     HasBinaryProperty(c, UProperty.POSIX_Print)
            </code>
            <para/>
            The C/POSIX character classes are also available in <see cref="T:ICU4N.Text.UnicodeSet"/> patterns,
            using patterns like <c>[:graph:]</c> or <c>\p{graph}</c>.
            <para/>
            <icunote>There are several ICU (and .NET) whitespace functions.
            Comparison:
            <list type="bullet">
                <item><term><see cref="M:ICU4N.UChar.IsUWhiteSpace(System.Int32)"/></term><description>
                    Unicode White_Space property;
                    most of general categories "Z" (separators) + most whitespace ISO controls
                    (including no-break spaces, but excluding IS1..IS4 and ZWSP)
                </description></item>
                <item><term><see cref="M:ICU4N.UChar.IsWhiteSpace(System.Int32)"/></term><description>
                    .NET <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> or <see cref="M:System.Char.IsWhiteSpace(System.String,System.Int32)"/>; 
                    Z + whitespace ISO controls but excluding no-break spaces
                </description></item>
                <item><term><see cref="M:ICU4N.UChar.IsSpaceChar(System.Int32)"/></term><description>
                    just Z (including no-break spaces)
                </description></item>
            </list>
            </icunote>
            <para/>
            This class is not subclassable.
            </remarks>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.1</stable>
            <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>
            <see cref="T:ICU4N.Globalization.UCharacterDirection"/>
        </member>
        <member name="F:ICU4N.UChar.Unassigned">
            <summary>
            Unassigned character type
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="T:ICU4N.UChar.UnicodeBlock">
            <icu>_usage_</icu>
            <summary>
            A family of character subsets representing the character blocks in the
            Unicode specification, generated from Unicode Data file Blocks.txt.
            Character blocks generally define characters used for a specific script
            or purpose. A character is contained by at most one Unicode block.
            <para/>
            <icunote>All fields named XXX_ID are specific to ICU.</icunote>
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Invalid_Code_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Basic_Latin_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_1_Supplement_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.IPA_Extensions_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Spacing_Modifier_Letters_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Greek_ID">
            <summary>
            Unicode 3.2 renames this block to "Greek and Coptic".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Armenian_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hebrew_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syriac_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Thaana_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Devanagari_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bengali_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gurmukhi_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gujarati_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Oriya_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tamil_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Telugu_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kannada_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Malayalam_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sinhala_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Thai_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lao_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tibetan_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Georgian_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cherokee_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Unified_Canadian_Aboriginal_Syllabics_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ogham_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Runic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khmer_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mongolian_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_Additional_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Greek_Extended_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.General_Punctuation_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Superscripts_And_Subscripts_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Currency_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Marks_For_Symbols_ID">
            <summary>
            Unicode 3.2 renames this block to "Combining Diacritical Marks for
            Symbols".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Letterlike_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Number_Forms_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arrows_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mathematical_Operators_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Technical_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Control_Pictures_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Optical_Character_Recognition_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Alphanumerics_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Box_Drawing_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Block_Elements_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Geometric_Shapes_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Dingbats_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Braille_Patterns_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Radicals_Supplement_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kangxi_Radicals_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ideographic_Description_Characters_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Symbols_And_Punctuation_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hiragana_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Katakana_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bopomofo_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Compatibility_Jamo_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kanbun_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bopomofo_Extended_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_CJK_Letters_And_Months_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yi_Syllables_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yi_Radicals_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Syllables_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.High_Surrogates_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.High_Private_Use_Surrogates_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Low_Surrogates_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Private_Use_Area_ID">
            <summary>
            Same as <see cref="F:ICU4N.UChar.UnicodeBlock.Private_Use"/>.
            Until Unicode 3.1.1; the corresponding block name was "Private Use";
            and multiple code point ranges had this block.
            Unicode 3.2 renames the block for the BMP PUA to "Private Use Area"
            and adds separate blocks for the supplementary PUAs.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Private_Use_ID">
            <summary>
            Same as <see cref="F:ICU4N.UChar.UnicodeBlock.Private_Use_Area"/>.
            Until Unicode 3.1.1; the corresponding block name was "Private Use";
            and multiple code point ranges had this block.
            Unicode 3.2 renames the block for the BMP PUA to "Private Use Area"
            and adds separate blocks for the supplementary PUAs.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Ideographs_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Alphabetic_Presentation_Forms_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Presentation_Forms_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Half_Marks_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Forms_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Small_Form_Variants_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Presentation_Forms_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Specials_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.HalfWidth_And_FullWidth_Forms_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Italic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gothic_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Deseret_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Byzantine_Musical_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Musical_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mathematical_Alphanumeric_Symbols_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Ideographs_Supplement_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tags_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Supplementary_ID">
            <summary>
            Unicode 4.0.1 renames the "Cyrillic Supplementary" block to "Cyrillic Supplement".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Supplement_ID">
            <summary>
            Unicode 4.0.1 renames the "Cyrillic Supplementary" block to "Cyrillic Supplement".
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tagalog_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hanunoo_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Buhid_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tagbanwa_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Mathematical_Symbols_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Mathematical_Symbols_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Mathematical_Operators_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Katakana_Phonetic_Extensions_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Variation_Selectors_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplementary_Private_Use_Area_A_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplementary_Private_Use_Area_B_ID">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Limbu_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Le_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khmer_Symbols_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phonetic_Extensions_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols_And_Arrows_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yijing_Hexagram_Symbols_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_B_Syllabary_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_B_Ideograms_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Aegean_Numbers_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ugaritic_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Shavian_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Osmanya_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cypriot_Syllabary_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Xuan_Jing_Symbols_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Variation_Selectors_Supplement_ID">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Greek_Musical_Notation_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Greek_Numbers_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Supplement_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Buginese_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Strokes_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks_Supplement_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Coptic_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Extended_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Supplement_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Georgian_Supplement_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Glagolitic_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kharoshthi_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Modifier_Tone_Letters_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.New_Tai_Lue_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Persian_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phonetic_Extensions_Supplement_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Punctuation_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syloti_Nagri_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tifinagh_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vertical_Forms_ID">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nko_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Balinese_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_C_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_D_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phags_Pa_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phoenician_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cuneiform_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cuneiform_Numbers_And_Punctuation_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Counting_Rod_Numerals_ID">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sundanese_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lepcha_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ol_Chiki_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_A_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vai_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_B_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Saurashtra_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kayah_Li_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Rejang_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cham_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Symbols_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phaistos_Disc_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lycian_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Carian_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lydian_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mahjong_Tiles_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Domino_Tiles_ID">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Samaritan_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Unified_Canadian_Aboriginal_Syllabics_Extended_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Tham_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vedic_Extensions_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lisu_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bamum_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Common_Indic_Number_Forms_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Devanagari_Extended_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo_Extended_A_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Javanese_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar_Extended_A_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Viet_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meetei_Mayek_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo_Extended_B_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Imperial_Aramaic_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_South_Arabian_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Avestan_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Inscriptional_Parthian_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Inscriptional_Pahlavi_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Turkic_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Rumi_Numeral_Symbols_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kaithi_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Egyptian_Hieroglyphs_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Alphanumeric_Supplement_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Ideographic_Supplement_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_C_ID">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mandaic_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Batak_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Extended_A_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Brahmi_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bamum_Supplement_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kana_Supplement_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Playing_Cards_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols_And_Pictographs_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Emoticons_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Transport_And_Map_Symbols_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Alchemical_Symbols_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_D_ID">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Extended_A_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Mathematical_Alphabetic_Symbols_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Chakma_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meetei_Mayek_Extensions_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meroitic_Cursive_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meroitic_Hieroglyphs_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miao_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sharada_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sora_Sompeng_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sundanese_Supplement_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Takri_ID">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bassa_Vah_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Caucasian_Albanian_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Coptic_Epact_Numbers_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks_Extended_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Duployan_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Elbasan_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Geometric_Shapes_Extended_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Grantha_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khojki_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khudawadi_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_E_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_A_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mahajani_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Manichaean_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mende_Kikakui_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Modi_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mro_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar_Extended_B_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nabataean_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_North_Arabian_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Permic_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ornamental_Dingbats_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Pahawh_Hmong_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Palmyrene_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Pau_Cin_Hau_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Psalter_Pahlavi_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Shorthand_Format_Controls_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Siddham_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sinhala_Archaic_Numbers_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_C_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tirhuta_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Warang_Citi_ID">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ahom_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Anatolian_Hieroglyphs_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cherokee_Supplement_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_E_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Early_Dynastic_Cuneiform_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hatran_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Multani_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Hungarian_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Symbols_And_Pictographs_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sutton_Signwriting_ID">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Adlam_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bhaiksuki_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_C_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Glagolitic_Supplement_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ideographic_Symbols_And_Punctuation_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Marchen_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mongolian_Supplement_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Newa_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Osage_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tangut_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tangut_Components_ID">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_F_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kana_Extended_A_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Masaram_Gondi_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nushu_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Soyombo_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syriac_Supplement_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Zanabazar_Square_ID">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Count">
            <summary>
            One more than the highest normal UnicodeBlock value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/> 
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Block"/>.
            </summary>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.BLOCKS_">
            <summary>
            Array of <see cref="T:ICU4N.UChar.UnicodeBlock"/>s, for easy access in <see cref="M:ICU4N.UChar.UnicodeBlock.GetInstance(System.Int32)"/>
            </summary>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.NoBlock">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Basic_Latin">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_1_Supplement">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.IPA_Extensions">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Spacing_Modifier_Letters">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Greek">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Armenian">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hebrew">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syriac">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Thaana">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Devanagari">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bengali">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gurmukhi">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gujarati">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Oriya">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tamil">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Telugu">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kannada">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Malayalam">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sinhala">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Thai">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lao">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tibetan">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Georgian">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cherokee">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Unified_Canadian_Aboriginal_Syllabics">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ogham">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Runic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khmer">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mongolian">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_Additional">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Greek_Extended">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.General_Punctuation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Superscripts_And_Subscripts">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Currency_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Marks_For_Symbols">
            <summary>
            Unicode 3.2 renames this block to "Combining Diacritical Marks for
            Symbols".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Letterlike_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Number_Forms">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arrows">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mathematical_Operators">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Technical">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Control_Pictures">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Optical_Character_Recognition">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Alphanumerics">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Box_Drawing">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Block_Elements">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Geometric_Shapes">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Dingbats">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Braille_Patterns">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Radicals_Supplement">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kangxi_Radicals">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ideographic_Description_Characters">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Symbols_And_Punctuation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hiragana">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Katakana">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bopomofo">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Compatibility_Jamo">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kanbun">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bopomofo_Extended">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_CJK_Letters_And_Months">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yi_Syllables">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yi_Radicals">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Syllables">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.High_Surrogates">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.High_Private_Use_Surrogates">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Low_Surrogates">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Private_Use_Area">
            <summary>
            Same as <see cref="F:ICU4N.UChar.UnicodeBlock.Private_Use"/>.
            Until Unicode 3.1.1; the corresponding block name was "Private Use";
            and multiple code point ranges had this block.
            Unicode 3.2 renames the block for the BMP PUA to "Private Use Area"
            and adds separate blocks for the supplementary PUAs.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Private_Use">
            <summary>
            Same as <see cref="F:ICU4N.UChar.UnicodeBlock.Private_Use_Area"/>.
            Until Unicode 3.1.1; the corresponding block name was "Private Use";
            and multiple code point ranges had this block.
            Unicode 3.2 renames the block for the BMP PUA to "Private Use Area"
            and adds separate blocks for the supplementary PUAs.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Ideographs">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Alphabetic_Presentation_Forms">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Presentation_Forms_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Half_Marks">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Forms">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Small_Form_Variants">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Presentation_Forms_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Specials">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.HalfWidth_And_FullWidth_Forms">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Italic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Gothic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Deseret">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Byzantine_Musical_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Musical_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mathematical_Alphanumeric_Symbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Compatibility_Ideographs_Supplement">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tags">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Supplementary">
            <summary>
            Unicode 4.0.1 renames the "Cyrillic Supplementary" block to "Cyrillic Supplement".
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Supplement">
            <summary>
            Unicode 4.0.1 renames the "Cyrillic Supplementary" block to "Cyrillic Supplement".
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tagalog">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hanunoo">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Buhid">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tagbanwa">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Mathematical_Symbols_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Mathematical_Symbols_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Mathematical_Operators">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Katakana_Phonetic_Extensions">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Variation_Selectors">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplementary_Private_Use_Area_A">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplementary_Private_Use_Area_B">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Limbu">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Le">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khmer_Symbols">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phonetic_Extensions">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols_And_Arrows">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Yijing_Hexagram_Symbols">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_B_Syllabary">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_B_Ideograms">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Aegean_Numbers">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ugaritic">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Shavian">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Osmanya">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cypriot_Syllabary">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Xuan_Jing_Symbols">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Variation_Selectors_Supplement">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Greek_Musical_Notation">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Greek_Numbers">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Supplement">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Buginese">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Strokes">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks_Supplement">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Coptic">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Extended">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Supplement">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Georgian_Supplement">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Glagolitic">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kharoshthi">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Modifier_Tone_Letters">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.New_Tai_Lue">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Persian">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phonetic_Extensions_Supplement">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Punctuation">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syloti_Nagri">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tifinagh">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vertical_Forms">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nko">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Balinese">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_C">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_D">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phags_Pa">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phoenician">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cuneiform">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cuneiform_Numbers_And_Punctuation">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Counting_Rod_Numerals">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sundanese">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lepcha">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ol_Chiki">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_A">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vai">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_B">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Saurashtra">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kayah_Li">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Rejang">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cham">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ancient_Symbols">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Phaistos_Disc">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lycian">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Carian">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lydian">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mahjong_Tiles">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Domino_Tiles">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Samaritan">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Unified_Canadian_Aboriginal_Syllabics_Extended">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Tham">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Vedic_Extensions">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Lisu">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bamum">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Common_Indic_Number_Forms">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Devanagari_Extended">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo_Extended_A">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Javanese">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar_Extended_A">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tai_Viet">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meetei_Mayek">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hangul_Jamo_Extended_B">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Imperial_Aramaic">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_South_Arabian">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Avestan">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Inscriptional_Parthian">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Inscriptional_Pahlavi">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Turkic">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Rumi_Numeral_Symbols">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kaithi">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Egyptian_Hieroglyphs">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Alphanumeric_Supplement">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Enclosed_Ideographic_Supplement">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_C">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mandaic">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Batak">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ethiopic_Extended_A">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Brahmi">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bamum_Supplement">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kana_Supplement">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Playing_Cards">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miscellaneous_Symbols_And_Pictographs">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Emoticons">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Transport_And_Map_Symbols">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Alchemical_Symbols">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_D">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Extended_A">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Arabic_Mathematical_Alphabetic_Symbols">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Chakma">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meetei_Mayek_Extensions">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meroitic_Cursive">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Meroitic_Hieroglyphs">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Miao">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sharada">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sora_Sompeng">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sundanese_Supplement">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Takri">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bassa_Vah">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Caucasian_Albanian">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Coptic_Epact_Numbers">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Combining_Diacritical_Marks_Extended">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Duployan">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Elbasan">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Geometric_Shapes_Extended">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Grantha">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khojki">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Khudawadi">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Latin_Extended_E">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Linear_A">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mahajani">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Manichaean">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mende_Kikakui">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Modi">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mro">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Myanmar_Extended_B">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nabataean">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_North_Arabian">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Permic">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ornamental_Dingbats">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Pahawh_Hmong">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Palmyrene">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Pau_Cin_Hau">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Psalter_Pahlavi">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Shorthand_Format_Controls">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Siddham">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sinhala_Archaic_Numbers">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Arrows_C">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tirhuta">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Warang_Citi">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ahom">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Anatolian_Hieroglyphs">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cherokee_Supplement">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_E">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Early_Dynastic_Cuneiform">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Hatran">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Multani">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Old_Hungarian">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Supplemental_Symbols_And_Pictographs">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Sutton_Signwriting">
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Adlam">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Bhaiksuki">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Cyrillic_Extended_C">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Glagolitic_Supplement">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Ideographic_Symbols_And_Punctuation">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Marchen">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Mongolian_Supplement">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Newa">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Osage">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tangut">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Tangut_Components">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.CJK_Unified_Ideographs_Extension_F">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Kana_Extended_A">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Masaram_Gondi">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Nushu">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Soyombo">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Syriac_Supplement">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Zanabazar_Square">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.Invalid_Code">
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.UnicodeBlock.GetInstance(System.Int32)">
            <icu/>
            <summary>
            Returns the only instance of the <see cref="T:ICU4N.UChar.UnicodeBlock"/> with the argument ID.
            If no such ID exists, a <see cref="F:ICU4N.UChar.UnicodeBlock.Invalid_Code"/> <see cref="T:ICU4N.UChar.UnicodeBlock"/> will be returned.
            </summary>
            <param name="id"><see cref="T:ICU4N.UChar.UnicodeBlock"/> ID.</param>
            <returns>the only instance of the <see cref="T:ICU4N.UChar.UnicodeBlock"/> with the argument ID
            if it exists, otherwise a <see cref="F:ICU4N.UChar.UnicodeBlock.Invalid_Code"/> <see cref="T:ICU4N.UChar.UnicodeBlock"/> will be
            returned.
            </returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.UnicodeBlock.Of(System.Int32)">
            <summary>
            Returns the Unicode allocation block that contains the code point,
            or null if the code point is not a member of a defined block.
            </summary>
            <param name="ch">Code point to be tested.</param>
            <returns>The Unicode allocation block that contains the code point.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.UnicodeBlock.ForName(System.String)">
            <summary>
            Returns the Unicode block with the given name. This matches
            against the official UCD name (ignoring case).
            </summary>
            <param name="blockName">The name of the block to match.</param>
            <returns>The <see cref="T:ICU4N.UChar.UnicodeBlock"/> with that name.</returns>
            <exception cref="T:System.ArgumentException">If the blockName could not be matched.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="P:ICU4N.UChar.UnicodeBlock.ID">
            <icu/>
            <summary>
            Gets the type ID of this Unicode block.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.UnicodeBlock.ToString">
            <summary>
            Returns the name of this <see cref="T:ICU4N.UChar.UnicodeBlock"/>.
            </summary>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.m_id_">
            <summary>
            Identification code for this <see cref="T:ICU4N.UChar.UnicodeBlock"/>
            </summary>
        </member>
        <member name="F:ICU4N.UChar.UnicodeBlock.name">
            <summary>
            Name for this <see cref="T:ICU4N.UChar.UnicodeBlock"/>
            </summary>
        </member>
        <member name="M:ICU4N.UChar.UnicodeBlock.#ctor(System.String,System.Int32)">
            <summary>
            <see cref="T:ICU4N.UChar.UnicodeBlock"/> constructor.
            </summary>
            <param name="name">Name of this <see cref="T:ICU4N.UChar.UnicodeBlock"/>.</param>
            <param name="id">Unique id of this <see cref="T:ICU4N.UChar.UnicodeBlock"/>.</param>
            <exception cref="T:System.ArgumentNullException">If name is <c>null</c>.</exception>
        </member>
        <member name="T:ICU4N.UChar.EastAsianWidth">
            <summary>
            East Asian Width constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.East_Asian_Width"/>
            <seealso cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.Neutral">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.Ambiguous">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.HalfWidth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.FullWidth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.Narrow">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.Wide">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.EastAsianWidth.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.EastAsianWidth"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.East_Asian_Width"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.DecompositionType">
            <summary>
            Decomposition Type constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Decomposition_Type"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.None">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Canonical">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Compat">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Circle">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Final">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Font">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Fraction">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Initial">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Isolated">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Medial">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Narrow">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.NoBreak">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Small">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Square">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Sub">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Super">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Vertical">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.Wide">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.DecompositionType.COUNT">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.DecompositionType"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Decomposition_Type"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.JoiningType">
            <summary>
            Joining Type constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Joining_Type"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.NonJoining">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.JoinCausing">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.DualJoining">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.LeftJoining">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.RightJoining">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.Transparent">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningType.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.JoiningType"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Joining_Type"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.JoiningGroup">
            <summary>
            Joining Group constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Joining_Group"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.NoJoiningGroup">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Ain">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Alaph">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Alef">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Beh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Beth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Dal">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.DalathRish">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.E">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Feh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.FinalSemkath">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Gaf">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Gamal">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Hah">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.TehMarbutaGoal">
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.HamzaOnHehGoal">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.He">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Heh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.HehGoal">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Heth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Kaf">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Kaph">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.KnottedHeh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Lam">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Lamadh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Meem">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Mim">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Noon">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Nun">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Pe">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Qaf">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Qaph">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Reh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ReversedPe">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Sad">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Sadhe">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Seen">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Semkath">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Shin">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.SwashKaf">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.SyriacWaw">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Tah">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Taw">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.TehMarbuta">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Teth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Waw">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Yeh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.YehBarree">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.YehWithTail">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Yudh">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.YudhHe">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Zain">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Fe">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Khaph">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Zhain">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.BurushaskiYehBarree">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.FarsiYeh">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Nya">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.RohingyaYeh">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanAleph">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanAyin">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanBeth">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanDaleth">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanDhamedh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanFive">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanGimel">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanHeth">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanHundred">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanKaph">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanLamedh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanMem">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanNun">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanOne">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanPe">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanQoph">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanResh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanSadhe">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanSamekh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanTaw">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanTen">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanTeth">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanThamedh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanTwenty">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanWaw">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanYodh">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.ManichaeanZayin">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.StraightWaw">
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.AfricanFeh">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.AfricanNoon">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.AfricanQaf">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamBha">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamJa">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamLla">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamLlla">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamNga">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamNna">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamNnna">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamNya">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamRa">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamSsa">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.MalayalamTta">
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.UChar.JoiningGroup.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.JoiningGroup"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Joining_Group"/>
            </summary>
        </member>
        <member name="T:ICU4N.UChar.GraphemeClusterBreak">
            <summary>
            Grapheme Cluster Break constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Grapheme_Cluster_Break"/>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Other">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Control">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Cr">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Extend">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.L">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Lf">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Lv">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Lvt">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.T">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.V">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.SpacingMark">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Prepend">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.RegionalIndicator">
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.EBase">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.EBaseGaz">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.EModifier">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.GlueAfterZwj">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Zwj">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.GraphemeClusterBreak.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.GraphemeClusterBreak"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Grapheme_Cluster_Break"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.WordBreak">
            <summary>
            Word Break constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Word_Break"/>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Other">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.ALetter">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Format">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Katakana">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.MidLetter">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.MidNum">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Numeric">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.ExtendNumLet">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Cr">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Extend">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Lf">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.MidNumLet">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Newline">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.RegionalIndicator">
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.HebrewLetter">
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.SingleQuote">
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.DoubleQuote">
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.EBase">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.EBaseGaz">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.EModifier">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.GlueAfterZwj">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Zwj">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.WordBreak.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.WordBreak"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Word_Break"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.SentenceBreak">
            <summary>
            Sentence Break constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Sentence_Break"/>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Other">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.ATerm">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Close">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Format">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Lower">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Numeric">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.OLetter">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Sep">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Sp">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.STerm">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Upper">
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Cr">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Extend">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Lf">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.SContinue">
            <stable>ICU 4.0</stable>
        </member>
        <member name="F:ICU4N.UChar.SentenceBreak.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.SentenceBreak"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Sentence_Break"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.LineBreak">
            <summary>
            Line Break constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Line_Break"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Unknown">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Ambiguous">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Alphabetic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.BreakBoth">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.BreakAfter">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.BreakBefore">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.MandatoryBreak">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.ContingentBreak">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.ClosePunctuation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.CombiningMark">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.CarriageReturn">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Exclamation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Glue">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Hyphen">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Ideographic">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Inseparable">
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.InfixNumeric">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.LineFeed">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Nonstarter">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Numeric">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.OpenPunctuation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.PostfixNumeric">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.PrefixNumeric">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Quotation">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.ComplexContext">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Surrogate">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Space">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.BreakSymbols">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.ZwSpace">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.NextLine">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.WordJoiner">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.H2">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.H3">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Jl">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Jt">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Jv">
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.CloseParenthesis">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.ConditionalJapaneseStarter">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.HebrewLetter">
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.RegionalIndicator">
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.EBase">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.EModifier">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Zwj">
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.UChar.LineBreak.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.LineBreak"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Line_Break"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.NumericType">
            <summary>
            Numeric Type constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Numeric_Type"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.NumericType.None">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.NumericType.Decimal">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.NumericType.Digit">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.NumericType.Numeric">
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.UChar.NumericType.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.NumericType"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Numeric_Type"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.HangulSyllableType">
            <summary>
            Hangul Syllable Type constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Hangul_Syllable_Type"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.NotApplicable">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.LeadingJamo">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.VowelJamo">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.TrailingJamo">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.LvSyllable">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.LvtSyllable">
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.HangulSyllableType.COUNT">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.HangulSyllableType"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Hangul_Syllable_Type"/>.
            </summary>
        </member>
        <member name="T:ICU4N.UChar.BidiPairedBracketType">
            <summary>
            Bidi Paired Bracket Type constants.
            </summary>
            <seealso cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type"/>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.BidiPairedBracketType.None">
            <summary>
            Not a paired bracket.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.BidiPairedBracketType.Open">
            <summary>
            Open paired bracket.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.BidiPairedBracketType.Close">
            <summary>
            Close paired bracket.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.UChar.BidiPairedBracketType.Count">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.UChar.BidiPairedBracketType"/> value.
            The highest value is available via <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            with parameter <see cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type"/>.
            </summary>
        </member>
        <member name="F:ICU4N.UChar.MinValue">
            <summary>
            The lowest Unicode code point value, constant 0.
            Same as <see cref="F:ICU4N.Support.Text.Character.MIN_CODE_POINT"/>, same integer value as <see cref="F:System.Char.MinValue"/>.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxValue">
            <summary>
            The highest Unicode code point value (scalar value), constant U+10FFFF (uses 21 bits).
            Same integer value as <see cref="F:ICU4N.Support.Text.Character.MAX_CODE_POINT"/>.
            <para/>
            Up-to-date Unicode implementation of <see cref="F:System.Char.MaxValue"/>
            which is still a char with the value U+FFFF.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.UChar.SupplementaryMinValue">
            <summary>
            The minimum value for Supplementary code points, constant U+10000.
            Same as <see cref="F:ICU4N.Support.Text.Character.MIN_SUPPLEMENTARY_CODE_POINT"/>.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.UChar.ReplacementChar">
            <summary>
            Unicode value used when translating into Unicode encoding form and there
            is no existing character.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.UChar.NoNumericValue">
            <summary>
            Special value that is returned by <see cref="M:ICU4N.UChar.GetUnicodeNumericValue(System.Int32)"/> when no
            numeric value is defined for a code point.
            </summary>
            <stable>ICU 2.4</stable>
            <seealso cref="M:ICU4N.UChar.GetUnicodeNumericValue(System.Int32)"/>
        </member>
        <member name="F:ICU4N.UChar.MinRadix">
            <summary>
            Compatibility constant for <see cref="F:ICU4N.Support.Text.Character.MIN_RADIX"/>.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxRadix">
            <summary>
            Compatibility constant for <see cref="F:ICU4N.Support.Text.Character.MAX_RADIX"/>.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.UChar.TitleCaseNoLowerCase">
            <summary>
            Do not lowercase non-initial parts of words when titlecasing.
            Option bit for titlecasing APIs that take an options bit set.
            </summary>
            <remarks>
            By default, titlecasing will titlecase the first cased character
            of a word and lowercase all other characters.
            With this option, the other characters will not be modified.
            </remarks>
            <see cref="M:ICU4N.UChar.ToTitleCase(System.Int32)"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.UChar.TitleCaseNoBreakAdjustment">
            <summary>
            Do not adjust the titlecasing indexes from <see cref="M:ICU4N.Text.BreakIterator.Next"/> indexes;
            titlecase exactly the characters at breaks from the iterator.
            Option bit for titlecasing APIs that take an options bit set.
            </summary>
            <remarks>
            By default, titlecasing will take each break iterator index,
            adjust it by looking for the next cased character, and titlecase that one.
            Other characters are lowercased.
            <para/>
            This follows Unicode 4 &amp; 5 section 3.13 Default Case Operations:
            <para/>
            R3  ToTitleCase(X): Find the word boundaries based on Unicode Standard Annex
            #29, "Text Boundaries." Between each pair of word boundaries, find the first
            cased character F. If F exists, map F to default_title(F); then map each
            subsequent character C to default_lower(C).
            </remarks>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Int32)"/>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoLowerCase"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.UChar.Digit(System.Int32,System.Int32)">
            <summary>
            Returns the numeric value of a decimal digit code point.
            <para/>
            Note that this will return positive values for code points 
            for which <see cref="M:ICU4N.UChar.IsDigit(System.Int32)"/> returns false.
            </summary>
            <remarks>
            A code point is a valid digit if and only if:
            <list type="bullet">
                <item><description><paramref name="ch"/> is a decimal digit or one of the european letters, and</description></item>
                <item><description>the value of <paramref name="ch"/> is less than the specified radix.</description></item>
            </list>
            </remarks>
            <param name="ch">The code point to query.</param>
            <param name="radix">The radix.</param>
            <returns>The numeric value represented by the code point in the
            specified radix, or -1 if the code point is not a decimal digit
            or if its value is too large for the radix.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.Digit(System.Int32)">
            <summary>
            Returns the numeric value of a decimal digit code point.
            <para/>
            This is a convenience overload of <see cref="M:ICU4N.UChar.Digit(System.Int32,System.Int32)"/>
            that provides a decimal radix.
            </summary>
            <param name="ch">The code point to query.</param>
            <returns>The numeric value represented by the code point,
            or -1 if the code point is not a decimal digit or if its
            value is too large for a decimal radix.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetNumericValue(System.Int32)">
            <summary>
            Returns the numeric value of the code point as a nonnegative
            integer.
            <para/>
            If the code point does not have a numeric value, then -1 is returned.
            <para/>
            If the code point has a numeric value that cannot be represented as a
            nonnegative integer (for example, a fractional value), then -2 is
            returned.
            </summary>
            <param name="ch">The code point to query.</param>
            <returns>The numeric value of the code point, or -1 if it has no numeric
            value, or -2 if it has a numeric value that cannot be represented as a
            nonnegative integer.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetUnicodeNumericValue(System.Int32)">
            <icu/>
            <summary>
            Returns the numeric value for a Unicode code point as defined in the
            Unicode Character Database.
            <para/>
            A <see cref="T:System.Double"/> return type is necessary because some numeric values are
            fractions, negative, or too large for <see cref="T:System.Int32"/>.
            <para/>
            For characters without any numeric values in the Unicode Character
            Database, this function will return <see cref="F:ICU4N.UChar.NoNumericValue"/>.
            Note: This is different from the Unicode Standard which specifies NaN as the default value.
            <para/>
            This corresponds to the ICU4C function u_getNumericValue.
            </summary>
            <param name="ch">Code point to get the numeric value for.</param>
            <returns>Numeric value of <paramref name="ch"/>, or <see cref="F:ICU4N.UChar.NoNumericValue"/> if none is defined.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSpace(System.Int32)">
            <summary>
            Compatibility override of Java deprecated method.  This
            method will always remain deprecated. 
            Same as <see cref="M:ICU4N.Support.Text.Character.IsSpace(System.Char)"/>.
            </summary>
            <param name="ch">The code point.</param>
            <returns>true if the code point is a space character as
            defined by <see cref="M:ICU4N.Support.Text.Character.IsSpace(System.Char)"/>.</returns>
        </member>
        <member name="M:ICU4N.UChar.GetUnicodeCategory(System.Int32)">
            <summary>
            Returns a value indicating a code point's Unicode category.
            Up-to-date Unicode implementation of <c>char.GetUnicodeCategory(char)</c>
            except for the code points that had their category changed.
            <para/>
            Return results are constants from the enum <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.
            <para/>
            <em>NOTE:</em> the <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values are <em>not</em> compatible with
            those returned by <c>char.GetUnicodeCategory(char)</c> or <see cref="M:ICU4N.Support.Text.Character.GetType(System.Int32)"/>.
            <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values
            match the ones used in ICU4C, while <see cref="T:ICU4N.Support.Text.Character"/> type
            values, though similar, skip the value 17. The <see cref="T:System.Globalization.UnicodeCategory"/>
            numeric values are often different than with <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>'s values.
            </summary>
            <param name="ch">Code point whose category is to be determined.</param>
            <returns>Category which is a value of <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetUnicodeCategory(System.Char)">
            <summary>
            Returns a value indicating a code point's Unicode category.
            Up-to-date Unicode implementation of <c>char.GetUnicodeCategory(char)</c>
            except for the code points that had their category changed.
            <para/>
            Return results are constants from the enum <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.
            <para/>
            <em>NOTE:</em> the <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values are <em>not</em> compatible with
            those returned by <c>char.GetUnicodeCategory(char)</c> or <see cref="M:ICU4N.Support.Text.Character.GetType(System.Int32)"/>.
            <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values
            match the ones used in ICU4C, while <see cref="T:ICU4N.Support.Text.Character"/> type
            values, though similar, skip the value 17. The <see cref="T:System.Globalization.UnicodeCategory"/>
            numeric values are often different than with <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>'s values.
            </summary>
            <param name="c"><see cref="T:System.Char"/> whose category is to be determined.</param>
            <returns>Category which is a value of <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.GetUnicodeCategory(System.String,System.Int32)">
            <summary>
            Returns a value indicating a code point's Unicode category.
            Up-to-date Unicode implementation of <c>char.GetUnicodeCategory(char)</c>
            except for the code points that had their category changed.
            <para/>
            Return results are constants from the enum <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.
            <para/>
            <em>NOTE:</em> the <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values are <em>not</em> compatible with
            those returned by <c>char.GetUnicodeCategory(char)</c> or <see cref="M:ICU4N.Support.Text.Character.GetType(System.Int32)"/>.
            <see cref="T:ICU4N.Globalization.UUnicodeCategory"/> values
            match the ones used in ICU4C, while <see cref="T:ICU4N.Support.Text.Character"/> type
            values, though similar, skip the value 17. The <see cref="T:System.Globalization.UnicodeCategory"/>
            numeric values are often different than with <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>'s values.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The character position in <paramref name="s"/>.</param>
            <returns>Category which is a value of <see cref="T:ICU4N.Globalization.UUnicodeCategory"/>.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsDefined(System.Int32)">
            <summary>
            Determines if a code point has a defined meaning in the up-to-date
            Unicode standard.
            E.g. supplementary code points though allocated space are not defined in
            Unicode yet.
            </summary>
            <param name="ch">Code point to be determined if it is defined in the most
            current version of Unicode.</param>
            <returns>true if this code point is defined in unicode.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsDefined(System.Char)">
            <summary>
            Determines if a code point has a defined meaning in the up-to-date
            Unicode standard.
            E.g. supplementary code points though allocated space are not defined in
            Unicode yet.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be determined if it is defined in the most
            current version of Unicode.</param>
            <returns>true if this code point is defined in unicode.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsDefined(System.String,System.Int32)">
            <summary>
            Determines if a code point has a defined meaning in the up-to-date
            Unicode standard.
            E.g. supplementary code points though allocated space are not defined in
            Unicode yet.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if this code point is defined in unicode.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsDigit(System.Int32)">
            <summary>
            Determines if a code point is a .NET digit.
            <para/>
            It returns true for decimal digits only.
            </summary>
            <param name="ch">Code point to query.</param>
            <returns>true if this code point is a digit.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsDigit(System.Char)">
            <summary>
            Determines if a code point is a .NET digit.
            <para/>
            It returns true for decimal digits only.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to query.</param>
            <returns>true if this code point is a digit.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsDigit(System.String,System.Int32)">
            <summary>
            Determines if a code point is a .NET digit.
            <para/>
            It returns true for decimal digits only.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if this code point is a digit.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsISOControl(System.Int32)">
            <summary>
            Determines if the specified code point is an ISO control character.
            A code point is considered to be an ISO control character if it is in
            the range &#92;u0000 through &#92;u001F or in the range &#92;u007F through
            &#92;u009F.
            </summary>
            <param name="ch">Code point to determine if it is an ISO control character.</param>
            <returns>true if code point is a ISO control character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsISOControl(System.Char)">
            <summary>
            Determines if the specified code point is an ISO control character.
            A code point is considered to be an ISO control character if it is in
            the range &#92;u0000 through &#92;u001F or in the range &#92;u007F through
            &#92;u009F.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to determine if it is an ISO control character.</param>
            <returns>true if code point is a ISO control character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsISOControl(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is an ISO control character.
            A code point is considered to be an ISO control character if it is in
            the range &#92;u0000 through &#92;u001F or in the range &#92;u007F through
            &#92;u009F.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index"></param>
            <returns>true if code point is a ISO control character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLetter(System.Int32)">
            <summary>
            Determines if the specified code point is a letter.
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLetter(System.Char)"/>.
            </summary>
            <param name="ch">Code point to determine if it is a letter.</param>
            <returns>true if code point is a letter.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLetter(System.Char)">
            <summary>
            Determines if the specified code point is a letter.
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLetter(System.Char)"/>.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to determine if it is a letter.</param>
            <returns>true if code point is a letter.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLetter(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a letter.
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLetter(System.String,System.Int32)"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is a letter.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLetterOrDigit(System.Int32)">
            <summary>
            Determines if the specified code point is a letter or digit.
            </summary>
            <param name="ch">Code point to determine if it is a letter or a digit.</param>
            <returns>true if code point is a letter or a digit.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLetterOrDigit(System.Char)">
            <summary>
            Determines if the specified code point is a letter or digit.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to determine if it is a letter or a digit.</param>
            <returns>true if code point is a letter or a digit.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLetterOrDigit(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a letter or digit.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is a letter or a digit.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLower(System.Int32)">
            <summary>
            Determines if the specified code point is a lowercase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLower(System.Char)"/>.
            </remarks>
            <param name="ch">Code point to determine if it is in lowercase.</param>
            <returns>true if code point is a lowercase character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLower(System.Char)">
            <summary>
            Determines if the specified code point is a lowercase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLower(System.Char)"/>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if it is in lowercase.</param>
            <returns>true if code point is a lowercase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsLower(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a lowercase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsLower(System.String,System.Int32)"/>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is a lowercase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsWhiteSpace(System.Int32)">
            <summary>
            Determines if the specified code point is a white space character.
            </summary>
            <remarks>
            A code point is considered to be an whitespace character if and only
            if it satisfies one of the following criteria:
            <list type="bullet">
                <item><description>
                    It is a Unicode Separator character (categories "Z" = "Zs" or "Zl" or "Zp"), but is not
                    also a non-breaking space (&#92;u00A0 or &#92;u2007 or &#92;u202F).
                </description></item>
                <item><description>
                    It is &#92;u0009, HORIZONTAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000A, LINE FEED.
                </description></item>
                <item><description>
                    It is &#92;u000B, VERTICAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000C, FORM FEED.
                </description></item>
                <item><description>
                    It is &#92;u000D, CARRIAGE RETURN.
                </description></item>
                <item><description>
                    It is &#92;u001C, FILE SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001D, GROUP SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001E, RECORD SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001F, UNIT SEPARATOR.
                </description></item>
            </list>
            <para/>
            This API tries to sync with the semantics of .NET's <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>, 
            but it may not return the exact same results because of the Unicode version
            difference.
            <para/>
            Note: Unicode 4.0.1 changed U+200B ZERO WIDTH SPACE from a Space Separator (Zs)
            to a Format Control (Cf). Since then, <c>IsWhitespace(0x200b)</c> returns false.
            See <a href="http://www.unicode.org/versions/Unicode4.0.1/">http://www.unicode.org/versions/Unicode4.0.1/</a>.
            </remarks>
            <param name="ch">Code point to determine if it is a white space.</param>
            <returns>true if the specified code point is a white space character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsWhiteSpace(System.Char)">
            <summary>
            Determines if the specified code point is a white space character.
            </summary>
            <remarks>
            A code point is considered to be an whitespace character if and only
            if it satisfies one of the following criteria:
            <list type="bullet">
                <item><description>
                    It is a Unicode Separator character (categories "Z" = "Zs" or "Zl" or "Zp"), but is not
                    also a non-breaking space (&#92;u00A0 or &#92;u2007 or &#92;u202F).
                </description></item>
                <item><description>
                    It is &#92;u0009, HORIZONTAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000A, LINE FEED.
                </description></item>
                <item><description>
                    It is &#92;u000B, VERTICAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000C, FORM FEED.
                </description></item>
                <item><description>
                    It is &#92;u000D, CARRIAGE RETURN.
                </description></item>
                <item><description>
                    It is &#92;u001C, FILE SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001D, GROUP SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001E, RECORD SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001F, UNIT SEPARATOR.
                </description></item>
            </list>
            <para/>
            This API tries to sync with the semantics of .NET's <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>, 
            but it may not return the exact same results because of the Unicode version
            difference.
            <para/>
            Note: Unicode 4.0.1 changed U+200B ZERO WIDTH SPACE from a Space Separator (Zs)
            to a Format Control (Cf). Since then, <c>IsWhitespace(0x200b)</c> returns false.
            See <a href="http://www.unicode.org/versions/Unicode4.0.1/">http://www.unicode.org/versions/Unicode4.0.1/</a>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if it is a white space.</param>
            <returns>true if the specified code point is a white space character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsWhiteSpace(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a white space character.
            </summary>
            <remarks>
            A code point is considered to be an whitespace character if and only
            if it satisfies one of the following criteria:
            <list type="bullet">
                <item><description>
                    It is a Unicode Separator character (categories "Z" = "Zs" or "Zl" or "Zp"), but is not
                    also a non-breaking space (&#92;u00A0 or &#92;u2007 or &#92;u202F).
                </description></item>
                <item><description>
                    It is &#92;u0009, HORIZONTAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000A, LINE FEED.
                </description></item>
                <item><description>
                    It is &#92;u000B, VERTICAL TABULATION.
                </description></item>
                <item><description>
                    It is &#92;u000C, FORM FEED.
                </description></item>
                <item><description>
                    It is &#92;u000D, CARRIAGE RETURN.
                </description></item>
                <item><description>
                    It is &#92;u001C, FILE SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001D, GROUP SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001E, RECORD SEPARATOR.
                </description></item>
                <item><description>
                    It is &#92;u001F, UNIT SEPARATOR.
                </description></item>
            </list>
            <para/>
            This API tries to sync with the semantics of .NET's <see cref="M:System.Char.IsWhiteSpace(System.String,System.Int32)"/>, 
            but it may not return the exact same results because of the Unicode version
            difference.
            <para/>
            Note: Unicode 4.0.1 changed U+200B ZERO WIDTH SPACE from a Space Separator (Zs)
            to a Format Control (Cf). Since then, <c>IsWhitespace(0x200b)</c> returns false.
            See <a href="http://www.unicode.org/versions/Unicode4.0.1/">http://www.unicode.org/versions/Unicode4.0.1/</a>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the specified code point is a white space character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsSpaceChar(System.Int32)">
            <summary>
            Determines if the specified code point is a Unicode specified space
            character, i.e. if code point is in the category Zs, Zl and Zp.
            </summary>
            <param name="ch">Code point to determine if it is a space.</param>
            <returns>true if the specified code point is a space character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSpaceChar(System.Char)">
            <summary>
            Determines if the specified code point is a Unicode specified space
            character, i.e. if code point is in the category Zs, Zl and Zp.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to determine if it is a space.</param>
            <returns>true if the specified code point is a space character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsSpaceChar(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a Unicode specified space
            character, i.e. if code point is in the category Zs, Zl and Zp.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the specified code point is a space character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsTitleCase(System.Int32)">
            <summary>
            Determines if the specified code point is a titlecase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            </remarks>
            <param name="ch">Code point to determine if it is in title case.</param>
            <returns>true if the specified code point is a titlecase character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsTitleCase(System.Char)">
            <summary>
            Determines if the specified code point is a titlecase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if it is in title case.</param>
            <returns>true if the specified code point is a titlecase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsTitleCase(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is a titlecase character.
            UnicodeData only contains case mappings for code points where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For more information about Unicode case mapping
            please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">Technical report #21</a>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the specified code point is a titlecase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierPart(System.Int32)">
            <summary>
            Determines if the specified code point may be any part of a Unicode
            identifier other than the starting character.
            </summary>
            <remarks>
            A code point may be part of a Unicode identifier if and only if it is
            one of the following:
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
                <item><description> Pc Connecting punctuation character </description></item>
                <item><description> Nd decimal number </description></item>
                <item><description> Mc Spacing combining mark </description></item>
                <item><description> Mn Non-spacing mark </description></item>
                <item><description> Cf formatting code </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="ch">code point to determine if is can be part of a Unicode
            identifier.</param>
            <returns>true if code point is any character belonging a unicode
            identifier suffix after the first character.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierPart(System.Char)">
            <summary>
            Determines if the specified code point may be any part of a Unicode
            identifier other than the starting character.
            </summary>
            <remarks>
            A code point may be part of a Unicode identifier if and only if it is
            one of the following:
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
                <item><description> Pc Connecting punctuation character </description></item>
                <item><description> Nd decimal number </description></item>
                <item><description> Mc Spacing combining mark </description></item>
                <item><description> Mn Non-spacing mark </description></item>
                <item><description> Cf formatting code </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if is can be part of a Unicode
            identifier.</param>
            <returns>true if code point is any character belonging a unicode
            identifier suffix after the first character.
            </returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierPart(System.String,System.Int32)">
            <summary>
            Determines if the specified code point may be any part of a Unicode
            identifier other than the starting character.
            </summary>
            <remarks>
            A code point may be part of a Unicode identifier if and only if it is
            one of the following:
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
                <item><description> Pc Connecting punctuation character </description></item>
                <item><description> Nd decimal number </description></item>
                <item><description> Mc Spacing combining mark </description></item>
                <item><description> Mn Non-spacing mark </description></item>
                <item><description> Cf formatting code </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is any character belonging a unicode
            identifier suffix after the first character.
            </returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierStart(System.Int32)">
            <summary>
            Determines if the specified code point is permissible as the first
            character in a Unicode identifier.
            </summary>
            <remarks>
            A code point may start a Unicode identifier if it is of type either
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="ch">code point to determine if it can start a Unicode identifier.</param>
            <returns>true if code point is the first character belonging a unicode
            identifier.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierStart(System.Char)">
            <summary>
            Determines if the specified code point is permissible as the first
            character in a Unicode identifier.
            </summary>
            <remarks>
            A code point may start a Unicode identifier if it is of type either
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if it can start a Unicode identifier.</param>
            <returns>true if code point is the first character belonging a unicode
            identifier.
            </returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUnicodeIdentifierStart(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is permissible as the first
            character in a Unicode identifier.
            </summary>
            <remarks>
            A code point may start a Unicode identifier if it is of type either
            <list type="bullet">
                <item><description> Lu Uppercase letter </description></item>
                <item><description> Ll Lowercase letter </description></item>
                <item><description> Lt Titlecase letter </description></item>
                <item><description> Lm Modifier letter </description></item>
                <item><description> Lo Other letter </description></item>
                <item><description> Nl Letter number </description></item>
            </list>
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is the first character belonging a unicode
            identifier.
            </returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsIdentifierIgnorable(System.Int32)">
            <summary>
            Determines if the specified code point should be regarded as an
            ignorable character in a .NET identifier.
            </summary>
            <remarks>
            A character is .NET-identifier-ignorable if it has the general category
            Cf Formatting Control, or it is a non-.NET-whitespace ISO control:
            U+0000..U+0008, U+000E..U+001B, U+007F..U+009F.
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            <para/>
            Note that Unicode just recommends to ignore Cf (format controls).
            </remarks>
            <param name="ch">Code point to be determined if it can be ignored in a Unicode
            identifier.</param>
            <returns>true if the code point is ignorable.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsIdentifierIgnorable(System.Char)">
            <summary>
            Determines if the specified code point should be regarded as an
            ignorable character in a .NET identifier.
            </summary>
            <remarks>
            A character is .NET-identifier-ignorable if it has the general category
            Cf Formatting Control, or it is a non-.NET-whitespace ISO control:
            U+0000..U+0008, U+000E..U+001B, U+007F..U+009F.
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            <para/>
            Note that Unicode just recommends to ignore Cf (format controls).
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to be determined if it can be ignored in a Unicode
            identifier.</param>
            <returns>true if the code point is ignorable.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsIdentifierIgnorable(System.String,System.Int32)">
            <summary>
            Determines if the specified code point should be regarded as an
            ignorable character in a .NET identifier.
            </summary>
            <remarks>
            A character is .NET-identifier-ignorable if it has the general category
            Cf Formatting Control, or it is a non-.NET-whitespace ISO control:
            U+0000..U+0008, U+000E..U+001B, U+007F..U+009F.
            <para/>
            See <a href="http://www.unicode.org/unicode/reports/tr8/">UTR #8</a>.
            <para/>
            Note that Unicode just recommends to ignore Cf (format controls).
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the code point is ignorable.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUpper(System.Int32)">
            <summary>
            Determines if the specified code point is an uppercase character.
            UnicodeData only contains case mappings for code point where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For language specific case conversion behavior, use <c>CultureInfo.TextInfo.ToUpper(char)</c>.
            <para/>
            For example, the case conversion for dot-less i and dotted I in Turkish,
            or for final sigma in Greek.
            For more information about Unicode case mapping please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">
            Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsUpper(System.Char)"/>.
            </remarks>
            <param name="ch">Code point to determine if it is in uppercase.</param>
            <returns>true if the code point is an uppercase character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUpper(System.Char)">
            <summary>
            Determines if the specified code point is an uppercase character.
            UnicodeData only contains case mappings for code point where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For language specific case conversion behavior, use <c>CultureInfo.TextInfo.ToUpper(char)</c>.
            <para/>
            For example, the case conversion for dot-less i and dotted I in Turkish,
            or for final sigma in Greek.
            For more information about Unicode case mapping please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">
            Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsUpper(System.Char)"/>.
            </remarks>
            <param name="c"><see cref="T:System.Char"/> to determine if it is in uppercase.</param>
            <returns>true if the <see cref="T:System.Char"/> is an uppercase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUpper(System.String,System.Int32)">
            <summary>
            Determines if the specified code point is an uppercase character.
            UnicodeData only contains case mappings for code point where they are
            one-to-one mappings; it also omits information about context-sensitive
            case mappings.
            </summary>
            <remarks>
            For language specific case conversion behavior, use <c>CultureInfo.TextInfo.ToUpper(char)</c>.
            <para/>
            For example, the case conversion for dot-less i and dotted I in Turkish,
            or for final sigma in Greek.
            For more information about Unicode case mapping please refer to the
            <a href="http://www.unicode.org/unicode/reports/tr21/">
            Technical report #21</a>.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.IsUpper(System.String,System.Int32)"/>.
            </remarks>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the <see cref="T:System.Char"/> is an uppercase character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.ToLower(System.Int32)">
            <summary>
            The given code point is mapped to its lowercase equivalent; if the code
            point has no lowercase equivalent, the code point itself is returned.
            Up-to-date Unicode implementation of <see cref="M:System.Char.ToLower(System.Char)"/>
            </summary>
            <remarks>
            This function only returns the simple, single-code point case mapping.
            Full case mappings should be used whenever possible because they produce
            better results by working on whole strings.
            They take into account the string context and the language and can map
            to a result string with a different length as appropriate.
            Full case mappings are applied by the case mapping functions
            that take string parameters rather than code points (int).
            See also the User Guide chapter on C/POSIX migration:
            <a href="http://www.icu-project.org/userguide/posix.html#case_mappings">
            http://www.icu-project.org/userguide/posix.html#case_mappings</a>
            </remarks>
            <param name="ch">Code point whose lowercase equivalent is to be retrieved.</param>
            <returns>The lowercase equivalent code point.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToString(System.Int32)">
            <summary>
            Converts argument code point and returns a string object representing
            the code point's value in UTF-16 format.
            The result is a string whose length is 1 for BMP code points, 2 for supplementary ones.
            <para/>
            Up-to-date Unicode implementation of <see cref="M:System.Char.ConvertFromUtf32(System.Int32)"/>, however
            this implementation differs in that it returns null rather than throwing exceptions if
            the input is not a valid code point.
            </summary>
            <param name="ch">Code point.</param>
            <returns>String representation of the code point, null if code point is not
            defined in unicode.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(System.Int32)">
            <summary>
            Converts the code point argument to titlecase.
            If no titlecase is available, the uppercase is returned. If no uppercase
            is available, the code point itself is returned.
            Up-to-date Unicode implementation of <c>CultureInfo.TextInfo.ToTitleCase(string)</c>.
            </summary>
            <remarks>
            This function only returns the simple, single-code point case mapping.
            Full case mappings should be used whenever possible because they produce
            better results by working on whole strings.
            They take into account the string context and the language and can map
            to a result string with a different length as appropriate.
            Full case mappings are applied by the case mapping functions
            that take string parameters rather than code points (int).
            See also the User Guide chapter on C/POSIX migration:
            <a href="http://www.icu-project.org/userguide/posix.html#case_mappings">
            http://www.icu-project.org/userguide/posix.html#case_mappings</a>
            </remarks>
            <param name="ch">Code point whose title case is to be retrieved.</param>
            <returns>Titlecase code point.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToUpper(System.Int32)">
            <summary>
            Converts the character argument to uppercase.
            If no uppercase is available, the character itself is returned.
            Up-to-date Unicode implementation of <see cref="M:System.Char.ToUpper(System.Char)"/>.
            </summary>
            <remarks>
            This function only returns the simple, single-code point case mapping.
            Full case mappings should be used whenever possible because they produce
            better results by working on whole strings.
            They take into account the string context and the language and can map
            to a result string with a different length as appropriate.
            Full case mappings are applied by the case mapping functions
            that take string parameters rather than code points (int).
            See also the User Guide chapter on C/POSIX migration:
            <a href="http://www.icu-project.org/userguide/posix.html#case_mappings">
            http://www.icu-project.org/userguide/posix.html#case_mappings</a>
            </remarks>
            <param name="ch">Code point whose uppercase is to be retrieved.</param>
            <returns>Uppercase code point.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementary(System.Int32)">
            <icu/>
            <summary>
            Determines if the code point is a supplementary character.
            A code point is a supplementary character if and only if it is greater
            than <see cref="F:ICU4N.UChar.SupplementaryMinValue"/>.
            </summary>
            <param name="ch">Code point to be determined if it is in the supplementary plane.</param>
            <returns>true if code point is a supplementary character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementary(System.Char)">
            <icu/>
            <summary>
            Determines if the code point is a supplementary character.
            A code point is a supplementary character if and only if it is greater
            than <see cref="F:ICU4N.UChar.SupplementaryMinValue"/>.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be determined if it is in the supplementary plane.</param>
            <returns>true if code point is a supplementary character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementary(System.String,System.Int32)">
            <icu/>
            <summary>
            Determines if the code point is a supplementary character.
            A code point is a supplementary character if and only if it is greater
            than <see cref="F:ICU4N.UChar.SupplementaryMinValue"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is a supplementary character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsBMP(System.Int32)">
            <icu/>
            <summary>
            Determines if the code point is in the BMP plane.
            </summary>
            <param name="ch">Code point to be determined if it is not a supplementary character.</param>
            <returns>true if code point is not a supplementary character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsBMP(System.Char)">
            <icu/>
            <summary>
            Determines if the code point is in the BMP plane.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be determined if it is not a supplementary character.</param>
            <returns>true if code point is not a supplementary character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsBMP(System.String,System.Int32)">
            <icu/>
            <summary>
            Determines if the code point is in the BMP plane.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if code point is not a supplementary character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsPrintable(System.Int32)">
            <icu/>
            <summary>
            Determines whether the specified code point is a printable character
            according to the Unicode standard.
            </summary>
            <param name="ch">Code point to be determined if it is printable.</param>
            <returns>true if the code point is a printable character.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsPrintable(System.Char)">
            <icu/>
            <summary>
            Determines whether the specified code point is a printable character
            according to the Unicode standard.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be determined if it is printable.</param>
            <returns>true if the code point is a printable character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsPrintable(System.String,System.Int32)">
            <icu/>
            <summary>
            Determines whether the specified code point is a printable character
            according to the Unicode standard.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the code point is a printable character.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsBaseForm(System.Int32)">
            <icu/>
            <summary>
            Determines whether the specified code point is of base form.
            A code point of base form does not graphically combine with preceding
            characters, and is neither a control nor a format character.
            </summary>
            <param name="ch">Code point to be determined if it is of base form.</param>
            <returns>true if the code point is of base form.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsBaseForm(System.Char)">
            <icu/>
            <summary>
            Determines whether the specified code point is of base form.
            A code point of base form does not graphically combine with preceding
            characters, and is neither a control nor a format character.
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be determined if it is of base form.</param>
            <returns>true if the code point is of base form.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsBaseForm(System.String,System.Int32)">
            <icu/>
            <summary>
            Determines whether the specified code point is of base form.
            A code point of base form does not graphically combine with preceding
            characters, and is neither a control nor a format character.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the code point is of base form.</returns>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.GetDirection(System.Int32)">
            <icu/>
            <summary>
            Returns the Bidirection property of a code point.
            For example, 0x0041 (letter A) has the <see cref="F:ICU4N.Globalization.UCharacterDirection.LeftToRight"/> directional
            property.
            <para/>
            Result returned belongs to the enum <see cref="T:ICU4N.Globalization.UCharacterDirection"/>.
            </summary>
            <param name="ch">The code point to be determined its direction.</param>
            <returns>Direction constant from <see cref="T:ICU4N.Globalization.UCharacterDirection"/>.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsMirrored(System.Int32)">
            <summary>
            Determines whether the code point has the "mirrored" property.
            This property is set for characters that are commonly used in
            Right-To-Left contexts and need to be displayed with a "mirrored"
            glyph.
            </summary>
            <param name="ch">Code point whose mirror is to be determined.</param>
            <returns>true if the code point has the "mirrored" property.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetMirror(System.Int32)">
            <icu/>
            <summary>
            Maps the specified code point to a "mirror-image" code point.
            For code points with the "mirrored" property, implementations sometimes
            need a "poor man's" mapping to another code point such that the default
            glyph may serve as the mirror-image of the default glyph of the
            specified code point.
            <para/>
            This is useful for text conversion to and from codepages with visual
            order, and for displays without glyph selection capabilities.
            </summary>
            <param name="ch">Code point whose mirror is to be retrieved.</param>
            <returns>Another code point that may serve as a mirror-image substitute,
            or <paramref name="ch"/> itself if there is no such mapping or 
            <paramref name="ch"/> does not have the "mirrored" property.
            </returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetBidiPairedBracket(System.Int32)">
            <icu/>
            <summary>
            Maps the specified character to its paired bracket character.
            For <see cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type"/>!=None, this 
            is the same as <see cref="M:ICU4N.UChar.GetMirror(System.Int32)"/>.
            Otherwise <paramref name="c"/> itself is returned.
            See <a href="http://www.unicode.org/reports/tr9/">http://www.unicode.org/reports/tr9/</a>.
            </summary>
            <param name="c">The code point to be mapped.</param>
            <returns>The paired bracket code point,
            or <paramref name="c"/> itself if there is no such mapping
            (<see cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type"/>=None)
            </returns>
            <seealso cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket"/>
            <seealso cref="F:ICU4N.Globalization.UProperty.Bidi_Paired_Bracket_Type"/>
            <seealso cref="M:ICU4N.UChar.GetMirror(System.Int32)"/>
            <stable>ICU 52</stable>
        </member>
        <member name="M:ICU4N.UChar.GetCombiningClass(System.Int32)">
            <icu/>
            <summary>
            Returns the combining class of the argument codepoint.
            </summary>
            <param name="ch">Code point whose combining is to be retrieved.</param>
            <returns>The combining class of the codepoint.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLegal(System.Int32)">
            <icu/>
            <summary>
            A code point is illegal if and only if
            <list type="bullet">
                <item><description> Out of bounds, less than 0 or greater than <see cref="F:ICU4N.UChar.MaxValue"/> </description></item>
                <item><description> A surrogate value, 0xD800 to 0xDFFF </description></item>
                <item><description> Not-a-character, having the form 0x xxFFFF or 0x xxFFFE </description></item>
            </list>
            Note: legal does not mean that it is assigned in this version of Unicode.
            </summary>
            <param name="ch">Code point to determine if it is a legal code point by itself.</param>
            <returns>true if and only if legal.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLegal(System.String)">
            <icu/>
            <summary>
            A string is legal if and only if all its code points are legal.
            A code point is illegal if and only if
            <list type="bullet">
                <item><description> Out of bounds, less than 0 or greater than <see cref="F:ICU4N.UChar.MaxValue"/> </description></item>
                <item><description> A surrogate value, 0xD800 to 0xDFFF </description></item>
                <item><description> Not-a-character, having the form 0x xxFFFF or 0x xxFFFE </description></item>
            </list>
            Note: legal does not mean that it is assigned in this version of Unicode.
            </summary>
            <param name="str">String containing code points to examine.</param>
            <returns>true if and only if legal.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="P:ICU4N.UChar.UnicodeVersion">
            <icu/>
            <summary>
            Gets the version of Unicode data used.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetName(System.Int32)">
            <icu/>
            <summary>
            Returns the most current Unicode name of the argument code point, or
            null if the character is unassigned or outside the range
            <see cref="F:ICU4N.UChar.MinValue"/> and <see cref="F:ICU4N.UChar.MaxValue"/>
            or does not have a name.
            <para/>
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </summary>
            <param name="ch">The code point for which to get the name.</param>
            <returns>Most current Unicode name.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetName(System.String,System.String)">
            <icu/>
            <summary>
            Returns the names for each of the characters in a string.
            </summary>
            <param name="s">String to format.</param>
            <param name="separator">String to go between names.</param>
            <returns>String of names.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.UChar.GetName1_0(System.Int32)">
            <icu/>
            <summary>
            Returns null.
            Used to return the Unicode_1_Name property value which was of little practical value.
            </summary>
            <param name="ch">The code point for which to get the name.</param>
            <returns>Null.</returns>
        </member>
        <member name="M:ICU4N.UChar.GetExtendedName(System.Int32)">
            <icu/>
            <summary>
            Returns a name for a valid codepoint. Unlike, <see cref="M:ICU4N.UChar.GetName(System.Int32)"/> and
            <see cref="M:ICU4N.UChar.GetName1_0(System.Int32)"/>, this method will return a name even for codepoints that
            are not assigned a name in UnicodeData.txt.
            </summary>
            <remarks>
            The names are returned in the following order.
            <list type="bullet">
                <item><description>Most current Unicode name if there is any</description></item>
                <item><description>Unicode 1.0 name if there is any</description></item>
                <item><description>Extended name in the form of 
                    "&lt;codepoint_type-codepoint_hex_digits&gt;". E.g., &lt;noncharacter-fffe&gt;</description></item>
            </list>
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </remarks>
            <param name="ch">The code point for which to get the name.</param>
            <returns>A name for the argument codepoint.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetNameAlias(System.Int32)">
            <icu/>
            <summary>
            Returns the corrected name from NameAliases.txt if there is one.
            Returns null if the character is unassigned or outside the range
            <see cref="F:ICU4N.UChar.MinValue"/> and <see cref="F:ICU4N.UChar.MaxValue"/>
            or does not have a name.
            <para/>
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </summary>
            <param name="ch">The code point for which to get the name alias.</param>
            <returns>Unicode name alias, or null.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetISOComment(System.Int32)">
            <icu/>
            <summary>
            Returns null.
            Used to return the ISO 10646 comment for a character.
            The Unicode <see cref="F:ICU4N.Globalization.UProperty.ISO_Comment"/> property is deprecated and has no values.
            </summary>
            <param name="ch">The code point for which to get the ISO comment.
            It must be the case that <c>0 &lt;= <paramref name="ch"/> &lt;= 0x10ffff</c>.
            </param>
            <returns>null.</returns>
        </member>
        <member name="M:ICU4N.UChar.GetCharFromName(System.String)">
            <icu/>
            <summary>
            Finds a Unicode code point by its most current Unicode name and
            return its code point value. All Unicode names are in uppercase.
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </summary>
            <param name="name">Most current Unicode character name whose code point is to
            be returned.</param>
            <returns>Code point or -1 if name is not found.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetCharFromName1_0(System.String)">
            <icu/>
            <summary>
            Returns -1.
            <para/>
            Used to find a Unicode character by its version 1.0 Unicode name and return
            its code point value.
            </summary>
            <param name="name">Unicode 1.0 code point name whose code point is to be
            returned.</param>
            <returns>-1</returns>
            <seealso cref="M:ICU4N.UChar.GetName1_0(System.Int32)"/>
        </member>
        <member name="M:ICU4N.UChar.GetCharFromExtendedName(System.String)">
            <icu/>
            <summary>
            Find a Unicode character by either its name and return its code
            point value. 
            </summary>
            <remarks>
            All Unicode names are in uppercase.
            Extended names are all lowercase except for numbers and are contained
            within angle brackets.
            The names are searched in the following order
            <list type="bullet">
                <item><description>Most current Unicode name if there is any</description></item>
                <item><description>Unicode 1.0 name if there is any</description></item>
                <item><description>Extended name in the form of
                    "&lt;codepoint_type-codepoint_hex_digits&gt;". E.g. &lt;noncharacter-FFFE&gt;</description></item>
            </list>
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </remarks>
            <param name="name">Codepoint name.</param>
            <returns>Code point associated with the name or -1 if the name is not
            found.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetCharFromNameAlias(System.String)">
            <icu/>
            <summary>
            Find a Unicode character by its corrected name alias and return
            its code point value. All Unicode names are in uppercase.
            Note calling any methods related to code point names, e.g. Get*Name*()
            incurs a one-time initialization cost to construct the name tables.
            </summary>
            <param name="name">Unicode name alias whose code point is to be returned.</param>
            <returns>Code point or -1 if name is not found.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice)">
            <summary>
            Return the Unicode name for a given property, as given in the
            Unicode database file PropertyAliases.txt.  Most properties
            have more than one name.  The <paramref name="nameChoice"/> determines which one
            is returned.
            </summary>
            <remarks>
            In addition, this function maps the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/> to the synthetic names "gcm" /
            "General_Category_Mask".  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="property"><see cref="T:ICU4N.Globalization.UProperty"/> selector.</param>
            <param name="nameChoice">
            <see cref="T:ICU4N.Globalization.NameChoice"/> selector for which name
            to get.  All properties have a long name.  Most have a short
            name, but some do not.  Unicode allows for additional names; if
            present these will be returned by <see cref="F:ICU4N.Globalization.NameChoice.Long"/> + i,
            where i=1, 2,...
            </param>
            <returns>
            A name, or null if Unicode explicitly defines no name
            ("n/a") for a given <paramref name="property"/>/<paramref name="nameChoice"/>.  
            If a given <paramref name="nameChoice"/> throws an exception, then all larger 
            values of <paramref name="nameChoice"/> will throw an exception.  If null is 
            returned for a given <paramref name="nameChoice"/>, then other 
            <paramref name="nameChoice"/> values may return non-null results.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="property"/> or 
            <paramref name="nameChoice"/> are invalid.</exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="T:ICU4N.Globalization.NameChoice"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice,System.String@)">
            <summary>
            Return the Unicode name for a given property, as given in the
            Unicode database file PropertyAliases.txt.  Most properties
            have more than one name.  The <paramref name="nameChoice"/> determines which one
            is returned.
            </summary>
            <remarks>
            In addition, this function maps the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/> to the synthetic names "gcm" /
            "General_Category_Mask".  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="property"><see cref="T:ICU4N.Globalization.UProperty"/> selector.</param>
            <param name="nameChoice">
            <see cref="T:ICU4N.Globalization.NameChoice"/> selector for which name
            to get.  All properties have a long name.  Most have a short
            name, but some do not.  Unicode allows for additional names; if
            present these will be returned by <see cref="F:ICU4N.Globalization.NameChoice.Long"/> + i,
            where i=1, 2,...
            </param>
            <param name="result">
            A name, or null if Unicode explicitly defines no name
            ("n/a") for a given <paramref name="property"/>/<paramref name="nameChoice"/>.
            If a given <paramref name="nameChoice"/> returns false, then all larger 
            values of <paramref name="nameChoice"/> will return false.  If null is
            returned for a given <paramref name="nameChoice"/>, then other
            <paramref name="nameChoice"/> values may return non-null results.
            </param>
            <returns>
            true if both <paramref name="property"/> or 
            <paramref name="nameChoice"/> are valid, othewise false.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="T:ICU4N.Globalization.NameChoice"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)">
            <summary>
            Return the Unicode name for a given property value, as given in
            the Unicode database file PropertyValueAliases.txt.  Most
            values have more than one name.  The <paramref name="nameChoice"/> determines
            which one is returned.
            </summary>
            <remarks>
            Note: Some of the names in PropertyValueAliases.txt can only be
            retrieved using <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">
            <see cref="T:ICU4N.Globalization.UProperty"/> selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            If out of range, null is returned.
            </param>
            <param name="value">
            Selector for a value for the given property.  In
            general, valid values range from 0 up to some maximum.  There
            are a few exceptions:
            <list type="number">
                <item><desription>
                    <see cref="F:ICU4N.Globalization.UProperty.Block"/> values begin at the
                    non-zero value <see cref="F:ICU4N.UChar.UnicodeBlock.Basic_Latin_ID"/>.
                </desription></item>
                <item><desription>
                    <see cref="F:ICU4N.Globalization.UProperty.Canonical_Combining_Class"/> values are not contiguous
                    and range from 0..240.
                </desription></item>
                <item><desription>
                    <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/> values
                    are mask values produced by left-shifting 1 by
                    <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
                    [:L:] to be represented.  Mask values are non-contiguous.
                </desription></item>
            </list>
            </param>
            <param name="nameChoice">
            <see cref="T:ICU4N.Globalization.NameChoice"/> selector for which name
            to get.  All values have a long name.  Most have a short name,
            but some do not.  Unicode allows for additional names; if
            present these will be returned by <see cref="F:ICU4N.Globalization.NameChoice.Long"/> + i,
            where i=1, 2,...
            </param>
            <returns>
            A name, or null if Unicode explicitly defines no name
            ("n/a") for a given property/value/nameChoice.  If a given
            <paramref name="nameChoice"/> throws an exception, then all larger values of
            <paramref name="nameChoice"/> will throw an exception.  If null is returned for a
            given <paramref name="nameChoice"/>, then other <paramref name="nameChoice"/> values may return
            non-null results.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="property"/>, 
            <paramref name="value"/>, or <paramref name="nameChoice"/> are invalid.</exception>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice,System.String@)"/>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="T:ICU4N.Globalization.NameChoice"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice,System.String@)">
            <summary>
            Get the Unicode name for a given property value, as given in
            the Unicode database file PropertyValueAliases.txt.  Most
            values have more than one name.  The <paramref name="nameChoice"/> determines
            which one is returned.
            <para/>
            This is similar to <see cref="M:ICU4N.UChar.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/>,
            but returns a true/false result if a name or value cannot be found rather
            than throwing exceptions.
            </summary>
            <remarks>
            Note: Some of the names in PropertyValueAliases.txt can only be
            retrieved using <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">
            <see cref="T:ICU4N.Globalization.UProperty"/> selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            If out of range, null is returned.
            </param>
            <param name="value">
            Selector for a value for the given property.  In
            general, valid values range from 0 up to some maximum.  There
            are a few exceptions:
            <list type="number">
                <item><desription>
                    <see cref="F:ICU4N.Globalization.UProperty.Block"/> values begin at the
                    non-zero value <see cref="F:ICU4N.UChar.UnicodeBlock.Basic_Latin_ID"/>.
                </desription></item>
                <item><desription>
                    <see cref="F:ICU4N.Globalization.UProperty.Canonical_Combining_Class"/> values are not contiguous
                    and range from 0..240.
                </desription></item>
                <item><desription>
                    UProperty.GENERAL_CATEGORY_MASK values
                    are mask values produced by left-shifting 1 by
                    <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
                    [:L:] to be represented.  Mask values are non-contiguous.
                </desription></item>
            </list>
            </param>
            <param name="nameChoice">
            <see cref="T:ICU4N.Globalization.NameChoice"/> selector for which name
            to get.  All values have a long name.  Most have a short name,
            but some do not.  Unicode allows for additional names; if
            present these will be returned by <see cref="F:ICU4N.Globalization.NameChoice.Long"/> + i,
            where i=1, 2,...
            </param>
            <param name="result">
            The Unicode name for a given property value, as given in
            the Unicode database file PropertyValueAliases.txt, or null
            if the lookup failed.
            </param>
            <returns>
            true if the operation succeeded, or false if Unicode explicitly
            defines no name ("n/a") for a given property/value/nameChoice.
            If a given <paramref name="nameChoice"/> returns false,
            then all larger values of <paramref name="nameChoice"/> will return false.
            If null is returned for a given <paramref name="nameChoice"/>, then 
            other <paramref name="nameChoice"/> values may return non-null results.
            </returns>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice,System.String@)"/>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="T:ICU4N.Globalization.NameChoice"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueEnumNoThrow(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Same as <see cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)"/>, except doesn't throw exception. Instead, returns <see cref="F:ICU4N.Globalization.UProperty.Undefined"/>.
            </summary>
            <param name="property">Same as <see cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)"/>.</param>
            <param name="valueAlias">Same as <see cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)"/>.</param>
            <returns>Returns <see cref="F:ICU4N.Globalization.UProperty.Undefined"/> if the value is not valid, otherwise the value.</returns>
        </member>
        <member name="M:ICU4N.UChar.GetCodePoint(System.Char,System.Char)">
            <icu/>
            <summary>
            Returns a code point corresponding to the two surrogate code units.
            </summary>
            <param name="lead">The lead char.</param>
            <param name="trail">The trail char.</param>
            <returns>Code point if surrogate characters are valid.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the code units do not form a valid code point.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.GetCodePoint(System.Char)">
            <icu/>
            <summary>
            Returns the code point corresponding to the BMP code point.
            </summary>
            <param name="char16">The BMP code point.</param>
            <returns>Code point if argument is a valid character.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the code units do not form a valid code point.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToUpper(System.String)">
            <summary>
            Returns the uppercase version of the argument string.
            Casing is dependent on the current culture and context-sensitive.
            </summary>
            <param name="str">Source string to be performed on.</param>
            <returns>Uppercase version of the argument string.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToLower(System.String)">
            <summary>
            Returns the lowercase version of the argument string.
            Casing is dependent on the current culture and context-sensitive.
            </summary>
            <param name="str">Source string to be performed on.</param>
            <returns>Lowercase version of the argument string.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(System.String,ICU4N.Text.BreakIterator)">
            <summary>
            Returns the titlecase version of the argument string.
            </summary>
            <remarks>
            Position for titlecasing is determined by the argument break
            iterator, hence the user can customize his break iterator for
            a specialized titlecasing. In this case only the forward iteration
            needs to be implemented.
            If the break iterator passed in is null, the default Unicode algorithm
            will be used to determine the titlecase positions.
            <para/>
            Only positions returned by the break iterator will be title cased,
            character in between the positions will all be in lower case.
            <para/>
            Casing is dependent on the current culture and context-sensitive.
            </remarks>
            <param name="str">Source string to be performed on.</param>
            <param name="breakiter">Break iterator to determine the positions in which
            the character should be title cased.</param>
            <returns>Lowercase version of the argument string.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the uppercase version of the argument <paramref name="str"/>.
            Casing is dependent on the argument <paramref name="locale"/>.
            </summary>
            <param name="locale"><see cref="T:System.Globalization.CultureInfo"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <returns>Uppercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToUpper(ICU4N.Util.ULocale,System.String)">
            <summary>
            Returns the uppercase version of the argument <paramref name="str"/>.
            Casing is dependent on the argument <paramref name="locale"/>.
            </summary>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <returns>Uppercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)">
            <summary>
            Returns the lowercase version of the argument <paramref name="str"/>.
            Casing is dependent on the argument <paramref name="locale"/>.
            </summary>
            <param name="locale"><see cref="T:System.Globalization.CultureInfo"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.ToLower(ICU4N.Util.ULocale,System.String)">
            <summary>
            Returns the lowercase version of the argument <paramref name="str"/>.
            Casing is dependent on the argument <paramref name="locale"/>.
            </summary>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator)">
            <summary>
            Returns the titlecase version of the argument <paramref name="str"/>.
            </summary>
            <remarks>
            Position for titlecasing is determined by the argument break
            iterator, hence the user can customize his break iterator for
            a specialized titlecasing. In this case only the forward iteration
            needs to be implemented.
            If the break iterator passed in is null, the default Unicode algorithm
            will be used to determine the titlecase positions.
            <para/>
            Only positions returned by the break iterator will be title cased,
            character in between the positions will all be in lower case.
            <para/>
            Casing is dependent on the argument <paramref name="locale"/>.
            </remarks>
            <param name="locale"><see cref="T:System.Globalization.CultureInfo"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <param name="breakiter">Break iterator to determine the positions in which
            the character should be title cased.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(ICU4N.Util.ULocale,System.String,ICU4N.Text.BreakIterator)">
            <summary>
            Returns the titlecase version of the argument <paramref name="str"/>.
            </summary>
            <remarks>
            Position for titlecasing is determined by the argument break
            iterator, hence the user can customize his break iterator for
            a specialized titlecasing. In this case only the forward iteration
            needs to be implemented.
            If the break iterator passed in is null, the default Unicode algorithm
            will be used to determine the titlecase positions.
            <para/>
            Only positions returned by the break iterator will be title cased,
            character in between the positions will all be in lower case.
            <para/>
            Casing is dependent on the argument <paramref name="locale"/>.
            </remarks>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <param name="titleIter">Break iterator to determine the positions in which
            the character should be title cased.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(ICU4N.Util.ULocale,System.String,ICU4N.Text.BreakIterator,System.Int32)">
            <summary>
            Returns the titlecase version of the argument <paramref name="str"/>.
            </summary>
            <remarks>
            Position for titlecasing is determined by the argument break
            iterator, hence the user can customize his break iterator for
            a specialized titlecasing. In this case only the forward iteration
            needs to be implemented.
            If the break iterator passed in is null, the default Unicode algorithm
            will be used to determine the titlecase positions.
            <para/>
            Only positions returned by the break iterator will be title cased,
            character in between the positions will all be in lower case.
            <para/>
            Casing is dependent on the argument <paramref name="locale"/>.
            </remarks>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <param name="titleIter">Break iterator to determine the positions in which
            the character should be title cased.</param>
            <param name="options">Bit set to modify the titlecasing operation.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <stable>ICU 3.8</stable>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoLowerCase"/>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoBreakAdjustment"/>
        </member>
        <member name="M:ICU4N.UChar.ToTitleFirst(ICU4N.Util.ULocale,System.String)">
            <summary>
            Return a string with just the first word titlecased, for menus and UI, etc. This does not affect most of the string,
            and sometimes has no effect at all; the original string is returned whenever casing
            would not be appropriate for the first word (such as for CJK characters or initial numbers).
            Initial non-letters are skipped in order to find the character to change.
            Characters past the first affected are left untouched: see also <see cref="F:ICU4N.UChar.TitleCaseNoLowerCase"/>.
            <para/>
            Examples:
            <list type="table">
                <listheader>
                    <term>Source</term>
                    <term>Result</term>
                    <term>Locale</term>
                </listheader>
                <item>
                    <term>anglo-American locale</term>
                    <term>Anglo-American locale</term>
                    <term></term>
                </item>
                <item>
                    <term>contact us</term>
                    <term>Contact us</term>
                    <term></term>
                </item>
                <item>
                    <term>49ers win!</term>
                    <term>49ers win!</term>
                    <term></term>
                </item>
                <item>
                    <term>(abc)</term>
                    <term>(abc)</term>
                    <term></term>
                </item>
                <item>
                    <term>ijs</term>
                    <term>Ijs</term>
                    <term></term>
                </item>
                <item>
                    <term>ijs</term>
                    <term>IJs</term>
                    <term>nl-BE</term>
                </item>
                <item>
                    <term>ijs</term>
                    <term>js</term>
                    <term>tr-DE</term>
                </item>
            </list>
            </summary>
            <param name="locale">The locale for accessing exceptional behavior (eg for tr).</param>
            <param name="str">The source string to change.</param>
            <returns>The modified string, or the original if no modifications were necessary.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)">
            <icu/>
            <summary>
            Returns the titlecase version of the argument <paramref name="str"/>.
            </summary>
            <remarks>
            Position for titlecasing is determined by the argument break
            iterator, hence the user can customize his break iterator for
            a specialized titlecasing. In this case only the forward iteration
            needs to be implemented.
            If the break iterator passed in is null, the default Unicode algorithm
            will be used to determine the titlecase positions.
            <para/>
            Only positions returned by the break iterator will be title cased,
            character in between the positions will all be in lower case.
            <para/>
            Casing is dependent on the argument <paramref name="locale"/>.
            </remarks>
            <param name="locale"><see cref="T:ICU4N.Util.ULocale"/> which <paramref name="str"/> is to be converted in.</param>
            <param name="str">Source string to be performed on.</param>
            <param name="titleIter">Break iterator to determine the positions in which
            the character should be title cased.</param>
            <param name="options">Bit set to modify the titlecasing operation.</param>
            <returns>Lowercase version of the argument <paramref name="str"/>.</returns>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoLowerCase"/>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoBreakAdjustment"/>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.UChar.FoldCase(System.Int32,System.Boolean)">
            <icu/>
            <summary>
            The given character is mapped to its case folding equivalent according
            to UnicodeData.txt and CaseFolding.txt; if the character has no case
            folding equivalent, the character itself is returned.
            <para/>
            This function only returns the simple, single-code point case mapping.
            Full case mappings should be used whenever possible because they produce
            better results by working on whole strings.
            They can map to a result string with a different length as appropriate.
            Full case mappings are applied by the case mapping functions
            that take string parameters rather than code points (int).
            See also the User Guide chapter on C/POSIX migration:
            <a href="http://www.icu-project.org/userguide/posix.html#case_mappings">
            http://www.icu-project.org/userguide/posix.html#case_mappings</a>
            </summary>
            <param name="ch">The character to be converted.</param>
            <param name="defaultmapping">
            Indicates whether the default mappings defined in
            CaseFolding.txt are to be used, otherwise the
            mappings for dotted I and dotless i marked with
            'T' in CaseFolding.txt are included.
            </param>
            <returns>The case folding equivalent of the character, if
            any; otherwise the character itself.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,System.Boolean)"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.UChar.FoldCase(System.String,System.Boolean)">
            <icu/>
            <summary>
            The given string is mapped to its case folding equivalent according to
            UnicodeData.txt and CaseFolding.txt; if any character has no case
            folding equivalent, the character itself is returned.
            "Full", multiple-code point case folding mappings are returned here.
            For "simple" single-code point mappings use the API
            <see cref="M:ICU4N.UChar.FoldCase(System.Int32,System.Boolean)"/>.
            </summary>
            <param name="str">The string to be converted.</param>
            <param name="defaultmapping">
            Indicates whether the default mappings defined in
            CaseFolding.txt are to be used, otherwise the
            mappings for dotted I and dotless i marked with
            'T' in CaseFolding.txt are included.
            </param>
            <returns>The case folding equivalent of the character, if
            any; otherwise the character itself.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.Int32,System.Boolean)"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.UChar.FoldCaseDefault">
            <icu/>
            <summary>
            Option value for case folding: use default mappings defined in
            CaseFolding.txt.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.UChar.FoldCaseExcludeSpecialI">
            <icu/>
            <summary>
            Option value for case folding:
            Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
            and dotless i appropriately for Turkic languages (tr, az).
            </summary>
            <remarks>
            Before Unicode 3.2, CaseFolding.txt contains mappings marked with 'I' that
            are to be included for default mappings and
            excluded for the Turkic-specific mappings.
            <para/>
            Unicode 3.2 CaseFolding.txt instead contains mappings marked with 'T' that
            are to be excluded for default mappings and
            included for the Turkic-specific mappings.
            </remarks>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.FoldCase(System.Int32,ICU4N.Globalization.FoldCase)">
            <icu/>
            <summary>
            The given character is mapped to its case folding equivalent according
            to UnicodeData.txt and CaseFolding.txt; if the character has no case
            folding equivalent, the character itself is returned.
            <para/>
            This function only returns the simple, single-code point case mapping.
            Full case mappings should be used whenever possible because they produce
            better results by working on whole strings.
            They can map to a result string with a different length as appropriate.
            Full case mappings are applied by the case mapping functions
            that take string parameters rather than code points (int).
            See also the User Guide chapter on C/POSIX migration:
            <a href="http://www.icu-project.org/userguide/posix.html#case_mappings">
            http://www.icu-project.org/userguide/posix.html#case_mappings</a>
            </summary>
            <param name="ch">The character to be converted.</param>
            <param name="foldCase">Option for special processing. Currently the recognised options
            are <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> and <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <returns>The case folding equivalent of the character, if any; otherwise the
            character itself.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)">
            <icu/>
            <summary>
            The given string is mapped to its case folding equivalent according to
            UnicodeData.txt and CaseFolding.txt; if any character has no case
            folding equivalent, the character itself is returned.
            "Full", multiple-code point case folding mappings are returned here.
            For "simple" single-code point mappings use the API
            <see cref="M:ICU4N.UChar.FoldCase(System.Int32,ICU4N.Globalization.FoldCase)"/>.
            </summary>
            <param name="str">The string to be converted.</param>
            <param name="foldCase">Option for special processing. Currently the recognised options
            are <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> and <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <returns>The case folding equivalent of the character, if any; otherwise the
            character itself.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.Int32,ICU4N.Globalization.FoldCase)"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetHanNumericValue(System.Int32)">
            <icu/>
            <summary>
            Returns the numeric value of a Han character.
            <para/>
            This returns the value of Han 'numeric' code points,
            including those for zero, ten, hundred, thousand, ten thousand,
            and hundred million.
            This includes both the standard and 'checkwriting'
            characters, the 'big circle' zero character, and the standard
            zero character.
            <para/>
            Note: The Unicode Standard has numeric values for more
            Han characters recognized by this method
            (see <see cref="M:ICU4N.UChar.GetNumericValue(System.Int32)"/> and the UCD file DerivedNumericValues.txt),
            and a <see cref="T:ICU4N.Text.NumberFormat"/> can be used with
            a Chinese <see cref="T:ICU4N.Text.NumberingSystem"/>.
            </summary>
            <param name="ch">Code point to query.</param>
            <returns>Value if it is a Han 'numeric character,' otherwise return -1.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetTypeEnumerator">
            <icu/>
            <summary>
            Returns an iterator for character types, iterating over codepoints.
            <para/>
            Example of use:
            <code>
            IRangeValueEnumerator iterator = UChar.GetTypeEnumerator();
            while (iterator.MoveNext())
            {
                Console.WriteLine("Codepoint \\u" +
                                    iterator.Current.Start.ToHexString() +
                                    " to codepoint \\u" +
                                    (iterator.Current.Limit - 1).ToHexString() +
                                    " has the character type " +
                                    iterator.Current.Value);
            }
            </code>
            </summary>
            <remarks>
            This is equivalent to getTypeIterator() in ICU4J.
            </remarks>
            <returns>An enumerator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetNameEnumerator">
            <icu/>
            <summary>
            Returns an enumerator for character names, iterating over codepoints.
            </summary>
            <remarks>
            This API only gets the iterator for the modern, most up-to-date
            Unicode names. For older 1.0 Unicode names use <see cref="M:ICU4N.UChar.GetName1_0Enumerator"/> or
            for extended names use <see cref="M:ICU4N.UChar.GetExtendedNameEnumerator"/>.
            <para/>
            Example of use:
            <code>
            IValueEnumerator iterator = UChar.GetNameEnumerator();
            while (iterator.MoveNext())
            {
                Console.WriteLine("Codepoint \\u" +
                                    (iterator.Current.Codepoint).ToHexString() +
                                    " has the name " + (string)iterator.Current.Value);
            }
            </code>
            <para/>
            The maximal range which the name iterator iterates is from
            <see cref="F:ICU4N.UChar.MinValue"/> to <see cref="F:ICU4N.UChar.MaxValue"/>
            <para/>
            NOTE: This is equivalent to getNameIterator() in ICU4J
            </remarks>
            <returns>An enumerator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetName1_0Enumerator">
            <icu/>
            <summary>
            Returns an empty enumerator.
            <para/>
            Used to return an iterator for the older 1.0 Unicode character names, iterating over codepoints.
            </summary>
            <returns>An empty enumerator.</returns>
            <seealso cref="M:ICU4N.UChar.GetName1_0(System.Int32)"/>
        </member>
        <member name="M:ICU4N.UChar.GetExtendedNameEnumerator">
            <icu/>
            <summary>
            Returns an enumerator for character names, iterating over codepoints.
            </summary>
            <remarks>
            This API only gets the enumerator for the extended names.
            For modern, most up-to-date Unicode names use <see cref="M:ICU4N.UChar.GetNameEnumerator"/> or
            for older 1.0 Unicode names use <see cref="M:ICU4N.UChar.GetName1_0Enumerator"/>.
            <para/>
            Example of use:
            <code>
            IValueEnumerator iterator = UChar.GetExtendedNameIterator();
            while (iterator.MoveNext())
            {
                Console.WriteLine("Codepoint \\u" +
                                    (iterator.Current.Codepoint).ToHexString() +
                                    " has the name " + (string)iterator.Current.Value);
            }
            </code>
            <para/>
            The maximal range which the name iterator iterates is from
            <see cref="F:ICU4N.UChar.MinValue"/> to <see cref="F:ICU4N.UChar.MaxValue"/>.
            <para/>
            NOTE: This is equivalent to getExtendedNameIterator() in ICU4J
            </remarks>
            <returns>An enumerator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.GetAge(System.Int32)">
            <icu/>
            <summary>
            Returns the "age" of the code point.
            <para/>
            The "age" is the Unicode version when the code point was first
            designated (as a non-character or for Private Use) or assigned a
            character.
            <para/>
            This can be useful to avoid emitting code points to receiving
            processes that do not accept newer characters.
            <para/>
            The data is from the UCD file DerivedAge.txt.
            </summary>
            <param name="ch">The code point.</param>
            <returns>The Unicode version number.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)">
            <icu/>
            <summary>
            Check a binary Unicode property for a code point.
            <para/>
            Unicode, especially in version 3.2, defines many more properties
            than the original set in UnicodeData.txt.
            <para/>
            This API is intended to reflect Unicode properties as defined in
            the Unicode Character Database (UCD) and Unicode Technical Reports
            (UTR).
            <para/>
            For details about the properties see
            <a href="http://www.unicode.org/">http://www.unicode.org/</a>.
            <para/>
            For names of Unicode properties see the UCD file
            PropertyAliases.txt.
            <para/>
            This API does not check the validity of the codepoint.
            <para/>
            Important: If ICU is built with UCD files from Unicode versions
            below 3.2, then properties marked with "new" are not or
            not fully available.
            </summary>
            <param name="ch">Code point to test.</param>
            <param name="property">Selector constant from <see cref="T:ICU4N.Globalization.UProperty"/>,
            identifies which binary property to check.</param>
            <returns>
            true or false according to the binary Unicode property value
            for <paramref name="ch"/>. Also false if <paramref name="property"/> 
            is out of bounds or if the Unicode version does not have data for 
            the property at all, or not for this code point.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUAlphabetic(System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/>.
            <para/>
            Different from <see cref="M:ICU4N.UChar.IsLetter(System.Int32)"/>!
            </summary>
            <param name="ch">Codepoint to be tested.</param>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUAlphabetic(System.Char)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/>.
            <para/>
            Different from <see cref="M:ICU4N.UChar.IsLetter(System.Char)"/>!
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be tested.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUAlphabetic(System.String,System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Alphabetic"/>.
            <para/>
            Different from <see cref="M:ICU4N.UChar.IsLetter(System.String,System.Int32)"/>!
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsULower(System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsLower(System.Int32)"/>!
            </summary>
            <param name="ch">Codepoint to be tested.</param>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.IsULower(System.Char)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsLower(System.Char)"/>!
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be tested.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsULower(System.String,System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Lowercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsLower(System.String,System.Int32)"/>!
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUUpper(System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsUpper(System.Int32)"/>!
            </summary>
            <param name="ch">Codepoint to be tested.</param>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUUpper(System.Char)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsUpper(System.Char)"/>!
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be tested.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUUpper(System.String,System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.Uppercase"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsUpper(System.String,System.Int32)"/>!
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUWhiteSpace(System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.White_Space"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.White_Space"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsWhiteSpace(System.Int32)"/>!
            </summary>
            <param name="ch">Codepoint to be tested.</param>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.UChar.IsUWhiteSpace(System.Char)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.White_Space"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.White_Space"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsWhiteSpace(System.Int32)"/>!
            </summary>
            <param name="c"><see cref="T:System.Char"/> to be tested.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.IsUWhiteSpace(System.String,System.Int32)">
            <icu/>
            <summary>
            Check if a code point has the <see cref="F:ICU4N.Globalization.UProperty.White_Space"/> Unicode property.
            <para/>
            Same as <see cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/> with <see cref="F:ICU4N.Globalization.UProperty.White_Space"/>.
            <para/>
            This is different from <see cref="M:ICU4N.UChar.IsWhiteSpace(System.Int32)"/>!
            </summary>
            <param name="s">A string.</param>
            <param name="index"></param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)">
            <icu/>
            <summary>
            Returns the property value for an Unicode property type of a code point.
            Also returns binary and mask property values. 
            </summary>
            <remarks>
            Unicode, especially in version 3.2, defines many more properties than
            the original set in UnicodeData.txt.
            <para/>
            The properties APIs are intended to reflect Unicode properties as
            defined in the Unicode Character Database (UCD) and Unicode Technical
            Reports (UTR). For details about the properties see
            <a href="http://www.unicode.org/">http://www.unicode.org/</a>.
            <para/>
            For names of Unicode properties see the UCD file PropertyAliases.txt.
            <para/>
            Sample usage:
            <code>
            int ea = UChar.GetInt32PropertyValue(c, UProperty.East_Asian_Width);
            int ideo = UChar.GetInt32PropertyValue(c, UProperty.Ideographic);
            bool b = (ideo == 1) ? true : false;
            </code>
            </remarks>
            <param name="ch">Code point to test.</param>
            <param name="type">UProperty selector constant, identifies which binary
            property to check. Must be
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            </param>
            <returns>
            Numeric value that is directly the property value or,
            for enumerated properties, corresponds to the numeric value of
            the enumerated constant (or enum) of the respective property value
            enumeration type (cast to enum type if necessary).
            Returns 0 or 1 (for false / true) for binary Unicode properties.
            Returns a bit-mask for mask properties.
            Returns 0 if 'type' is out of bounds or if the Unicode version
            does not have data for the property at all, or not for this code
            point.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/>
            <seealso cref="M:ICU4N.UChar.GetIntPropertyMinValue(ICU4N.Globalization.UProperty)"/>
            <seealso cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            <seealso cref="P:ICU4N.UChar.UnicodeVersion"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetStringPropertyValue(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)">
            <icu/>
            <summary>
            Returns a string version of the property value.
            </summary>
            <param name="propertyEnum">The property enum value.</param>
            <param name="codepoint">The codepoint value.</param>
            <param name="nameChoice">The choice of the name.</param>
            <returns>Value as string.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.UChar.GetIntPropertyMinValue(ICU4N.Globalization.UProperty)">
            <icu/>
            <summary>
            Returns the minimum value for an integer/binary Unicode property type.
            Can be used together with <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            to allocate arrays of <see cref="T:ICU4N.Text.UnicodeSet"/> or similar.
            </summary>
            <param name="type"><see cref="T:ICU4N.Globalization.UProperty"/> selector constant, identifies which binary
            property to check. Must be
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/>.
            </param>
            <returns>
            Minimum value returned by <see cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/>
            for a Unicode property. 0 if the property
            selector 'type' is out of range.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.HasBinaryProperty(System.Int32,ICU4N.Globalization.UProperty)"/>
            <seealso cref="P:ICU4N.UChar.UnicodeVersion"/>
            <seealso cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>
            <seealso cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)">
            <icu/>
            <summary>
            Returns the maximum value for an integer/binary Unicode property.
            Can be used together with <see cref="M:ICU4N.UChar.GetIntPropertyMinValue(ICU4N.Globalization.UProperty)"/>
            to allocate arrays of <see cref="T:ICU4N.Text.UnicodeSet"/> or similar.
            </summary>
            <remarks>
            Examples for min/max values (for Unicode 3.2):
            <list type="bullet">
                <item><description>
                    <see cref="F:ICU4N.Globalization.UProperty.BiDi_Class"/>:    0/18
                    (<see cref="F:ICU4N.Globalization.UCharacterDirection.LeftToRight"/>/<see cref="F:ICU4N.Globalization.UCharacterDirection.BoundaryNeutral"/>)
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Globalization.UProperty.Script"/>:        0/45 (<see cref="F:ICU4N.Globalization.UScript.Common"/>/<see cref="F:ICU4N.Globalization.UScript.Tagbanwa"/>)
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Globalization.UProperty.Ideographic"/>:   0/1  (false/true)
                </description></item>
            </list>
            For undefined <see cref="T:ICU4N.Globalization.UProperty"/> enum values, min/max values will be 0/-1.
            </remarks>
            <param name="type">
            <see cref="T:ICU4N.Globalization.UProperty"/> selector constant, identifies which binary
            property to check. Must be
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= <paramref name="type"/> &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/>.
            </param>
            <returns>
            Maximum value returned by <see cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/> for a Unicode
            property. &lt;= 0 if the property selector '<paramref name="type"/>' is out of range.
            </returns>
        </member>
        <member name="M:ICU4N.UChar.ForDigit(System.Int32,System.Int32)">
            <summary>
            Provide the <see cref="M:ICU4N.Support.Text.Character.ForDigit(System.Int32,System.Int32)"/> API, for convenience.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MinHighSurrogate">
            <summary>
            Constant U+D800, same as <see cref="F:ICU4N.Support.Text.Character.MIN_HIGH_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxHighSurrogate">
            <summary>
            Constant U+DBFF, same as <see cref="F:ICU4N.Support.Text.Character.MAX_HIGH_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MinLowSurrogate">
            <summary>
            Constant U+DC00, same as <see cref="F:ICU4N.Support.Text.Character.MIN_LOW_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxLowSurrogate">
            <summary>
            Constant U+DFFF, same as <see cref="F:ICU4N.Support.Text.Character.MAX_LOW_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MinSurrogate">
            <summary>
            Constant U+D800, same as <see cref="F:ICU4N.Support.Text.Character.MIN_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxSurrogate">
            <summary>
            Constant U+DFFF, same as <see cref="F:ICU4N.Support.Text.Character.MAX_SURROGATE"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MinSupplementaryCodePoint">
            <summary>
            Constant U+10000, same as <see cref="F:ICU4N.Support.Text.Character.MIN_SUPPLEMENTARY_CODE_POINT"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MaxCodePoint">
            <summary>
            Constant U+10FFFF, same as <see cref="F:ICU4N.Support.Text.Character.MAX_CODE_POINT"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.MinCodePoint">
            <summary>
            Constant U+0000, same as <see cref="F:ICU4N.Support.Text.Character.MIN_CODE_POINT"/>.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsValidCodePoint(System.Int32)">
            <summary>
            Equivalent to <see cref="M:ICU4N.Support.Text.Character.IsValidCodePoint(System.Int32)"/>.
            </summary>
            <param name="cp">The code point to check.</param>
            <returns>true if <paramref name="cp"/> is a valid code point.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementaryCodePoint(System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.IsSupplementaryCodePoint(System.Int32)"/>.
            </summary>
            <param name="cp">The code point to check.</param>
            <returns>true if <paramref name="cp"/> is a supplementary code point.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementaryCodePoint(System.Char)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.IsSupplementaryCodePoint(System.Int32)"/>.
            </summary>
            <param name="c">The <see cref="T:System.Char"/> to check.</param>
            <returns>true if <paramref name="c"/> is a supplementary code point.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSupplementaryCodePoint(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.IsSupplementaryCodePoint(System.Int32)"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the <see cref="T:System.Char"/> in <paramref name="s"/> at <paramref name="index"/> is a supplementary code point.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsHighSurrogate(System.Char)">
            <summary>
            Same as <see cref="M:System.Char.IsHighSurrogate(System.Char)"/>.
            </summary>
            <param name="ch">The <see cref="T:System.Char"/> to check.</param>
            <returns>true if <paramref name="ch"/> is a high (lead) surrogate.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsHighSurrogate(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:System.Char.IsHighSurrogate(System.String,System.Int32)"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the character in <paramref name="s"/> at <paramref name="index"/> is a high (lead) surrogate.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLowSurrogate(System.Char)">
            <summary>
            Same as <see cref="M:System.Char.IsLowSurrogate(System.Char)"/>.
            </summary>
            <param name="ch">The <see cref="T:System.Char"/> to check.</param>
            <returns>true if <paramref name="ch"/> is a low (trail) surrogate.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsLowSurrogate(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:System.Char.IsLowSurrogate(System.String,System.Int32)"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The position of the character to evaluate in <paramref name="s"/>.</param>
            <returns>true if the character in <paramref name="s"/> at <paramref name="index"/> is a low (trail) surrogate.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSurrogatePair(System.Char,System.Char)">
            <summary>
            Same as <see cref="M:System.Char.IsSurrogatePair(System.Char,System.Char)"/>.
            </summary>
            <param name="high">The high (lead) <see cref="T:System.Char"/>.</param>
            <param name="low">The low (trail) <see cref="T:System.Char"/>.</param>
            <returns>true if <paramref name="high"/>, <paramref name="low"/> form a surrogate pair.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.IsSurrogatePair(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:System.Char.IsSurrogatePair(System.String,System.Int32)"/>.
            </summary>
            <param name="s">A <see cref="T:System.String"/>.</param>
            <param name="index">The starting position of the pair of characters to evaluate within <paramref name="s"/>.</param>
            <returns><c>true</c> if the <paramref name="s"/> parameter includes adjacent characters at positions index and <paramref name="index"/> + 1, and the 
            numeric value of the character at position <paramref name="index"/> ranges from U+D800 through U+DBFF, and the numeric 
            value of the character at position <paramref name="index"/> + 1 ranges from U+DC00 through U+DFFF; otherwise, <c>false</c>.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CharCount(System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CharCount(System.Int32)"/>.
            Returns the number of chars needed to represent the code point (1 or 2).
            This does not check the code point for validity.
            </summary>
            <param name="cp">The code point to check.</param>
            <returns>The number of chars needed to represent the code point.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.ToCodePoint(System.Char,System.Char)">
            <summary>
            Similar to <see cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)"/>.
            Returns the code point represented by the two surrogate code units.
            However, this does not check the surrogate pair for validity.
            </summary>
            <param name="high">The high (lead) surrogate.</param>
            <param name="low">The low (trail) surrogate.</param>
            <returns>The code point formed by the surrogate pair.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointAt(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the code point at index.
            This examines only the characters at index and index+1.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index of the first or only char forming the code point.</param>
            <param name="limit">The limit of the valid text.</param>
            <returns>The code point at the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointBefore(System.Char[],System.Int32,System.Int32)">
            <summary>
            Return the code point before index.
            This examines only the characters at index-1 and index-2.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index after the last or only char forming the code point.</param>
            <param name="limit">The start of the valid text.</param>
            <returns>The code point before the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.ToChars(System.Int32,System.Char[],System.Int32)">
            <summary>
            Writes the chars representing the
            code point into the destination at the given index.
            </summary>
            <param name="cp">The code point to convert.</param>
            <param name="dst">The destination array into which to put the char(s) representing the code point.</param>
            <param name="dstIndex">The index at which to put the first (or only) char.</param>
            <returns>The count of the number of chars written (1 or 2).</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="cp"/> is not a valid code point.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.ToChars(System.Int32)">
            <summary>
            Returns a char array representing the code point.
            </summary>
            <param name="cp">The code point to convert.</param>
            <returns>An array containing the char(s) representing the code point.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="cp"/> is not a valid code point.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.GetDirectionality(System.Int32)">
            <summary>
            Returns a value representing the directionality of the character.
            </summary>
            <param name="cp">The code point to check.</param>
            <returns>The directionality of the code point.</returns>
            <see cref="M:ICU4N.UChar.GetDirection(System.Int32)"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.OffsetByCodePoints(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adjusts the char index by a code point offset.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="start">The start of the range to check.</param>
            <param name="count">The length of the range to check.</param>
            <param name="index">The index to adjust.</param>
            <param name="codePointOffset">The number of code points by which to offset the index.</param>
            <returns>The adjusted index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.UChar.LAST_CHAR_MASK_">
            <summary>
            To get the last character out from a data type
            </summary>
        </member>
        <member name="F:ICU4N.UChar.NO_BREAK_SPACE_">
            <summary>
            No break space code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.FIGURE_SPACE_">
            <summary>
            Figure space code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.NARROW_NO_BREAK_SPACE_">
            <summary>
            Narrow no break space code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.IDEOGRAPHIC_NUMBER_ZERO_">
            <summary>
            Ideographic number zero code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_FIRST_">
            <summary>
            CJK Ideograph, First code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_SECOND_">
            <summary>
            CJK Ideograph, Second code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_THIRD_">
            <summary>
            CJK Ideograph, Third code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_FOURTH_">
            <summary>
            CJK Ideograph, Fourth code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_FIFTH_">
            <summary>
            CJK Ideograph, FIFTH code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_SIXTH_">
            <summary>
            CJK Ideograph, Sixth code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_SEVENTH_">
            <summary>
            CJK Ideograph, Seventh code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_EIGHTH_">
            <summary>
            CJK Ideograph, Eighth code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_NINETH_">
            <summary>
            CJK Ideograph, Nineth code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.APPLICATION_PROGRAM_COMMAND_">
            <summary>
            Application Program command code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.UNIT_SEPARATOR_">
            <summary>
            Unit separator code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.DELETE_">
            <summary>
            Delete code point
            </summary>
        </member>
        <member name="F:ICU4N.UChar.CJK_IDEOGRAPH_COMPLEX_ZERO_">
            Han digit characters
        </member>
        <member name="M:ICU4N.UChar.GetPropertyEnum(System.String)">
            <summary>
            Return the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <returns>a <see cref="T:ICU4N.Globalization.UProperty"/> enum.</returns>
            <exception cref="T:System.ArgumentException">thrown if <paramref name="propertyAlias"/> is not recognized.</exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyEnum(System.String,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyEnum(System.Text.StringBuilder)">
            <summary>
            Return the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <returns>a <see cref="T:ICU4N.Globalization.UProperty"/> enum.</returns>
            <exception cref="T:System.ArgumentException">thrown if <paramref name="propertyAlias"/> is not recognized.</exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyEnum(System.Text.StringBuilder,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyEnum(System.Char[])">
            <summary>
            Return the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <returns>a <see cref="T:ICU4N.Globalization.UProperty"/> enum.</returns>
            <exception cref="T:System.ArgumentException">thrown if <paramref name="propertyAlias"/> is not recognized.</exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyEnum(System.Char[],System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyEnum(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Return the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <returns>a <see cref="T:ICU4N.Globalization.UProperty"/> enum.</returns>
            <exception cref="T:System.ArgumentException">thrown if <paramref name="propertyAlias"/> is not recognized.</exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyEnum(ICU4N.Support.Text.ICharSequence,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyEnum(System.String,System.Int32@)">
            <summary>
            Get the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <param name="result">A <see cref="T:ICU4N.Globalization.UProperty"/> enum.</param>
            <returns>
            true if <paramref name="propertyAlias"/> is valid, othewise false.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.GetPropertyEnum(System.String)"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyEnum(System.Text.StringBuilder,System.Int32@)">
            <summary>
            Get the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <param name="result">A <see cref="T:ICU4N.Globalization.UProperty"/> enum.</param>
            <returns>
            true if <paramref name="propertyAlias"/> is valid, othewise false.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.GetPropertyEnum(System.Text.StringBuilder)"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyEnum(System.Char[],System.Int32@)">
            <summary>
            Get the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <param name="result">A <see cref="T:ICU4N.Globalization.UProperty"/> enum.</param>
            <returns>
            true if <paramref name="propertyAlias"/> is valid, othewise false.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.GetPropertyEnum(System.Char[])"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyEnum(ICU4N.Support.Text.ICharSequence,System.Int32@)">
            <summary>
            Get the <see cref="T:ICU4N.Globalization.UProperty"/> selector for a given property name, as
            specified in the Unicode database file PropertyAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            In addition, this function maps the synthetic names "gcm" /
            "General_Category_Mask" to the property
            <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>.  These names are not in
            PropertyAliases.txt.
            </remarks>
            <param name="propertyAlias">The property name to be matched.  The name
            is compared using "loose matching" as described in PropertyAliases.txt.</param>
            <param name="result">A <see cref="T:ICU4N.Globalization.UProperty"/> enum.</param>
            <returns>
            true if <paramref name="propertyAlias"/> is valid, othewise false.
            </returns>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.GetPropertyEnum(ICU4N.Support.Text.ICharSequence)"/>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String)">
            <summary>
            Return the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <returns>
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="property"/> is not a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector or <paramref name="valueAlias"/> is not a value of this <paramref name="property"/>
            </exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder)">
            <summary>
            Return the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <returns>
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="property"/> is not a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector or <paramref name="valueAlias"/> is not a value of this <paramref name="property"/>
            </exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[])">
            <summary>
            Return the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <returns>
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="property"/> is not a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector or <paramref name="valueAlias"/> is not a value of this <paramref name="property"/>
            </exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[],System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Return the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <returns>
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="property"/> is not a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector or <paramref name="valueAlias"/> is not a value of this <paramref name="property"/>
            </exception>
            <seealso cref="T:ICU4N.Globalization.UProperty"/>
            <seealso cref="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence,System.Int32@)"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String,System.Int32@)">
            <summary>
            Gets the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <param name="result">
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </param>
            <returns>
            true if <paramref name="property"/> is a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector and <paramref name="valueAlias"/> is a value of this <paramref name="property"/>; othewise false;
            </returns>
            <see cref="T:ICU4N.Globalization.UProperty"/>
            <stable>ICU 60.1.0</stable>
            <seealso cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String)"/>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder,System.Int32@)">
            <summary>
            Gets the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <param name="result">
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </param>
            <returns>
            true if <paramref name="property"/> is a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector and <paramref name="valueAlias"/> is a value of this <paramref name="property"/>; othewise false;
            </returns>
            <see cref="T:ICU4N.Globalization.UProperty"/>
            <stable>ICU 60.1.0</stable>
            <seealso cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder)"/>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[],System.Int32@)">
            <summary>
            Gets the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <param name="result">
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </param>
            <returns>
            true if <paramref name="property"/> is a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector and <paramref name="valueAlias"/> is a value of this <paramref name="property"/>; othewise false;
            </returns>
            <see cref="T:ICU4N.Globalization.UProperty"/>
            <stable>ICU 60.1.0</stable>
            <seealso cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[])"/>
        </member>
        <member name="M:ICU4N.UChar.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence,System.Int32@)">
            <summary>
            Gets the property value integer for a given value name, as
            specified in the Unicode database file PropertyValueAliases.txt.
            Short, long, and any other variants are recognized.
            </summary>
            <remarks>
            Some of the names in PropertyValueAliases.txt will only be
            recognized with <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, not
            <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>.  These include: "C" / "Other", "L" /
            "Letter", "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P"
            / "Punctuation", "S" / "Symbol", and "Z" / "Separator".
            </remarks>
            <param name="property">UProperty selector constant.
            <see cref="F:ICU4N.Globalization.UProperty.Int_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/> &lt;= property &lt; <see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/> or
            <see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/> &lt; = property &lt; <see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>.
            Only these properties can be enumerated.
            </param>
            <param name="valueAlias">the value name to be matched.  The name is
            compared using "loose matching" as described in
            PropertyValueAliases.txt.
            </param>
            <param name="result">
            A value integer.  Note: <see cref="F:ICU4N.Globalization.UProperty.General_Category"/>
            values are mask values produced by left-shifting 1 by
            <see cref="!:UChar.GetType(int)"/>.  This allows grouped categories such as
            [:L:] to be represented.
            </param>
            <returns>
            true if <paramref name="property"/> is a valid <see cref="T:ICU4N.Globalization.UProperty"/>
            selector and <paramref name="valueAlias"/> is a value of this <paramref name="property"/>; othewise false;
            </returns>
            <see cref="T:ICU4N.Globalization.UProperty"/>
            <stable>ICU 60.1.0</stable>
            <seealso cref="M:ICU4N.UChar.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)"/>
        </member>
        <member name="M:ICU4N.UChar.CodePointAt(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointAt(System.String,System.Int32)"/>.
            Returns the code point at index.
            This examines only the characters at index and index+1.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index of the first or only char forming the code point.</param>
            <returns>The code point at the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointAt(System.Text.StringBuilder,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointAt(System.Text.StringBuilder,System.Int32)"/>.
            Returns the code point at index.
            This examines only the characters at index and index+1.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index of the first or only char forming the code point.</param>
            <returns>The code point at the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointAt(System.Char[],System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointAt(System.Char[],System.Int32)"/>.
            Returns the code point at index.
            This examines only the characters at index and index+1.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index of the first or only char forming the code point.</param>
            <returns>The code point at the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointAt(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointAt(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.
            Returns the code point at index.
            This examines only the characters at index and index+1.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index of the first or only char forming the code point.</param>
            <returns>The code point at the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointBefore(System.String,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointBefore(System.String,System.Int32)"/>.
            Return the code point before index.
            This examines only the characters at index-1 and index-2.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index after the last or only char forming the code point.</param>
            <returns>The code point before the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointBefore(System.Text.StringBuilder,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointBefore(System.Text.StringBuilder,System.Int32)"/>.
            Return the code point before index.
            This examines only the characters at index-1 and index-2.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index after the last or only char forming the code point.</param>
            <returns>The code point before the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointBefore(System.Char[],System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointBefore(System.Char[],System.Int32)"/>.
            Return the code point before index.
            This examines only the characters at index-1 and index-2.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index after the last or only char forming the code point.</param>
            <returns>The code point before the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointBefore(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Support.Text.Character.CodePointBefore(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.
            Return the code point before index.
            This examines only the characters at index-1 and index-2.
            </summary>
            <param name="seq">The characters to check.</param>
            <param name="index">The index after the last or only char forming the code point.</param>
            <returns>The code point before the index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointCount(System.String,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.CodePointCount(System.String,System.Int32,System.Int32)"/>
            method, for convenience.  Counts the number of code points in the range
            of text.
            </summary>
            <param name="text">the characters to check</param>
            <param name="start">the start of the range</param>
            <param name="limit">the limit of the range</param>
            <returns>the number of code points in the range</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.CodePointCount(System.Text.StringBuilder,System.Int32,System.Int32)"/>
            method, for convenience.  Counts the number of code points in the range
            of text.
            </summary>
            <param name="text">the characters to check</param>
            <param name="start">the start of the range</param>
            <param name="limit">the limit of the range</param>
            <returns>the number of code points in the range</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointCount(System.Char[],System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.CodePointCount(System.Char[],System.Int32,System.Int32)"/>
            method, for convenience.  Counts the number of code points in the range
            of text.
            </summary>
            <param name="text">the characters to check</param>
            <param name="start">the start of the range</param>
            <param name="limit">the limit of the range</param>
            <returns>the number of code points in the range</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.CodePointCount(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.CodePointCount(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)"/>
            method, for convenience.  Counts the number of code points in the range
            of text.
            </summary>
            <param name="text">the characters to check</param>
            <param name="start">the start of the range</param>
            <param name="limit">the limit of the range</param>
            <returns>the number of code points in the range</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.OffsetByCodePoints(System.String,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.OffsetByCodePoints(System.String,System.Int32,System.Int32)"/>
            method, for convenience.  Adjusts the char index by a code point offset.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index to adjust.</param>
            <param name="codePointOffset">The number of code points by which to offset the index.</param>
            <returns>The adjusted index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.OffsetByCodePoints(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="!:Character.OffsetByCodePoints(StringBuilder, int, int)"/>
            method, for convenience.  Adjusts the char index by a code point offset.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index to adjust.</param>
            <param name="codePointOffset">The number of code points by which to offset the index.</param>
            <returns>The adjusted index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.OffsetByCodePoints(System.Char[],System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="!:Character.OffsetByCodePoints(char[], int, int)"/>
            method, for convenience.  Adjusts the char index by a code point offset.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index to adjust.</param>
            <param name="codePointOffset">The number of code points by which to offset the index.</param>
            <returns>The adjusted index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.UChar.OffsetByCodePoints(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Equivalent to the <see cref="M:ICU4N.Support.Text.Character.OffsetByCodePoints(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)"/>
            method, for convenience.  Adjusts the char index by a code point offset.
            </summary>
            <param name="text">The characters to check.</param>
            <param name="index">The index to adjust.</param>
            <param name="codePointOffset">The number of code points by which to offset the index.</param>
            <returns>The adjusted index.</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="T:ICU4N.ICUConfig">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.DecimalFormat_SkipExtendedSeparatorParsing">
            <summary>
              Looks up a localized string similar to false.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.ICUBinary_DataPath">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.ICUResourceBundle_SkipRuntimeLocaleResourceScan">
            <summary>
              Looks up a localized string similar to false.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.MessagePattern_ApostropheMode">
            <summary>
              Looks up a localized string similar to DoubleOptional.
            </summary>
        </member>
        <member name="P:ICU4N.ICUConfig.TimeZone_DefaultTimeZoneType">
            <summary>
              Looks up a localized string similar to ICU.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.BMPSet">
            <summary>
            Helper class for frozen <see cref="T:ICU4N.Text.UnicodeSet"/>s, implements <see cref="M:ICU4N.Impl.BMPSet.Contains(System.Int32)"/> and 
            <see cref="M:ICU4N.Impl.BMPSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)"/> optimized for BMP code points.
            <para/>
            Latin-1: Look up bytes.
            2-byte characters: Bits organized vertically.
            3-byte characters: Use zero/one/mixed data per 64-block in U+0000..U+FFFF, with mixed for illegal ranges.
            Supplementary characters: Binary search over
            the supplementary part of the parent set's inversion list.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.BMPSet.latin1Contains">
            <summary>
            One bool ('true' or 'false') per Latin-1 character.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.BMPSet.table7FF">
            <summary>
            One bit per code point from U+0000..U+07FF. The bits are organized vertically; consecutive code points
            correspond to the same bit positions in consecutive table words. With code point parts lead=c{10..6}
            trail=c{5..0} it is set.Contains(c)==(table7FF[trail] bit lead)
            <para/>
            Bits for 0..FF are unused (0).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.BMPSet.bmpBlockBits">
            <summary>
            One bit per 64 BMP code points. The bits are organized vertically; consecutive 64-code point blocks
            correspond to the same bit position in consecutive table words. With code point parts lead=c{15..12}
            t1=c{11..6} test bits (lead+16) and lead in bmpBlockBits[t1]. If the upper bit is 0, then the lower bit
            indicates if Contains(c) for all code points in the 64-block. If the upper bit is 1, then the block is mixed
            and set.Contains(c) must be called.
            <para/>
            Bits for 0..7FF are unused (0).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.BMPSet.list4kStarts">
            <summary>
            Inversion list indexes for restricted binary searches in findCodePoint(), from FindCodePoint(U+0800, U+1000,
            U+2000, .., U+F000, U+10000). U+0800 is the first 3-byte-UTF-8 code point. Code points below U+0800 are
            always looked up in the bit tables. The last pair of indexes is for finding supplementary code points.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.BMPSet.list">
            <summary>
            The inversion list of the parent set, for the slower Contains() implementation for mixed BMP blocks and for
            supplementary code points. The list is terminated with list[listLength-1]=0x110000.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.Set32x64Bits(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Set bits in a bit rectangle in "vertical" bit organization. start&lt;limit&lt;=0x800
            </summary>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.FindCodePoint(System.Int32,System.Int32,System.Int32)">
            <summary>
            Same as <see cref="M:ICU4N.Text.UnicodeSet.FindCodePoint(System.Int32)"/> except that the binary search is restricted for finding code
            points in a certain range.
            <para/>
            For restricting the search for finding in the range start..end, pass in lo=FindCodePoint(start) and
            hi=FindCodePoint(end) with 0&lt;=lo&lt;=hi&lt;len. FindCodePoint(c) defaults to lo=0 and hi=len-1.
            </summary>
            <param name="c">A character in a subrange of MIN_VALUE..MAX_VALUE.</param>
            <param name="lo">The lowest index to be returned.</param>
            <param name="hi">The highest index to be returned.</param>
            <returns>The smallest integer i in the range lo..hi, inclusive, such that c &lt; list[i].</returns>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Span the initial substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <param name="s"></param>
            <param name="start">The start index.</param>
            <param name="spanCondition"></param>
            <param name="outCount">If not null: Receives the number of code points in the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
            <remarks>
            NOTE: to reduce the overhead of function call to Contains(c), it is manually inlined here. Check for
            sufficient length for trail unit for each surrogate pair. Handle single surrogates as surrogate code points
            as usual in ICU.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.Span(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Span the initial substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <param name="s"></param>
            <param name="start">The start index.</param>
            <param name="spanCondition"></param>
            <param name="outCount">If not null: Receives the number of code points in the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
            <remarks>
            NOTE: to reduce the overhead of function call to Contains(c), it is manually inlined here. Check for
            sufficient length for trail unit for each surrogate pair. Handle single surrogates as surrogate code points
            as usual in ICU.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.Span(System.Char[],System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Span the initial substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <param name="s"></param>
            <param name="start">The start index.</param>
            <param name="spanCondition"></param>
            <param name="outCount">If not null: Receives the number of code points in the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
            <remarks>
            NOTE: to reduce the overhead of function call to Contains(c), it is manually inlined here. Check for
            sufficient length for trail unit for each surrogate pair. Handle single surrogates as surrogate code points
            as usual in ICU.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.Span(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Span the initial substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <param name="s"></param>
            <param name="start">The start index.</param>
            <param name="spanCondition"></param>
            <param name="outCount">If not null: Receives the number of code points in the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
            <remarks>
            NOTE: to reduce the overhead of function call to Contains(c), it is manually inlined here. Check for
            sufficient length for trail unit for each surrogate pair. Handle single surrogates as surrogate code points
            as usual in ICU.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Symmetrical with <see cref="M:ICU4N.Impl.BMPSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)"/>.
            Span the trailing substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="s"/>.Length >= limit and <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.SpanBack(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Symmetrical with <see cref="M:ICU4N.Impl.BMPSet.Span(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)"/>.
            Span the trailing substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="s"/>.Length >= limit and <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.SpanBack(System.Char[],System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Symmetrical with <see cref="M:ICU4N.Impl.BMPSet.Span(System.Char[],System.Int32,ICU4N.Text.SpanCondition,System.Int32@)"/>.
            Span the trailing substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="s"/>.Length >= limit and <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.BMPSet.SpanBack(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Symmetrical with <see cref="M:ICU4N.Impl.BMPSet.Span(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)"/>.
            Span the trailing substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
            It must be <paramref name="s"/>.Length >= limit and <paramref name="spanCondition"/>==0 or 1.
            </summary>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="T:ICU4N.Impl.CacheBase`3">
            <summary>
            Base class for cache implementations.
            </summary>
            <remarks>
            To use, instantiate a subclass of a concrete implementation class, where the subclass
            implements the <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> method, and call Get() with the key and the data.
            The Get() call will use the data only if it needs to call <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/>,
            otherwise the data is ignored.
            </remarks>
            <typeparam name="TKey">Cache lookup key type.</typeparam>
            <typeparam name="TValue">Cache instance value type.</typeparam>
            <typeparam name="TData">Data type for creating a new instance value.</typeparam>
            <author>Markus Scherer, Mark Davis</author>
        </member>
        <member name="M:ICU4N.Impl.CacheBase`3.GetInstance(`0,`2)">
            <summary>
            Retrieves an instance from the cache. Calls <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> if the cache
            does not already contain an instance with this <paramref name="key"/>.
            Ignores <paramref name="data"/> if the cache already contains an instance with this <paramref name="key"/>.
            </summary>
            <param name="key">Cache lookup key for the requested instance.</param>
            <param name="data">Data for <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> if the instance is not already cached.</param>
            <returns>The requested instance.</returns>
        </member>
        <member name="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)">
            <summary>
            Creates an instance for the <paramref name="key"/> and <paramref name="data"/>. Must be overridden.
            </summary>
            <param name="key">Cache lookup key for the requested instance.</param>
            <param name="data">Data for the instance creation.</param>
            <returns>The requested instance.</returns>
        </member>
        <member name="T:ICU4N.Impl.CacheValueStrength">
            <summary>
            "Strength" of holding a value in CacheValue instances.
            The default strength is <see cref="F:ICU4N.Impl.CacheValueStrength.Soft"/>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.CacheValueStrength.Strong">
            <summary>
            Subsequent <see cref="M:ICU4N.Impl.CacheValue`1.GetInstance(`0)"/>-created objects
            will hold direct references to their values.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.CacheValueStrength.Soft">
            <summary>
            Subsequent <c>GetInstance()</c>-created objects
            will hold <see cref="T:ICU4N.Support.SoftReference`1"/>s to their values.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.CacheValue`1">
            <summary>
            Value type for cache items:
            Holds a value either via a direct reference or via a <see cref="T:ICU4N.Support.Reference`1"/>,
            depending on the current "strength" when <see cref="M:ICU4N.Impl.CacheValue`1.GetInstance(`0)"/> was called.
            </summary>
            <remarks>
            The value is <i>conceptually</i> immutable.
            If it is held via a direct reference, then it is actually immutable.
            <para/>
            A <see cref="T:ICU4N.Support.Reference`1"/> may be cleared (garbage-collected),
            after which <see cref="M:ICU4N.Impl.CacheValue`1.Get"/> returns null.
            It can then be reset via <see cref="M:ICU4N.Impl.CacheValue`1.ResetIfCleared(`0)"/>.
            The new value should be the same as, or equivalent to, the old value.
            <para/>
            Null values are supported. They can be distinguished from cleared values
            via <see cref="P:ICU4N.Impl.CacheValue`1.IsNull"/>.
            </remarks>
            <typeparam name="V">Cache instance value type.</typeparam>
        </member>
        <member name="M:ICU4N.Impl.CacheValue`1.SetStrength(ICU4N.Impl.CacheValueStrength)">
            <summary>
            Gets or Sets the "strength" of value references for subsequent <see cref="M:ICU4N.Impl.CacheValue`1.GetInstance(`0)"/> calls.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CacheValue`1.FutureInstancesWillBeStrong">
            <summary>
            Returns true if the "strength" is set to <see cref="F:ICU4N.Impl.CacheValueStrength.Strong"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CacheValue`1.GetInstance(`0)">
            <summary>
            Returns a <see cref="T:ICU4N.Impl.CacheValue`1"/> instance that holds the value.
            It holds it directly if the value is null or if the current "strength" is <see cref="F:ICU4N.Impl.CacheValueStrength.Strong"/>.
            Otherwise, it holds it via a <see cref="T:ICU4N.Support.Reference`1"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CacheValue`1.IsNull">
            <summary>
            Distinguishes a null value from a <see cref="T:ICU4N.Support.Reference`1"/> value that has been cleared.
            Returns true if this object represents a null value.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CacheValue`1.Get">
            <summary>
            Returns the value (which can be null),
            or null if it was held in a <see cref="T:ICU4N.Support.Reference`1"/> and has been cleared.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CacheValue`1.ResetIfCleared(`0)">
            <summary>
            If the value was held via a <see cref="T:ICU4N.Support.Reference`1"/> which has been cleared,
            then it is replaced with a new <see cref="T:ICU4N.Support.Reference`1"/> to the new value,
            and the new value is returned.
            The old and new values should be the same or equivalent.
            <para/>
            Otherwise the old value is returned.
            </summary>
            <param name="value">Replacement value, for when the current <see cref="T:ICU4N.Support.Reference`1"/> has been cleared.</param>
            <returns>The old or new value.</returns>
        </member>
        <member name="T:ICU4N.Impl.CaseMapImpl.StringContextIterator">
            <summary>
            Implementation of <see cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/>, iterates over a string.
            See ustrcase.c/utf16_caseContextIterator().
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="src">String to iterate over.</param>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.#ctor(System.Text.StringBuilder)">
            <summary>
            Constructor.
            </summary>
            <param name="src">String to iterate over.</param>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.#ctor(System.Char[])">
            <summary>
            Constructor.
            </summary>
            <param name="src">String to iterate over.</param>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.#ctor(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Constructor.
            </summary>
            <param name="src">String to iterate over.</param>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.SetLimit(System.Int32)">
            <summary>
            Set the iteration limit for <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP"/> to an index within the string.
            If the limit parameter is negative or past the string, then the
            string length is restored as the iteration limit.
            <para/>
            This limit does not affect the <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.Next"/> function which always
            iterates to the very end of the string.
            </summary>
            <param name="lim">The iteration limit.</param>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.MoveToLimit">
            <summary>
            Move to the iteration limit without fetching code points up to there.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP">
            <summary>
            Iterate forward through the string to fetch the next code point
            to be case-mapped, and set the context indexes for it.
            </summary>
            <remarks>
            When the iteration limit is reached (and -1 is returned),
            <see cref="P:ICU4N.Impl.CaseMapImpl.StringContextIterator.CPStart"/> will be at the iteration limit.
            <para/>
            Iteration with <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.Next"/> does not affect the position for <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP"/>.
            </remarks>
            <returns>The next code point to be case-mapped, or &lt;0 when the iteration is done.</returns>
        </member>
        <member name="P:ICU4N.Impl.CaseMapImpl.StringContextIterator.CPStart">
            <summary>
            Gets the start of the code point that was last returned 
            by <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CaseMapImpl.StringContextIterator.CPLimit">
            <summary>
            Gets the limit of the code point that was last returned
            by <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CaseMapImpl.StringContextIterator.CPLength">
            <summary>
            Gets the length of the code point that was last returned
            by <see cref="M:ICU4N.Impl.CaseMapImpl.StringContextIterator.NextCaseMapCP"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.CaseMapImpl.TITLECASE_ITERATOR_MASK">
            <summary>
            Bit mask for the titlecasing iterator options bit field.
            Currently only 3 out of 8 values are used:
            0 (words), <see cref="F:ICU4N.Impl.CaseMapImpl.TITLECASE_WHOLE_STRING"/>, <see cref="F:ICU4N.Impl.CaseMapImpl.TITLECASE_SENTENCES"/>.
            See stringoptions.h.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Impl.CaseMapImpl.TITLECASE_ADJUSTMENT_MASK">
            <summary>
            Bit mask for the titlecasing index adjustment options bit set.
            Currently two bits are defined:
            <see cref="F:ICU4N.UChar.TitleCaseNoBreakAdjustment"/>, <see cref="F:ICU4N.Impl.CaseMapImpl.TITLECASE_ADJUST_TO_CASED"/>.
            See stringoptions.h.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Impl.CaseMapImpl.OMIT_UNCHANGED_TEXT">
            <summary>
            Omit unchanged text when case-mapping with Edits.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.GetDiacriticData(System.Int32)">
            <summary>
            Returns a non-zero value for each of the Greek combining diacritics
            listed in The Unicode Standard, version 8, chapter 7.2 Greek,
            plus some perispomeni look-alikes.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper(System.Int32,System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper(System.Int32,System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper(System.Int32,System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper(System.Int32,ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper``1(System.Int32,System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper``1(System.Int32,System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper``1(System.Int32,System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.GreekUpper.ToUpper``1(System.Int32,ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Greek string uppercasing with a state machine.
            Probably simpler than a stateless function that has to figure out complex context-before
            for each character.
            <para/>
            TODO: Try to re-consolidate one way or another with the non-Greek function.
            <para/>
            Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.AppendResult(System.Int32,System.Text.StringBuilder,System.Int32,System.Int32,ICU4N.Text.Edits)">
            <summary>
            Appends a full case mapping result, see <see cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Impl.CaseMapImpl.AppendResult(System.Int32,ICU4N.Support.Text.IAppendable,System.Int32,System.Int32,ICU4N.Text.Edits)">
            <summary>
            Appends a full case mapping result, see <see cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:ICU4N.Impl.CharacterIteration.Done32">
            <summary>
            32 bit Char value returned from when an iterator has run out of range.
                Positive value so fast case (not end, not surrogate) can be checked
                with a single test.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteration.Next32(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Move the iterator forward to the next code point, and return that code point,
            leaving the iterator positioned at char returned.
            For Supplementary chars, the iterator is left positioned at the lead surrogate.
            </summary>
            <param name="ci">The character iterator.</param>
            <returns>The next code point.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteration.NextTrail32(ICU4N.Support.Text.CharacterIterator,System.Int32)">
            <summary>
            Out-of-line portion of the in-line <see cref="M:ICU4N.Impl.CharacterIteration.Next32(ICU4N.Support.Text.CharacterIterator)"/> code.
            The call site does an initial ci.Next() and calls this function
            if the 16 bit value it gets is >= <see cref="F:ICU4N.Text.UTF16.LeadSurrogateMinValue"/>.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.CharacterIteratorWrapper">
            <summary>
            This class is a wrapper around <see cref="T:ICU4N.Support.Text.CharacterIterator"/> and implements the
            <see cref="T:ICU4N.Text.UCharacterIterator"/> protocol
            </summary>
            <author>ram</author>
        </member>
        <member name="P:ICU4N.Impl.CharacterIteratorWrapper.Current">
            <seealso cref="P:ICU4N.Text.UCharacterIterator.Current"/>
        </member>
        <member name="P:ICU4N.Impl.CharacterIteratorWrapper.Length">
            <seealso cref="P:ICU4N.Text.UCharacterIterator.Length"/>
        </member>
        <member name="P:ICU4N.Impl.CharacterIteratorWrapper.Index">
            <seealso cref="P:ICU4N.Text.UCharacterIterator.Index"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.Next">
            <seealso cref="M:ICU4N.Text.UCharacterIterator.Next"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.Previous">
            <seealso cref="M:ICU4N.Text.UCharacterIterator.Previous"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.SetToLimit">
            <seealso cref="M:ICU4N.Text.UCharacterIterator.SetToLimit"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.GetText(System.Char[],System.Int32)">
            <seealso cref="M:ICU4N.Text.UCharacterIterator.GetText(System.Char[])"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.Clone">
            <summary>
            Creates a clone of this iterator.  Clones the underlying character iterator.
            </summary>
            <seealso cref="M:ICU4N.Text.UCharacterIterator.Clone"/>
        </member>
        <member name="M:ICU4N.Impl.CharacterIteratorWrapper.GetCharacterIterator">
            <seealso cref="M:ICU4N.Text.UCharacterIterator.GetCharacterIterator"/>
        </member>
        <member name="T:ICU4N.Impl.CharTrie">
            <summary>
            Trie implementation which stores data in char, 16 bits.
            </summary>
            <author>synwee</author>
            <seealso cref="T:ICU4N.Impl.Trie"/>
            <since>release 2.1, Jan 01 2002</since>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.#ctor(ICU4N.Support.IO.ByteBuffer,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Creates a new Trie with the settings for the trie data.
            <para/>
            Unserialize the 32-bit-aligned input buffer and use the data for the trie.
            </summary>
            <param name="bytes">Data of an ICU data file, containing the trie.</param>
            <param name="dataManipulate">Object which provides methods to parse the char data.</param>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.#ctor(System.Int32,System.Int32,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Make a dummy CharTrie.
            </summary>
            <remarks>
            A dummy trie is an empty runtime trie, used when a real data trie cannot
            be loaded.
            <para/>
            The trie always returns the initialValue,
            or the leadUnitValue for lead surrogate code points.
            The Latin-1 part is always set up to be linear.
            </remarks>
            <param name="initialValue">The initial value that is set for all code points.</param>
            <param name="leadUnitValue">The value for lead surrogate code _units_ that do not have associated supplementary data.</param>
            <param name="dataManipulate">Object which provides methods to parse the char data.</param>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetCodePointValue(System.Int32)">
            <summary>
            Gets the value associated with the codepoint.
            <para/>
            If no value is associated with the codepoint, a default value will be
            returned.
            </summary>
            <param name="ch">Codepoint.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetLeadValue(System.Char)">
            <summary>
            Gets the value to the data which this lead surrogate character points
            to.
            <para/>
            Returned data may contain folding offset information for the next
            trailing surrogate character.
            <para/>
            This method does not guarantee correct results for trail surrogates.
            </summary>
            <param name="ch">Lead surrogate character.</param>
            <returns>Data value.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetBMPValue(System.Char)">
            <summary>
            Get the value associated with the BMP code point.
            Lead surrogate code points are treated as normal code points, with
            unfolded values that may differ from <see cref="M:ICU4N.Impl.CharTrie.GetLeadValue(System.Char)"/> results.
            </summary>
            <param name="ch">The input BMP code point.</param>
            <returns>Trie data value associated with the BMP codepoint.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetSurrogateValue(System.Char,System.Char)">
            <summary>
            Get the value associated with a pair of surrogates.
            </summary>
            <param name="lead">A lead surrogate.</param>
            <param name="trail">A trail surrogate.</param>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetTrailValue(System.Int32,System.Char)">
            <summary>
            Get a value from a folding offset (from the value of a lead surrogate)
            and a trail surrogate.
            </summary>
            <param name="leadvalue">Value associated with the lead surrogate which contains the folding offset.</param>
            <param name="trail">Trail surrogate.</param>
            <returns>Trie data value associated with the trail character.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetLatin1LinearValue(System.Char)">
            <summary>
            Gets the latin 1 fast path value.
            <para/>
            Note this only works if latin 1 characters have their own linear array.
            </summary>
            <param name="ch">Latin 1 characters.</param>
            <returns>Value associated with latin character.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.Equals(System.Object)">
            <summary>
            Checks if the argument Trie has the same data as this Trie.
            </summary>
            <param name="other">Trie to check.</param>
            <returns>true if the argument Trie has the same data as this Trie, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.Unserialize(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Parses the byte buffer and stores its trie content into a index and
            data array.
            </summary>
            <param name="bytes">Buffer containing trie data.</param>
        </member>
        <member name="M:ICU4N.Impl.CharTrie.GetSurrogateOffset(System.Char,System.Char)">
            <summary>
             Gets the offset to the data which the surrogate pair points to.
            </summary>
            <param name="lead">Lead surrogate.</param>
            <param name="trail">Trailing surrogate.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="P:ICU4N.Impl.CharTrie.Item(System.Int32)">
            <summary>
            Gets the value at the argument index.
            For use internally in <see cref="T:ICU4N.Impl.TrieEnumerator"/>.
            <para/>
            NOTE: This was named GetValue(int) in icu4j.
            </summary>
            <param name="index">Value at index will be retrieved.</param>
            <returns>32 bit value.</returns>
            <seealso cref="T:ICU4N.Impl.TrieEnumerator"/>
        </member>
        <member name="P:ICU4N.Impl.CharTrie.InitialValue">
            <summary>
            Gets the default initial (32 bit) value.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.CharTrie.m_initialValue_">
            <summary>
            Default value
            </summary>
        </member>
        <member name="F:ICU4N.Impl.CharTrie.m_data_">
            <summary>
            Array of char data
            </summary>
        </member>
        <member name="T:ICU4N.Impl.CSCharacterIterator">
            <summary>
            Implement the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> abstract class on a <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            Intended for internal use by ICU only.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.#ctor(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Constructor.
            </summary>
            <param name="text">The <see cref="T:ICU4N.Support.Text.ICharSequence"/> to iterate over.</param>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.First">
            <summary>
            Sets the current position to the begin index and returns the character at
            the new position.
            </summary>
            <returns>The character at the begin index.</returns>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.Last">
            <summary>
            Sets the current position to the end index - 1 and returns the character
            at the new position.
            </summary>
            <returns>The character before the end index.</returns>
        </member>
        <member name="P:ICU4N.Impl.CSCharacterIterator.Current">
            <summary>
            Returns the character at the current index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the current index is
            past the beginning or end of the sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.Next">
            <summary>
            Increments the current index and returns the character at the new index.
            </summary>
            <returns>The character at the next index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the next
            index would be past the end.</returns>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.Previous">
            <summary>
            Decrements the current index and returns the character at the new index.
            </summary>
            <returns>The character at the previous index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the
            previous index would be past the beginning.</returns>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.SetIndex(System.Int32)">
            <summary>
            Sets the current index to a new position and returns the character at the
            new index.
            </summary>
            <param name="position">The new index that this character iterator is set to.</param>
            <returns>The character at the new index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the index is
            past the end.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="position"/> is less than 
            the begin index or greater than the end index.</exception>
        </member>
        <member name="P:ICU4N.Impl.CSCharacterIterator.BeginIndex">
            <summary>
            Gets the begin index. Returns the index of the first character of the iteration.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CSCharacterIterator.EndIndex">
            <summary>
            Gets the end index. Returns the index one past the last character of the iteration.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.CSCharacterIterator.Index">
            <summary>
            Gets the current index.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.CSCharacterIterator.Clone">
            <summary>
            Returns a new <see cref="T:ICU4N.Support.Text.CharacterIterator"/> with the same properties.
            </summary>
            <returns>A shallow copy of this character iterator.</returns>
        </member>
        <member name="F:ICU4N.Impl.CurrencyData.CurrencySpacingInfo.hasBeforeCurrency">
            new String[SpacingType.COUNT.ordinal()][SpacingPattern.COUNT.ordinal()];
        </member>
        <member name="T:ICU4N.Impl.IAuthenticate">
            <summary>
            Special interface for data authentication
            </summary>
        </member>
        <member name="M:ICU4N.Impl.IAuthenticate.IsDataVersionAcceptable(System.Byte[])">
            <summary>
            Method used in <see cref="M:ICU4N.Impl.ICUBinary.ReadHeader(ICU4N.Support.IO.ByteBuffer,System.Int32,ICU4N.Impl.IAuthenticate)"/> to provide data format
            authentication.
            </summary>
            <param name="version">Version of the current data.</param>
            <returns>true if dataformat is an acceptable version, false otherwise.</returns>
        </member>
        <member name="T:ICU4N.Impl.ICUBinary.DatPackageReader">
            <summary>
            Reads the ICU .dat package file format.
            Most methods do not modify the <see cref="T:ICU4N.Support.IO.ByteBuffer"/> in any way,
            not even its position or other state.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUBinary.DatPackageReader.DATA_FORMAT">
            <summary>
            .dat package data format ID "CmnD".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.DatPackageReader.Validate(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Checks that the <see cref="T:ICU4N.Support.IO.ByteBuffer"/> contains a valid, usable ICU .dat package.
            Moves the buffer position from 0 to after the data header.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.DataFile.AddBaseNamesInFolder(System.String,System.String,System.Collections.Generic.ISet{System.String})">
            <param name="folder">The relative ICU data folder, like "" or "coll".</param>
            <param name="suffix">Usually ".res".</param>
            <param name="names">File base names relative to the folder are added without the suffix,
            for example "de_CH".</param>
        </member>
        <member name="F:ICU4N.Impl.ICUBinary.PackageDataFile.pkgBytes">
            <summary>
            .dat package bytes, or null if not a .dat package.
            position() is after the header.
            Do not modify the position or other state, for thread safety.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.CompareKeys(System.String,ICU4N.Support.IO.ByteBuffer,System.Int32)">
            <summary>
            Compares the length-specified input key with the
            NUL-terminated table key. (ASCII)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetData(System.String)">
            <summary>
            Loads an ICU binary data file and returns it as a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            The buffer contents is normally read-only, but its position etc. can be modified.
            </summary>
            <param name="itemPath">Relative ICU data item path, for example "root.res" or "coll/ucadata.icu".</param>
            <returns>The data as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>,
            or null if the resource could not be found.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetData(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Loads an ICU binary data file and returns it as a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            The buffer contents is normally read-only, but its position etc. can be modified.
            </summary>
            <param name="assembly">Used for <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)"/> unless the data is found elsewhere.</param>
            <param name="resourceName">Resource name for use with the <paramref name="assembly"/>.</param>
            <param name="itemPath">Relative ICU data item path, for example "root.res" or "coll/ucadata.icu".</param>
            <returns>The data as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>,
            or null if the resource could not be found.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetRequiredData(System.String)">
            <summary>
            Loads an ICU binary data file and returns it as a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            The buffer contents is normally read-only, but its position etc. can be modified.
            </summary>
            <param name="itemPath">Relative ICU data item path, for example "root.res" or "coll/ucadata.icu".</param>
            <returns>The data as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.</returns>
            <exception cref="T:System.Resources.MissingManifestResourceException">If required==true and the resource could not be found.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetRequiredData(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Loads an ICU binary data file and returns it as a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            The buffer contents is normally read-only, but its position etc. can be modified.
            </summary>
            <param name="assembly">Used for <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)"/> unless the data is found elsewhere.</param>
            <param name="resourceName">Resource name for use with the <paramref name="assembly"/>.</param>
            <param name="itemPath">Relative ICU data item path, for example "root.res" or "coll/ucadata.icu".</param>
            <returns>The data as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.</returns>
            <exception cref="T:System.Resources.MissingManifestResourceException">If required==true and the resource could not be found.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetData(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>
            Loads an ICU binary data file and returns it as a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            The buffer contents is normally read-only, but its position etc. can be modified.
            </summary>
            <param name="assembly">Used for <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)"/> unless the data is found elsewhere.</param>
            <param name="resourceName">Resource name for use with the <paramref name="assembly"/>.</param>
            <param name="itemPath">Relative ICU data item path, for example "root.res" or "coll/ucadata.icu".</param>
            <param name="required">If the resource cannot be found,
            this method returns null (!<paramref name="required"/>) or throws an exception (<paramref name="required"/>).</param>
            <returns>The data as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>,
            or null if <paramref name="required"/>==false and the resource could not be found.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.AddBaseNamesInFileFolder(System.String,System.String,System.Collections.Generic.ISet{System.String})">
            <param name="folder">The relative ICU data folder, like "" or "coll".</param>
            <param name="suffix">Usually ".res".</param>
            <param name="names">File base names relative to the folder are added without the suffix,
            for example "de_CH".</param>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.ReadHeaderAndDataVersion(ICU4N.Support.IO.ByteBuffer,System.Int32,ICU4N.Impl.IAuthenticate)">
            <summary>
            Same as <see cref="M:ICU4N.Impl.ICUBinary.ReadHeader(ICU4N.Support.IO.ByteBuffer,System.Int32,ICU4N.Impl.IAuthenticate)"/>, 
            but returns a <see cref="T:ICU4N.Util.VersionInfo"/> rather than a compact int.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.ReadHeader(ICU4N.Support.IO.ByteBuffer,System.Int32,ICU4N.Impl.IAuthenticate)">
            <summary>
            Reads an ICU data header, checks the data format, and returns the data version.
            </summary>
            <remarks>
            Assumes that the <see cref="T:ICU4N.Support.IO.ByteBuffer"/> position is 0 on input.
            <para/>
            The buffer byte order is set according to the data.
            The buffer position is advanced past the header (including UDataInfo and comment).
            <para/>
            See C++ ucmndata.h and unicode/udata.h.
            </remarks>
            <returns>dataVersion</returns>
            <exception cref="T:System.IO.IOException">If this is not a valid ICU data item of the expected dataFormat.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.WriteHeader(System.Int32,System.Int32,System.Int32,ICU4N.Support.IO.DataOutputStream)">
            <summary>
            Writes an ICU data header.
            Does not write a copyright string.
            </summary>
            <param name="dataFormat"></param>
            <param name="formatVersion"></param>
            <param name="dataVersion"></param>
            <param name="dos"></param>
            <returns>The length of the header (number of bytes written).</returns>
            <exception cref="T:System.IO.IOException">From the <see cref="T:ICU4N.Support.IO.DataOutputStream"/>.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.SliceWithOrder(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Same as <see cref="M:ICU4N.Support.IO.ByteBuffer.Slice"/>.slice() plus preserving the byte order.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetByteBufferFromStreamAndDisposeStream(System.IO.Stream)">
            <summary>
            Reads the entire contents from the stream into a byte array
            and wraps it into a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>. Disposes the <see cref="T:System.IO.Stream"/> at the end.
            </summary>
            <remarks>
            This was named getByteBufferFromInputStreamAndCloseStream() in ICU4J.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetVersionInfoFromCompactInt(System.Int32)">
            <summary>
            Returns a <see cref="T:ICU4N.Util.VersionInfo"/> for the bytes in the compact version integer.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUBinary.GetVersionByteArrayFromCompactInt(System.Int32)">
            <summary>
            Returns an array of the bytes in the compact version integer.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUConfig">
            <summary>
            ICUConfig is a class used for accessing ICU4N runtime configuration.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUConfig.Get(System.String)">
            <summary>
            Get ICU configuration property value for the given name.
            </summary>
            <param name="name">The configuration property name.</param>
            <returns>The configuration property value, or null if it does not exist.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUConfig.Get(System.String,System.String)">
            <summary>
            Get ICU configuration property value for the given name.
            </summary>
            <param name="name">The configuration property name.</param>
            <param name="def">The default value.</param>
            <returns>The configuration property value.  If the property does not
            exist, <paramref name="def"/> is returned.</returns>
        </member>
        <member name="T:ICU4N.Impl.ICUData">
            <summary>
            Provides access to ICU data files as <see cref="T:System.IO.Stream"/>s.  Implements security checking.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_DATA_PATH">
            <summary>
            The data path to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.PACKAGE_NAME">
            <summary>
            The ICU data package name.
            This is normally the name of the .dat package, and the prefix (plus '/')
            of the package entry names.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_BUNDLE">
            <summary>
            The data path to be used with <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_BASE_NAME">
            <summary>
            The base name of ICU data to be used with <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)"/>,
            <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,System.Boolean)"/> etc.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_COLLATION_BASE_NAME">
            <summary>
            The base name of collation data to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_BRKITR_NAME">
            <summary>
            The base name of rbbi data to be used with <see cref="M:ICU4N.Impl.ICUBinary.GetData(System.Reflection.Assembly,System.String,System.String,System.Boolean)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_BRKITR_BASE_NAME">
            <summary>
            The base name of rbbi data to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_RBNF_BASE_NAME">
            <summary>
            The base name of rbnf data to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.ICU_TRANSLIT_BASE_NAME">
            <summary>
            The base name of transliterator data to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUData.logBinaryDataFromInputStream">
            <summary>
            For testing (otherwise false): When reading a <see cref="T:System.IO.Stream"/> from an <see cref="T:System.Reflection.Assembly"/>
            (that is, not from a file), log when the stream contains ICU binary data.
            <para/>
            This cannot be <see cref="T:ICU4N.Impl.ICUConfig"/>'ured because <see cref="T:ICU4N.Impl.ICUConfig"/> calls <see cref="M:ICU4N.Impl.ICUData.GetStream(System.String)"/>
            to read the properties file, so we would get a circular dependency
            in the class initialization.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUData.GetStream(System.Reflection.Assembly,System.String,System.Boolean)">
            <summary>
            Should be called only from <see cref="M:ICU4N.Impl.ICUBinary.GetData(System.Reflection.Assembly,System.String,System.String,System.Boolean)"/> or from convenience overloads here.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUData.GetStream(System.String)">
            <summary>
            Convenience override that calls <c>GetStream(typeof(ICUData), resourceName, false)</c>.
            </summary>
            <returns>Returns null if the resource could not be found.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUData.GetRequiredStream(System.String)">
            <summary>
            Convenience method that calls <c>GetStream(typeof(ICUData), resourceName, true)</c>
            </summary>
            <exception cref="T:System.Resources.MissingManifestResourceException">If the resource could not be found.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUData.GetStream(System.Type,System.String)">
            <summary>
            Convenience override that calls <c>GetStream(root, resourceName, false)</c>.
            </summary>
            <returns>Returns null if the resource could not be found.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUData.GetRequiredStream(System.Type,System.String)">
            <summary>
            Convenience method that calls <c>GetStream(root, resourceName, true)</c>.
            </summary>
            <exception cref="T:System.Resources.MissingManifestResourceException">If the resource could not be found.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.#ctor">
            <summary>
            Construct an <see cref="T:ICU4N.Impl.ICULocaleService"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.#ctor(System.String)">
            <summary>
            Construct an <see cref="T:ICU4N.Impl.ICULocaleService"/> with a <paramref name="name"/> (useful for debugging).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale)">
            <summary>
            Convenience override for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,System.Int32,ICU4N.Util.ULocale[])"/> with <see cref="F:ICU4N.Impl.ICULocaleService.LocaleKey.KIND_ANY"/>
            for kind and null for actualReturn.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,System.Int32)">
            <summary>
            Convenience override for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,System.Int32,ICU4N.Util.ULocale[])"/> with a null actualReturn.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,ICU4N.Util.ULocale[])">
            <summary>
            Convenience override for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,System.Int32,ICU4N.Util.ULocale[])"/> with <see cref="F:ICU4N.Impl.ICULocaleService.LocaleKey.KIND_ANY"/> for kind.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.Get(ICU4N.Util.ULocale,System.Int32,ICU4N.Util.ULocale[])">
            <summary>
            Convenience override for callers using locales.  This uses
            <see cref="M:ICU4N.Impl.ICULocaleService.CreateKey(System.String,System.Int32)"/> to create a key, calls 
            <see cref="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key)"/>, and then
            if <paramref name="actualReturn"/> is not null, returns the actualResult from
            <see cref="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key)"/> (stripping any prefix) into a <see cref="T:ICU4N.Util.ULocale"/>.
            </summary>
            <param name="locale"></param>
            <param name="kind"></param>
            <param name="actualReturn"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale)">
            <summary>
            Convenience override for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Int32,System.Boolean)"/>
            passing <see cref="F:ICU4N.Impl.ICULocaleService.LocaleKey.KIND_ANY"/> for the kind, and true for the visibility.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Boolean)">
            <summary>
            Convenience override for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Int32,System.Boolean)"/>
            passing <see cref="F:ICU4N.Impl.ICULocaleService.LocaleKey.KIND_ANY"/> for the kind.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Int32)">
            <summary>
            Convenience function for callers using locales.  This calls
            <see cref="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Int32,System.Boolean)"/>
            passing true for the visibility.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.RegisterObject(System.Object,ICU4N.Util.ULocale,System.Int32,System.Boolean)">
            <summary>
            Convenience function for callers using locales.  This instantiates
            a <see cref="T:ICU4N.Impl.ICULocaleService.SimpleLocaleKeyFactory"/>, and registers the factory.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.GetAvailableLocales">
            <summary>
            Convenience method for callers using locales.  This returns the standard
            <see cref="T:System.Globalization.CultureInfo"/> list, built from the <see cref="T:System.Collections.Generic.ICollection`1"/> of visible ids.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.GetAvailableULocales">
            <summary>
            Convenience method for callers using locales.  This returns the standard
            <see cref="T:ICU4N.Util.ULocale"/> list, built from the <see cref="T:System.Collections.Generic.ICollection`1"/> of visible ids.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICULocaleService.LocaleKey">
            <summary>
            A subclass of <see cref="T:ICU4N.Impl.ICUService.Key"/> that implements a locale fallback mechanism.
            </summary>
            <remarks>
            The first locale to search for is the locale provided by the
            client, and the fallback locale to search for is the current
            default locale.  If a prefix is present, the currentDescriptor
            includes it before the locale proper, separated by "/".  This
            is the default key instantiated by ICULocaleService.
            <para/>
            Canonicalization adjusts the locale string so that the
            section before the first understore is in lower case, and the rest
            is in upper case, with no trailing underscores.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.CreateWithCanonicalFallback(System.String,System.String)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.ICULocaleService.LocaleKey"/> with canonical primary and fallback IDs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.CreateWithCanonicalFallback(System.String,System.String,System.Int32)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.ICULocaleService.LocaleKey"/> with canonical primary and fallback IDs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.CreateWithCanonical(ICU4N.Util.ULocale,System.String,System.Int32)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.ICULocaleService.LocaleKey"/> with canonical primary and fallback IDs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.#ctor(System.String,System.String,System.String,System.Int32)">
            <param name="primaryID">The user's requested locale string.</param>
            <param name="canonicalPrimaryID"><paramref name="primaryID"/> string in canonical form.</param>
            <param name="canonicalFallbackID">The current default locale's string in canonical form.</param>
            <param name="kind"></param>
        </member>
        <member name="P:ICU4N.Impl.ICULocaleService.LocaleKey.Prefix">
            <summary>
            Return the prefix associated with the kind, or null if the kind is <see cref="F:ICU4N.Impl.ICULocaleService.LocaleKey.KIND_ANY"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICULocaleService.LocaleKey.Kind">
            <summary>
            Return the kind code associated with this key.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICULocaleService.LocaleKey.CanonicalID">
            <summary>
            Return the (canonical) original ID.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICULocaleService.LocaleKey.CurrentID">
            <summary>
            Return the (canonical) current ID, or null if no current id.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.GetCurrentDescriptor">
            <summary>
            Return the (canonical) current descriptor, or null if no current id.
            Includes the keywords, whereas the ID does not include keywords.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.GetCanonicalLocale">
            <summary>
            Convenience method to return the locale corresponding to the (canonical) original ID.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.GetCurrentLocale">
            <summary>
            Convenience method to return the ulocale corresponding to the (canonical) currentID.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.Fallback">
            <summary>
            If the key has a fallback, modify the key and return true,
            otherwise return false.
            <para/>
            First falls back through the primary ID, then through
            the fallbackID.  The final fallback is "" (root)
            unless the primary id was "" (root), in which case
            there is no fallback.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKey.IsFallbackOf(System.String)">
            <summary>
            If a key created from id would eventually fallback to match the
            canonical ID of this key, return true.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICULocaleService.LocaleKeyFactory">
            <summary>
            A subclass of Factory that uses LocaleKeys.  If 'visible' the
            factory reports its IDs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.#ctor(System.Boolean)">
            <summary>
            Constructor used by subclasses.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.#ctor(System.Boolean,System.String)">
            <summary>
            Constructor used by subclasses.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)">
            <summary>
            Implement superclass abstract method.  This checks the <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/>
            against the supported IDs, and passes the canonicalLocale and
            <see cref="P:ICU4N.Impl.ICULocaleService.LocaleKey.Kind"/> to <see cref="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.HandleCreate(ICU4N.Util.ULocale,System.Int32,ICU4N.Impl.ICUService)"/> (which subclasses must implement).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.UpdateVisibleIDs(System.Collections.Generic.IDictionary{System.String,ICU4N.Impl.ICUService.IFactory})">
            <summary>
            Implementation of <see cref="T:ICU4N.Impl.ICUService.IFactory"/> method.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.GetDisplayName(System.String,ICU4N.Util.ULocale)">
            <summary>
            Return a localized name for the locale represented by id.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.HandleCreate(ICU4N.Util.ULocale,System.Int32,ICU4N.Impl.ICUService)">
            <summary>
            Utility method used by <see cref="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)"/>.  Subclasses can
            implement this instead of <see cref="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.IsSupportedID(System.String)">
            <summary>
            Return true if this id is one the factory supports (visible or
            otherwise).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.GetSupportedIDs">
            <summary>
            Return the set of ids that this factory supports (visible or
            otherwise).  This can be called often and might need to be
            cached if it is expensive to create.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.LocaleKeyFactory.ToString">
            <summary>
            For debugging.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICULocaleService.SimpleLocaleKeyFactory">
            <summary>
            A <see cref="T:ICU4N.Impl.ICULocaleService.LocaleKeyFactory"/> that just returns a single object for a kind/locale.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.SimpleLocaleKeyFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)">
            <summary>
            Returns the service object if kind/locale match.  Service is not used.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory">
            <summary>
            A <see cref="T:ICU4N.Impl.ICULocaleService.LocaleKeyFactory"/> that creates a service based on the ICU locale data.
            This is a base class for most ICU factories.  Subclasses instantiate it
            with a constructor that takes a bundle name, which determines the supported
            IDs.  Subclasses then override <see cref="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.HandleCreate(ICU4N.Util.ULocale,System.Int32,ICU4N.Impl.ICUService)"/> to create the actual service
            object.  The default implementation returns a <see cref="T:System.Resources.ResourceManager"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.#ctor">
            <summary>
            Convenience constructor that uses the main ICU bundle name.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.#ctor(System.String)">
            <summary>
            A service factory based on ICU resource data in resources
            with the given name.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.GetSupportedIDs">
            <summary>
            Return the supported IDs.  This is the set of all locale names for the bundleName.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.UpdateVisibleIDs(System.Collections.Generic.IDictionary{System.String,ICU4N.Impl.ICUService.IFactory})">
            <summary>
            Override of superclass method.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ICUResourceBundleFactory.HandleCreate(ICU4N.Util.ULocale,System.Int32,ICU4N.Impl.ICUService)">
            <summary>
            Create the service.  The default implementation returns the resource bundle
            for the locale, ignoring kind, and service.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICULocaleService.ValidateFallbackLocale">
            <summary>
            Return the name of the current fallback locale.  If it has changed since this was
            last accessed, the service cache is cleared.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUNotifier">
            <summary>
            Abstract implementation of a notification facility.
            </summary>
            <remarks>
            Clients add <see cref="T:ICU4N.Impl.IEventListener"/>s with <see cref="M:ICU4N.Impl.ICUNotifier.AddListener(ICU4N.Impl.IEventListener)"/> 
            and remove them with <see cref="M:ICU4N.Impl.ICUNotifier.RemoveListener(ICU4N.Impl.IEventListener)"/>.
            Notifiers call <see cref="M:ICU4N.Impl.ICUNotifier.NotifyChanged"/> when they wish to notify listeners.
            This queues the listener list on the notification thread, which
            eventually dequeues the list and calls <see cref="M:ICU4N.Impl.ICUNotifier.NotifyListener(ICU4N.Impl.IEventListener)"/> on each
            listener in the list.
            <para/>
            Subclasses override <see cref="M:ICU4N.Impl.ICUNotifier.AcceptsListener(ICU4N.Impl.IEventListener)"/> and <see cref="M:ICU4N.Impl.ICUNotifier.NotifyListener(ICU4N.Impl.IEventListener)"/>
            to add type-safe notification.  <see cref="M:ICU4N.Impl.ICUNotifier.AcceptsListener(ICU4N.Impl.IEventListener)"/> should return
            true if the listener is of the appropriate type; <see cref="T:ICU4N.Impl.ICUNotifier"/>
            itself will ensure the listener is non-null and that the
            identical listener is not already registered with the Notifier.
            <see cref="M:ICU4N.Impl.ICUNotifier.NotifyListener(ICU4N.Impl.IEventListener)"/> should cast the listener to the appropriate
            type and call the appropriate method on the listener.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.AddListener(ICU4N.Impl.IEventListener)">
            <summary>
            Add a listener to be notified when <see cref="M:ICU4N.Impl.ICUNotifier.NotifyChanged"/> is called.
            The listener must not be null. <see cref="M:ICU4N.Impl.ICUNotifier.AcceptsListener(ICU4N.Impl.IEventListener)"/> must return
            true for the listener.  Attempts to concurrently
            register the identical listener more than once will be
            silently ignored.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.RemoveListener(ICU4N.Impl.IEventListener)">
            <summary>
            Stop notifying this listener.  The listener must
            not be null.  Attempts to remove a listener that is
            not registered will be silently ignored.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.NotifyChanged">
            <summary>
            Queue a notification on the notification thread for the current
            listeners.  When the thread unqueues the notification, <see cref="M:ICU4N.Impl.ICUNotifier.NotifyListener(ICU4N.Impl.IEventListener)"/>
            is called on each listener from the notification thread.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUNotifier.NotifyThread">
            <summary>
            The notification thread.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.NotifyThread.Queue(ICU4N.Impl.IEventListener[])">
            <summary>
            Queue the notification on the thread.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.NotifyThread.Run">
            <summary>
            Wait for a notification to be queued, then notify all
            listeners listed in the notification.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.AcceptsListener(ICU4N.Impl.IEventListener)">
            <summary>
            Subclasses implement this to return true if the listener is
            of the appropriate type.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUNotifier.NotifyListener(ICU4N.Impl.IEventListener)">
            <summary>
            Subclasses implement this to notify the listener.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.NO_INHERITANCE_MARKER">
            <summary>
            CLDR string value "" prevents fallback to the parent bundle.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER">
            <summary>
            The class loader constant to be used with <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,ICU4N.Impl.ICUResourceBundle.OpenType)"/> API
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.INSTALLED_LOCALES">
            <summary>
            The name of the resource containing the installed locales
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceBundle.WholeBundle">
            <summary>
            Fields for a whole bundle, rather than any specific resource in the bundle.
            Corresponds roughly to ICU4C/source/common/uresimp.h struct UResourceDataEntry.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.WholeBundle.reader">
            <summary>
            Access to the bits and bytes of the resource bundle.
            Hides low-level details.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceBundle.Loader">
            <summary>
            Loader for bundle instances, for caching.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetFunctionalEquivalent(System.String,System.Reflection.Assembly,System.String,System.String,ICU4N.Util.ULocale,System.Boolean[],System.Boolean)">
            <summary>
            Returns a functionally equivalent locale, considering keywords as well, for the specified keyword.
            </summary>
            <param name="baseName">Resource specifier.</param>
            <param name="assembly"></param>
            <param name="resName">Top level resource to consider (such as "collations").</param>
            <param name="keyword">A particular keyword to consider (such as "collation" ).</param>
            <param name="locID">The requested locale.</param>
            <param name="isAvailable">If non-null, 1-element array of fillin parameter that indicates whether the
            requested locale was available. The locale is defined as 'available' if it physically
            exists within the specified tree and included in 'InstalledLocales'.</param>
            <param name="omitDefault">If true, omit keyword and value if default.
            'de_DE\@collation=standard' -> 'de_DE'</param>
            <returns>The locale.</returns>
            <internal>ICU 3.0</internal>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetKeywordValues(System.String,System.String,System.Reflection.Assembly)">
            <summary>
            Given a tree path and keyword, return a string enumeration of all possible values for that keyword.
            </summary>
            <param name="baseName">Resource specifier.</param>
            <param name="keyword">A particular keyword to consider, must match a top level resource name
            within the tree. (i.e. "collations").</param>
            <param name="assembly">The assembly to retrieve the resources from.</param>
            <internal>ICU 3.0</internal>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetWithFallback(System.String)">
            <summary>
            This method performs multilevel fallback for fetching items from the
            bundle e.g: If resource is in the form de__PHONEBOOK{ collations{
            default{ "phonebook"} } } If the value of "default" key needs to be
            accessed, then do: 
            <code>
                UResourceBundle bundle = UResourceBundle.GetBundleInstance("de__PHONEBOOK");
                ICUResourceBundle result = null;
                if (bundle is ICUResourceBundle)
                {
                    result = ((ICUResourceBundle) bundle).GetWithFallback("collations/default");
                }
            </code>
            </summary>
            <param name="path">The path to the required resource key.</param>
            <returns>Resource represented by the key.</returns>
            <exception cref="T:System.Resources.MissingManifestResourceException">If a resource was not found.</exception>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.FindWithFallback(System.String)">
            <summary>
            Like <see cref="M:ICU4N.Impl.ICUResourceBundle.GetWithFallback(System.String)"/>, but returns null if the resource is not found instead of
            throwing an exception.
            </summary>
            <param name="path">The path to the resource.</param>
            <returns>The resource, or null.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableLocaleNameSet(System.String,System.Reflection.Assembly)">
            <summary>
            Return a set of the locale names supported by a collection of resource
            bundles.
            </summary>
            <param name="bundlePrefix">The prefix of the resource bundles to use.</param>
            <param name="assembly"></param>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetFullLocaleNameSet">
            <summary>
            Return a set of all the locale names supported by a collection of
            resource bundles.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetFullLocaleNameSet(System.String,System.Reflection.Assembly)">
            <summary>
            Return a set of all the locale names supported by a collection of
            resource bundles.
            </summary>
            <param name="bundlePrefix">The prefix of the resource bundles to use.</param>
            <param name="assembly"></param>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableLocaleNameSet">
            <summary>
            Return a set of the locale names supported by a collection of resource
            bundles.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableULocales(System.String,System.Reflection.Assembly)">
            <summary>
            Get the set of <see cref="T:ICU4N.Util.ULocale"/>s installed in the specified bundles.
            </summary>
            <returns>The list of available locales.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableULocales">
            <summary>
            Get the set of <see cref="T:ICU4N.Util.ULocale"/>s installed the base bundle.
            </summary>
            <returns>The list of available locales.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableLocales(System.String,System.Reflection.Assembly)">
            <summary>
            Get the set of <see cref="T:System.Globalization.CultureInfo"/>s installed in the specified bundles.
            </summary>
            <returns>The list of available locales.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailableLocales">
            <summary>
            Get the set of <see cref="T:System.Globalization.CultureInfo"/>s installed the base bundle.
            </summary>
            <returns>The list of available locales.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetLocaleList(ICU4N.Util.ULocale[])">
            <summary>
            Convert a list of <see cref="T:ICU4N.Util.ULocale"/>s to a list of <see cref="T:System.Globalization.CultureInfo"/>s.  <see cref="T:ICU4N.Util.ULocale"/>s with a script code will not be converted
            since they cannot be represented as a <see cref="T:System.Globalization.CultureInfo"/>.  This means that the two lists will <b>not</b> match
            one-to-one, and that the returned list might be shorter than the input list.
            </summary>
            <param name="ulocales">A list of <see cref="T:ICU4N.Util.ULocale"/>s to convert to a list of <see cref="T:System.Globalization.CultureInfo"/>s.</param>
            <returns>The list of converted Locales.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetLocale">
            <summary>
            Returns the locale of this resource bundle. This method can be used after
            a call to <see cref="M:ICU4N.Impl.ICUResourceBundle.GetBundle(ICU4N.Impl.ICUResourceBundleReader,System.String,System.String,System.Reflection.Assembly)"/> to determine whether the resource bundle returned
            really corresponds to the requested locale or is a fallback.
            </summary>
            <returns>The locale of this resource bundle.</returns>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceBundle.AvailEntry">
            <summary>
            Holds the prefix, and lazily creates the <see cref="T:CultureInfo[]"/> list or the locale name
            <see cref="T:System.Collections.Generic.ISet`1"/> as needed.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.GET_AVAILABLE_CACHE">
            <summary>
            Cache used for AvailableEntry
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAvailEntry(System.String,System.Reflection.Assembly)">
            <summary>
            Stores the locale information in a cache accessed by key (bundle prefix).
            The cached objects are <see cref="T:ICU4N.Impl.ICUResourceBundle.AvailEntry"/>s. The cache is implemented by <see cref="T:ICU4N.Impl.SoftCache`3"/>
            so it can be GC'd.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.FindStringWithFallback(System.String,ICU4N.Util.UResourceBundle,ICU4N.Util.UResourceBundle)">
            <summary>
            Like FindResourceWithFallback(...).GetString() but with minimal creation of intermediate
            <see cref="T:ICU4N.Impl.ICUResourceBundle"/> objects.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetResPathKeys(System.String[],System.Int32)">
            <summary>
            Fills some of the keys array with the keys on the path to this resource object.
            Writes the top-level key into index 0 and increments from there.
            </summary>
            <param name="keys"></param>
            <param name="depth">Must be <see cref="M:ICU4N.Impl.ICUResourceBundle.GetResDepth"/>.</param>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetResPathKeys(System.String,System.Int32,System.String[],System.Int32)">
            <summary>
            Fills some of the keys array (from start) with the num keys from the path string.
            </summary>
            <param name="path">Path string.</param>
            <param name="num">Must be <see cref="M:ICU4N.Impl.ICUResourceBundle.CountPathKeys(System.String)"/>.</param>
            <param name="keys"></param>
            <param name="start">Index where the first path key is stored.</param>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.OpenType.LOCALE_DEFAULT_ROOT">
            <summary>
            Open a resource bundle for the locale;
            if there is not even a base language bundle, then fall back to the default locale;
            if there is no bundle for that either, then load the root bundle.
            <para/>
            This is the default bundle loading behavior.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.OpenType.LOCALE_ROOT">
            <summary>
            Open a resource bundle for the locale;
            if there is not even a base language bundle, then load the root bundle;
            never fall back to the default locale.
            <para/>
            This is used for algorithms that have good pan-Unicode default behavior,
            such as case mappings, collation, and segmentation (BreakIterator).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.OpenType.LOCALE_ONLY">
            <summary>
            Open a resource bundle for the locale;
            if there is not even a base language bundle, then fail;
            never fall back to the default locale nor to the root locale.
            <para/>
            This is used when fallback to another language is not desired
            and the root locale is not generally useful.
            For example, <see cref="P:ICU4N.Util.LocaleData.NoSubstitute"/>
            or currency display names for <see cref="T:ICU4N.Text.LocaleDisplayNames"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.OpenType.DIRECT">
            <summary>
            Open a resource bundle for the exact bundle name as requested;
            no fallbacks, do not load parent bundles.
            <para/>
            This is used for supplemental (non-locale) data.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.key">
            <summary>
            Data member where the subclasses store the key.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.RES_BOGUS">
            <summary>
            A resource word value that means "no resource".
            Note: 0xffffffff == -1
            <para/>
            This has the same value as <see cref="F:ICU4N.Util.UResourceBundle.NONE"/>, but they are semantically
            different and should be used appropriately according to context:
            NONE means "no type".
            (The type of <see cref="F:ICU4N.Impl.ICUResourceBundle.RES_BOGUS"/> is RES_RESERVED=15 which was defined in ICU4C ures.h.)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.ALIAS">
            <summary>
            Resource type constant for aliases;
            internally stores a string which identifies the actual resource
            storing the data (can be in a different resource bundle).
            Resolved internally before delivering the actual resource through the API.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.TABLE32">
            <summary>
            Resource type constant for tables with 32-bit count, key offsets and values.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.TABLE16">
            <summary>
            Resource type constant for tables with 16-bit count, key offsets and values.
            All values are <see cref="F:ICU4N.Impl.ICUResourceBundle.STRING_V2"/> strings.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.STRING_V2">
            <summary>
            Resource type constant for 16-bit Unicode strings in formatVersion 2.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundle.ARRAY16">
            <summary>
            Resource type constant for arrays with 16-bit count and values.
            All values are <see cref="F:ICU4N.Impl.ICUResourceBundle.STRING_V2"/> strings.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.CreateBundle(System.String,System.String,System.Reflection.Assembly)">
            <summary>
            Create a bundle using a reader.
            </summary>
            <param name="baseName">The name for the bundle.</param>
            <param name="localeID">The locale identification.</param>
            <param name="root">The <see cref="T:System.Reflection.Assembly"/> object root.</param>
            <returns>The new bundle.</returns>
        </member>
        <member name="P:ICU4N.Impl.ICUResourceBundle.IsRoot">
            <summary>
            Returns true if this is the root bundle, or an item in the root bundle.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUResourceBundle.NoFallback">
            <summary>
            Gets the noFallback flag specified in the loaded bundle.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.#ctor(ICU4N.Impl.ICUResourceBundle.WholeBundle)">
            <summary>
            Constructor for the root table of a bundle.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundle.GetAliasedResource(ICU4N.Impl.ICUResourceBundle,System.String[],System.Int32,System.String,System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},ICU4N.Util.UResourceBundle)">
            <summary>
            Returns the resource object referred to from the alias _resource int's path string.
            Throws <see cref="T:System.Resources.MissingManifestResourceException"/> if not found.
            <para/>
            If the alias path does not contain a key path:
            If keys != null then keys[:depth] is used.
            Otherwise the base key path plus the key parameter is used.
            </summary>
            <param name="base">A direct or indirect container of the alias.</param>
            <param name="keys">The key path to the alias, or null. (const)</param>
            <param name="depth">The length of the key path, if keys != null.</param>
            <param name="key">The alias' own key within this current container, if keys == null.</param>
            <param name="_resource">The alias resource int.</param>
            <param name="aliasesVisited">Set of alias path strings already visited, for detecting loops.
            We cannot change the type (e.g., to <see cref="T:ISet{string}"/>) because it is used
            in protected/@stable <see cref="T:ICU4N.Util.UResourceBundle"/> methods.</param>
            <param name="requested">The original resource object from which the lookup started,
            which is the starting point for "/LOCALE/..." aliases.</param>
            <returns>The aliased resource object.</returns>
        </member>
        <member name="P:ICU4N.Impl.ICUResourceBundle.TopLevelKeySet">
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleImpl.ResourceTable.FindString(System.String)">
            <summary>
            Returns a String if found, or null if not found or if the key item is not a string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleImpl.ResourceTable.#ctor(ICU4N.Impl.ICUResourceBundle.WholeBundle,System.Int32)">
            <summary>
            Constructor for the root table of a bundle.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceBundleReader">
            <summary>
            This class reads the *.res resource bundle format.
            <para/>
            For the file format documentation see ICU4C's source/common/uresdata.h file.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.DATA_FORMAT">
            <summary>
            File format version that this class understands.
            "ResB"
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_LENGTH">
            <summary>
            [0] contains the length of indexes[]
            which is at most URES_INDEX_TOP of the latest format version
            formatVersion==1: all bits contain the length of indexes[]
              but the length is much less than 0xff;
            formatVersion>1:
              only bits  7..0 contain the length of indexes[],
                   bits 31..8 are reserved and set to 0
            formatVersion>=3:
                   bits 31..8 poolStringIndexLimit bits 23..0
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_KEYS_TOP">
            <summary>
            [1] contains the top of the key strings,
                same as the bottom of resources or UTF-16 strings, rounded up
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_BUNDLE_TOP">
            <summary>
            [3] contains the top of the bundle,
                in case it were ever different from [2]
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_MAX_TABLE_LENGTH">
            <summary>[4] max. length of any table</summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_ATTRIBUTES">
            <summary>
            [5] attributes bit set, see URES_ATT_* (new in formatVersion 1.2)
            <para/>
            formatVersion>=3:
              bits 31..16 poolStringIndex16Limit
              bits 15..12 poolStringIndexLimit bits 27..24
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_16BIT_TOP">
            <summary>
            [6] top of the 16-bit units (UTF-16 string v2 UChars, URES_TABLE16, URES_ARRAY16),
                rounded up (new in formatVersion 2.0, ICU 4.4)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_INDEX_POOL_CHECKSUM">
            <summary>[7] checksum of the pool bundle (new in formatVersion 2.0, ICU 4.4)</summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_ATT_NO_FALLBACK">
            <summary>
            Nofallback attribute, attribute bit 0 in indexes[URES_INDEX_ATTRIBUTES].
            New in formatVersion 1.2 (ICU 3.6).
            <para/>
            If set, then this resource bundle is a standalone bundle.
            If not set, then the bundle participates in locale fallback, eventually
            all the way to the root bundle.
            If indexes[] is missing or too short, then the attribute cannot be determined
            reliably. Dependency checking should ignore such bundles, and loading should
            use fallbacks.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.URES_ATT_IS_POOL_BUNDLE">
            <summary>
            Attributes for bundles that are, or use, a pool bundle.
            A pool bundle provides key strings that are shared among several other bundles
            to reduce their total size.
            New in formatVersion 2 (ICU 4.4).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.LARGE_SIZE">
            <summary>
            Objects with more value bytes are stored in <see cref="T:ICU4N.Support.SoftReference`1"/>s.
            Smaller objects (which are not much larger than a <see cref="T:ICU4N.Support.SoftReference`1"/>)
            are stored directly, avoiding the overhead of the reference.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.bytes">
            <summary>
            Buffer of all of the resource bundle bytes after the header.
            (equivalent of C++ pRoot)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.ReaderCache.CreateInstance(ICU4N.Impl.ICUResourceBundleReader.ReaderCacheKey,System.Reflection.Assembly)">
            <seealso cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.#ctor">
            <summary>
            Default constructor, just used for <see cref="F:ICU4N.Impl.ICUResourceBundleReader.NULL_READER"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.RES_GET_INT(System.Int32)">
            <summary>get signed and unsigned integer values directly from the Resource handle</summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.GetStringV2(System.Int32)">
            <returns>A string from the local bundle's b16BitUnits at the local offset.</returns>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.IsNoInheritanceMarker(System.Int32)">
            <summary>
            CLDR string value ""=="\u2205\u2205\u2205" prevents fallback to the parent bundle.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.PUBLIC_TYPES">
            <summary>
            From C++ uresdata.c gPublicTypes[URES_LIMIT].
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceBundleReader.ResourceCache">
            <summary>
            Cache of some of one resource bundle's resources.
            Avoids creating multiple .NET objects for the same resource items,
            including multiple copies of their contents.
            </summary>
            <remarks>
            Mutable objects must not be cached and then returned to the caller
            because the cache must not be writable via the returned reference.
            <para/>
            Resources are mapped by their resource integers.
            Empty resources with offset 0 cannot be mapped.
            Integers need not and should not be cached.
            Multiple .res items may share resource offsets (genrb eliminates some duplicates).
            <para/>
            This cache uses int[] and Object[] arrays to minimize object creation
            and avoid auto-boxing.
            <para/>
            Large resource objects are usually stored in <see cref="T:ICU4N.Support.SoftReference`1"/>s.
            <para/>
            For few resources, a small table is used with binary search.
            When more resources are cached, then the data structure changes to be faster
            but also use more memory.
            </remarks>
        </member>
        <member name="F:ICU4N.Impl.ICUResourceBundleReader.ResourceCache.levelBitsList">
            <summary>
            Number of bits in each level, each stored in a nibble.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.ResourceCache.MakeKey(System.Int32)">
            <summary>
            Turns a resource integer (with unused bits in the middle)
            into a key with fewer bits (at most keyBits).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceBundleReader.GetFullName(System.String,System.String)">
            <summary>
            Gets the full name of the resource with suffix.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUResourceTableAccess">
            <summary>
            Static utility functions for probing resource tables, used by <see cref="T:ICU4N.Util.ULocale"/> and
            <see cref="T:ICU4N.Text.LocaleDisplayNames"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceTableAccess.GetTableString(System.String,ICU4N.Util.ULocale,System.String,System.String,System.String)">
            <summary>
            Utility to fetch locale display data from resource bundle tables.  Convenience
            wrapper for <see cref="M:ICU4N.Impl.ICUResourceTableAccess.GetTableString(ICU4N.Impl.ICUResourceBundle,System.String,System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUResourceTableAccess.GetTableString(ICU4N.Impl.ICUResourceBundle,System.String,System.String,System.String,System.String)">
            <summary>
            Utility to fetch locale display data from resource bundle tables.  Uses fallback
            through the "Fallback" resource if available.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICURWLock">
            <summary>
            A Reader/Writer lock originally written for ICU service
            implementation. The internal implementation was replaced
            with .NET's stock read write lock <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            for ICU 52.
            </summary>
            <remarks>
            This assumes that there will be little writing contention.
            It also doesn't allow active readers to acquire and release
            a write lock, or deal with priority inversion issues.
            <para/>
            Access to the lock should be enclosed in a try/finally block
            in order to ensure that the lock is always released in case of
            exceptions:
            <code>
            try
            {
                lock.AcquireRead();
                // use service protected by the lock
            }
            finally
            {
                lock.ReleaseRead();
            }
            </code>
            <para/>
            The lock provides utility methods <see cref="M:ICU4N.Impl.ICURWLock.GetStats"/> and <see cref="M:ICU4N.Impl.ICURWLock.ClearStats"/>
            to return statistics on the use of the lock.
            </remarks>
        </member>
        <member name="T:ICU4N.Impl.ICURWLock.Stats">
            <summary>
            Internal class used to gather statistics on the <see cref="T:ICU4N.Impl.ICURWLock"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICURWLock.Stats.ReadCount">
            <summary>
            Number of times read access granted (read count).
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICURWLock.Stats.MultipleReadCount">
            <summary>
            Number of times concurrent read access granted (multiple read count).
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICURWLock.Stats.WaitingReadCount">
            <summary>
            Number of times blocked for read (waiting reader count).
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICURWLock.Stats.WriterCount">
            <summary>
            Number of times write access granted (writer count).
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICURWLock.Stats.WaitingWriterCount">
            <summary>
            Number of times blocked for write (waiting writer count).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.Stats.ToString">
            <summary>
            Return a string listing all the stats.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.ResetStats">
            <summary>
            Reset the stats.  Returns existing stats, if any.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.ClearStats">
            <summary>
            Clear the stats (stop collecting stats).  Returns existing stats, if any.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.GetStats">
            <summary>
            Return a snapshot of the current stats.  This does not reset the stats.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.AcquireRead">
            <summary>
            Acquire a read lock, blocking until a read lock is
            available.  Multiple readers can concurrently hold the read
            lock.
            </summary>
            <remarks>
            If there's a writer, or a waiting writer, increment the
            waiting reader count and block on this.  Otherwise
            increment the active reader count and return.  Caller must call
            <see cref="M:ICU4N.Impl.ICURWLock.ReleaseRead"/> when done (for example, in a finally block).
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.ReleaseRead">
            <summary>
            Release a read lock and return.  An error will be thrown
            if a read lock is not currently held.
            </summary>
            <remarks>
            If this is the last active reader, notify the oldest
            waiting writer.  Call when finished with work
            controlled by <see cref="M:ICU4N.Impl.ICURWLock.AcquireRead"/>.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.AcquireWrite">
            <summary>
            Acquire the write lock, blocking until the write lock is
            available.  Only one writer can acquire the write lock, and
            when held, no readers can acquire the read lock.
            </summary>
            <remarks>
            If there are no readers and no waiting writers, mark as
            having an active writer and return.  Otherwise, add a lock to the
            end of the waiting writer list, and block on it.  Caller
            must call <see cref="M:ICU4N.Impl.ICURWLock.ReleaseWrite"/> when done (for example, in a finally
            block).
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICURWLock.ReleaseWrite">
            <summary>
            Release the write lock and return.  An error will be thrown
            if the write lock is not currently held.
            </summary>
            <remarks>
            If there are waiting readers, make them all active and
            notify all of them.  Otherwise, notify the oldest waiting
            writer, if any.  Call when finished with work controlled by
            <see cref="M:ICU4N.Impl.ICURWLock.AcquireWrite"/>.
            </remarks>
        </member>
        <member name="T:ICU4N.Impl.ICUService">
            <summary>
            An <see cref="T:ICU4N.Impl.ICUService"/> provides access to service objects that implement a
            particular service, e.g. transliterators.  Users provide a String
            id (for example, a locale string) to the service, and get back an
            object for that id.  
            </summary>
            <remarks>
            <see cref="T:ICU4N.Impl.ICUService"/> objects can be any kind of object.
            The service object is cached and returned for later queries, so
            generally it should not be mutable, or the caller should clone the
            object before modifying it.
            <para/>
            <see cref="T:ICU4N.Impl.ICUService"/>s 'canonicalize' the query id and use the canonical id to
            query for the service.  The service also defines a mechanism to
            'fallback' the id multiple times.  Clients can optionally request
            the actual id that was matched by a query when they use an id to
            retrieve a service object.
            <para/>
            <see cref="T:ICU4N.Impl.ICUService"/> objects are instantiated by <see cref="T:ICU4N.Impl.ICUService.IFactory"/> objects registered with
            the service.  The service queries each <see cref="T:ICU4N.Impl.ICUService.IFactory"/> in turn, from most recently
            registered to earliest registered, until one returns a service object.
            If none responds with a service object, a fallback id is generated,
            and the process repeats until a service object is returned or until
            the id has no further fallbacks.
            <para/>
            Factories can be dynamically registered and unregistered with the
            service.  When registered, a <see cref="T:ICU4N.Impl.ICUService.IFactory"/> is installed at the head of
            the factory list, and so gets 'first crack' at any keys or fallback
            keys.  When unregistered, it is removed from the service and can no
            longer be located through it.  Service objects generated by this
            factory and held by the client are unaffected.
            <para/>
            <see cref="T:ICU4N.Impl.ICUService"/> uses <see cref="T:ICU4N.Impl.ICUService.Key"/>s to query factories and perform
            fallback.  The <see cref="T:ICU4N.Impl.ICUService.Key"/> defines the canonical form of the id, and
            implements the fallback strategy.  Custom <see cref="T:ICU4N.Impl.ICUService.Key"/>s can be defined that
            parse complex IDs into components that <see cref="T:ICU4N.Impl.ICUService.IFactory"/>s can more easily
            use.  The <see cref="T:ICU4N.Impl.ICUService.Key"/> can cache the results of this parsing to save
            repeated effort.  <see cref="T:ICU4N.Impl.ICUService"/> provides convenience APIs that
            take Strings and generate default <see cref="T:ICU4N.Impl.ICUService.Key"/>s for use in querying.
            <para/>
            <see cref="T:ICU4N.Impl.ICUService"/> provides API to get the list of ids publicly
            supported by the service (although queries aren't restricted to
            this list).  This list contains only 'simple' IDs, and not fully
            unique ids.  Factories are associated with each simple ID and
            the responsible factory can also return a human-readable localized
            version of the simple ID, for use in user interfaces.  <see cref="T:ICU4N.Impl.ICUService"/>
            can also provide a sorted collection of the all the localized visible
            ids.
            <para/>
            <see cref="T:ICU4N.Impl.ICUService"/> implements <see cref="T:ICU4N.Impl.ICUNotifier"/>, so that clients can register
            to receive notification when factories are added or removed from
            the service.  ICUService provides a default <see cref="T:ICU4N.Impl.IEventListener"/> subinterface,
            <see cref="T:ICU4N.Impl.ICUService.IServiceListener"/>, which can be registered with the service.  When
            the service changes, the <see cref="M:ICU4N.Impl.ICUService.IServiceListener.ServiceChanged(ICU4N.Impl.ICUService)"/> method
            is called, with the service as the only argument.
            <para/>
            The <see cref="T:ICU4N.Impl.ICUService"/> API is both rich and generic, and it is expected
            that most implementations will statically 'wrap' <see cref="T:ICU4N.Impl.ICUService"/> to
            present a more appropriate API-- for example, to declare the type
            of the objects returned from get, to limit the factories that can
            be registered with the service, or to define their own listener
            interface with a custom callback method.  They might also customize
            <see cref="T:ICU4N.Impl.ICUService"/> by overriding it, for example, to customize the <see cref="T:ICU4N.Impl.ICUService.Key"/> and
            fallback strategy.  <see cref="T:ICU4N.Impl.ICULocaleService"/> is a customized service that
            uses Locale names as ids and uses Keys that implement the standard
            resource bundle fallback strategy.
            </remarks>
        </member>
        <member name="F:ICU4N.Impl.ICUService.name">
            <summary>
            Name used for debugging.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.#ctor(System.String)">
            <summary>
            Construct with a <paramref name="name"/> (useful for debugging).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUService.factoryLock">
            <summary>
            Access to factories is protected by a read-write lock.  This is
            to allow multiple threads to read concurrently, but keep
            changes to the factory list atomic with respect to all readers.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUService.factories">
            <summary>
            All the factories registered with this service.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ICUService.defaultSize">
            <summary>
            Record the default number of factories for this service.
            Can be set by <see cref="M:ICU4N.Impl.ICUService.MarkDefault"/>.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUService.Key">
            <summary>
            Keys are used to communicate with factories to generate an
            instance of the service.  Keys define how ids are
            canonicalized, provide both a current id and a current
            descriptor to use in querying the cache and factories, and
            determine the fallback strategy.
            </summary>
            <remarks>
            Keys provide both a <see cref="M:ICU4N.Impl.ICUService.Key.GetCurrentDescriptor"/> and a <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/>.
            The descriptor contains an optional prefix, followed by '/'
            and the <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/>.  Factories that handle complex keys,
            for example number format factories that generate multiple
            kinds of formatters for the same locale, use the descriptor
            to provide a fully unique identifier for the service object,
            while using the <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/> (in this case, the locale string),
            as the visible IDs that can be localized.
            <para/>
            The default implementation of <see cref="T:ICU4N.Impl.ICUService.Key"/> has no fallbacks and
            has no custom descriptors.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Key.#ctor(System.String)">
            <summary>
            Construct a key from an <paramref name="id"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUService.Key.ID">
            <summary>
            Return the original ID used to construct this key.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUService.Key.CanonicalID">
            <summary>
            Return the canonical version of the original ID.  This implementation
            returns the original ID unchanged.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUService.Key.CurrentID">
            <summary>
            Return the (canonical) current ID.  This implementation
            returns the canonical ID.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Key.GetCurrentDescriptor">
            <summary>
            Return the current descriptor.  This implementation returns
            the current ID.  The current descriptor is used to fully
            identify an instance of the service in the cache.  A
            factory may handle all descriptors for an ID, or just a
            particular descriptor.  The factory can either parse the
            descriptor or use custom API on the key in order to
            instantiate the service.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Key.Fallback">
            <summary>
            If the key has a fallback, modify the key and return true,
            otherwise return false.  The current ID will change if there
            is a fallback.  No <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/>s should be repeated, and fallback
            must eventually return false.  This implmentation has no fallbacks
            and always returns false.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Key.IsFallbackOf(System.String)">
            <summary>
            If a key created from <paramref name="idToCheck"/> would eventually fallback to match the
            <see cref="P:ICU4N.Impl.ICUService.Key.CanonicalID"/> of this key, return true.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUService.IFactory">
            <summary>
            Factories generate the service objects maintained by the
            service.  A factory generates a service object from a key,
            updates id->factory mappings, and returns the display name for
            a supported id.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.IFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)">
            <summary>
            Create a service object from the <paramref name="key"/>, if this factory
            supports the <paramref name="key"/>.  Otherwise, return null.
            </summary>
            <remarks>
            If the factory supports the key, then it can call
            the service's <see cref="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key,System.String[],ICU4N.Impl.ICUService.IFactory)"/> method
            passing itself as the factory to get the object that
            the service would have created prior to the factory's
            registration with the service.  This can change the
            key, so any information required from the key should
            be extracted before making such a callback.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICUService.IFactory.UpdateVisibleIDs(System.Collections.Generic.IDictionary{System.String,ICU4N.Impl.ICUService.IFactory})">
            <summary>
            Update the result IDs (not descriptors) to reflect the IDs
            this factory handles.  This function and <see cref="M:ICU4N.Impl.ICUService.IFactory.GetDisplayName(System.String,ICU4N.Util.ULocale)"/> are
            used to support <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/>.  Basically, the
            factory has to determine which IDs it will permit to be
            available, and of those, which it will provide localized
            display names for.  In most cases this reflects the IDs that
            the factory directly supports.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.IFactory.GetDisplayName(System.String,ICU4N.Util.ULocale)">
            <summary>
            Return the display name for this id in the provided locale.
            This is an localized id, not a descriptor.  If the id is
            not visible or not defined by the factory, return null.
            If locale is null, return id unchanged.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUService.SimpleFactory">
            <summary>
            A default implementation of factory.  This provides default
            implementations for subclasses, and implements a singleton
            factory that matches a single id  and returns a single
            (possibly deferred-initialized) instance.  This implements
            <see cref="M:ICU4N.Impl.ICUService.SimpleFactory.UpdateVisibleIDs(System.Collections.Generic.IDictionary{System.String,ICU4N.Impl.ICUService.IFactory})"/> to add a mapping from its ID to itself
            if visible is true, or to remove any existing mapping
            for its ID if visible is false.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.#ctor(System.Object,System.String)">
            <summary>
            Convenience constructor that calls <see cref="M:ICU4N.Impl.ICUService.SimpleFactory.#ctor(System.Object,System.String,System.Boolean)"/>
            with visible true.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.#ctor(System.Object,System.String,System.Boolean)">
            <summary>
            Construct a simple factory that maps a single id to a single
            service instance.  If visible is true, the id will be visible.
            Neither the instance nor the id can be null.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.Create(ICU4N.Impl.ICUService.Key,ICU4N.Impl.ICUService)">
            <summary>
            Return the service instance if the factory's id is equal to
            the <paramref name="key"/>'s <see cref="P:ICU4N.Impl.ICUService.Key.CurrentID"/>.  
            <paramref name="service"/> is ignored.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.UpdateVisibleIDs(System.Collections.Generic.IDictionary{System.String,ICU4N.Impl.ICUService.IFactory})">
            <summary>
            If visible, adds a mapping from id -> this to the <paramref name="result"/>,
            otherwise removes id from <paramref name="result"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.GetDisplayName(System.String,ICU4N.Util.ULocale)">
            <summary>
            If <see cref="F:ICU4N.Impl.ICUService.SimpleFactory.id"/> equals <paramref name="identifier"/>, 
            returns <paramref name="identifier"/> regardless of locale,
            otherwise returns null.  (This default implementation has
            no localized id information.)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.SimpleFactory.ToString">
            <summary>
            For debugging.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Get(System.String)">
            <summary>
            Convenience override for <see cref="M:ICU4N.Impl.ICUService.Get(System.String,System.String[])"/>. This uses
            <see cref="M:ICU4N.Impl.ICUService.CreateKey(System.String)"/> to create a key for the provided <paramref name="descriptor"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Get(System.String,System.String[])">
            <summary>
            Convenience override for <see cref="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key,System.String[])"/>.  This uses
            <see cref="M:ICU4N.Impl.ICUService.CreateKey(System.String)"/> to create a key from the provided <paramref name="descriptor"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key)">
            <summary>
            Convenience override for <see cref="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key,System.String[])"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetKey(ICU4N.Impl.ICUService.Key,System.String[])">
            <summary>
            Given a <paramref name="key"/>, return a service object, and, if <paramref name="actualReturn"/>
            is not null, the descriptor with which it was found in the
            first element of <paramref name="actualReturn"/>.  If no service object matches
            this key, return null, and leave <paramref name="actualReturn"/> unchanged.
            </summary>
            <remarks>
            This queries the cache using the <paramref name="key"/>'s descriptor, and if no
            object in the cache matches it, tries the <paramref name="key"/> on each
            registered factory, in order.  If none generates a service
            object for the key, repeats the process with each fallback of
            the <paramref name="key"/>, until either one returns a service object, or the <paramref name="key"/>
            has no fallback.
            <para/>
            If <paramref name="key"/> is null, just returns null.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.ICUService.HandleDefault(ICU4N.Impl.ICUService.Key,System.String[])">
            <summary>
            Default handler for this service if no factory in the list
            handled the <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetVisibleIDs">
            <summary>
            Convenience override for <see cref="M:ICU4N.Impl.ICUService.GetVisibleIDs(System.String)"/> that passes null
            as the fallback, thus returning all visible IDs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetVisibleIDs(System.String)">
            <summary>
            Return a snapshot of the visible IDs for this service.  This
            set will not change as Factories are added or removed, but the
            supported ids will, so there is no guarantee that all and only
            the ids in the returned set are visible and supported by the
            service in subsequent calls.
            <para/>
            <paramref name="matchID"/> is passed to <see cref="M:ICU4N.Impl.ICUService.CreateKey(System.String)"/> to create a key.  If the
            key is not null, it is used to filter out ids that don't have
            the key as a fallback.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetVisibleIDMap">
            <summary>
            Return a map from visible ids to factories.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayName(System.String)">
            <summary>
            Convenience override for <see cref="M:ICU4N.Impl.ICUService.GetDisplayName(System.String,ICU4N.Util.ULocale)"/> that
            uses the current default locale.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayName(System.String,ICU4N.Util.ULocale)">
            <summary>
            Given a visible <paramref name="id"/>, return the display name in the requested <paramref name="locale"/>.
            If there is no directly supported id corresponding to this id, return
            null.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames">
            <summary>
            Convenience override of <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/> that
            uses the current default Locale as the locale, null as
            the comparer, and null for the matchID.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale)">
            <summary>
            Convenience override of <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/> that
            uses null for the comparer, and null for the matchID.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Globalization.CompareInfo)">
            <summary>
            Convenience override of <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/> that
            uses null for the matchID, thus returning all display names.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String})">
            <summary>
            Convenience override of <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/> that
            uses null for the matchID, thus returning all display names.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.String)">
            <summary>
            Convenience override of <see cref="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)"/> that
            uses null for the comparator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Globalization.CompareInfo,System.String)">
            <summary>
            Return a snapshot of the mapping from display names to visible
            IDs for this service.  This set will not change as factories
            are added or removed, but the supported ids will, so there is
            no guarantee that all and only the ids in the returned map will
            be visible and supported by the service in subsequent calls,
            nor is there any guarantee that the current display names match
            those in the set.  The display names are sorted based on the
            comparer provided.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.GetDisplayNames(ICU4N.Util.ULocale,System.Collections.Generic.IComparer{System.String},System.String)">
            <summary>
            Return a snapshot of the mapping from display names to visible
            IDs for this service.  This set will not change as factories
            are added or removed, but the supported ids will, so there is
            no guarantee that all and only the ids in the returned map will
            be visible and supported by the service in subsequent calls,
            nor is there any guarantee that the current display names match
            those in the set.  The display names are sorted based on the
            comparer provided.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Factories">
            <summary>
            Return a snapshot of the currently registered factories.  There
            is no guarantee that the list will still match the current
            factory list of the service subsequent to this call.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.RegisterObject(System.Object,System.String)">
            <summary>
            A convenience override of <see cref="M:ICU4N.Impl.ICUService.RegisterObject(System.Object,System.String,System.Boolean)"/>
            that defaults visible to true.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.RegisterObject(System.Object,System.String,System.Boolean)">
            <summary>
            Register an object with the provided <paramref name="id"/>.  The <paramref name="id"/> will be
            canonicalized.  The canonicalized ID will be returned by
            <see cref="M:ICU4N.Impl.ICUService.GetVisibleIDs"/> if visible is true.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.RegisterFactory(ICU4N.Impl.ICUService.IFactory)">
            <summary>
            Register a <see cref="T:ICU4N.Impl.ICUService.IFactory"/>.  Returns the factory if the service accepts
            the factory, otherwise returns null.  The default implementation
            accepts all factories.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.UnregisterFactory(ICU4N.Impl.ICUService.IFactory)">
            <summary>
            Unregister a <see cref="T:ICU4N.Impl.ICUService.IFactory"/>.  The first matching registered factory will
            be removed from the list.  Returns true if a matching factory was
            removed.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Reset">
            <summary>
            Reset the service to the default factories.  The factory
            lock is acquired and then <see cref="M:ICU4N.Impl.ICUService.ReInitializeFactories"/> is called.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.ReInitializeFactories">
            <summary>
            Reinitialize the factory list to its default state.  By default
            this clears the list.  Subclasses can override to provide other
            default initialization of the factory list.  Subclasses must
            not call this method directly, as it must only be called while
            holding write access to the factory list.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUService.IsDefault">
            <summary>
            Return true if the service is in its default state.  The default
            implementation returns true if there are no factories registered.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.MarkDefault">
            <summary>
            Set the default size to the current number of registered factories.
            Used by subclasses to customize the behavior of <see cref="P:ICU4N.Impl.ICUService.IsDefault"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.CreateKey(System.String)">
            <summary>
            Create a key from an id.  This creates a <see cref="T:ICU4N.Impl.ICUService.Key"/> instance.
            Subclasses can override to define more useful keys appropriate
            to the factories they accept.  If id is null, returns null.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.ClearCaches">
            <summary>
            Clear caches maintained by this service.  Subclasses can
            override if they implement additional that need to be cleared
            when the service changes. Subclasses should generally not call
            this method directly, as it must only be called while
            synchronized on this.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.ClearServiceCache">
            <summary>
            Clears only the service cache.
            This can be called by subclasses when a change affects the service
            cache but not the id caches, e.g., when the default locale changes
            the resolution of ids changes, but not the visible ids themselves.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ICUService.IServiceListener">
            <summary>
            <see cref="T:ICU4N.Impl.ICUService.IServiceListener"/> is the listener that <see cref="T:ICU4N.Impl.ICUService"/> provides by default.
            <see cref="T:ICU4N.Impl.ICUService"/> will notifiy this listener when factories are added to
            or removed from the service.  Subclasses can provide
            different listener interfaces that extend <see cref="T:ICU4N.Impl.IEventListener"/>, and modify
            <see cref="M:ICU4N.Impl.ICUService.AcceptsListener(ICU4N.Impl.IEventListener)"/> and <see cref="M:ICU4N.Impl.ICUService.NotifyListener(ICU4N.Impl.IEventListener)"/> as appropriate.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.AcceptsListener(ICU4N.Impl.IEventListener)">
            <summary>
            Return true if the listener is accepted; by default this
            requires a <see cref="T:ICU4N.Impl.ICUService.IServiceListener"/>.  Subclasses can override to accept
            different listeners.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.NotifyListener(ICU4N.Impl.IEventListener)">
            <summary>
            Notify the listener, which by default is a <see cref="T:ICU4N.Impl.ICUService.IServiceListener"/>.
            Subclasses can override to use a different listener.
            </summary>
            <param name="l"></param>
        </member>
        <member name="M:ICU4N.Impl.ICUService.Stats">
            <summary>
            When the statistics for this service is already enabled,
            return the log and resets he statistics.
            When the statistics is not enabled, this method enable
            the statistics. Used for debugging purposes.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ICUService.Name">
            <summary>
            Return the name of this service. This will be the empty string if none was assigned.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.ICUService.ToString">
            <summary>
            Returns the result of <c>base.ToString()</c>, appending the name in curly braces.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ICU4N.Impl.IDNA2003Options">
            <summary>
            Options for <see cref="T:ICU4N.Impl.IDNA2003"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.IDNA2003Options.Default">
            <summary>
            Default options value: None of the other options are set.
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned">
            <summary>
            Option to allow unassigned code points in domain names and labels.
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules">
            <summary>
            Option to check whether the input conforms to the STD3 ASCII rules,
            for example the restriction of labels to LDH characters
            (ASCII Letters, Digits and Hyphen-Minus).
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Impl.IDNA2003">
            <summary>
            IDNA2003 implementation code, moved out of <see cref="T:ICU4N.Text.IDNA"/>
            while extending that class to support IDNA2008/UTS #46 as well.
            </summary>
            <author>Ram Viswanadha</author>
        </member>
        <member name="M:ICU4N.Impl.IDNA2003.IsLabelSeparator(System.Int32)">
            Ascertain if the given code point is a label separator as 
            defined by the IDNA RFC
            
            @param ch The code point to be ascertained
            @return true if the char is a label separator
            @stable ICU 2.8
        </member>
        <member name="T:ICU4N.Impl.Int32Trie">
            <summary>
            Trie implementation which stores data in int, 32 bits.
            </summary>
            <seealso cref="T:ICU4N.Impl.Trie"/>
            <author>synwee</author>
            <since>release 2.1, Jan 01 2002</since>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.#ctor(ICU4N.Support.IO.ByteBuffer,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Creates a new Trie with the settings for the trie data.
            <para/>
            Unserialize the 32-bit-aligned input stream and use the data for the trie.
            </summary>
            <param name="bytes">File buffer to a ICU data file, containing the trie.</param>
            <param name="dataManipulate"><see cref="T:ICU4N.Impl.Trie.IDataManipulate"/> object which provides methods to parse the char data.</param>
            <exception cref="T:System.IO.IOException">Thrown when data reading fails.</exception>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.#ctor(System.Int32,System.Int32,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Make a dummy <see cref="T:ICU4N.Impl.Int32Trie"/>.
            </summary>
            <remarks>
            A dummy trie is an empty runtime trie, used when a real data trie cannot
            be loaded.
            <para/>
            The trie always returns the <paramref name="initialValue"/>,
            or the <paramref name="leadUnitValue"/> for lead surrogate code points.
            The Latin-1 part is always set up to be linear.
            </remarks>
            <param name="initialValue">The initial value that is set for all code points.</param>
            <param name="leadUnitValue">The value for lead surrogate code _units_ that do not
            have associated supplementary data.</param>
            <param name="dataManipulate"><see cref="T:ICU4N.Impl.Trie.IDataManipulate"/> object which provides methods to parse the char data.</param>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetCodePointValue(System.Int32)">
            <summary>
            Gets the value associated with the codepoint.
            If no value is associated with the codepoint, a default value will be
            returned.
            </summary>
            <param name="ch">Codepoint.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetLeadValue(System.Char)">
            <summary>
            Gets the value to the data which this lead surrogate character points
            to. Returned data may contain folding offset information for the next
            trailing surrogate character.
            This method does not guarantee correct results for trail surrogates.
            </summary>
            <param name="ch">Lead surrogate character.</param>
            <returns>Data value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetBMPValue(System.Char)">
            <summary>
            Get the value associated with the BMP code point.
            Lead surrogate code points are treated as normal code points, with
            unfolded values that may differ from <see cref="M:ICU4N.Impl.Int32Trie.GetLeadValue(System.Char)"/> results.
            </summary>
            <param name="ch">The input BMP code point.</param>
            <returns>Trie data value associated with the BMP codepoint.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetSurrogateValue(System.Char,System.Char)">
            <summary>
            Get the value associated with a pair of surrogates.
            </summary>
            <param name="lead">A lead surrogate.</param>
            <param name="trail">A trail surrogate.</param>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetTrailValue(System.Int32,System.Char)">
            <summary>
            Get a value from a folding offset (from the value of a lead surrogate)
            and a trail surrogate.
            </summary>
            <param name="leadvalue">The value of a lead surrogate that contains the folding offset.</param>
            <param name="trail">Trail surrogate.</param>
            <returns>Trie data value associated with the trail character.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetLatin1LinearValue(System.Char)">
            <summary>
            Gets the latin 1 fast path value.
            <para/>
            Note this only works if latin 1 characters have their own linear array.
            </summary>
            <param name="ch">Latin 1 characters.</param>
            <returns>Value associated with latin character.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.Equals(System.Object)">
            CLOVER:OFF
             <summary>
             Checks if the argument <see cref="T:ICU4N.Impl.Trie"/> has the same data as this <see cref="T:ICU4N.Impl.Trie"/>.
             </summary>
             <param name="other">Other Trie to check.</param>
             <returns>true if the argument Trie has the same data as this Trie, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.Unserialize(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Parses the input stream and stores its trie content into a index and
            data array
            </summary>
            <param name="bytes">Data buffer containing trie data.</param>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.GetSurrogateOffset(System.Char,System.Char)">
            <summary>
            Gets the offset to the data which the surrogate pair points to.
            </summary>
            <param name="lead">Lead surrogate.</param>
            <param name="trail">Trailing surrogate.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="P:ICU4N.Impl.Int32Trie.Item(System.Int32)">
            <summary>
            Gets the value at the argument index.
            For use internally in <see cref="T:ICU4N.Impl.TrieEnumerator"/>
            </summary>
            <param name="index">Value at index will be retrieved.</param>
            <returns>32 bit value</returns>
            <seealso cref="T:ICU4N.Impl.TrieEnumerator"/>
        </member>
        <member name="P:ICU4N.Impl.Int32Trie.InitialValue">
            <summary>
            Gets the default initial 32 bit value.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Int32Trie.#ctor(System.Char[],System.Int32[],System.Int32,System.Int32,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Internal constructor for builder use.
            </summary>
            <param name="index">The index array to be slotted into this trie.</param>
            <param name="data">The data array to be slotted into this trie.</param>
            <param name="initialvalue">The initial value for this trie.</param>
            <param name="options">Trie options to use.</param>
            <param name="datamanipulate">Folding implementation.</param>
        </member>
        <member name="F:ICU4N.Impl.Int32Trie.m_initialValue_">
            <summary>
            Default value
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Int32Trie.m_data_">
            <summary>
            Array of char data
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Int32TrieBuilder">
            <summary>
            Builder class to manipulate and generate a trie.
            </summary>
            <remarks>
            This is useful for ICU data in primitive types.
            Provides a compact way to store information that is indexed by Unicode 
            values, such as character properties, types, keyboard values, etc. This is 
            very useful when you have a block of Unicode data that contains significant 
            values while the rest of the Unicode data is unused in the application or 
            when you have a lot of redundance, such as where all 21,000 Han ideographs 
            have the same value.  However, lookup is much faster than a hash table.
            A trie of any primitive data type serves two purposes:
            <list type="bullet">
                <item><description>Fast access of the indexed values.</description></item>
                <item><description>Smaller memory footprint.</description></item>
            </list>
            This is a direct port from the ICU4C version
            </remarks>
            <author>Syn Wee Quek</author>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.#ctor(ICU4N.Impl.Int32TrieBuilder)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.#ctor(System.Int32[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Constructs a build table.
            </summary>
            <param name="aliasdata">Data to be filled into table.</param>
            <param name="maxdatalength">Maximum data length allowed in table.</param>
            <param name="initialvalue">Inital data value.</param>
            <param name="leadunitvalue"></param>
            <param name="latin1linear">Is latin 1 to be linear.</param>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.GetValue(System.Int32)">
            <summary>
            Gets a 32 bit data from the table data.
            </summary>
            <param name="ch">Codepoint which data is to be retrieved.</param>
            <returns>The 32 bit data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.GetValue(System.Int32,System.Boolean[])">
            <summary>
            Get a 32 bit data from the table data.
            </summary>
            <param name="ch">Code point for which data is to be retrieved.</param>
            <param name="inBlockZero">Output parameter, inBlockZero[0] returns true if the
            char maps into block zero, otherwise false.</param>
            <returns>The 32 bit data value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.SetValue(System.Int32,System.Int32)">
            <summary>
            Sets a 32 bit data in the table data.
            </summary>
            <param name="ch">Codepoint which data is to be set.</param>
            <param name="value">Value to set.</param>
            <returns>true if the set is successful, otherwise
            if the table has been compacted return false</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.Serialize(ICU4N.Impl.TrieBuilder.IDataManipulate,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Serializes the build table with 32 bit data.
            </summary>
            <param name="datamanipulate">Builder raw fold method implementation.</param>
            <param name="triedatamanipulate">Result trie fold method.</param>
            <returns>A new trie.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.Serialize(System.IO.Stream,System.Boolean,ICU4N.Impl.TrieBuilder.IDataManipulate)">
            <summary>
            Serializes the build table to an output stream.
            <para/>
            Compacts the build-time trie after all values are set, and then
            writes the serialized form onto an output stream.
            <para/>
            After this, this build-time Trie can only be serialized again and/or closed;
            no further values can be added.
            <para/>
            This function is the rough equivalent of utrie_seriaize() in ICU4C.
            </summary>
            <param name="os">The output stream to which the seriaized trie will be written.
            If nul, the function still returns the size of the serialized Trie.</param>
            <param name="reduceTo16Bits">If true, reduce the data size to 16 bits.  The resulting
            serialized form can then be used to create a <see cref="T:ICU4N.Impl.CharTrie"/>.</param>
            <param name="datamanipulate">Builder raw fold method implementation.</param>
            <returns>The number of bytes written to the output stream.</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.SetRange(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Set a value in a range of code points [start..limit].
            All code points c with start &lt;= c &lt; limit will get the value if
            overwrite is true or if the old value is 0.
            </summary>
            <param name="start">The first code point to get the value.</param>
            <param name="limit">One past the last code point to get the value.</param>
            <param name="value">The value.</param>
            <param name="overwrite">Flag for whether old non-initial values are to be overwritten.</param>
            <returns>false if a failure occurred (illegal argument or data array overrun).</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.GetDataBlock(System.Int32)">
            <summary>
            No error checking for illegal arguments.
            </summary>
            <param name="ch">codepoint to look for</param>
            <returns>-1 if no new data block available (out of memory in data array).</returns>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.Compact(System.Boolean)">
            <summary>
            Compact a folded build-time trie.
            The compaction
            <list type="bullet">
                <item><description>removes blocks that are identical with earlier ones</description></item>
                <item><description>overlaps adjacent blocks as much as possible (if overlap == true)</description></item>
                <item><description>moves blocks in steps of the data granularity</description></item>
                <item><description>moves and overlaps blocks that overlap with multiple values in the overlap region</description></item>
            </list>
            It does not
            <list type="bullet">
                <item><description>try to move and overlap blocks that are not already adjacent</description></item>
            </list>
            </summary>
            <param name="overlap">flag</param>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.FindSameDataBlock(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the same data block.
            </summary>
            <param name="data">array</param>
            <param name="dataLength"></param>
            <param name="otherBlock"></param>
            <param name="step"></param>
        </member>
        <member name="M:ICU4N.Impl.Int32TrieBuilder.Fold(ICU4N.Impl.TrieBuilder.IDataManipulate)">
            <summary>
            Fold the normalization data for supplementary code points into
            a compact area on top of the BMP-part of the trie index,
            with the lead surrogates indexing this compact area.
            <para/>
            Duplicate the index values for lead surrogates:
            From inside the BMP area, where some may be overridden with folded values,
            to just after the BMP area, where they can be retrieved for
            code point lookups.
            </summary>
            <param name="manipulate">Fold implementation.</param>
        </member>
        <member name="T:ICU4N.Impl.LocaleDisplayNamesImpl.CapitalizationContextUsage">
            <summary>
            Capitalization context usage types for locale display names
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleDisplayNamesImpl.capitalizationUsage">
            <summary>
            Capitalization transforms. For each usage type, indicates whether to titlecase for
            the context specified in capitalization (which we know at construction time).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleDisplayNamesImpl.contextUsageTypeMap">
            <summary>
            Map from resource key to <see cref="T:ICU4N.Impl.LocaleDisplayNamesImpl.CapitalizationContextUsage"/> value
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleDisplayNamesImpl.capitalizationBrkIter">
            <summary>
            <see cref="T:ICU4N.Text.BreakIterator"/> to use for capitalization
            </summary>
        </member>
        <member name="T:ICU4N.Impl.LocaleIDParser">
            <summary>
            Utility class to parse and normalize locale ids (including POSIX style)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleIDParser.id">
            <summary>
            Char array representing the locale ID.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleIDParser.index">
            <summary>
            Current position in <see cref="F:ICU4N.Impl.LocaleIDParser.id"/> (while parsing).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleIDParser.buffer">
            <summary>
            Temporary buffer for parsed sections of data.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleIDParser.KEYWORD_SEPARATOR">
            <summary>
            Parsing constants.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.Append(System.Char)">
            <summary>
            Append <paramref name="c"/> to the buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetString(System.Int32)">
            <summary>
            Returns the text in the buffer from start to blen as a string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.Set(System.Int32,System.String)">
            <summary>
            Set the length of the buffer to pos, then append the string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.Append(System.String)">
            <summary>
            Append the string to the buffer.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.LocaleIDParser.DONE">
            <summary>
            Character to indicate no more text is available in the id.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.Next">
            <summary>
            Returns the character at index in the id, and advance index.  The returned character
            is <see cref="F:ICU4N.Impl.LocaleIDParser.DONE"/> if index was at the limit of the buffer.  The index is advanced regardless
            so that decrementing the index will always 'unget' the last character returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SkipUntilTerminatorOrIDSeparator">
            <summary>
            Advance index until the next terminator or id separator, and leave it there.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.AtTerminator">
            <summary>
            Returns true if the character at index in the id is a terminator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.IsTerminator(System.Char)">
            <summary>
            Returns true if the character is a terminator (keyword separator, dot, or DONE).
            Dot is a terminator because of the POSIX form, where dot precedes the codepage.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.IsTerminatorOrIDSeparator(System.Char)">
            <summary>
            Returns true if the character is a terminator or id separator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.HaveExperimentalLanguagePrefix">
            <summary>
            Returns true if the start of the buffer has an experimental or private language
            prefix, the pattern '[ixIX][-_].' shows the syntax checked.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.HaveKeywordAssign">
            <summary>
            Returns true if a value separator occurs at or after index.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.ParseLanguage">
            <summary>
            Advance index past language, and accumulate normalized language code in buffer.
            Index must be at 0 when this is called.  Index is left at a terminator or id
            separator.  Returns the start of the language code in the buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SkipLanguage">
            <summary>
            Advance index past language.  Index must be at 0 when this is called.  Index
            is left at a terminator or id separator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.ParseScript">
            <summary>
            Advance index past script, and accumulate normalized script in buffer.
            Index must be immediately after the language.
            If the item at this position is not a script (is not four characters
            long) leave index and buffer unchanged.  Otherwise index is left at
            a terminator or id separator.  Returns the start of the script code
            in the buffer (this may be equal to the buffer length, if there is no
            script).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SkipScript">
            <summary>
            Advance index past script.
            Index must be immediately after the language and IDSeparator.
            If the item at this position is not a script (is not four characters
            long) leave index.  Otherwise index is left at a terminator or
            id separator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.ParseCountry">
            <summary>
            Advance index past country, and accumulate normalized country in buffer.
            Index must be immediately after the script (if there is one, else language)
            and IDSeparator.  Return the start of the country code in the buffer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SkipCountry">
            <summary>
            Advance index past country.
            Index must be immediately after the script (if there is one, else language)
            and IDSeparator.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.ParseVariant">
            <summary>
            Advance index past variant, and accumulate normalized variant in buffer.  This ignores
            the codepage information from POSIX ids.  Index must be immediately after the country
            or script.  Index is left at the keyword separator or at the end of the text.  Return
            the start of the variant code in the buffer.
            </summary>
            <remarks>
            In standard form, we can have the following forms:
            <list type="bullet">
                <item><description>ll__VVVV</description></item>
                <item><description>ll_CC_VVVV</description></item>
                <item><description>ll_Ssss_VVVV</description></item>
                <item><description>ll_Ssss_CC_VVVV</description></item>
            </list>
            <para/>
            This also handles POSIX ids, which can have the following forms (pppp is code page id):
            <list type="bullet">
                <item><description>ll_CC.pppp          --> ll_CC</description></item>
                <item><description>ll_CC.pppp@VVVV     --> ll_CC_VVVV</description></item>
                <item><description>ll_CC@VVVV          --> ll_CC_VVVV</description></item>
            </list>
            <para/>
            We identify this use of '@' in POSIX ids by looking for an '=' following
            the '@'.  If there is one, we consider '@' to start a keyword list, instead of
            being part of a POSIX id.
            <para/>
            Note:  since it was decided that we want an option to not handle POSIX ids, this
            becomes a bit more complex.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetLanguage">
            <summary>
            Returns the normalized language id, or the empty string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetScript">
            <summary>
            Returns the normalized script id, or the empty string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetCountry">
            <summary>
            Returns the normalized country id, or the empty string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetVariant">
            <summary>
            Returns the normalized variant id, or the empty string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetLanguageScriptCountryVariant">
            <summary>
            Returns the language, script, country, and variant as separate strings.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetBaseName">
            <summary>
            Returns the normalized base form of the locale id.  The base
            form does not include keywords.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetName">
            <summary>
            Returns the normalized full form of the locale id.  The full
            form includes keywords if they are present.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SetToKeywordStart">
            <summary>
            If we have keywords, advance index to the start of the keywords and return true,
            otherwise return false.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetKeywordMap">
            <summary>
            Returns a map of the keywords and values, or null if there are none.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.ParseKeywords">
            <summary>
            Parse the keywords and return start of the string in the buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetKeywords">
            <summary>
            Returns an iterator over the keywords, or null if we have an empty map.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.GetKeywordValue(System.String)">
            <summary>
            Returns the value for the named keyword, or null if the keyword is not
            present.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.DefaultKeywordValue(System.String,System.String)">
            <summary>
            Set the keyword value only if it is not already set to something else.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SetKeywordValue(System.String,System.String)">
            <summary>
            Set the value for the named keyword, or unset it if <paramref name="value"/> is null.  If
            <paramref name="keywordName"/> itself is null, unset all keywords.  If <paramref name="keywordName"/> is not null,
            <paramref name="value"/> must not be null.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDParser.SetKeywordValue(System.String,System.String,System.Boolean)">
            <summary>
            Set the value for the named keyword, or unset it if <paramref name="value"/> is null.  If
            <paramref name="keywordName"/> itself is null, unset all keywords.  If <paramref name="keywordName"/> is not null,
            <paramref name="value"/> must not be null.  If reset is true, ignore any previous value for
            the keyword, otherwise do not change the keyword (including removal of
            one or all keywords).
            </summary>
        </member>
        <member name="T:ICU4N.Impl.LocaleIDs">
            <summary>
            Utilities for mapping between old and new language, country, and other
            locale ID related names.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDs.GetISOCountries">
            <summary>
            Returns a list of all 2-letter country codes defined in ISO 3166.
            Can be used to create Locales.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDs.GetISOLanguages">
            <summary>
            Returns a list of all 2-letter language codes defined in ISO 639
            plus additional 3-letter codes determined to be useful for locale generation as
            defined by Unicode CLDR.
            Can be used to create Locales.
            </summary>
            <remarks>
            [NOTE:  ISO 639 is not a stable standard-- some languages' codes have changed.
            The list this function returns includes both the new and the old codes for the
            languages whose codes have changed.]
            </remarks>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDs.GetISO3Country(System.String)">
            <summary>
            Returns a three-letter abbreviation for the provided country.  If the provided
            country is empty, returns the empty string.  Otherwise, returns
            an uppercase ISO 3166 3-letter country code.
            </summary>
            <exception cref="T:System.Resources.MissingManifestResourceException">Throws <see cref="T:System.Resources.MissingManifestResourceException"/> if the
            three-letter country abbreviation is not available for this locale.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDs.GetISO3Language(System.String)">
            <summary>
            Returns a three-letter abbreviation for the language.  If language is
            empty, returns the empty string.  Otherwise, returns
            a lowercase ISO 639-2/T language code.
            </summary>
            <remarks>The ISO 639-2 language codes can be found on-line at
            <a href="ftp://dkuug.dk/i18n/iso-639-2.txt">ftp://dkuug.dk/i18n/iso-639-2.txt</a>.
            </remarks>
            <exception cref="T:System.Resources.MissingManifestResourceException">Throws <see cref="T:System.Resources.MissingManifestResourceException"/> if the
            three-letter language abbreviation is not available for this locale.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Impl.LocaleIDs.FindIndex(System.String[],System.String)">
            <summary>
            Linear search of the string array. The arrays are unfortunately ordered by the
            two-letter target code, not the three-letter search code, which seems backwards.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.LocaleUtility">
            <summary>
            A class to hold utility functions missing from java.util.Locale.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.LocaleUtility.GetLocaleFromName(System.String)">
            A helper function to convert a string of the form
            aa_BB_CC to a locale object.  Why isn't this in Locale?
        </member>
        <member name="M:ICU4N.Impl.LocaleUtility.IsFallbackOf(System.String,System.String)">
            Compare two locale strings of the form aa_BB_CC, and
            return true if parent is a 'strict' fallback of child, that is,
            if child =~ "^parent(_.+)*" (roughly).
        </member>
        <member name="M:ICU4N.Impl.LocaleUtility.IsFallbackOf(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            Compare two locales, and return true if the parent is a
            'strict' fallback of the child (parent string is a fallback
            of child string).
        </member>
        <member name="M:ICU4N.Impl.LocaleUtility.Fallback(System.Globalization.CultureInfo)">
            Fallback from the given locale name by removing the rightmost _-delimited
            element. If there is none, return the root locale ("", "", ""). If this
            is the root locale, return null. NOTE: The string "root" is not
            recognized; do not use it.
            
            @return a new Locale that is a fallback from the given locale, or null.
        </member>
        <member name="M:ICU4N.Impl.LocaleUtility.Fallback(System.String)">
            <summary>
            Fallback from the given ICU locale name 
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.SetExtensions(System.String)">
            <summary>
            Set extension/private subtags in a single string representation
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.SetExtensions(System.Collections.Generic.IList{System.String},System.String)">
            <summary>
            Set a list of BCP47 extensions and private use subtags.
            BCP47 extensions are already validated and well-formed, but may contain duplicates.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.SetLanguageTag(ICU4N.Impl.Locale.LanguageTag)">
            <summary>
            Reset Builder's internal state with the given language tag
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.RemovePrivateuseVariant(System.String)">
            <summary>
            Remove special private use subtag sequence identified by "lvariant"
            and return the rest. Only used by LocaleExtensions.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.CheckVariants(System.String,System.String)">
            <summary>
            Check if the given variant subtags separated by the given
            separator(s) are valid.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.InternalLocaleBuilder.SetUnicodeLocaleExtension(System.String)">
            <summary>
            Private methods parsing Unicode Locale Extension subtags.
            Duplicated attributes/keywords will be ignored.
            The input must be a valid extension subtags (excluding singleton).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Locale.KeyTypeData.GetKeyInfo(ICU4N.Util.UResourceBundle)">
            Reads
                        keyInfo{
                            deprecated{
                                        kh{"true"}
                                        vt{"true"}
                            }
                            valueType{
                                        ca{"incremental"}
                                        h0{"single"}
                                        kr{"multiple"}
                                        vt{"multiple"}
                                        x0{"any"}
                            }
                        }
        </member>
        <member name="M:ICU4N.Impl.Locale.KeyTypeData.GetTypeInfo(ICU4N.Util.UResourceBundle)">
            Reads:
                        typeInfo{
                            deprecated{
                                        co{
                                            direct{"true"}
                                        }
                                        tz{
                                            camtr{"true"}
                                        }
                            }
                        }
        </member>
        <member name="M:ICU4N.Impl.Locale.LanguageTag.Parse(System.String,ICU4N.Impl.Locale.ParseStatus)">
             <summary>
             BNF in RFC5464
             </summary>
             <remarks>
             Language-Tag  = langtag             ; normal language tags
                           / privateuse          ; private use tag
                           / grandfathered       ; grandfathered tags
            
            
             langtag       = language
                             ["-" script]
                             ["-" region]
                             *("-" variant)
                             *("-" extension)
                             ["-" privateuse]
            
             language      = 2*3ALPHA            ; shortest ISO 639 code
                             ["-" extlang]       ; sometimes followed by
                                                 ; extended language subtags
                           / 4ALPHA              ; or reserved for future use
                           / 5*8ALPHA            ; or registered language subtag
            
             extlang       = 3ALPHA              ; selected ISO 639 codes
                             *2("-" 3ALPHA)      ; permanently reserved
            
             script        = 4ALPHA              ; ISO 15924 code
            
             region        = 2ALPHA              ; ISO 3166-1 code
                           / 3DIGIT              ; UN M.49 code
            
             variant       = 5*8alphanum         ; registered variants
                           / (DIGIT 3alphanum)
            
             extension     = singleton 1*("-" (2*8alphanum))
            
                                                 ; Single alphanumerics
                                                 ; "x" reserved for private use
             singleton     = DIGIT               ; 0 - 9
                           / %x41-57             ; A - W
                           / %x59-5A             ; Y - Z
                           / %x61-77             ; a - w
                           / %x79-7A             ; y - z
            
             privateuse    = "x" 1*("-" (1*8alphanum))
             </remarks>
        </member>
        <member name="T:ICU4N.Impl.Locale.StringTokenEnumerator">
            <summary>
            NOTE: This is equivalent to StringTokenEnumerator in ICU4J
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Norm2AllModes.GetFCDNormalizer2">
            <summary>
            Gets the FCD normalizer, with the FCD data initialized.
            </summary>
            <returns>FCD normalizer.</returns>
        </member>
        <member name="T:ICU4N.Impl.Normalizer2Impl">
            <summary>
            Low-level implementation of the Unicode Normalization Algorithm.
            For the data structure and details see the documentation at the end of
            C++ normalizer2impl.h and in the design doc at
            http://site.icu-project.org/design/normalization/custom
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Hangul.Decompose(System.Int32,System.Text.StringBuilder)">
            <summary>
            Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer
            and returns the length of the decomposition (2 or 3).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Hangul.Decompose(System.Int32,ICU4N.Support.Text.IAppendable)">
            <summary>
            Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer
            and returns the length of the decomposition (2 or 3).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Hangul.GetRawDecomposition(System.Int32,System.Text.StringBuilder)">
            <summary>
            Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer.
            This is the raw, not recursive, decomposition. Its length is always 2.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Hangul.GetRawDecomposition(System.Int32,ICU4N.Support.Text.IAppendable)">
            <summary>
            Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer.
            This is the raw, not recursive, decomposition. Its length is always 2.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer">
            <summary>
            Writable buffer that takes care of canonical ordering.
            Its <see cref="T:ICU4N.Support.Text.IAppendable"/> methods behave like the C++ implementation's
            appendZeroCC() methods.
            <para/>
            If dest is a <see cref="T:System.Text.StringBuilder"/>, then the buffer writes directly to it.
            Otherwise, the buffer maintains a <see cref="T:System.Text.StringBuilder"/> for intermediate text segments
            until no further changes are necessary and whole segments are appended.
            Append() methods that take combining-class values always write to the <see cref="T:System.Text.StringBuilder"/>.
            Other Append() methods flush and append to the <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.Flush">
            <summary>
            Flushes from the intermediate <see cref="P:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.StringBuilder"/> to the <see cref="T:ICU4N.Support.Text.IAppendable"/>,
            if they are different objects.
            Used after recomposition.
            Must be called at the end when writing to a non-StringBuilderAppendable <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.FlushAndAppendZeroCC(System.String,System.Int32,System.Int32)">
            <summary>
            Flushes from the intermediate <see cref="T:System.Text.StringBuilder"/> to the <see cref="T:ICU4N.Support.Text.IAppendable"/>,
            if they are different objects.
            Then appends the new text to the <see cref="T:ICU4N.Support.Text.IAppendable"/> or <see cref="T:System.Text.StringBuilder"/>.
            Normally used after quick check loops find a non-empty sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.FlushAndAppendZeroCC(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Flushes from the intermediate <see cref="T:System.Text.StringBuilder"/> to the <see cref="T:ICU4N.Support.Text.IAppendable"/>,
            if they are different objects.
            Then appends the new text to the <see cref="T:ICU4N.Support.Text.IAppendable"/> or <see cref="T:System.Text.StringBuilder"/>.
            Normally used after quick check loops find a non-empty sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.FlushAndAppendZeroCC(System.Char[],System.Int32,System.Int32)">
            <summary>
            Flushes from the intermediate <see cref="T:System.Text.StringBuilder"/> to the <see cref="T:ICU4N.Support.Text.IAppendable"/>,
            if they are different objects.
            Then appends the new text to the <see cref="T:ICU4N.Support.Text.IAppendable"/> or <see cref="T:System.Text.StringBuilder"/>.
            Normally used after quick check loops find a non-empty sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ReorderingBuffer.FlushAndAppendZeroCC(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Flushes from the intermediate <see cref="T:System.Text.StringBuilder"/> to the <see cref="T:ICU4N.Support.Text.IAppendable"/>,
            if they are different objects.
            Then appends the new text to the <see cref="T:ICU4N.Support.Text.IAppendable"/> or <see cref="T:System.Text.StringBuilder"/>.
            Normally used after quick check loops find a non-empty sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.IsSurrogateLead(System.Int32)">
            <summary>
            Assuming <paramref name="c"/> is a surrogate code point (UTF16.IsSurrogate(c)),
            is it a lead surrogate?
            </summary>
            <param name="c">code unit or code point</param>
            <returns>true or false</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.String)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Text.StringBuilder)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Char[])">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.String)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Char[])">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.String)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Text.StringBuilder)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Char[])">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.String)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Char[])">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares two character sequence objects for binary equality.
            </summary>
            <param name="s1">s1 first sequence</param>
            <param name="s2">s2 second sequence</param>
            <returns>true if s1 contains the same text as s2.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.String,System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Text.StringBuilder,System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(System.Char[],System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.UTF16Plus.Equal(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Compares two character subsequences for binary equality.
            </summary>
            <param name="s1">first sequence</param>
            <param name="start1">start offset in first sequence</param>
            <param name="limit1">limit offset in first sequence</param>
            <param name="s2">second sequence</param>
            <param name="start2">start offset in second sequence</param>
            <param name="limit2">limit offset in second sequence</param>
            <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.EnsureCanonIterData">
            <summary>
            Builds the canonical-iterator data for this instance.
            This is required before any of <see cref="M:ICU4N.Impl.Normalizer2Impl.IsCanonSegmentStarter(System.Int32)"/> or
            <see cref="M:ICU4N.Impl.Normalizer2Impl.GetCanonStartSet(System.Int32,ICU4N.Text.UnicodeSet)"/> are called,
            or else they crash.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetFCD16(System.Int32)">
            <summary>
            Returns the FCD data for code point <paramref name="c"/>.
            </summary>
            <param name="c">A Unicode code point.</param>
            <returns>The lccc(c) in bits 15..8 and tccc(c) in bits 7..0.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.SingleLeadMightHaveNonZeroFCD16(System.Int32)">
            <summary>Returns true if the single-or-lead code unit c might have non-zero FCD data.</summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetFCD16FromNormData(System.Int32)">
            <summary>Gets the FCD value from the regular normalization data.</summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetDecomposition(System.Int32)">
            <summary>
            Gets the decomposition for one code point.
            </summary>
            <param name="c">Code point.</param>
            <returns><paramref name="c"/>'s decomposition, if it has one; returns null if it does not have a decomposition.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetRawDecomposition(System.Int32)">
            <summary>
            Gets the raw decomposition for one code point.
            </summary>
            <param name="c">Code point.</param>
            <returns><paramref name="c"/>'s raw decomposition, if it has one; returns null if it does not have a decomposition.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.IsCanonSegmentStarter(System.Int32)">
            <summary>
            Returns true if code point <paramref name="c"/> starts a canonical-iterator string segment.
            <b><see cref="M:ICU4N.Impl.Normalizer2Impl.EnsureCanonIterData"/> must have been called before this method,
            or else this method will crash.</b>
            </summary>
            <param name="c">A Unicode code point.</param>
            <returns>true if <paramref name="c"/> starts a canonical-iterator string segment.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetCanonStartSet(System.Int32,ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if there are characters whose decomposition starts with <paramref name="c"/>.
            If so, then the set is cleared and then filled with those characters.
            <b><see cref="M:ICU4N.Impl.Normalizer2Impl.EnsureCanonIterData"/> must have been called before this method,
            or else this method will crash.</b>
            </summary>
            <param name="c">A Unicode code point.</param>
            <param name="set">A UnicodeSet to receive the characters whose decompositions
            start with <paramref name="c"/>, if there are any.</param>
            <returns>true if there are characters whose decomposition starts with <paramref name="c"/>.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Normalizer2Impl.IX_MIN_YES_NO" -->
        <member name="F:ICU4N.Impl.Normalizer2Impl.IX_MIN_NO_NO">
            <summary>Mappings are comp-normalized.</summary>
        </member>
        <member name="F:ICU4N.Impl.Normalizer2Impl.IX_MIN_YES_NO_MAPPINGS_ONLY">
            <summary>Mappings only in [minYesNoMappingsOnly..minNoNo[.</summary>
        </member>
        <member name="F:ICU4N.Impl.Normalizer2Impl.IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE">
            <summary>Mappings are not comp-normalized but have a comp boundary before.</summary>
        </member>
        <member name="F:ICU4N.Impl.Normalizer2Impl.IX_MIN_NO_NO_COMP_NO_MAYBE_CC">
            <summary>Mappings do not have a comp boundary before.</summary>
        </member>
        <member name="F:ICU4N.Impl.Normalizer2Impl.IX_MIN_NO_NO_EMPTY">
            <summary>Mappings to the empty string.</summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.IsMostDecompYesAndZeroCC(System.Int32)">
            <summary>
            A little faster and simpler than <see cref="M:ICU4N.Impl.Normalizer2Impl.IsDecompYesAndZeroCC(System.Int32)"/> but does not include
            the MaybeYes which combine-forward and have ccc=0.
            (Standard Unicode 10 normalization does not have such characters.)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetCompositionsListForDecompYes(System.Int32)">
            <returns>Index into maybeYesCompositions, or -1.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetCompositionsListForComposite(System.Int32)">
            <returns>Index into maybeYesCompositions.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.GetCompositionsList(System.Int32)">
            <param name="norm16">Code point must have compositions.</param>
            <returns>Index into maybeYesCompositions.</returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Combine(System.String,System.Int32,System.Int32)">
            <summary>
            Finds the recomposition result for
            a forward-combining "lead" character,
            specified with a pointer to its compositions list,
            and a backward-combining "trail" character.
            </summary>
            <remarks>
            If the lead and trail characters combine, then this function returns
            the following "compositeAndFwd" value:
            <code>
            Bits 21..1  composite character
            Bit      0  set if the composite is a forward-combining starter
            </code>
            otherwise it returns -1.
            <para/>
            The compositions list has (trail, compositeAndFwd) pair entries,
            encoded as either pairs or triples of 16-bit units.
            The last entry has the high bit of its first unit set.
            <para/>
            The list is sorted by ascending trail characters (there are no duplicates).
            A linear search is used.
            <para/>
            See normalizer2impl.h for a more detailed description
            of the compositions list format.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.AddComposites(System.Int32,ICU4N.Text.UnicodeSet)">
            <param name="list">Some character's compositions list.</param>
            <param name="set">Recursively receives the composites from these compositions.</param>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Recompose(ICU4N.Impl.Normalizer2Impl.ReorderingBuffer,System.Int32,System.Boolean)">
            <summary>
            Recomposes the buffer text starting at <paramref name="recomposeStartIndex"/>
            (which is in NFD - decomposed and canonically ordered),
            and truncates the buffer contents.
            </summary>
            <remarks>
            Note that recomposition never lengthens the text:
            Any character consists of either one or two code units;
            a composition may contain at most one more code unit than the original starter,
            while the combining mark that is removed has at least one code unit.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Normalizer2Impl.HasCompBoundaryBefore(System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Impl.Normalizer2Impl.IsTrailCC01ForCompBoundaryAfter(System.Int32)">
            <summary>For FCC: Given norm16 HAS_COMP_BOUNDARY_AFTER, does it have tccc&lt;=1?</summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Decompose(System.String,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
            limit can be NULL if src is NUL-terminated.
            <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Decompose(System.Text.StringBuilder,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
            limit can be NULL if src is NUL-terminated.
            <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Decompose(System.Char[],System.Int32,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
            limit can be NULL if src is NUL-terminated.
            <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.Decompose(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>
            Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
            limit can be NULL if src is NUL-terminated.
            <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ComposeQuickCheck(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Very similar to Compose(): Make the same changes in both places if relevant.
            doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
            !doSpan: QuickCheck
            </summary>
            <returns>
            bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
            bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
            then the quick check result is "no"
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ComposeQuickCheck(System.Text.StringBuilder,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Very similar to Compose(): Make the same changes in both places if relevant.
            doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
            !doSpan: QuickCheck
            </summary>
            <returns>
            bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
            bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
            then the quick check result is "no"
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ComposeQuickCheck(System.Char[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Very similar to Compose(): Make the same changes in both places if relevant.
            doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
            !doSpan: QuickCheck
            </summary>
            <returns>
            bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
            bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
            then the quick check result is "no"
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Normalizer2Impl.ComposeQuickCheck(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Very similar to Compose(): Make the same changes in both places if relevant.
            doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
            !doSpan: QuickCheck
            </summary>
            <returns>
            bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
            bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
            then the quick check result is "no"
            </returns>
        </member>
        <member name="T:ICU4N.Impl.PatternProps">
            <summary>
            Implements the immutable Unicode properties Pattern_Syntax and Pattern_White_Space.
            Hardcodes these properties, does not load data, does not depend on other ICU classes.
            </summary>
            <remarks>
            Note: Both properties include ASCII as well as non-ASCII, non-Latin-1 code points,
            and both properties only include BMP code points (no supplementary ones).
            Pattern_Syntax includes some unassigned code points.
            <para/>
            [:Pattern_White_Space:] =
                [\u0009-\u000D\ \u0085\u200E\u200F\u2028\u2029]
            <para/>
            [:Pattern_Syntax:] =
                [!-/\:-@\[-\^`\{-~\u00A1-\u00A7\u00A9\u00AB\u00AC\u00AE
                \u00B0\u00B1\u00B6\u00BB\u00BF\u00D7\u00F7
                \u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E
                \u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F
                \u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsSyntax(System.Int32)">
            <summary>
            Returns true if c is a Pattern_Syntax code point.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsSyntaxOrWhiteSpace(System.Int32)">
            <summary>
            Returns true if c is a Pattern_Syntax or Pattern_White_Space code point.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsWhiteSpace(System.Int32)">
            <summary>
            Returns true if c is a Pattern_White_Space character.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.TrimWhiteSpace(System.String)">
            <returns><paramref name="s"/> except with leading and trailing Pattern_White_Space removed.</returns>
        </member>
        <member name="F:ICU4N.Impl.PatternProps.latin1">
            <summary>
            One byte per Latin-1 character.
            Bit 0 is set if either Pattern property is true,
            bit 1 if Pattern_Syntax is true,
            bit 2 if Pattern_White_Space is true.
            That is, Pattern_Syntax is encoded as 3 and Pattern_White_Space as 5.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.PatternProps.index2000">
            <summary>
            One byte per 32 characters from U+2000..U+303F indexing into
            a small table of 32-bit data words.
            The first two data words are all-zeros and all-ones.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.PatternProps.syntax2000">
            <summary>
            One 32-bit integer per 32 characters. Ranges of all-false and all-true
            are mapped to the first two values, other ranges map to appropriate bit patterns.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.PatternProps.syntaxOrWhiteSpace2000">
            <summary>
            Same as syntax2000, but with additional bits set for the
            Pattern_White_Space characters 200E 200F 2028 2029.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipWhiteSpace(System.String,System.Int32)">
            <summary>
            Skips over Pattern_White_Space starting at index i of the string.
            </summary>
            <returns>The smallest index at or after i with a non-white space character.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipWhiteSpace(System.Text.StringBuilder,System.Int32)">
            <summary>
            Skips over Pattern_White_Space starting at index i of the string.
            </summary>
            <returns>The smallest index at or after i with a non-white space character.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipWhiteSpace(System.Char[],System.Int32)">
            <summary>
            Skips over Pattern_White_Space starting at index i of the string.
            </summary>
            <returns>The smallest index at or after i with a non-white space character.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipWhiteSpace(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Skips over Pattern_White_Space starting at index i of the string.
            </summary>
            <returns>The smallest index at or after i with a non-white space character.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.String)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <param name="s"></param>
            <returns>true if there are no Pattern_White_Space or Pattern_Syntax characters in s.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.Text.StringBuilder)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <param name="s"></param>
            <returns>true if there are no Pattern_White_Space or Pattern_Syntax characters in s.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.Char[])">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <param name="s"></param>
            <returns>true if there are no Pattern_White_Space or Pattern_Syntax characters in s.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <param name="s"></param>
            <returns>true if there are no Pattern_White_Space or Pattern_Syntax characters in s.</returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.String,System.Int32,System.Int32)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <returns>
            true if there are no Pattern_White_Space or Pattern_Syntax characters
            in <paramref name="s"/> between <paramref name="start"/> and (exclusive) <paramref name="limit"/>.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <returns>
            true if there are no Pattern_White_Space or Pattern_Syntax characters
            in <paramref name="s"/> between <paramref name="start"/> and (exclusive) <paramref name="limit"/>.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(System.Char[],System.Int32,System.Int32)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <returns>
            true if there are no Pattern_White_Space or Pattern_Syntax characters
            in <paramref name="s"/> between <paramref name="start"/> and (exclusive) <paramref name="limit"/>.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.IsIdentifier(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Tests whether the string contains a "pattern identifier", that is,
            whether it contains only non-Pattern_White_Space, non-Pattern_Syntax characters.
            </summary>
            <returns>
            true if there are no Pattern_White_Space or Pattern_Syntax characters
            in <paramref name="s"/> between <paramref name="start"/> and (exclusive) <paramref name="limit"/>.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipIdentifier(System.String,System.Int32)">
            <summary>
            Skips over a "pattern identifier" starting at index <paramref name="i"/> of the string.
            </summary>
            <returns>
            The smallest index at or after <paramref name="i"/> with
            a Pattern_White_Space or Pattern_Syntax character.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipIdentifier(System.Text.StringBuilder,System.Int32)">
            <summary>
            Skips over a "pattern identifier" starting at index <paramref name="i"/> of the string.
            </summary>
            <returns>
            The smallest index at or after <paramref name="i"/> with
            a Pattern_White_Space or Pattern_Syntax character.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipIdentifier(System.Char[],System.Int32)">
            <summary>
            Skips over a "pattern identifier" starting at index <paramref name="i"/> of the string.
            </summary>
            <returns>
            The smallest index at or after <paramref name="i"/> with
            a Pattern_White_Space or Pattern_Syntax character.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.PatternProps.SkipIdentifier(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Skips over a "pattern identifier" starting at index <paramref name="i"/> of the string.
            </summary>
            <returns>
            The smallest index at or after <paramref name="i"/> with
            a Pattern_White_Space or Pattern_Syntax character.
            </returns>
        </member>
        <member name="T:ICU4N.Impl.PluralRulesLoader">
            <summary>
            Loader for plural rules data.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.#ctor">
            <summary>
            Access through singleton.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetAvailableULocales">
            <summary>
            Returns the locales for which we have plurals data. Utility for testing.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetFunctionalEquivalent(ICU4N.Util.ULocale,System.Boolean[])">
            <summary>
            Returns the functionally equivalent locale.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetLocaleIdToRulesIdMap(ICU4N.Text.PluralType)">
            <summary>
            Returns the lazily-constructed map.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetRulesIdToEquivalentULocaleMap">
            <summary>
            Returns the lazily-constructed map.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.CheckBuildRulesIdMaps">
            <summary>
            Lazily constructs the localeIdToRulesId and rulesIdToEquivalentULocale
            maps if necessary. These exactly reflect the contents of the locales
            resource in plurals.res.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetRulesIdForLocale(ICU4N.Util.ULocale,ICU4N.Text.PluralType)">
            <summary>
            Gets the rulesId from the locale,with locale fallback. If there is no
            rulesId, return null. The rulesId might be the empty string if the rule
            is the default rule.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetRulesForRulesId(System.String)">
            <summary>
            Gets the rule from the rulesId. If there is no rule for this rulesId,
            return null.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.GetPluralBundle">
            <summary>
            Return the plurals resource. Note <see cref="T:System.Resources.MissingManifestResourceException"/> is unchecked,
            listed here for clarity. Callers should handle this exception.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.ForLocale(ICU4N.Util.ULocale,ICU4N.Text.PluralType)">
            <summary>
            Returns the plural rules for the the locale. If we don't have data,
            <see cref="F:ICU4N.Text.PluralRules.Default"/> is returned.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.PluralRulesLoader.loader">
            <summary>
            The only instance of the loader.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.PluralRulesLoader.Loader">
            <summary>
            The only instance of the loader.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.PluralRulesLoader.HasOverride(ICU4N.Util.ULocale)">
            <seealso cref="M:ICU4N.Text.PluralRules.Factory.HasOverride(ICU4N.Util.ULocale)"/>
        </member>
        <member name="T:ICU4N.Impl.Punycode">
            <summary>
            Ported code from ICU punycode.c 
            </summary>
            <author>ram</author>
        </member>
        <member name="F:ICU4N.Impl.Punycode.basicToDigit">
            <summary>
            basicToDigit[] contains the numeric value of a basic code
            point (for use in representing integers) in the range 0 to
            BASE-1, or -1 if b is does not represent a value.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Punycode.DigitToBasic(System.Int32,System.Boolean)">
            <summary>
            <see cref="M:ICU4N.Impl.Punycode.DigitToBasic(System.Int32,System.Boolean)"/> returns the basic code point whose value
            (when used for representing integers) is d, which must be in the
            range 0 to BASE-1. The lowercase form is used unless the uppercase flag is
            nonzero, in which case the uppercase form is used.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Encode(System.String,System.Boolean[])">
            <summary>
            Converts Unicode to Punycode.
            The input string must not contain single, unpaired surrogates.
            The output will be represented as an array of ASCII code points.
            </summary>
            <param name="src">The source of the string Buffer passed.</param>
            <param name="caseFlags">The boolean array of case flags.</param>
            <returns>An array of ASCII code points.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Encode(System.Text.StringBuilder,System.Boolean[])">
            <summary>
            Converts Unicode to Punycode.
            The input string must not contain single, unpaired surrogates.
            The output will be represented as an array of ASCII code points.
            </summary>
            <param name="src">The source of the string Buffer passed.</param>
            <param name="caseFlags">The boolean array of case flags.</param>
            <returns>An array of ASCII code points.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Encode(System.Char[],System.Boolean[])">
            <summary>
            Converts Unicode to Punycode.
            The input string must not contain single, unpaired surrogates.
            The output will be represented as an array of ASCII code points.
            </summary>
            <param name="src">The source of the string Buffer passed.</param>
            <param name="caseFlags">The boolean array of case flags.</param>
            <returns>An array of ASCII code points.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Encode(ICU4N.Support.Text.ICharSequence,System.Boolean[])">
            <summary>
            Converts Unicode to Punycode.
            The input string must not contain single, unpaired surrogates.
            The output will be represented as an array of ASCII code points.
            </summary>
            <param name="src">The source of the string Buffer passed.</param>
            <param name="caseFlags">The boolean array of case flags.</param>
            <returns>An array of ASCII code points.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Decode(System.String,System.Boolean[])">
            <summary>
            Converts Punycode to Unicode.
            The Unicode string will be at most as long as the Punycode string.
            </summary>
            <param name="src">The source of the string buffer being passed.</param>
            <param name="caseFlags">The array of bool case flags.</param>
            <returns><see cref="T:System.Text.StringBuilder"/> string.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Decode(System.Text.StringBuilder,System.Boolean[])">
            <summary>
            Converts Punycode to Unicode.
            The Unicode string will be at most as long as the Punycode string.
            </summary>
            <param name="src">The source of the string buffer being passed.</param>
            <param name="caseFlags">The array of bool case flags.</param>
            <returns><see cref="T:System.Text.StringBuilder"/> string.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Decode(System.Char[],System.Boolean[])">
            <summary>
            Converts Punycode to Unicode.
            The Unicode string will be at most as long as the Punycode string.
            </summary>
            <param name="src">The source of the string buffer being passed.</param>
            <param name="caseFlags">The array of bool case flags.</param>
            <returns><see cref="T:System.Text.StringBuilder"/> string.</returns>
        </member>
        <member name="M:ICU4N.Impl.Punycode.Decode(ICU4N.Support.Text.ICharSequence,System.Boolean[])">
            <summary>
            Converts Punycode to Unicode.
            The Unicode string will be at most as long as the Punycode string.
            </summary>
            <param name="src">The source of the string buffer being passed.</param>
            <param name="caseFlags">The array of bool case flags.</param>
            <returns><see cref="T:System.Text.StringBuilder"/> string.</returns>
        </member>
        <member name="T:ICU4N.Impl.Relation">
            <summary>
            Convenience Methods
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Relation`2">
            <summary>
            A Relation is a set of mappings from keys to values.
            Unlike <see cref="T:System.Collections.Generic.IDictionary`2"/>, there is not guaranteed to be a single value per key.
            The dictionary-like APIs return collections for values.
            </summary>
            <typeparam name="TKey">Type of key.</typeparam>
            <typeparam name="TValue">Type of value.</typeparam>
            <author>medavis</author>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.#ctor(ICU4N.Text.IReplaceable)">
            <summary>
            Public constructor.
            </summary>
            <param name="replaceable">Text which the iterator will be based on.</param>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.#ctor(System.String)">
            <summary>
            Public constructor.
            </summary>
            <param name="str">Text which the iterator will be based on.</param>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.#ctor(System.Text.StringBuilder)">
            <summary>
            Public constructor.
            </summary>
            <param name="buf">Buffer of text on which the iterator will be based.</param>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.Clone">
            <summary>
            Creates a copy of this iterator, does not clone the underlying
            <see cref="T:ICU4N.Text.IReplaceable"/> object.
            </summary>
            <returns>Copy of this iterator.</returns>
        </member>
        <member name="P:ICU4N.Impl.ReplaceableUCharacterIterator.Current">
            <summary>
            Gets the current <see cref="T:ICU4N.Text.UTF16"/> character.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ReplaceableUCharacterIterator.CurrentCodePoint">
            <summary>
            Returns the current codepoint.
            </summary>
            <returns>Current codepoint.</returns>
        </member>
        <member name="P:ICU4N.Impl.ReplaceableUCharacterIterator.Length">
            <summary>
            Gets the length of the text.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.ReplaceableUCharacterIterator.Index">
            <summary>
            Gets or Sets the current <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> in text.
            This assumes the text is stored as 16-bit code units.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if an invalid value is
                       supplied. i.e. value is out of bounds.</exception>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.Next">
            <summary>
            Returns next UTF16 character and increments the iterator's <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> by 1.
            If the resulting <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is greater or equal to the text length, the
            <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is reset to the text length and a value of <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is
            returned.
            </summary>
            <returns>Next UTF16 character in text or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the new <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is off the
                    end of the text range.</returns>
        </member>
        <member name="M:ICU4N.Impl.ReplaceableUCharacterIterator.Previous">
            <summary>
            Returns previous UTF16 character and decrements the iterator's <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> by
            1.
            If the resulting <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is less than 0, the <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is reset to 0 and a
            value of <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is returned.
            </summary>
            <returns>Next UTF16 character in text or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the new <see cref="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex"/> is off the
                    start of the text range.</returns>
        </member>
        <member name="F:ICU4N.Impl.ReplaceableUCharacterIterator.replaceable">
            <summary>
            Replacable object
            </summary>
        </member>
        <member name="F:ICU4N.Impl.ReplaceableUCharacterIterator.currentIndex">
            <summary>
            Current currentIndex
            </summary>
        </member>
        <member name="T:ICU4N.Impl.ResourceBundleWrapper">
            <summary>
            just a wrapper for Java ListResourceBundles and
            </summary>
            <author>ram</author>
        </member>
        <member name="T:ICU4N.Impl.ResourceBundleWrapper.Loader">
            <summary>Loader for bundle instances, for caching.</summary>
        </member>
        <member name="T:ICU4N.Impl.Row">
            <summary>
            Convenience Methods
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Row`2">
            <author>Mark Davis</author>
        </member>
        <member name="T:ICU4N.Impl.Row`3">
            <author>Mark Davis</author>
        </member>
        <member name="T:ICU4N.Impl.Row`4">
            <author>Mark Davis</author>
        </member>
        <member name="T:ICU4N.Impl.Row`5">
            <author>Mark Davis</author>
        </member>
        <member name="T:ICU4N.Impl.RuleCharacterIteratorOptions">
            <summary>
            Options for the <see cref="T:ICU4N.Impl.RuleCharacterIterator"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseVariables">
            <summary>
            Bitmask option to enable parsing of variable names.  If (options &amp;
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseVariables"/> != 0, then an embedded variable will be expanded to
            its value.  Variables are parsed using the <see cref="T:ICU4N.Text.SymbolTable"/> API.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseEscapes">
            <summary>
            Bitmask option to enable parsing of escape sequences.  If (options &amp;
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseEscapes"/> != 0, then an embedded escape sequence will be expanded
            to its value.  Escapes are parsed using <see cref="M:ICU4N.Impl.Utility.UnescapeAt(System.String,System.Int32[])"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIteratorOptions.SkipWhitespace">
            <summary>
            Bitmask option to enable skipping of whitespace.  If (options &amp;
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.SkipWhitespace"/> != 0, then Unicode Pattern_White_Space characters will be silently
            skipped, as if they were not present in the input.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.RuleCharacterIterator">
            <summary>
            An iterator that returns 32-bit code points.  This class is deliberately
            <em>not</em> related to any of the .NET or ICU4N character iterator classes
            in order to minimize complexity.
            </summary>
            <author>Alan Liu</author>
            <since>ICU 2.8</since>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.text">
            <summary>
            Text being iterated.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.pos">
            <summary>
            Position of iterator.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.sym">
            <summary>
            Symbol table used to parse and dereference variables.  May be null.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.buf">
            <summary>
            Current variable expansion, or null if none.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.bufPos">
            <summary>
            Position within buf[].  Meaningless if buf == null.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.isEscaped">
            <summary>
            Flag indicating whether the last character was parsed from an escape.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.RuleCharacterIterator.DONE">
            <summary>
            Value returned when there are no more characters to iterate.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.#ctor(System.String,ICU4N.Text.ISymbolTable,ICU4N.Support.Text.ParsePosition)">
            <summary>
            Constructs an iterator over the given text, starting at the given
            position.
            </summary>
            <param name="text">The text to be iterated.</param>
            <param name="sym">The symbol table, or null if there is none.  If sym is null,
            then variables will not be deferenced, even if the <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseVariables"/>
            option is set.</param>
            <param name="pos">Upon input, the index of the next character to return.  If a
            variable has been dereferenced, then pos will <em>not</em> increment as
            characters of the variable value are iterated.</param>
        </member>
        <member name="P:ICU4N.Impl.RuleCharacterIterator.AtEnd">
            <summary>
            Returns true if this iterator has no more characters to return.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.Next(ICU4N.Impl.RuleCharacterIteratorOptions)">
            <summary>
            Returns the next character using the given options, or <see cref="F:ICU4N.Impl.RuleCharacterIterator.DONE"/> if there
            are no more characters, and advance the position to the next
            character.
            </summary>
            <param name="options">One or more of the following options, bitwise-OR-ed
            together: <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseVariables"/>, 
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseEscapes"/>, 
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.SkipWhitespace"/>.</param>
            <returns>The current 32-bit code point, or <see cref="F:ICU4N.Impl.RuleCharacterIterator.DONE"/>.</returns>
        </member>
        <member name="P:ICU4N.Impl.RuleCharacterIterator.IsEscaped">
            <summary>
            Returns true if the last character returned by <see cref="M:ICU4N.Impl.RuleCharacterIterator.Next(ICU4N.Impl.RuleCharacterIteratorOptions)"/> was
            escaped.  This will only be the case if the option passed in to
            <see cref="M:ICU4N.Impl.RuleCharacterIterator.Next(ICU4N.Impl.RuleCharacterIteratorOptions)"/> included 
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseEscapes"/> and the next character was an
            escape sequence.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.RuleCharacterIterator.InVariable">
            <summary>
            Returns true if this iterator is currently within a variable expansion.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.GetPos(System.Object)">
            <summary>
            Returns an object which, when later passed to <see cref="M:ICU4N.Impl.RuleCharacterIterator.SetPos(System.Object)"/>, will
            restore this iterator's position.
            </summary>
            <remarks>
            Usage idiom:
            <code>
            RuleCharacterIterator iterator = ...;
            object pos = iterator.GetPos(null); // allocate position object
            for (;;) 
            {
                pos = iterator.GetPos(pos); // reuse position object
                int c = iterator.Next(...);
            }
            </code>
            </remarks>
            <param name="p">A position object previously returned by <see cref="M:ICU4N.Impl.RuleCharacterIterator.GetPos(System.Object)"/>,
            or null.  If not null, it will be updated and returned.  If
            null, a new position object will be allocated and returned.</param>
            <returns>A position object which may be passed to <see cref="M:ICU4N.Impl.RuleCharacterIterator.SetPos(System.Object)"/>,
            either `p,' or if `p' == null, a newly-allocated object.</returns>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.SetPos(System.Object)">
            <summary>
            Restores this iterator to the position it had when <see cref="M:ICU4N.Impl.RuleCharacterIterator.GetPos(System.Object)"/>
            returned the given object.
            </summary>
            <param name="p">A position object previously returned by <see cref="M:ICU4N.Impl.RuleCharacterIterator.GetPos(System.Object)"/>.</param>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.SkipIgnored(ICU4N.Impl.RuleCharacterIteratorOptions)">
            <summary>
            Skips ahead past any ignored characters, as indicated by the given
            options.  This is useful in conjunction with the <see cref="M:ICU4N.Impl.RuleCharacterIterator.Lookahead"/> method.
            <para/>
            Currently, this only has an effect for <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.SkipWhitespace"/>.
            </summary>
            <param name="options">One or more of the following options, bitwise-OR-ed
            together: <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseVariables"/>, 
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.ParseEscapes"/>, 
            <see cref="F:ICU4N.Impl.RuleCharacterIteratorOptions.SkipWhitespace"/>.</param>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.Lookahead">
            <summary>
            Returns a string containing the remainder of the characters to be
            returned by this iterator, without any option processing.  
            </summary>
            <remarks>
            If the iterator is currently within a variable expansion, this will only
            extend to the end of the variable expansion.  This method is provided
            so that iterators may interoperate with string-based APIs.  The typical
            sequence of calls is to call <see cref="M:ICU4N.Impl.RuleCharacterIterator.SkipIgnored(ICU4N.Impl.RuleCharacterIteratorOptions)"/>, then call <see cref="M:ICU4N.Impl.RuleCharacterIterator.Lookahead"/>, then
            parse the string returned by <see cref="M:ICU4N.Impl.RuleCharacterIterator.Lookahead"/>, then call <see cref="M:ICU4N.Impl.RuleCharacterIterator.Jumpahead(System.Int32)"/> to
            resynchronize the iterator.
            </remarks>
            <returns>A string containing the characters to be returned by future
            calls to <see cref="M:ICU4N.Impl.RuleCharacterIterator.Next(ICU4N.Impl.RuleCharacterIteratorOptions)"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.Jumpahead(System.Int32)">
            <summary>
            Advances the position by the given number of 16-bit code units.
            This is useful in conjunction with the <see cref="M:ICU4N.Impl.RuleCharacterIterator.Lookahead"/> method.
            </summary>
            <param name="count">The number of 16-bit code units to jump over.</param>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.ToString">
            <summary>
            Returns a string representation of this object, consisting of the
            characters being iterated, with a '|' marking the current position.
            Position within an expanded variable is <em>not</em> indicated.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.Current">
            <summary>
            Returns the current 32-bit code point without parsing escapes, parsing
            variables, or skipping whitespace.
            </summary>
            <returns>The current 32-bit code point.</returns>
        </member>
        <member name="M:ICU4N.Impl.RuleCharacterIterator.Advance(System.Int32)">
            <summary>
            Advances the position by the given amount.
            </summary>
            <param name="count">The number of 16-bit code units to advance past.</param>
        </member>
        <member name="T:ICU4N.Impl.SimpleFilteredSentenceBreakIterator">
            <author>tomzhang</author>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.#ctor(ICU4N.Text.BreakIterator,ICU4N.Util.CharsTrie,ICU4N.Util.CharsTrie)">
            <param name="adoptBreakIterator">Break iterator to adopt.</param>
            <param name="forwardsPartialTrie">Forward &amp; partial char trie to adopt.</param>
            <param name="backwardsTrie">Backward trie to adopt.</param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.ResetState">
            <summary>
            Reset the filter from the delegate.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.BreakExceptionAt(System.Int32)">
            <summary>
            Is there an exception at this point?
            </summary>
            <param name="n">The location of the possible break.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.InternalNext(System.Int32)">
            <summary>
            Given that the delegate has already given its "initial" answer,
            find the NEXT actual (non-suppressed) break.
            </summary>
            <param name="n">Initial position from delegate.</param>
            <returns>New break position or <see cref="F:ICU4N.Text.BreakIterator.Done"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.InternalPrev(System.Int32)">
            <summary>
            Given that the delegate has already given its "initial" answer,
            find the PREV actual (non-suppressed) break.
            </summary>
            <param name="n">Initial position from delegate.</param>
            <returns>New break position or <see cref="F:ICU4N.Text.BreakIterator.Done"/>.</returns>
        </member>
        <member name="F:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.Builder.filterSet">
            <summary>
            Filter set to store all exceptions.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.Builder.#ctor(ICU4N.Util.ULocale)">
            <summary>
            Create <see cref="T:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.Builder"/> using given locale.
            </summary>
            <param name="loc">The locale to get filtered iterators.</param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.Builder.#ctor">
            <summary>
            Create <see cref="T:ICU4N.Impl.SimpleFilteredSentenceBreakIterator.Builder"/> with no exception.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.SimpleFormatterImpl">
            <summary>
            Formats simple patterns like "{1} was born in {0}".
            Internal version of <see cref="T:ICU4N.Text.SimpleFormatter"/>
            with only static methods, to avoid wrapper objects.
            </summary>
            <remarks>
            This class "compiles" pattern strings into a binary format
            and implements formatting etc. based on that.
            <para/>
            Format:
            Index 0: One more than the highest argument number.
            Followed by zero or more arguments or literal-text segments.
            <para/>
            An argument is stored as its number, less than <see cref="F:ICU4N.Impl.SimpleFormatterImpl.ARG_NUM_LIMIT"/>.
            A literal-text segment is stored as its length (at least 1) offset by <see cref="F:ICU4N.Impl.SimpleFormatterImpl.ARG_NUM_LIMIT"/>,
            followed by that many chars.
            </remarks>
        </member>
        <member name="F:ICU4N.Impl.SimpleFormatterImpl.ARG_NUM_LIMIT">
            <summary>
            Argument numbers must be smaller than this limit.
            Text segment lengths are offset by this much.
            This is currently the only unused char value in compiled patterns,
            except it is the maximum value of the first unit (max arg +1).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SimpleFormatterImpl.SEGMENT_LENGTH_ARGUMENT_CHAR">
            <summary>
            Initial and maximum char/UChar value set for a text segment.
            Segment length char values are from ARG_NUM_LIMIT+1 to this value here.
            Normally 0xffff, but can be as small as ARG_NUM_LIMIT+1 for testing.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SimpleFormatterImpl.MAX_SEGMENT_LENGTH">
            <summary>
            Maximum length of a text segment. Longer segments are split into shorter ones.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SimpleFormatterImpl.COMMON_PATTERNS">
            <summary>
            "Intern" some common patterns.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)">
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <returns>The max argument number + 1.</returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.GetTextWithNoArguments(System.String)">
            <summary>
            Returns the pattern text with none of the arguments.
            Like formatting with all-empty string values.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.String,System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.Text.StringBuilder,System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.Char[],System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.String[])">
            <summary>
            Formats the given values.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="values"></param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.Text.StringBuilder[])">
            <summary>
            Formats the given values.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="values"></param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.Char[][])">
            <summary>
            Formats the given values.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="values"></param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="values"></param>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatRawPattern(System.String,System.Int32,System.Int32,System.String[])">
            <summary>
            Formats the not-compiled pattern with the given values.
            Equivalent to <see cref="M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.String,System.Text.StringBuilder,System.Int32,System.Int32)"/> 
            followed by <see cref="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.String[])"/>.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">Not-compiled form of a pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <param name="values"></param>
            <returns>The compiled-pattern string.</returns>
            <exception cref="T:System.ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatRawPattern(System.String,System.Int32,System.Int32,System.Text.StringBuilder[])">
            <summary>
            Formats the not-compiled pattern with the given values.
            Equivalent to <see cref="M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.Text.StringBuilder,System.Text.StringBuilder,System.Int32,System.Int32)"/> 
            followed by <see cref="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.Text.StringBuilder[])"/>.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">Not-compiled form of a pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <param name="values"></param>
            <returns>The compiled-pattern string.</returns>
            <exception cref="T:System.ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatRawPattern(System.String,System.Int32,System.Int32,System.Char[][])">
            <summary>
            Formats the not-compiled pattern with the given values.
            Equivalent to <see cref="M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(System.Char[],System.Text.StringBuilder,System.Int32,System.Int32)"/> 
            followed by <see cref="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,System.Char[][])"/>.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">Not-compiled form of a pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <param name="values"></param>
            <returns>The compiled-pattern string.</returns>
            <exception cref="T:System.ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatRawPattern(System.String,System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the not-compiled pattern with the given values.
            Equivalent to <see cref="M:ICU4N.Impl.SimpleFormatterImpl.CompileToStringMinMaxArguments(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,System.Int32,System.Int32)"/> 
            followed by <see cref="M:ICU4N.Impl.SimpleFormatterImpl.FormatCompiledPattern(System.String,ICU4N.Support.Text.ICharSequence[])"/>.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">Not-compiled form of a pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <param name="values"></param>
            <returns>The compiled-pattern string.</returns>
            <exception cref="T:System.ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndAppend(System.String,System.Text.StringBuilder,System.Int32[],System.String[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as <paramref name="appendTo"/>.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            Can be null if <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>==0.
            </param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndAppend(System.String,System.Text.StringBuilder,System.Int32[],System.Text.StringBuilder[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as <paramref name="appendTo"/>.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            Can be null if <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>==0.
            </param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndAppend(System.String,System.Text.StringBuilder,System.Int32[],System.Char[][])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as <paramref name="appendTo"/>.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            Can be null if <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>==0.
            </param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndAppend(System.String,System.Text.StringBuilder,System.Int32[],ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as <paramref name="appendTo"/>.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            Can be null if <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>==0.
            </param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndReplace(System.String,System.Text.StringBuilder,System.Int32[],System.String[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            </param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndReplace(System.String,System.Text.StringBuilder,System.Int32[],System.Text.StringBuilder[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            </param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndReplace(System.String,System.Text.StringBuilder,System.Int32[],System.Char[][])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            </param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:ICU4N.Impl.SimpleFormatterImpl.FormatAndReplace(System.String,System.Text.StringBuilder,System.Int32[],ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="compiledPattern">Compiled form of a pattern string.</param>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="M:ICU4N.Impl.SimpleFormatterImpl.GetArgumentLimit(System.String)"/>.
            </param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="T:ICU4N.Impl.AnonymousSoftCache`3">
            <summary>
            Generic, thread-safe cache implementation.
            </summary>
            <remarks>
            To use, pass a delegate that implements the <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> method.
            </remarks>
            <typeparam name="K">Cache lookup key type</typeparam>
            <typeparam name="V">Cache instance value type (must not be a CacheValue)</typeparam>
            <typeparam name="D">Data type for creating a new instance value</typeparam>
            <seealso cref="T:ICU4N.Impl.SoftCache`3"/>
            <seealso cref="T:ICU4N.Impl.CacheBase`3"/>
            <author>Shad Storhaug</author>
        </member>
        <member name="T:ICU4N.Impl.SoftCache`3">
            <summary>
            Generic, thread-safe cache implementation.
            </summary>
            <remarks>
            To use, instantiate a subclass which implements the <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> method,
            and call Get() with the key and the data. The Get() call will use the data
            only if it needs to call <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/>, otherwise the data is ignored.
            <para/>
            When caching instances while the CacheValue "strength" is <see cref="F:ICU4N.Impl.CacheValueStrength.Soft"/>,
            the runtime can later release these instances once they are not used any more at all.
            If such an instance is then requested again, the <see cref="M:ICU4N.Impl.SoftCache`3.GetInstance(`0,`2)"/> method 
            will call <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> again and reset the CacheValue.
            The cache holds on to its map of keys to CacheValues forever.
            <para/>
            A value can be null if <see cref="M:ICU4N.Impl.CacheBase`3.CreateInstance(`0,`2)"/> returns null.
            In this case, it must do so consistently for the same key and data.
            </remarks>
            <typeparam name="K">Cache lookup key type</typeparam>
            <typeparam name="V">Cache instance value type (must not be a CacheValue)</typeparam>
            <typeparam name="D">Data type for creating a new instance value</typeparam>
            <author>Markus Scherer, Mark Davis</author>
        </member>
        <member name="T:ICU4N.Impl.SortedSetRelation">
            <summary>
            Computationally efficient determination of the relationship between
            two SortedSets.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.A_NOT_B">
            <summary>
            The relationship between two sets A and B can be determined by looking at:
            <list type="bullet">
                <item><description>A - B</description></item>
                <item><description>A &amp; B (intersection)</description></item>
                <item><description>B - A</description></item>
            </list>
            These are represented by a set of bits.
            <list type="bullet">
                <item><description>Bit 2 is true if A - B is not empty</description></item>
                <item><description>Bit 1 is true if A &amp; B is not empty</description></item>
                <item><description>BIT 0 is true if B - A is not empty</description></item>
            </list>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.A_AND_B">
            <summary>
            The relationship between two sets A and B can be determined by looking at:
            <list type="bullet">
                <item><description>A - B</description></item>
                <item><description>A &amp; B (intersection)</description></item>
                <item><description>B - A</description></item>
            </list>
            These are represented by a set of bits.
            <list type="bullet">
                <item><description>Bit 2 is true if A - B is not empty</description></item>
                <item><description>Bit 1 is true if A &amp; B is not empty</description></item>
                <item><description>BIT 0 is true if B - A is not empty</description></item>
            </list>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.B_NOT_A">
            <summary>
            The relationship between two sets A and B can be determined by looking at:
            <list type="bullet">
                <item><description>A - B</description></item>
                <item><description>A &amp; B (intersection)</description></item>
                <item><description>B - A</description></item>
            </list>
            These are represented by a set of bits.
            <list type="bullet">
                <item><description>Bit 2 is true if A - B is not empty</description></item>
                <item><description>Bit 1 is true if A &amp; B is not empty</description></item>
                <item><description>BIT 0 is true if B - A is not empty</description></item>
            </list>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.ANY">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.CONTAINS">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.DISJOINT">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.ISCONTAINED">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.NO_B">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.EQUALS">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.NO_A">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.NONE">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.ADDALL">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.A">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.COMPLEMENTALL">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.B">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.REMOVEALL">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.RETAINALL">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.SortedSetRelation.B_REMOVEALL">
            <summary>
            There are 8 combinations of the relationship bits. These correspond to
            the filters (combinations of allowed bits) in <see cref="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})"/>. They also
            correspond to the modification functions, listed in comments.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.SortedSetRelation.HasRelation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})">
            <summary>
            Utility that could be on SortedSet. Faster implementation than
            what is in .NET for doing contains, equals, etc.
            </summary>
            <typeparam name="T">Type of element. Must implement <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="a">First set.</param>
            <param name="allow">Filter, using <see cref="F:ICU4N.Impl.SortedSetRelation.ANY"/>, <see cref="F:ICU4N.Impl.SortedSetRelation.CONTAINS"/>, etc.</param>
            <param name="b">Second set.</param>
            <returns>Whether the filter relationship is true or not.</returns>
        </member>
        <member name="M:ICU4N.Impl.SortedSetRelation.DoOperation``1(System.Collections.Generic.SortedSet{``0},System.Int32,System.Collections.Generic.SortedSet{``0})">
            <summary>
            Utility that could be on SortedSet. Allows faster implementation than
            what is in .NET for doing UnionWith, ExceptWith, IntersectWith, (complementAll).
            </summary>
            <typeparam name="T">Type of element. Must implement <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="a">First set.</param>
            <param name="relation">Relation the relation filter, using <see cref="F:ICU4N.Impl.SortedSetRelation.ANY"/>, <see cref="F:ICU4N.Impl.SortedSetRelation.CONTAINS"/>, etc.</param>
            <param name="b">Second set.</param>
            <returns>The new set.</returns>
        </member>
        <member name="T:ICU4N.Impl.StandardPlural">
            <summary>
            Standard CLDR plural form/category constants.
            See http://www.unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.Zero">
            <summary>
            Zero
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.One">
            <summary>
            One
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.Two">
            <summary>
            Two
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.Few">
            <summary>
            Few
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.Many">
            <summary>
            Many
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StandardPlural.Other">
            <summary>
            Other
            </summary>
        </member>
        <member name="T:ICU4N.Impl.StandardPluralUtil">
            <summary>
            Utilities for working with the <see cref="T:ICU4N.Impl.StandardPlural"/> enum.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.StandardPluralUtil.Values">
            <summary>
            Gets an unmodifiable List of all standard plural form constants.
            <see cref="T:System.Collections.Generic.IList`1"/> version of <see cref="T:ICU4N.Impl.StandardPlural"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.StandardPluralUtil.Count">
            <summary>
            Gets the number of standard plural forms/categories.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.GetKeyword(ICU4N.Impl.StandardPlural)">
            <summary>
            The lowercase CLDR keyword string for the plural form.
            </summary>
            <param name="standardPlural">This <see cref="T:ICU4N.Impl.StandardPlural"/>.</param>
            <returns>The lowercase CLDR keyword string for the plural form.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrNullFromString(System.String)">
            <summary>
            Returns the plural form corresponding to the keyword, or <c>null</c>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or null.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrNullFromString(System.Text.StringBuilder)">
            <summary>
            Returns the plural form corresponding to the keyword, or <c>null</c>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or null.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrNullFromString(System.Char[])">
            <summary>
            Returns the plural form corresponding to the keyword, or <c>null</c>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or null.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrNullFromString(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the plural form corresponding to the keyword, or <c>null</c>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or null.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrOtherFromString(System.String)">
            <summary>
            Returns the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrOtherFromString(System.Text.StringBuilder)">
            <summary>
            Returns the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrOtherFromString(System.Char[])">
            <summary>
            Returns the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.OrOtherFromString(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryFromString(System.String,ICU4N.Impl.StandardPlural@)">
            <summary>
            Returns the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">>When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(StandardPlural)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryFromString(System.Text.StringBuilder,ICU4N.Impl.StandardPlural@)">
            <summary>
            Returns the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">>When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(StandardPlural)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryFromString(System.Char[],ICU4N.Impl.StandardPlural@)">
            <summary>
            Returns the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">>When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(StandardPlural)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryFromString(ICU4N.Support.Text.ICharSequence,ICU4N.Impl.StandardPlural@)">
            <summary>
            Returns the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">>When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(StandardPlural)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrNegativeFromString(System.String)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or a negative value.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or a negative value.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrNegativeFromString(System.Text.StringBuilder)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or a negative value.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or a negative value.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrNegativeFromString(System.Char[])">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or a negative value.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or a negative value.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrNegativeFromString(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or a negative value.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or a negative value.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrOtherIndexFromString(System.String)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrOtherIndexFromString(System.Text.StringBuilder)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrOtherIndexFromString(System.Char[])">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.IndexOrOtherIndexFromString(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <returns>The index of the plural form corresponding to the keyword, or <see cref="F:ICU4N.Impl.StandardPlural.Other"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryIndexFromString(System.String,System.Int32@)">
            <summary>
            Gets the index of the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(int)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryIndexFromString(System.Text.StringBuilder,System.Int32@)">
            <summary>
            Gets the index of the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(int)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryIndexFromString(System.Char[],System.Int32@)">
            <summary>
            Gets the index of the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(int)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:ICU4N.Impl.StandardPluralUtil.TryIndexFromString(ICU4N.Support.Text.ICharSequence,System.Int32@)">
            <summary>
            Gets the index of the plural form corresponding to the keyword.
            </summary>
            <param name="keyword">Keyword for example "few" or "other".</param>
            <param name="result">When this method returns, contains the index of the plural form corresponding to the keyword, otherwise
            <see cref="T:default(int)"/>. This parameter is passed uninitialized.</param>
            <returns><c>true</c> if the <paramref name="keyword"/> is valid; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:ICU4N.Impl.StringPrepDataReader">
            <author>ram</author>
        </member>
        <member name="M:ICU4N.Impl.StringPrepDataReader.#ctor(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Private constructor.
            </summary>
            <param name="bytes">ICU StringPrep data file buffer.</param>
            <exception cref="T:System.IO.IOException">If data file fails authentication.</exception>
        </member>
        <member name="F:ICU4N.Impl.StringPrepDataReader.byteBuffer">
            <summary>
            ICU data file input stream
            </summary>
        </member>
        <member name="F:ICU4N.Impl.StringPrepDataReader.DATA_FORMAT_ID">
            File format version that this class understands.
            No guarantees are made if a older version is used
            see store.c of gennorm for more information and values
        </member>
        <member name="M:ICU4N.Impl.StringRange.IAdder.Add(System.String,System.String)">
            <param name="start"></param>
            <param name="end">May be null, for adding single string.</param>
        </member>
        <member name="M:ICU4N.Impl.StringRange.Compact(System.Collections.Generic.ISet{System.String},ICU4N.Impl.StringRange.IAdder,System.Boolean,System.Boolean)">
            <summary>
            Compact the set of strings.
            </summary>
            <param name="source">Set of strings.</param>
            <param name="adder">Adds each pair to the output. See the <see cref="T:ICU4N.Impl.StringRange.IAdder"/> interface.</param>
            <param name="shorterPairs">Use abc-d instead of abc-abd.</param>
            <param name="moreCompact">Use a more compact form, at the expense of more processing. If false, source must be sorted.</param>
        </member>
        <member name="M:ICU4N.Impl.StringRange.Compact(System.Collections.Generic.ISet{System.String},ICU4N.Impl.StringRange.IAdder,System.Boolean)">
            <summary>
            Faster but not as good compaction. Only looks at final codepoint.
            </summary>
            <param name="source">Set of strings.</param>
            <param name="adder">Adds each pair to the output. See the <see cref="T:ICU4N.Impl.StringRange.IAdder"/> interface.</param>
            <param name="shorterPairs">Use abc-d instead of abc-abd.</param>
        </member>
        <member name="T:ICU4N.Impl.Trie">
            <summary>
            A trie is a kind of compressed, serializable table of values
            associated with Unicode code points (0..0x10ffff).
            </summary>
            <remarks>
            This class defines the basic structure of a trie and provides methods
            to <b>retrieve the offsets to the actual data</b>.
            <para/>
            Data will be the form of an array of basic types, char or int.
            <para/>
            The actual data format will have to be specified by the user in the
            interface <see cref="T:ICU4N.Impl.Trie.IDataManipulate"/>.
            <para/>
            This trie implementation is optimized for getting offset while walking
            forward through a UTF-16 string.
            Therefore, the simplest and fastest access macros are the
            fromLead() and fromOffsetTrail() methods.
            The fromBMP() method are a little more complicated; they get offsets even
            for lead surrogate codepoints, while the fromLead() method get special
            "folded" offsets for lead surrogate code units if there is relevant data
            associated with them.
            From such a folded offsets, an offset needs to be extracted to supply
            to the fromOffsetTrail() methods.
            To handle such supplementary codepoints, some offset information are kept
            in the data.
            <para/>
            Methods in <see cref="T:ICU4N.Impl.Trie.IDataManipulate"/> are called to retrieve
            that offset from the folded value for the lead surrogate unit.
            <para/>
            For examples of use, see <see cref="T:ICU4N.Impl.CharTrie"/> or
            <see cref="T:ICU4N.Impl.Int32Trie"/>.
            </remarks>
            <author>synwee</author>
            <seealso cref="T:ICU4N.Impl.CharTrie"/>
            <seealso cref="T:ICU4N.Impl.Int32Trie"/>
            <since>release 2.1, Jan 01 2002</since>
        </member>
        <member name="T:ICU4N.Impl.Trie.IDataManipulate">
            <summary>
            Character data in <see cref="T:ICU4N.Impl.Trie"/> have different user-specified format
            for different purposes.
            This interface specifies methods to be implemented in order for
            <see cref="T:ICU4N.Impl.Trie"/> to surrogate offset information encapsulated within
            the data.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie.IDataManipulate.GetFoldingOffset(System.Int32)">
            <summary>
            Called by <see cref="T:ICU4N.Impl.Trie"/> to extract from a lead surrogate's
            data.
            The index array offset of the indexes for that lead surrogate.
            </summary>
            <param name="value">Data value for a surrogate from the trie, including the folding offset.</param>
            <returns>Offset or 0 if there is no data for the lead surrogate.</returns>
        </member>
        <member name="P:ICU4N.Impl.Trie.IsLatin1Linear">
            <summary>
            Determines if this trie has a linear latin 1 array. 
            Returns true if this trie has a linear latin 1 array, false otherwise.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie.Equals(System.Object)">
            <summary>
            Checks if the argument <see cref="T:ICU4N.Impl.Trie"/> has the same data as this <see cref="T:ICU4N.Impl.Trie"/>.
            Attributes are checked but not the index data.
            </summary>
            <param name="other"><see cref="T:ICU4N.Impl.Trie"/> to check.</param>
            <returns>true if the argument <see cref="T:ICU4N.Impl.Trie"/> has the same data as this <see cref="T:ICU4N.Impl.Trie"/>, false otherwise.</returns>
        </member>
        <member name="P:ICU4N.Impl.Trie.SerializedDataSize">
            <summary>
            Gets the serialized data file size of the <see cref="T:ICU4N.Impl.Trie"/> in terms of the 
            number of bytes. This is used during trie data reading for size checking purposes.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie.#ctor(ICU4N.Support.IO.ByteBuffer,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Trie constructor for <see cref="T:ICU4N.Impl.CharTrie"/> use.
            </summary>
            <param name="bytes">Data of an ICU data file, containing the trie.</param>
            <param name="dataManipulate">Object containing the information to parse the trie data.</param>
        </member>
        <member name="M:ICU4N.Impl.Trie.#ctor(System.Char[],System.Int32,ICU4N.Impl.Trie.IDataManipulate)">
            <summary>
            Trie constructor.
            </summary>
            <param name="index">Array to be used for index.</param>
            <param name="options">Options used by the trie.</param>
            <param name="dataManipulate">Object containing the information to parse the trie data.</param>
        </member>
        <member name="F:ICU4N.Impl.Trie.LEAD_INDEX_OFFSET_">
            <summary>
            Lead surrogate code points' index displacement in the index array.
            <code>
            0x10000-0xd800=0x2800
            0x2800 >> INDEX_STAGE_1_SHIFT_
            </code>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.INDEX_STAGE_1_SHIFT_">
            <summary>
            Shift size for shifting right the input index. 1..9
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.INDEX_STAGE_2_SHIFT_">
            <summary>
            Shift size for shifting left the index array values.
            Increases possible data size with 16-bit index values at the cost
            of compactability.
            This requires blocks of stage 2 data to be aligned by
            DATA_GRANULARITY.
            <code>
            0..INDEX_STAGE_1_SHIFT
            </code>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.DATA_BLOCK_LENGTH">
            <summary>
            Number of data values in a stage 2 (data array) block.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.INDEX_STAGE_3_MASK_">
            <summary>
            Mask for getting the lower bits from the input index.
            <see cref="F:ICU4N.Impl.Trie.DATA_BLOCK_LENGTH"/> - 1.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.SURROGATE_BLOCK_BITS">
            <summary>Number of bits of a trail surrogate that are used in index table lookups.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.SURROGATE_BLOCK_COUNT">
            <summary>
            Number of index (stage 1) entries per lead surrogate.
            Same as number of index entries for 1024 trail surrogates,
            ==0x400>><see cref="F:ICU4N.Impl.Trie.INDEX_STAGE_1_SHIFT_"/>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.BMP_INDEX_LENGTH">
            <summary>Length of the BMP portion of the index (stage 1) array.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.SURROGATE_MASK_">
            <summary>
            Surrogate mask to use when shifting offset to retrieve supplementary
            values.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_index_">
            <summary>
            Index or UTF16 characters
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_dataManipulate_">
            <summary>
            Internal TrieValue which handles the parsing of the data value.
            This class is to be implemented by the user.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_dataOffset_">
            <summary>
            Start index of the data portion of the trie. <see cref="T:ICU4N.Impl.CharTrie"/> combines
            index and data into a char array, so this is used to indicate the
            initial offset to the data portion.
            Note this index always points to the initial value.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_dataLength_">
            <summary>
            Length of the data array
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie.GetSurrogateOffset(System.Char,System.Char)">
            <summary>
            Gets the offset to the data which the surrogate pair points to.
            </summary>
            <param name="lead">Lead surrogate.</param>
            <param name="trail">Trailing surrogate.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="P:ICU4N.Impl.Trie.Item(System.Int32)">
            <summary>
            Gets the value at the argument index.
            </summary>
            <param name="index">Value at index will be retrieved.</param>
            <returns>32 bit value.</returns>
        </member>
        <member name="P:ICU4N.Impl.Trie.InitialValue">
            <summary>
            Gets the default initial 32 bit value.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie.GetRawOffset(System.Int32,System.Char)">
            <summary>
            Gets the offset to the data which the index ch after variable offset
            points to.
            </summary>
            <remarks>
            Note for locating a non-supplementary character data offset, calling
            <see cref="M:ICU4N.Impl.Trie.GetRawOffset(System.Int32,System.Char)"/> will do. Otherwise if it is a supplementary character formed by
            surrogates lead and trail. Then we would have to call <see cref="M:ICU4N.Impl.Trie.GetRawOffset(System.Int32,System.Char)"/>
            with GetFoldingIndexOffset(). See <see cref="M:ICU4N.Impl.Trie.GetSurrogateOffset(System.Char,System.Char)"/>.
            </remarks>
            <param name="offset">Index offset which <paramref name="ch"/> is to start from.</param>
            <param name="ch">Index to be used after offset.</param>
            <returns>Offset to the data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie.GetBMPOffset(System.Char)">
            <summary>
            Gets the offset to data which the BMP character points to
            Treats a lead surrogate as a normal code point.
            </summary>
            <param name="ch">BMP character.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie.GetLeadOffset(System.Char)">
            <summary>
            Gets the offset to the data which this lead surrogate character points
            to. Data at the returned offset may contain folding offset information for
            the next trailing surrogate character.
            </summary>
            <param name="ch">Lead surrogate character.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie.GetCodePointOffset(System.Int32)">
            <summary>
            Internal trie getter from a code point.
            Could be faster(?) but longer with
            <code>
                if((c32)&lt;=0xd7ff) { (result)=_TRIE_GET_RAW(trie, data, 0, c32); }
            </code>
            Gets the offset to data which the codepoint points to.
            </summary>
            <param name="ch">Codepoint.</param>
            <returns>Offset to data.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie.Unserialize(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Parses the byte buffer and creates the trie index with it.
            <para/>
            The position of the input <see cref="T:ICU4N.Support.IO.ByteBuffer"/> must be right after the trie header.
            <para/>
            This is overwritten by the child classes.
            </summary>
            <param name="bytes">Buffer containing trie data.</param>
        </member>
        <member name="P:ICU4N.Impl.Trie.IsInt32Trie">
            <summary>
            Determines if this is a 32 bit trie. Returns true if options specifies this is a 32 bit trie.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Trie.IsCharTrie">
            <summary>
            Determines if this is a 16 bit trie. Returns true if this is a 16 bit trie.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.HEADER_LENGTH_">
            <summary>
            Size of <see cref="T:ICU4N.Impl.Trie"/> header in bytes
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_">
            <summary>
            Latin 1 option mask
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.HEADER_SIGNATURE_">
            <summary>
            Constant number to authenticate the byte block
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.HEADER_OPTIONS_SHIFT_MASK_">
            <summary>
            Header option formatting
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_isLatin1Linear_">
            <summary>
            Flag indicator for Latin quick access data block
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie.m_options_">
            <summary>
            Trie options field.
            </summary>
            <remarks>
            Options bit field:
            <list type="bullet">
                <item><description>9  1 = Latin-1 data is stored linearly at data + <see cref="F:ICU4N.Impl.Trie.DATA_BLOCK_LENGTH"/></description></item>
                <item><description>8  0 = 16-bit data, 1=32-bit data</description></item>
                <item><description>7..4  <see cref="F:ICU4N.Impl.Trie.INDEX_STAGE_1_SHIFT_"/>   // 0..<see cref="F:ICU4N.Impl.Trie.INDEX_STAGE_2_SHIFT_"/></description></item>
                <item><description>3..0  INDEX_STAGE_2_SHIFT   // 1..9</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie.CheckHeader(System.Int32)">
            <summary>
            Authenticates raw data header.
            Checking the header information, signature and options.
            </summary>
            <param name="signature">This contains the options and type of a <see cref="T:ICU4N.Impl.Trie"/>.</param>
            <returns>true if the header is authenticated valid.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Impl.IValueMapper" -->
        <member name="T:ICU4N.Impl.Trie2">
            <summary>
            This is the interface and common implementation of a Unicode <see cref="T:ICU4N.Impl.Trie2"/>.
            It is a kind of compressed table that maps from Unicode code points (0..0x10ffff)
            to 16- or 32-bit integer values.  It works best when there are ranges of
            characters with the same value, which is generally the case with Unicode
            character properties.
            <para/>
            This is the second common version of a Unicode trie (hence the name Trie2).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2.CreateFromSerialized(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.Trie2"/> from its serialized form.  Inverse of utrie2_serialize().
            </summary>
            <remarks>
            Reads from the current position and leaves the buffer after the end of the trie.
            <para/>
            The serialized format is identical between ICU4C, ICU4J, and ICU4N, so this function
            will work with serialized <see cref="T:ICU4N.Impl.Trie2"/>s from any.
            <para/>
            The actual type of the returned <see cref="T:ICU4N.Impl.Trie2"/> will be either <see cref="T:ICU4N.Impl.Trie2_16"/> or <see cref="T:ICU4N.Impl.Trie2_32"/>, depending
            on the width of the data.
            <para/>
            To obtain the width of the <see cref="T:ICU4N.Impl.Trie2"/>, check the actual class type of the returned <see cref="T:ICU4N.Impl.Trie2"/>.
            Or use the <see cref="M:ICU4N.Impl.Trie2_16.CreateFromSerialized(ICU4N.Support.IO.ByteBuffer)"/> or <see cref="M:ICU4N.Impl.Trie2_32.CreateFromSerialized(ICU4N.Support.IO.ByteBuffer)"/> method, which will
            return only <see cref="T:ICU4N.Impl.Trie"/>s of their specific type/size.
            <para/>
            The serialized <see cref="T:ICU4N.Impl.Trie2"/> on the stream may be in either little or big endian byte order.
            This allows using serialized <see cref="T:ICU4N.Impl.Trie"/>s from ICU4C without needing to consider the
            byte order of the system that created them.
            </remarks>
            <param name="bytes">A byte buffer to the serialized form of a UTrie2.</param>
            <returns>An unserialized <see cref="T:ICU4N.Impl.Trie2"/>, ready for use.</returns>
            <exception cref="T:System.ArgumentException">If the stream does not contain a serialized <see cref="T:ICU4N.Impl.Trie2"/>.</exception>
            <exception cref="T:System.IO.IOException">If a read error occurs in the buffer.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetVersion(System.IO.Stream,System.Boolean)">
            <summary>
            Get the UTrie version from a <see cref="T:System.IO.Stream"/> containing the serialized form
            of either a <see cref="T:ICU4N.Impl.Trie"/> (version 1) or a <see cref="T:ICU4N.Impl.Trie2"/> (version 2).
            </summary>
            <param name="input">A <see cref="T:System.IO.Stream"/> containing the serialized form
            of a UTrie, version 1 or 2.  The stream must be seekable.
            The position of the input stream will be left unchanged.</param>
            <param name="littleEndianOk">If FALSE, only big-endian (Java native) serialized forms are recognized.
            If TRUE, little-endian serialized forms are recognized as well.</param>
            <returns>The Trie version of the serialized form, or 0 if it is not
            recognized as a serialized UTrie.</returns>
            <exception cref="T:System.IO.IOException">On errors in reading from the input stream.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2.Get(System.Int32)">
            <summary>
            Get the value for a code point as stored in the <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <param name="codePoint">The code point.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetFromU16SingleLead(System.Char)">
            <summary>
            Get the trie value for a UTF-16 code unit.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Impl.Trie2"/> stores two distinct values for input in the lead surrogate
            range, one for lead surrogates, which is the value that will be
            returned by this function, and a second value that is returned
            by <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/>.
            <para/>
            For code units outside of the lead surrogate range, this function
            returns the same result as <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/>.
            <para/>
            This function, together with the alternate value for lead surrogates,
            makes possible very efficient processing of UTF-16 strings without
            first converting surrogate pairs to their corresponding 32 bit code point
            values.
            <para/>
            At build-time, enumerate the contents of the <see cref="T:ICU4N.Impl.Trie2"/> to see if there
            is non-trivial (non-initialValue) data for any of the supplementary
            code points associated with a lead surrogate.
            If so, then set a special (application-specific) value for the
            lead surrogate code _unit_, with <see cref="M:ICU4N.Impl.Trie2Writable.SetForLeadSurrogateCodeUnit(System.Char,System.Int32)"/>.
            <para/>
            At runtime, use <see cref="M:ICU4N.Impl.Trie2.GetFromU16SingleLead(System.Char)"/>. If there is non-trivial
            data and the code unit is a lead surrogate, then check if a trail surrogate
            follows. If so, assemble the supplementary code point and look up its value
            with <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/>; otherwise reset the lead
            surrogate's value or do a code point lookup for it.
            <para/>
            If there is only trivial data for lead and trail surrogates, then processing
            can often skip them. For example, in normalization or case mapping
            all characters that do not have any mappings are simply copied as is.
            </remarks>
            <param name="c">The code point or lead surrogate value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.Equals(System.Object)">
            <summary>
            Equals function.  Two <see cref="T:ICU4N.Impl.Trie"/>s are equal if their contents are equal.
            The type need not be the same, so a <see cref="T:ICU4N.Impl.Trie2Writable"/> will be equal to
            (read-only) <see cref="T:ICU4N.Impl.Trie2_16"/> or <see cref="T:ICU4N.Impl.Trie2_32"/> so long as they are storing the same values.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Trie2.Range">
            <summary>
            When iterating over the contents of a <see cref="T:ICU4N.Impl.Trie2"/>, Elements of this type are produced.
            The iterator will return one item for each contiguous range of codepoints  having the same value.
            </summary>
            <remarks>
            When iterating, the same <see cref="T:ICU4N.Impl.Trie2.Range"/> object will be reused and returned for each range.
            If you need to retain complete iteration results, clone each returned <see cref="T:ICU4N.Impl.Trie2.Range"/>,
            or save the range in some other way, before advancing to the next iteration step.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetEnumerator">
            <summary>
            Create an enumerator over the value ranges in this <see cref="T:ICU4N.Impl.Trie2"/>.
            Values from the <see cref="T:ICU4N.Impl.Trie2"/> are not remapped or filtered, but are returned as they
            are stored in the <see cref="T:ICU4N.Impl.Trie2"/>.
            <para/>
            Note that this method was named iterator() in ICU4J.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetEnumerator(ICU4N.Impl.IValueMapper)">
            <summary>
            Create an enumerator over the value ranges from this <see cref="T:ICU4N.Impl.Trie2"/>.
            Values from the <see cref="T:ICU4N.Impl.Trie2"/> are passed through a caller-supplied remapping function,
            and it is the remapped values that determine the ranges that
            will be produced by the iterator.
            <para/>
            Note that this method was named iterator(ValueMapper) in ICU4J.
            </summary>
            <param name="mapper">Provides a function to remap values obtained from the <see cref="T:ICU4N.Impl.Trie2"/>.</param>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetEnumeratorForLeadSurrogate(System.Char,ICU4N.Impl.IValueMapper)">
            <summary>
            Create an enumerator over the <see cref="T:ICU4N.Impl.Trie2"/> values for the 1024=0x400 code points
            corresponding to a given <paramref name="lead"/> surrogate.
            <para/>
            For example, for the lead surrogate U+D87E it will enumerate the values
            for [U+2F800..U+2FC00[.
            <para/>
            Note that this method was named iteratorForLeadSurrogate(char, ValueMapper) in ICU4J.
            </summary>
            <remarks>
            Used by data builder code that sets special lead surrogate code unit values
            for optimized UTF-16 string processing.
            <para/>
            Do not modify the <see cref="T:ICU4N.Impl.Trie2"/> during the iteration.
            <para/>
            Except for the limited code point range, this functions just like <see cref="M:ICU4N.Impl.Trie2.GetEnumerator"/>.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetEnumeratorForLeadSurrogate(System.Char)">
            <summary>
            Create an enumerator over the <see cref="T:ICU4N.Impl.Trie2"/> values for the 1024=0x400 code points
            corresponding to a given lead surrogate.
            <para/>
            For example, for the lead surrogate U+D87E it will enumerate the values
            for [U+2F800..U+2FC00[.
            <para/>
            Note that this method was named iteratorForLeadSurrogate(char) in ICU4J.
            </summary>
            <remarks>
            Used by data builder code that sets special lead surrogate code unit values
            for optimized UTF-16 string processing.
            <para/>
            Do not modify the <see cref="T:ICU4N.Impl.Trie2"/> during the iteration.
            <para/>
            Except for the limited code point range, this functions just like <see cref="M:ICU4N.Impl.Trie2.GetEnumerator"/>.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2.SerializeHeader(ICU4N.Support.IO.DataOutputStream)">
            <summary>
            Serialize a <see cref="T:ICU4N.Impl.Trie2"/> Header and Index onto a <see cref="T:ICU4N.Support.IO.DataOutputStream"/>.  This is
            common code used for both the <see cref="T:ICU4N.Impl.Trie2_16"/> and <see cref="T:ICU4N.Impl.Trie2_32"/> serialize functions.
            </summary>
            <param name="dos">The stream to which the serialized <see cref="T:ICU4N.Impl.Trie2"/> data will be written.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="T:ICU4N.Impl.Trie2.CharSequenceValues">
            <summary>
            Struct-like class for holding the results returned by a UTrie2 <see cref="T:ICU4N.Support.Text.ICharSequence"/> iterator.
            The iteration walks over a <see cref="T:ICU4N.Support.Text.ICharSequence"/>, and for each Unicode code point therein
            returns the character and its associated <see cref="T:ICU4N.Impl.Trie2"/> value.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Trie2.CharSequenceValues.Index">
            <summary>String index of the current code point.</summary>
        </member>
        <member name="P:ICU4N.Impl.Trie2.CharSequenceValues.CodePoint">
            <summary>The code point at index.</summary>
        </member>
        <member name="P:ICU4N.Impl.Trie2.CharSequenceValues.Value">
            <summary>The <see cref="T:ICU4N.Impl.Trie2"/> value for the current code point.</summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetCharSequenceEnumerator(System.String,System.Int32)">
            <summary>
            Create an enumerator that will produce the values from the <see cref="T:ICU4N.Impl.Trie2"/> for
            the sequence of code points in an input text.
            </summary>
            <param name="text">A text string to be iterated over.</param>
            <param name="index">The starting iteration position within the input text.</param>
            <returns>The <see cref="T:ICU4N.Impl.Trie2.CharSequenceEnumerator"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetCharSequenceEnumerator(System.Text.StringBuilder,System.Int32)">
            <summary>
            Create an enumerator that will produce the values from the <see cref="T:ICU4N.Impl.Trie2"/> for
            the sequence of code points in an input text.
            </summary>
            <param name="text">A text string to be iterated over.</param>
            <param name="index">The starting iteration position within the input text.</param>
            <returns>The <see cref="T:ICU4N.Impl.Trie2.CharSequenceEnumerator"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetCharSequenceEnumerator(System.Char[],System.Int32)">
            <summary>
            Create an iterator that will produce the values from the Trie2 for
            the sequence of code points in an input text.
            </summary>
            <param name="text">A text string to be iterated over.</param>
            <param name="index">The starting iteration position within the input text.</param>
            <returns>The <see cref="T:ICU4N.Impl.Trie2.CharSequenceEnumerator"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2.GetCharSequenceEnumerator(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Create an enumerator that will produce the values from the <see cref="T:ICU4N.Impl.Trie2"/> for
            the sequence of code points in an input text.
            </summary>
            <param name="text">A text string to be iterated over.</param>
            <param name="index">The starting iteration position within the input text.</param>
            <returns>The <see cref="T:ICU4N.Impl.Trie2.CharSequenceEnumerator"/>.</returns>
        </member>
        <member name="T:ICU4N.Impl.Trie2.CharSequenceEnumerator">
            <summary>
            An enumerator that operates over an input <see cref="T:ICU4N.Support.Text.ICharSequence"/>, and for each Unicode code point
            in the input returns the associated value from the <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <remarks>
            This iterator can move forwards or backwards, and can be reset to an arbitrary index.
            <para/>
            Note that <see cref="T:ICU4N.Impl.Trie2_16"/> and <see cref="T:ICU4N.Impl.Trie2_32"/> subclass <see cref="T:ICU4N.Impl.Trie2.CharSequenceEnumerator"/>.  This is done
            only for performance reasons.  It does require that any changes made here be propagated
            into the corresponding code in the subclasses.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2.CharSequenceEnumerator.#ctor(ICU4N.Impl.Trie2,ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Trie2.ValueWidth">
            <summary>
            Selectors for the width of a UTrie2 data value.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Trie2.UTrie2Header">
            <summary>
            Trie2 data structure in serialized form:
            <code>
            UTrie2Header header;
            uint16_t index[header.index2Length];
            uint16_t data[header.shiftedDataLength&lt;&lt;2];  -- or uint32_t data[...]
            </code>
            For .NET, this is read from the stream into an instance of UTrie2Header.
            (The C version just places a struct over the raw serialized data.)
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.signature">
            <summary>"Tri2" in big-endian US-ASCII (0x54726932)</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.options">
            <summary>
            options bit field (uint16_t):
            <code>
            15.. 4   reserved (0)
            3.. 0   UTrie2ValueBits valueBits
            </code>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.indexLength">
            <summary>UTRIE2_INDEX_1_OFFSET..UTRIE2_MAX_INDEX_LENGTH  (uint16_t)</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.shiftedDataLength">
            <summary>(UTRIE2_DATA_START_OFFSET..UTRIE2_MAX_DATA_LENGTH)>>UTRIE2_INDEX_SHIFT  (uint16_t)</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.index2NullOffset">
            <summary>Null index and data blocks, not shifted.  (uint16_t)</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.dataNullOffset">
            <summary>Null index and data blocks, not shifted.  (uint16_t)</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTrie2Header.shiftedHighStart">
            <summary>
            First code point of the single-value range ending with U+10ffff,
            rounded up and then shifted right by UTRIE2_SHIFT_1.  (uint16_t)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.errorValue">
            <summary>Value returned for out-of-range code points and illegal UTF-8.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.highStart">
            <summary>Start of the last range which ends at U+10ffff, and its value.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_OPTIONS_VALUE_BITS_MASK">
            <summary>
            <see cref="T:ICU4N.Impl.Trie2"/> constants, defining shift widths, index array lengths, etc.
            <para/>
            These are needed for the runtime macros but users can treat these as
            implementation details and skip to the actual public API further below.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_1">
            <summary>Shift size for getting the index-1 table offset.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_2">
            <summary>Shift size for getting the index-2 table offset.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_1_2">
            <summary>
            Difference between the two shift sizes,
            for getting an index-1 offset from an index-2 offset. 6=11-5
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_OMITTED_BMP_INDEX_1_LENGTH">
            <summary>
            Number of index-1 entries for the BMP. 32=0x20
            This part of the index-1 table is omitted from the serialized form.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_CP_PER_INDEX_1_ENTRY">
            <summary>Number of code points per index-1 table entry. 2048=0x800</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_2_BLOCK_LENGTH">
            <summary>Number of entries in an index-2 block. 64=0x40</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_2_MASK">
            <summary>Mask for getting the lower bits for the in-index-2-block offset.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_DATA_BLOCK_LENGTH">
            <summary>Number of entries in a data block. 32=0x20</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_DATA_MASK">
            <summary>Mask for getting the lower bits for the in-data-block offset.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_SHIFT">
            <summary>
            Shift size for shifting left the index array values.
            Increases possible data size with 16-bit index values at the cost
            of compactability.
            This requires data blocks to be aligned by <see cref="F:ICU4N.Impl.Trie2.UTRIE2_DATA_GRANULARITY"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_DATA_GRANULARITY">
            <summary>The alignment size of a data block. Also the granularity for compaction.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_2_OFFSET">
            <summary>
            The BMP part of the index-2 table is fixed and linear and starts at offset 0.
            Length=2048=0x800=0x10000>><see cref="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_2"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_LSCP_INDEX_2_OFFSET">
            <summary>
            The part of the index-2 table for U+D800..U+DBFF stores values for
            lead surrogate code _units_ not code _points_.
            Values for lead surrogate code _points_ are indexed with this portion of the table.
            Length=32=0x20=0x400>><see cref="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_2"/>. (There are 1024=0x400 lead surrogates.)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_2_BMP_LENGTH">
            <summary>Count the lengths of both BMP pieces. 2080=0x820</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_UTF8_2B_INDEX_2_OFFSET">
            <summary>
            The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
            Length 32=0x20 for lead bytes C0..DF, regardless of <see cref="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_2"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_1_OFFSET">
            <summary>
            The index-1 table, only used for supplementary code points, at offset 2112=0x840.
            Variable length, for code points up to highStart, where the last single-value range starts.
            Maximum length 512=0x200=0x100000>><see cref="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_1"/>.
            <para/>
            (For 0x100000 supplementary code points U+10000..U+10ffff.)
            <para/>
            The part of the index-2 table for supplementary code points starts
            after this index-1 table.
            <para/>
            Both the index-1 table and the following part of the index-2 table
            are omitted completely if there is only BMP data.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_BAD_UTF8_DATA_OFFSET">
            <summary>
            The illegal-UTF-8 data block follows the ASCII block, at offset 128=0x80.
            Used with linear access for single bytes 0..0xbf for simple error handling.
            Length 64=0x40, not <see cref="F:ICU4N.Impl.Trie2.UTRIE2_DATA_BLOCK_LENGTH"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UTRIE2_DATA_START_OFFSET">
            <summary>The start of non-linear-ASCII data blocks, at offset 192=0xc0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UNEWTRIE2_INDEX_GAP_OFFSET">
            <summary>
            At build time, leave a gap in the index-2 table,
            at least as long as the maximum lengths of the 2-byte UTF-8 index-2 table
            and the supplementary index-1 table.
            Round up to <see cref="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_2_BLOCK_LENGTH"/> for proper compacting.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UNEWTRIE2_MAX_INDEX_2_LENGTH">
            <summary>
            Maximum length of the build-time index-2 array.
            Maximum number of Unicode code points (0x110000) shifted right by <see cref="F:ICU4N.Impl.Trie2.UTRIE2_SHIFT_2"/>,
            plus the part of the index-2 table for lead surrogate code points,
            plus the build-time index gap,
            plus the null index-2 block.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.UNEWTRIE2_MAX_DATA_LENGTH">
            <summary>
            Maximum length of the build-time data array.
            One entry per 0x110000 code points, plus the illegal-UTF-8 block and the null block,
            plus values for the 0x400 surrogate code units.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Trie2.Trie2Iterator">
            <summary>
            Implementation class for an enumerator over a <see cref="T:ICU4N.Impl.Trie2"/>.
            <para/>
            Iteration over a <see cref="T:ICU4N.Impl.Trie2"/> first returns all of the ranges that are indexed by code points,
            then returns the special alternate values for the lead surrogates.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.Trie2.Trie2Iterator.Next">
            <summary>
            The main Next() function for <see cref="T:ICU4N.Impl.Trie2"/> iterators
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2.Trie2Iterator.RangeEndLS(System.Char)">
            <summary>
            Find the last lead surrogate in a contiguous range  with the
            same <see cref="T:ICU4N.Impl.Trie2"/> value as the input character.
            </summary>
            <remarks>
            Use the alternate Lead Surrogate values from the Trie2,
            not the code-point values.
            <para/>
            Note: <see cref="T:ICU4N.Impl.Trie2_16"/> and <see cref="T:ICU4N.Impl.Trie2_32"/> override this implementation with optimized versions,
                  meaning that the implementation here is only being used with
                  <see cref="T:ICU4N.Impl.Trie2Writable"/>.  The code here is logically correct with any type
                  of <see cref="T:ICU4N.Impl.Trie2"/>, however.      
            </remarks>
            <param name="startingLS">The character to begin with.</param>
            <returns>The last contiguous character with the same value.</returns>
        </member>
        <member name="F:ICU4N.Impl.Trie2.Trie2Iterator.nextStart">
            <summary>The starting code point for the next range to be returned.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.Trie2Iterator.limitCP">
            <summary>
            The upper limit for the last normal range to be returned.  Normally 0x110000, but
            may be lower when iterating over the code points for a single lead surrogate.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.Trie2Iterator.doingCodePoints">
            <summary>
            True while iterating over the the <see cref="T:ICU4N.Impl.Trie2"/> values for code points.
            False while iterating over the alternate values for lead surrogates.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2.Trie2Iterator.doLeadSurrogates">
            <summary>
            True if the iterator should iterate the special values for lead surrogates in
            addition to the normal values for code points.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2.RangeEnd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the last character in a contiguous range of characters with the
            same <see cref="T:ICU4N.Impl.Trie2"/> value as the input character.
            </summary>
            <param name="start">The character to begin with.</param>
            <param name="limitp"></param>
            <param name="val"></param>
            <returns>The last contiguous character with the same value.</returns>
        </member>
        <member name="T:ICU4N.Impl.Trie2Writable">
            <summary>
            A <see cref="T:ICU4N.Impl.Trie2Writable"/> is a modifiable, or build-time <see cref="T:ICU4N.Impl.Trie2"/>.
            Functions for reading data from the <see cref="T:ICU4N.Impl.Trie"/> are all from class <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new, empty, writable <see cref="T:ICU4N.Impl.Trie2"/>. 32-bit data values are used.
            </summary>
            <param name="initialValueP">The initial value that is set for all code points.</param>
            <param name="errorValueP">The value for out-of-range code points and illegal UTF-8.</param>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.#ctor(ICU4N.Impl.Trie2)">
            <summary>
            Create a new build time (modifiable) <see cref="T:ICU4N.Impl.Trie2"/> whose contents are the same as the source <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <param name="source">The source <see cref="T:ICU4N.Impl.Trie2"/>.  Its contents will be copied into the new <see cref="T:ICU4N.Impl.Trie2"/>.</param>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.GetDataBlock(System.Int32,System.Boolean)">
            <summary>
            No error checking for illegal arguments.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.Set(System.Int32,System.Int32)">
            <summary>
            Set a value for a code point.
            </summary>
            <param name="c">The code point.</param>
            <param name="value">The value.</param>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.Uncompact">
            <summary>
            Uncompact a compacted <see cref="T:ICU4N.Impl.Trie2Writable"/>.
            </summary>
            <remarks>
            This is needed if a the <see cref="T:ICU4N.Impl.Trie2Writable"/> was compacted in preparation for creating a read-only
            <see cref="T:ICU4N.Impl.Trie2"/>, and then is subsequently altered.
            <para/>
            The structure is a bit awkward - it would be cleaner to leave the original
            <see cref="T:ICU4N.Impl.Trie2"/> unaltered - but compacting in place was taken directly from the ICU4C code.
            <para/>
            The approach is to create a new (uncompacted) <see cref="T:ICU4N.Impl.Trie2Writable"/> from this one, then transfer
            the guts from the new to the old.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.FillBlock(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <paramref name="initialValue"/> is ignored if <paramref name="overwrite"/>=TRUE.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.SetRange(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Set a value in a range of code points [start..end].
            <para/>
            All code points c with start&lt;=c&lt;=end will get the value if
            overwrite is TRUE or if the old value is the initial value.
            </summary>
            <param name="start">The first code point to get the value.</param>
            <param name="end">The last code point to get the value (inclusive).</param>
            <param name="value">The value.</param>
            <param name="overwrite">Flag for whether old non-initial values are to be overwritten.</param>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.SetRange(ICU4N.Impl.Trie2.Range,System.Boolean)">
            <summary>
            Set the values from a <see cref="T:ICU4N.Impl.Trie2.Range"/>.
            </summary>
            <remarks>
            All code points within the range will get the value if
            overwrite is TRUE or if the old value is the initial value.
            <para/>
            Ranges with the lead surrogate flag set will set the alternate
            lead-surrogate values in the Trie, rather than the code point values.
            <para/>
            This function is intended to work with the ranges produced when iterating
            the contents of a source Trie.
            </remarks>
            <param name="range">Contains the range of code points and the value to be set.</param>
            <param name="overwrite">Flag for whether old non-initial values are to be overwritten.</param>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.SetForLeadSurrogateCodeUnit(System.Char,System.Int32)">
            <summary>
            Set a value for a UTF-16 code unit.
            </summary>
            <remarks>
            Note that a <see cref="T:ICU4N.Impl.Trie2"/> stores separate values for 
            supplementary code points in the lead surrogate range
            (accessed via the plain <see cref="M:ICU4N.Impl.Trie2Writable.Set(System.Int32,System.Int32)"/> and <see cref="M:ICU4N.Impl.Trie2Writable.Get(System.Int32)"/> interfaces)
            and for lead surrogate code units.
            <para/>
            The lead surrogate code unit values are set via this function and
            read by the function <see cref="M:ICU4N.Impl.Trie2Writable.GetFromU16SingleLead(System.Char)"/>
            <para/>
            For code units outside of the lead surrogate range, this function
            behaves identically to <see cref="M:ICU4N.Impl.Trie2Writable.Set(System.Int32,System.Int32)"/>.
            </remarks>
            <param name="codeUnit">A UTF-16 code unit.</param>
            <param name="value">The value to be stored in the <see cref="T:ICU4N.Impl.Trie2"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.Get(System.Int32)">
            <summary>
            Get the value for a code point as stored in the <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <param name="codePoint">The code point.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.GetFromU16SingleLead(System.Char)">
            <summary>
            Get a trie value for a UTF-16 code unit.
            </summary>
            <remarks>
            This function returns the same value as <see cref="M:ICU4N.Impl.Trie2Writable.Get(System.Int32)"/> if the input 
            character is outside of the lead surrogate range.
            <para/>
            There are two values stored in a Trie for inputs in the lead
            surrogate range.  This function returns the alternate value,
            while <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/> returns the main value.
            </remarks>
            <param name="c">The code point or lead surrogate value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.FindHighStart(System.Int32)">
            <summary>
            Find the start of the last range in the trie by enumerating backward.
            Indexes for supplementary code points higher than this will be omitted.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.CompactData">
            <summary>
            Compact a build-time trie.
            </summary>
            <remarks>
            The compaction
            <list type="bullet">
                <item><description>removes blocks that are identical with earlier ones</description></item>
                <item><description>overlaps adjacent blocks as much as possible (if overlap==TRUE)</description></item>
                <item><description>moves blocks in steps of the data granularity</description></item>
                <item><description>moves and overlaps blocks that overlap with multiple values in the overlap region</description></item>
            </list>
            It does not
            <list type="bullet">
                <item><description>try to move and overlap blocks that are not already adjacent</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.ToTrie2_16">
            <summary>
            Produce an optimized, read-only <see cref="T:ICU4N.Impl.Trie2_16"/> from this writable <see cref="T:ICU4N.Impl.Trie"/>.
            The data values outside of the range that will fit in a 16 bit
            unsigned value will be truncated.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.ToTrie2_32">
            <summary>
            Produce an optimized, read-only <see cref="T:ICU4N.Impl.Trie2_32"/> from this writable <see cref="T:ICU4N.Impl.Trie"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UTRIE2_MAX_INDEX_LENGTH">
            <summary>
            Maximum length of the runtime index array.
            Limited by its own 16-bit index values, and by uint16_t UTrie2Header.indexLength.
            (The actual maximum length is lower,
            (0x110000>>UTRIE2_SHIFT_2)+UTRIE2_UTF8_2B_INDEX_2_LENGTH+UTRIE2_MAX_INDEX_1_LENGTH.)
            </summary>  
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UTRIE2_MAX_DATA_LENGTH">
            <summary>
            Maximum length of the runtime data array.
            Limited by 16-bit index values that are left-shifted by <see cref="F:ICU4N.Impl.Trie2.UTRIE2_INDEX_SHIFT"/>,
            and by uint16_t UTrie2Header.shiftedDataLength.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2Writable.Freeze(ICU4N.Impl.Trie2,ICU4N.Impl.Trie2.ValueWidth)">
            <summary>Compact the data and then populate an optimized read-only Trie.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_INITIAL_DATA_LENGTH">
            <summary>Start with allocation of 16k data entries.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_MEDIUM_DATA_LENGTH">
            <summary>Grow about 8x each time.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_INDEX_2_NULL_OFFSET">
            <summary>The null index-2 block, following the gap in the index-2 table.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_INDEX_2_START_OFFSET">
            <summary>The start of allocated index-2 blocks.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_DATA_NULL_OFFSET">
            <summary>
            The null data block.
            Length 64=0x40 even if <see cref="F:ICU4N.Impl.Trie2.UTRIE2_DATA_BLOCK_LENGTH"/> is smaller,
            to work with 6-bit trail bytes from 2-byte UTF-8.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_DATA_START_OFFSET">
            <summary>The start of allocated data blocks.</summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.UNEWTRIE2_DATA_0800_OFFSET">
            <summary>
            The start of data blocks for U+0800 and above.
            Below, compaction uses a block length of 64 for 2-byte UTF-8.
            From here on, compaction uses <see cref="F:ICU4N.Impl.Trie2.UTRIE2_DATA_BLOCK_LENGTH"/>.
            Data values for 0x780 code points beyond ASCII.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Trie2Writable.map">
            <summary>
            Multi-purpose per-data-block table.
            </summary>
            <remarks>
            Before compacting:
            <para/>
            Per-data-block reference counters/free-block list.
            <list type="table">
                <item><term>0</term><description>unused</description></item>
                <item><term>>0</term><description>reference counter (number of index-2 entries pointing here)</description></item>
                <item><term>&lt;0</term><description>next free data block in free-block list</description></item>
            </list>
            <para/>
            While compacting:
            <list type="bullet">
                <item><description>Map of adjusted indexes, used in <see cref="M:ICU4N.Impl.Trie2Writable.CompactData"/> and <see cref="M:ICU4N.Impl.Trie2Writable.CompactIndex2"/>.</description></item>
                <item><description>Maps from original indexes to new ones.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:ICU4N.Impl.Trie2_16">
            <summary>
            A read-only <see cref="T:ICU4N.Impl.Trie2"/>, holding 16 bit data values.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Impl.Trie2"/> is a highly optimized data structure for mapping from Unicode
            code points (values ranging from 0 to 0x10ffff) to a 16 or 32 bit value.
            <para/>
            See class <see cref="T:ICU4N.Impl.Trie2"/> for descriptions of the API for accessing the contents of a trie.
            <para/>
            The fundamental data access methods are declared final in this class, with
            the intent that applications might gain a little extra performance, when compared
            with calling the same methods via the abstract <see cref="T:ICU4N.Impl.Trie2"/> base class.
            </remarks>
            <author>aheninger</author>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.#ctor">
            <summary>
            Internal constructor, not for general use.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.CreateFromSerialized(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.Trie2"/> from its serialized form.  Inverse of utrie2_serialize().
            </summary>
            <remarks>
            The serialized format is identical between ICU4C, ICU4J, and ICU4N, so this function
            will work with serialized <see cref="T:ICU4N.Impl.Trie2"/>s from any.
            <para/>
            The serialized <see cref="T:ICU4N.Impl.Trie2"/> in the bytes may be in either little or big endian byte order.
            This allows using serialized Tries from ICU4C without needing to consider the
            byte order of the system that created them.
            </remarks>
            <param name="bytes">A byte buffer to the serialized form of a <see cref="T:ICU4N.Impl.Trie2"/>.</param>
            <returns>An unserialized <see cref="T:ICU4N.Impl.Trie2_16"/>, ready for use.</returns>
            <exception cref="T:System.ArgumentException">If the buffer does not contain a serialized <see cref="T:ICU4N.Impl.Trie2"/>.</exception>
            <exception cref="T:System.IO.IOException">If a read error occurs in the buffer.</exception>
            <exception cref="T:System.InvalidCastException">If the bytes contain a serialized <see cref="T:ICU4N.Impl.Trie2_32"/>.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.Get(System.Int32)">
            <summary>
            Get the value for a code point as stored in the <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <param name="codePoint">The code point.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.GetFromU16SingleLead(System.Char)">
            <summary>
            Get a <see cref="T:ICU4N.Impl.Trie2"/> value for a UTF-16 code unit.
            </summary>
            <remarks>
            This function returns the same value as <see cref="M:ICU4N.Impl.Trie2_16.Get(System.Int32)"/> if the input 
            character is outside of the lead surrogate range.
            <para/>
            There are two values stored in a <see cref="T:ICU4N.Impl.Trie2"/> for inputs in the lead
            surrogate range.  This function returns the alternate value,
            while <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/> returns the main value.
            </remarks>
            <param name="codeUnit">A 16 bit code unit or lead surrogate value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.Serialize(System.IO.Stream)">
            <summary>
            Serialize a <see cref="T:ICU4N.Impl.Trie2_16"/> onto an <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Impl.Trie2"/> can be serialized multiple times.
            The serialized data is compatible with ICU4C UTrie2 serialization.
            <see cref="T:ICU4N.Impl.Trie2"/> serialization is unrelated to .NET object serialization.
            </remarks>
            <param name="os">The stream to which the serialized Trie2 data will be written.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:System.IO.IOException">On an error writing to the <see cref="T:System.IO.Stream"/>.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.GetSerializedLength">
            <summary>
            Gets the number of bytes of the serialized trie.
            </summary>
            <returns>The number of bytes of the serialized trie.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_16.RangeEnd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Given a starting code point, find the last in a range of code points,
            all with the same value.
            </summary>
            <remarks>
            This function is part of the implementation of iterating over the
            <see cref="T:ICU4N.Impl.Trie2"/>'s contents.
            </remarks>
            <param name="startingCP">The code point at which to begin looking.</param>
            <param name="limit"></param>
            <param name="value"></param>
            <returns>The last code point with the same value as the starting code point.</returns>
        </member>
        <member name="T:ICU4N.Impl.Trie2_32">
            <summary>
            A read-only <see cref="T:ICU4N.Impl.Trie2"/>, holding 32 bit data values.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Impl.Trie2"/> is a highly optimized data structure for mapping from Unicode
            code points (values ranging from 0 to 0x10ffff) to a 16 or 32 bit value.
            <para/>
            See class <see cref="T:ICU4N.Impl.Trie2"/> for descriptions of the API for accessing the contents of a trie.
            <para/>
            The fundamental data access methods are declared final in this class, with
            the intent that applications might gain a little extra performance, when compared
            with calling the same methods via the abstract <see cref="T:ICU4N.Impl.Trie2"/> base class.
            </remarks>
            <author>aheninger</author>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.#ctor">
            <summary>
            Internal constructor, not for general use.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.CreateFromSerialized(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Create a <see cref="T:ICU4N.Impl.Trie2"/> from its serialized form.  Inverse of utrie2_serialize().
            </summary>
            <remarks>
            The serialized format is identical between ICU4C, ICU4J, and ICU4N, so this function
            will work with serialized <see cref="T:ICU4N.Impl.Trie2"/>s from any.
            <para/>
            The serialized <see cref="T:ICU4N.Impl.Trie2"/> in the bytes may be in either little or big endian byte order.
            This allows using serialized Tries from ICU4C without needing to consider the
            byte order of the system that created them.
            </remarks>
            <param name="bytes">A byte buffer to the serialized form of a <see cref="T:ICU4N.Impl.Trie2"/>.</param>
            <returns>An unserialized <see cref="T:ICU4N.Impl.Trie2_32"/>, ready for use.</returns>
            <exception cref="T:System.ArgumentException">If the buffer does not contain a serialized <see cref="T:ICU4N.Impl.Trie2"/>.</exception>
            <exception cref="T:System.IO.IOException">If a read error occurs in the buffer.</exception>
            <exception cref="T:System.InvalidCastException">If the bytes contain a serialized <see cref="T:ICU4N.Impl.Trie2_16"/>.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.Get(System.Int32)">
            <summary>
            Get the value for a code point as stored in the <see cref="T:ICU4N.Impl.Trie2"/>.
            </summary>
            <param name="codePoint">The code point.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.GetFromU16SingleLead(System.Char)">
            <summary>
            Get a <see cref="T:ICU4N.Impl.Trie2"/> value for a UTF-16 code unit.
            </summary>
            <remarks>
            This function returns the same value as <see cref="M:ICU4N.Impl.Trie2_32.Get(System.Int32)"/> if the input 
            character is outside of the lead surrogate range.
            <para/>
            There are two values stored in a <see cref="T:ICU4N.Impl.Trie2"/> for inputs in the lead
            surrogate range.  This function returns the alternate value,
            while <see cref="M:ICU4N.Impl.Trie2.Get(System.Int32)"/> returns the main value.
            </remarks>
            <param name="codeUnit">A 16 bit code unit or lead surrogate value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.Serialize(System.IO.Stream)">
            <summary>
            Serialize a <see cref="T:ICU4N.Impl.Trie2_32"/> onto an <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Impl.Trie2"/> can be serialized multiple times.
            The serialized data is compatible with ICU4C UTrie2 serialization.
            <see cref="T:ICU4N.Impl.Trie2"/> serialization is unrelated to .NET object serialization.
            </remarks>
            <param name="os">The stream to which the serialized Trie2 data will be written.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:System.IO.IOException">On an error writing to the <see cref="T:System.IO.Stream"/>.</exception>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.GetSerializedLength">
            <summary>
            Gets the number of bytes of the serialized trie.
            </summary>
            <returns>The number of bytes of the serialized trie.</returns>
        </member>
        <member name="M:ICU4N.Impl.Trie2_32.RangeEnd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Given a starting code point, find the last in a range of code points,
            all with the same value.
            </summary>
            <remarks>
            This function is part of the implementation of iterating over the
            <see cref="T:ICU4N.Impl.Trie2"/>'s contents.
            </remarks>
            <param name="startingCP">The code point at which to begin looking.</param>
            <param name="limit"></param>
            <param name="value"></param>
            <returns>The last code point with the same value as the starting code point.</returns>
        </member>
        <member name="T:ICU4N.Impl.TrieBuilder">
            <summary>
            Builder class to manipulate and generate a trie.
            </summary>
            <remarks>
            This is useful for ICU data in primitive types.
            Provides a compact way to store information that is indexed by Unicode 
            values, such as character properties, types, keyboard values, etc. This is 
            very useful when you have a block of Unicode data that contains significant 
            values while the rest of the Unicode data is unused in the application or 
            when you have a lot of redundance, such as where all 21,000 Han ideographs
            have the same value.  However, lookup is much faster than a hash table.
            A trie of any primitive data type serves two purposes:
            <list type="bullet">
                <item><description>Fast access of the indexed values.</description></item>
                <item><description>Smaller memory footprint.</description></item>
            </list>
            This is a direct port from the ICU4C version
            </remarks>
            <author>Syn Wee Quek</author>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.DATA_BLOCK_LENGTH">
            <summary>
            Number of data values in a stage 2 (data array) block. 2, 4, 8, .., 
            0x200
            </summary>
        </member>
        <member name="T:ICU4N.Impl.TrieBuilder.IDataManipulate">
            <summary>
            Character data in <see cref="T:ICU4N.Impl.Trie"/> have different user-specified format
            for different purposes.
            This interface specifies methods to be implemented in order for
            <see cref="T:ICU4N.Impl.Trie"/>, to surrogate offset information encapsulated within 
            the data.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.TrieBuilder.IDataManipulate.GetFoldedValue(System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Impl.TrieBuilder.IsInZeroBlock(System.Int32)">
            <summary>
            Checks if the character belongs to a zero block in the trie.
            </summary>
            <param name="ch">Codepoint which data is to be retrieved.</param>
            <returns>true if ch is in the zero block.</returns>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.m_index_">
            <summary>
            Index values at build-time are 32 bits wide for easier processing.
            Bit 31 is set if the data block is used by multiple index values 
            (from setRange()).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.m_map_">
            <summary>
            Map of adjusted indexes, used in utrie_compact().
            Maps from original indexes to new ones.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.SHIFT_">
            <summary>
            Shift size for shifting right the input index. 1..9 
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.MAX_INDEX_LENGTH_">
            <summary>
            Length of the index (stage 1) array before folding.
            Maximum number of Unicode code points (0x110000) shifted right by 
            SHIFT.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.BMP_INDEX_LENGTH_">
            <summary>
            Length of the BMP portion of the index (stage 1) array.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.SURROGATE_BLOCK_COUNT_">
            <summary>
            Number of index (stage 1) entries per lead surrogate.
            Same as number of indexe entries for 1024 trail surrogates,
            ==0x400>>UTRIE_SHIFT
            10 - SHIFT == Number of bits of a trail surrogate that are used in 
            index table lookups.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.MASK_">
            <summary>
            Mask for getting the lower bits from the input index.
            DATA_BLOCK_LENGTH - 1.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.INDEX_SHIFT_">
            <summary>
            Shift size for shifting left the index array values.
            Increases possible data size with 16-bit index values at the cost
            of compactability.
            This requires blocks of stage 2 data to be aligned by UTRIE_DATA_GRANULARITY.
            0..UTRIE_SHIFT
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.MAX_DATA_LENGTH_">
            <summary>
            Maximum length of the runtime data (stage 2) array.
            Limited by 16-bit index values that are left-shifted by INDEX_SHIFT_.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.OPTIONS_INDEX_SHIFT_">
            <summary>
            Shifting to position the index value in options
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.OPTIONS_DATA_IS_32_BIT_">
            <summary>
            If set, then the data (stage 2) array is 32 bits wide.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.OPTIONS_LATIN1_IS_LINEAR_">
            <summary>
            If set, then Latin-1 data (for U+0000..U+00ff) is stored in the data 
            (stage 2) array as a simple, linear array at data + DATA_BLOCK_LENGTH.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.DATA_GRANULARITY_">
            <summary>
            The alignment size of a stage 2 data block. Also the granularity for 
            compaction. 
            </summary>
        </member>
        <member name="M:ICU4N.Impl.TrieBuilder.EqualInt32(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Compare two sections of an array for equality.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.TrieBuilder.FindUnusedBlocks">
            <summary>
            Set a value in the trie index map to indicate which data block
            is referenced and which one is not.
            utrie_compact() will remove data blocks that are not used at all.
            Set
            <list type="bullet">
                <item><description>0 if it is used</description></item>
                <item><description>-1 if it is not used</description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Impl.TrieBuilder.FindSameIndexBlock(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Finds the same index block as the <paramref name="otherBlock"/>.
            </summary>
            <param name="index">index array.</param>
            <param name="indexLength">size of index</param>
            <param name="otherBlock"></param>
            <returns>Same index block.</returns>
        </member>
        <member name="F:ICU4N.Impl.TrieBuilder.MAX_BUILD_TIME_DATA_LENGTH_">
            <summary>
            Maximum length of the build-time data (stage 2) array.
            The maximum length is 0x110000 + DATA_BLOCK_LENGTH + 0x400.
            (Number of Unicode code points + one all-initial-value block +
            possible duplicate entries for 1024 lead surrogates.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Impl.TrieEnumerator" -->
        <member name="M:ICU4N.Impl.TrieEnumerator.#ctor(ICU4N.Impl.Trie)">
            <summary>
            TrieEnumeration constructor.
            </summary>
            <param name="trie">Trie to be used.</param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="trie"/> argument is null.</exception>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.Next(ICU4N.Util.RangeValueEnumeratorElement)">
            <summary>
            Returns true if we are not at the end of the iteration, false
            otherwise.
            The next set of codepoints with the same value type will be
            calculated during this call and returned in the arguement element.
            </summary>
            <param name="element">Return result.</param>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.RangeValueEnumeratorElement"/>
        </member>
        <member name="P:ICU4N.Impl.TrieEnumerator.Current">
            <summary>
            Gets the current <see cref="T:ICU4N.Util.RangeValueEnumeratorElement"/> of the iteration.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.MoveNext">
            <summary>
            Returns true if we are not at the end of the iteration, false
            otherwise.
            The next set of codepoints with the same value type will be
            calculated during this call and set to <see cref="P:ICU4N.Impl.TrieEnumerator.Current"/>.
            </summary>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.RangeValueEnumeratorElement"/>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.Reset">
            <summary>
            Resets the iterator to the beginning of the iteration
            </summary>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.Extract(System.Int32)">
            <summary>
            Called by <see cref="M:ICU4N.Impl.TrieEnumerator.Next(ICU4N.Util.RangeValueEnumeratorElement)"/> to extract a 32 bit value from a trie value
            used for comparison.
            This method is to be overwritten if special manipulation is to be done
            to retrieve a relevant comparison.
            The default function is to return the value as it is.
            </summary>
            <param name="value">A value from the trie.</param>
            <returns>Extracted value.</returns>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.SetResult(ICU4N.Util.RangeValueEnumeratorElement,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the result values.
            </summary>
            <param name="element">Return result object.</param>
            <param name="start">Start codepoint of range.</param>
            <param name="limit">(end + 1) codepoint of range.</param>
            <param name="value">Common value of range.</param>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CalculateNextBMPElement(ICU4N.Util.RangeValueEnumeratorElement)">
            <summary>
            Finding the next element.
            This method is called just before returning the result of
            <see cref="M:ICU4N.Impl.TrieEnumerator.Next(ICU4N.Util.RangeValueEnumeratorElement)"/>.
            We always store the next element before it is requested.
            In the case that we have to continue calculations into the
            supplementary planes, a false will be returned.
            </summary>
            <param name="element">Return result object.</param>
            <returns>true if the next range is found, false if we have to proceed to
            the supplementary range.</returns>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CalculateNextSupplementaryElement(ICU4N.Util.RangeValueEnumeratorElement)">
            <summary>
            Finds the next supplementary element.
            For each entry in the trie, the value to be delivered is passed through
            <see cref="M:ICU4N.Impl.TrieEnumerator.Extract(System.Int32)"/>.
            We always store the next element before it is requested.
            Called after <see cref="M:ICU4N.Impl.TrieEnumerator.CalculateNextBMPElement(ICU4N.Util.RangeValueEnumeratorElement)"/> completes its round of BMP characters.
            There is a slight difference in the usage of <see cref="F:ICU4N.Impl.TrieEnumerator.m_currentCodepoint_"/>.
            here as compared to <see cref="M:ICU4N.Impl.TrieEnumerator.CalculateNextBMPElement(ICU4N.Util.RangeValueEnumeratorElement)"/>. Though both represents the
            lower bound of the next element, in <see cref="M:ICU4N.Impl.TrieEnumerator.CalculateNextBMPElement(ICU4N.Util.RangeValueEnumeratorElement)"/> it gets set
            at the start of any loop, where-else, in <see cref="M:ICU4N.Impl.TrieEnumerator.CalculateNextSupplementaryElement(ICU4N.Util.RangeValueEnumeratorElement)"/>
            since <see cref="F:ICU4N.Impl.TrieEnumerator.m_currentCodepoint_"/> already contains the lower bound of the
            next element (passed down from <see cref="M:ICU4N.Impl.TrieEnumerator.CalculateNextBMPElement(ICU4N.Util.RangeValueEnumeratorElement)"/>), we keep it till
            the end before resetting it to the new value.
            Note, if there are no more iterations, it will never get to here.
            Blocked out by <see cref="M:ICU4N.Impl.TrieEnumerator.Next(ICU4N.Util.RangeValueEnumeratorElement)"/>.
            </summary>
            <param name="element">Return result object.</param>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CheckBlockDetail(System.Int32)">
            <summary>
            Internal block value calculations
            Performs calculations on a data block to find codepoints in <see cref="F:ICU4N.Impl.TrieEnumerator.m_nextBlock_"/>
            after the index m_nextBlockIndex_ that has the same value.
            Note m_*_ variables at this point is the next codepoint whose value
            has not been calculated.
            But when returned with false, it will be the last codepoint whose
            value has been calculated.
            </summary>
            <param name="currentValue">The value which other codepoints are tested against.</param>
            <returns>true if the whole block has the same value as currentValue or if
            the whole block has been calculated, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CheckBlock(System.Int32)">
            <summary>
            Internal block value calculations
            Performs calculations on a data block to find codepoints in <see cref="F:ICU4N.Impl.TrieEnumerator.m_nextBlock_"/>
            that has the same value.
            Will call <see cref="M:ICU4N.Impl.TrieEnumerator.CheckBlockDetail(System.Int32)"/> if highlevel check fails.
            Note m_*_ variables at this point is the next codepoint whose value
            has not been calculated.
            </summary>
            <param name="currentValue">The value which other codepoints are tested against.</param>
            <returns>true if the whole block has the same value as currentValue or if
            the whole block has been calculated, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CheckTrailBlock(System.Int32)">
            <summary>
            Internal block value calculations
            Performs calculations on multiple data blocks for a set of trail
            surrogates to find codepoints in m_nextBlock_ that has the same value.
            Will call <see cref="M:ICU4N.Impl.TrieEnumerator.CheckBlock(System.Int32)"/> for internal block checks.
            Note m_*_ variables at this point is the next codepoint whose value
            Note m_*_ variables at this point is the next codepoint whose value
            has not been calculated.
            </summary>
            <param name="currentValue">The value which other codepoints are tested against.</param>
            <returns>true if the whole block has the same value as currentValue or if
            the whole block has been calculated, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.TrieEnumerator.CheckNullNextTrailIndex">
            <summary>
            Checks if we are beginning at the start of a initial block.
            If we are then the rest of the codepoints in this initial block
            has the same values.
            We increment <see cref="F:ICU4N.Impl.TrieEnumerator.m_nextCodepoint_"/> and relevant data members if so.
            This is used only in for the supplementary codepoints because
            the offset to the trail indexes could be 0.
            </summary>
            <returns>true if we are at the start of a initial block.</returns>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.BMP_INDEX_LENGTH_">
            <summary>
            Size of the stage 1 BMP indexes
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.LEAD_SURROGATE_MIN_VALUE_">
            <summary>
            Lead surrogate minimum value
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.TRAIL_SURROGATE_MIN_VALUE_">
            <summary>
            Trail surrogate minimum value
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.TRAIL_SURROGATE_COUNT_">
            <summary>
            Number of trail surrogate
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_">
            <summary>
            Number of stage 1 indexes for supplementary calculations that maps to
            each lead surrogate character.
            See second pass into GetRawOffset for the trail surrogate character.
            10 for significant number of bits for trail surrogates, 5 for what we
            discard during shifting.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.DATA_BLOCK_LENGTH_">
            <summary>
            Number of data values in a stage 2 (data array) block.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.m_trie_">
            <summary>
            Trie instance
            </summary>
        </member>
        <member name="F:ICU4N.Impl.TrieEnumerator.m_initialValue_">
            <summary>
            Initial value for trie values
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UBiDiProps">
            <summary>
            Low-level Unicode bidi/shaping properties access.
            .NET port of ubidi_props.h/.c.
            </summary>
            <author>Markus W. Scherer</author>
            <created>2005jan16</created>
        </member>
        <member name="P:ICU4N.Impl.UBiDiProps.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UCaseProps">
            <summary>
            Low-level Unicode character/string case mapping code.
            .NET port of ucase.h/.c.
            </summary>
            <author>Markus W. Scherer</author>
            <created>2005jan29</created>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.flagsOffset">
            <summary>number of bits in an 8-bit integer value</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetSlotValueAndOffset(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the value of an optional-value slot where HasSlot(excWord, index).
            </summary>
            <param name="excWord">Initial exceptions word.</param>
            <param name="index">Desired slot index.</param>
            <param name="excOffset">offset into exceptions[] after excWord=exceptions[excOffset++];</param>
            <returns>bits 31..0: slot value
                        63..32: modified excOffset, moved to the last char of the value, use +1 for beginning of next slot</returns>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetSlotValue(System.Int32,System.Int32,System.Int32)">
            <summary>Same as <see cref="M:ICU4N.Impl.UCaseProps.GetSlotValueAndOffset(System.Int32,System.Int32,System.Int32)"/> but does not return the slot offset.</summary>
            <param name="excWord">Initial exceptions word.</param>
            <param name="index">Desired slot index.</param>
            <param name="excOffset">offset into exceptions[] after excWord=exceptions[excOffset++];</param>
            <returns>bits 63..32: modified excOffset, moved to the last char of the value, use +1 for beginning of next slot</returns>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.AddCaseClosure(System.Int32,ICU4N.Text.UnicodeSet)">
            <summary>
            Adds all simple case mappings and the full case folding for <paramref name="c"/> to sa,
            and also adds special case closure mappings.
            </summary>
            <remarks>
            <paramref name="c"/> itself is not added.
            For example, the mappings
            <list type="bullet">
                <item><description>for s include long s</description></item>
                <item><description>for sharp s include ss</description></item>
                <item><description>for k include the Kelvin sign</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.StrCmpMax(System.String,System.Int32,System.Int32)">
            <summary>
            compare s, which has a length, with t=unfold[unfoldOffset..], which has a maximum length or is NUL-terminated
            must be s.Length>0 and max>0 and s.Length&lt;=max
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.AddStringCaseClosure(System.String,ICU4N.Text.UnicodeSet)">
            <summary>
            Maps the string to single code points and adds the associated case closure
            mappings.
            </summary>
            <remarks>
            The string is mapped to code points if it is their full case folding string.
            In other words, this performs a reverse full case folding and then
            adds the case closure items of the resulting code points.
            If the string is found and its closure applied, then
            the string itself is added as well as part of its code points' closure.
            </remarks>
            <returns>true if the string was found.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetType(System.Int32)">
            <returns><see cref="F:ICU4N.Impl.UCaseProps.NONE"/>, <see cref="F:ICU4N.Impl.UCaseProps.LOWER"/>, <see cref="F:ICU4N.Impl.UCaseProps.UPPER"/>, <see cref="F:ICU4N.Impl.UCaseProps.TITLE"/></returns>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetTypeOrIgnorable(System.Int32)">
            <summary>
            Like <see cref="M:ICU4N.Impl.UCaseProps.GetType(System.Int32)"/>, but also sets <see cref="F:ICU4N.Impl.UCaseProps.IGNORABLE"/> if <paramref name="c"/> is case-ignorable.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetDotType(System.Int32)">
            <returns>NO_DOT, <see cref="F:ICU4N.Impl.UCaseProps.SOFT_DOTTED"/>, <see cref="F:ICU4N.Impl.UCaseProps.ABOVE"/>, <see cref="F:ICU4N.Impl.UCaseProps.OTHER_ACCENT"/>.</returns>
        </member>
        <member name="T:ICU4N.Impl.UCaseProps.IContextIterator">
            <summary>
            Iterator for string case mappings, which need to look at the
            context (surrounding text) of a given character for conditional mappings.
            </summary>
            <remarks>
            The iterator only needs to go backward or forward away from the
            character in question. It does not use any indexes on this interface.
            It does not support random access or an arbitrary change of
            iteration direction.
            <para/>
            The code point being case-mapped itself is never returned by
            this iterator.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IContextIterator.Reset(System.Int32)">
            <summary>
            Reset the iterator for forward or backward iteration.
            </summary>
            <param name="dir">
            >0: Begin iterating forward from the first code point
            after the one that is being case-mapped.
            &lt;0: Begin iterating backward from the first code point
            before the one that is being case-mapped.
            </param>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IContextIterator.Next">
            <summary>
            Iterate and return the next code point, moving in the direction
            determined by the <see cref="M:ICU4N.Impl.UCaseProps.IContextIterator.Reset(System.Int32)"/> call.
            </summary>
            <returns>Next code point, or &lt;0 when the iteration is done.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH">
            <summary>
            For string case mappings, a single character (a code point) is mapped
            either to itself (in which case in-place mapping functions do nothing),
            or to another single code point, or to a string.
            Aside from the string contents, these are indicated with a single int
            value as follows:
            <list type="table">
                <item><term>Mapping to self</term><description>Negative values (~self instead of -self to support U+0000)</description></item>
                <item><term>Mapping to another code point</term><description>Positive values ><see cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/></description></item>
                <item><term>Mapping to a string</term><description>
                    The string length (0..MAX_STRING_LENGTH) is
                    returned. Note that the string result may indeed have zero length.
                </description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetCaseLocale(System.String)">
            <summary>Accepts both 2- and 3-letter language subtags.</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IsFollowedByCasedLetter(ICU4N.Impl.UCaseProps.IContextIterator,System.Int32)">
            <summary>Is followed by {case-ignorable}* cased  ? (dir determines looking forward/backward)</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IsPrecededBySoftDotted(ICU4N.Impl.UCaseProps.IContextIterator)">
            <summary>Is preceded by Soft_Dotted character with no intervening cc=230 ?</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IsPrecededBy_I(ICU4N.Impl.UCaseProps.IContextIterator)">
            <summary>Is preceded by base character 'I' with no intervening cc=230 ?</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IsFollowedByMoreAbove(ICU4N.Impl.UCaseProps.IContextIterator)">
            <summary>Is followed by one or more cc==230 ?</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.IsFollowedByDotAbove(ICU4N.Impl.UCaseProps.IContextIterator)">
            <summary>Is followed by a dot above (without cc==230 in between) ?</summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.FOLD_CASE_OPTIONS_MASK">
            <summary>
            Bit mask for getting just the options from a string compare options word
            that are relevant for case folding (of a single string or code point).
            </summary>
            <remarks>
            Currently only bit 0 for <see cref="F:ICU4N.UChar.FoldCaseExcludeSpecialI"/>.
            It is conceivable that at some point we might use one more bit for using uppercase sharp s.
            It is conceivable that at some point we might want the option to use only simple case foldings
            when operating on strings.
            </remarks>
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.Fold(System.Int32,ICU4N.Globalization.FoldCase)">
            <summary>Returns the simple case folding mapping for <paramref name="c"/>.</summary>
        </member>
        <member name="P:ICU4N.Impl.UCaseProps.DummyStringBuilder">
            <summary>
            We need a <see cref="T:System.Text.StringBuilder"/> for multi-code point output from the
            full case mapping functions. However, we do not actually use that output,
            we just check whether the input character was mapped to anything else.
            We use a shared <see cref="T:System.Text.StringBuilder"/> to avoid allocating a new one in each call.
            We remove its contents each time so that it does not grow large over time.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.FMT">
            <summary>format "cAsE"</summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetTypeFromProps(System.Int32)">
            <returns><see cref="F:ICU4N.Impl.UCaseProps.NONE"/>, <see cref="F:ICU4N.Impl.UCaseProps.LOWER"/>, <see cref="F:ICU4N.Impl.UCaseProps.UPPER"/>, <see cref="F:ICU4N.Impl.UCaseProps.TITLE"/></returns>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.GetTypeAndIgnorableFromProps(System.Int32)">
            <summary>
            Like <see cref="M:ICU4N.Impl.UCaseProps.GetTypeFromProps(System.Int32)"/>, but also sets <see cref="F:ICU4N.Impl.UCaseProps.IGNORABLE"/> if <paramref name="props"/> indicate case-ignorable.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.EXC_SHIFT">
            <summary>exception: bits 15..5 are an unsigned 11-bit index into the exceptions array</summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.EXC_LOWER">
            <summary>first 8 bits indicate values in optional slots</summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.EXC_DOUBLE_SLOTS">
            <summary>each slot is 2 uint16_t instead of 1</summary>
        </member>
        <member name="F:ICU4N.Impl.UCaseProps.EXC_DOT_SHIFT">
            <summary>EXC_DOT_MASK=<see cref="F:ICU4N.Impl.UCaseProps.DOT_MASK"/>&lt;&lt;<see cref="F:ICU4N.Impl.UCaseProps.EXC_DOT_SHIFT"/></summary>
        </member>
        <member name="P:ICU4N.Impl.UCaseProps.Instance">
            <summary>
            Public singleton instance.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.ToFullLower(System.Int32,ICU4N.Impl.UCaseProps.IContextIterator,System.Text.StringBuilder,System.Int32)">
            <summary>
            Get the full lowercase mapping for <paramref name="c"/>.
            </summary>
            <param name="c">Character to be mapped.</param>
            <param name="iter">
            Character iterator, used for context-sensitive mappings.
            See <see cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/> for details.
            If iter==null then a context-independent result is returned.
            </param>
            <param name="output">If the mapping result is a string, then it is appended to <paramref name="output"/>.</param>
            <param name="caseLocale">Case locale value from ucase_getCaseLocale().</param>
            <returns>Output code point or string length, see <see cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>.</returns>
            <seealso cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/>
            <seealso cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.UCaseProps.ToFullLower(System.Int32,ICU4N.Impl.UCaseProps.IContextIterator,ICU4N.Support.Text.IAppendable,System.Int32)">
            <summary>
            Get the full lowercase mapping for <paramref name="c"/>.
            </summary>
            <param name="c">Character to be mapped.</param>
            <param name="iter">
            Character iterator, used for context-sensitive mappings.
            See <see cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/> for details.
            If iter==null then a context-independent result is returned.
            </param>
            <param name="output">If the mapping result is a string, then it is appended to <paramref name="output"/>.</param>
            <param name="caseLocale">Case locale value from ucase_getCaseLocale().</param>
            <returns>Output code point or string length, see <see cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>.</returns>
            <seealso cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/>
            <seealso cref="F:ICU4N.Impl.UCaseProps.MAX_STRING_LENGTH"/>
            <internal/>
        </member>
        <member name="T:ICU4N.Impl.UCharacterIteratorWrapper">
            <summary>
            This class is a wrapper around <see cref="T:ICU4N.Text.UCharacterIterator"/> and implements the
            <see cref="T:ICU4N.Support.Text.CharacterIterator"/> protocol
            </summary>
            <author>ram</author>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.First">
            <summary>
            Sets the position to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/> and returns the character at that
            position.
            </summary>
            <returns>The first character in the text, or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if the text is empty.</returns>
            <seealso cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.Last">
            <summary>
            Sets the position to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/>-1 (<see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/> if the text is empty)
            and returns the character at that position.
            </summary>
            <returns>The last character in the text, or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if the text is empty.</returns>
            <seealso cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/>
        </member>
        <member name="P:ICU4N.Impl.UCharacterIteratorWrapper.Current">
            <summary>
            Gets the character at the current position (as returned by <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.Index"/>).
            </summary>
            <returns>
            the character at the current position or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if the current
            position is off the end of the text.
            </returns>
            <seealso cref="P:ICU4N.Impl.UCharacterIteratorWrapper.Index"/>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.Next">
            <summary>
            Increments the iterator's index by one and returns the character
            at the new index.  If the resulting index is greater or equal
            to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/>, the current index is reset to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/> and
            a value of <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> is returned.
            </summary>
            <returns>The character at the new position or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if the new
            position is off the end of the text range.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.Previous">
            <summary>
            Decrements the iterator's index by one and returns the character
            at the new index. If the current index is <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/>, the index
            remains at <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/> and a value of <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> is returned.
            </summary>
            <returns>the character at the new position or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if the current
            position is equal to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.SetIndex(System.Int32)">
            <summary>
            Sets the position to the specified position in the text and returns that
            character.
            </summary>
            <param name="position">The position within the text.  Valid values range from
            <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex"/> to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/>. An <see cref="T:System.ArgumentException"/> is thrown
            if an invalid value is supplied.</param>
            <returns>The character at the specified position or <see cref="F:ICU4N.Text.UCharacterIterator.Done"/> if 
            the specified position is equal to <see cref="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex"/>.</returns>
        </member>
        <member name="P:ICU4N.Impl.UCharacterIteratorWrapper.BeginIndex">
            <summary>
            Gets the start index of the text.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UCharacterIteratorWrapper.EndIndex">
            <summary>
            Gets the end index of the text.  This index is the index of the first
            character following the end of the text.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UCharacterIteratorWrapper.Index">
            <summary>
            Gets the current index.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterIteratorWrapper.Clone">
            <summary>
            Create a copy of this iterator.
            </summary>
            <returns>A copy of this.</returns>
        </member>
        <member name="T:ICU4N.Impl.UCharacterName">
            <summary>
            Internal class to manage character names.
            Since data for names are stored
            in an array of <see cref="T:System.Char"/>, by default indexes used in this class is refering to
            a 2 byte count, unless otherwise stated. Cases where the index is refering
            to a byte count, the index is halved and depending on whether the index is
            even or odd, the MSB or LSB of the result char at the halved index is
            returned. For indexes to an array of <see cref="T:System.Int32"/>, the index is multiplied by 2,
            result <see cref="T:System.Char"/> at the multiplied index and its following <see cref="T:System.Char"/> is returned as an
            <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UCharacterName.Instance">
            <summary>
            Public singleton instance.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.LINES_PER_GROUP_">
            <summary>
            Number of lines per group
            1 &lt;&lt; GROUP_SHIFT_
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.m_groupcount_">
            <summary>
            Maximum number of groups.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetName(System.Int32,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Retrieve the name of a Unicode code point.
            Depending on <paramref name="choice"/>, the character name written into the
            buffer is the "modern" name or the name that was defined in Unicode
            version 1.0.
            The name contains only "invariant" characters
            like A-Z, 0-9, space, and '-'.
            </summary>
            <param name="ch">The code point for which to get the name.</param>
            <param name="choice">Selector for which name to get.</param>
            <returns>If code point is above 0x1fff, null is returned.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetCharFromName(ICU4N.Impl.UCharacterNameChoice,System.String)">
            <summary>
            Find a character by its name and return its code point value
            
            </summary>
            <param name="choice">Selector to indicate if argument name is a Unicode 1.0 or the most current version.</param>
            <param name="name">The name to search for.</param>
            <returns>Code point.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupLengths(System.Int32,System.Char[],System.Char[])">
            <summary>
            Reads a block of compressed lengths of 32 strings and expands them into
            offsets and lengths for each string. 
            </summary>
            <remarks>
            Lengths are stored with a
            variable-width encoding in consecutive nibbles:
            <list type="bullet">
                <item><description>If a nibble&lt;0xc, then it is the length itself (0 = empty string).</description></item>
                <item><description>If a nibble>=0xc, then it forms a length value with the following nibble.</description></item>
            </list>
            The offsets and lengths arrays must be at least 33 (one more) long
            because there is no check here at the end if the last nibble is still
            used.
            </remarks>
            <param name="index">Index of group string object in array.</param>
            <param name="offsets">Array to store the value of the string offsets.</param>
            <param name="lengths">Array to store the value of the string length.</param>
            <returns>Next index of the data string immediately after the lengths
            in terms of byte address.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupName(System.Int32,System.Int32,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Gets the name of the argument group index.
            </summary>
            <remarks>
            UnicodeData.txt uses ';' as a field separator, so no field can contain
            ';' as part of its contents. In unames.icu, it is marked as
            token[';'] == -1 only if the semicolon is used in the data file - which
            is iff we have Unicode 1.0 names or ISO comments or aliases.
            So, it will be token[';'] == -1 if we store U1.0 names/ISO comments/aliases
            although we know that it will never be part of a name.
            Equivalent to ICU4C's expandName.
            </remarks>
            <param name="index">Index of the group name string in byte count.</param>
            <param name="length">Length of the group name string.</param>
            <param name="choice">Choice of Unicode 1.0 name or the most current name.</param>
            <returns>Name of the group.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetExtendedName(System.Int32)">
            <summary>
            Retrieves the extended name.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroup(System.Int32)">
            <summary>
            Gets the group index for the codepoint, or the group before it.
            </summary>
            <param name="codepoint">The codepoint index.</param>
            <returns>Group index containing codepoint or the group before it.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetExtendedOr10Name(System.Int32)">
            <summary>
            Gets the extended and 1.0 name when the most current unicode names
            fail.
            </summary>
            <param name="ch">Codepoint.</param>
            <returns>Name of codepoint extended or 1.0.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupMSB(System.Int32)">
            <summary>
            Gets the MSB from the group index.
            </summary>
            <param name="gindex">Group index.</param>
            <returns>The MSB of the group if gindex is valid, -1 otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetCodepointMSB(System.Int32)">
            <summary>
            Gets the MSB of the codepoint.
            </summary>
            <param name="codepoint">The codepoint value.</param>
            <returns>The MSB of the codepoint.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupLimit(System.Int32)">
            <summary>
            Gets the maximum codepoint + 1 of the group.
            </summary>
            <param name="msb">Most significant byte of the group.</param>
            <returns>Limit codepoint of the group.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupMin(System.Int32)">
            <summary>
            Gets the minimum codepoint of the group.
            </summary>
            <param name="msb">Most significant byte of the group.</param>
            <returns>Minimum codepoint of the group.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupOffset(System.Int32)">
            <summary>
            Gets the offset to a group.
            </summary>
            <param name="codepoint">The codepoint value.</param>
            <returns>Offset to a group.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupMinFromCodepoint(System.Int32)">
            <summary>
            Gets the minimum codepoint of a group.
            </summary>
            <param name="codepoint">The codepoint value.</param>
            <returns>Minimum codepoint in the group which codepoint belongs to.</returns>
        </member>
        <member name="P:ICU4N.Impl.UCharacterName.AlgorithmLength">
            <summary>
            Gets the Algorithm range length.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetAlgorithmStart(System.Int32)">
            <summary>
            Gets the start of the range.
            </summary>
            <param name="index">Algorithm index.</param>
            <returns>Algorithm range start.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetAlgorithmEnd(System.Int32)">
            <summary>
            Gets the end of the range.
            </summary>
            <param name="index">Algorithm index.</param>
            <returns>Algorithm range end.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetAlgorithmName(System.Int32,System.Int32)">
            <summary>
            Gets the Algorithmic name of the codepoint.
            </summary>
            <param name="index">Algorithmic range index.</param>
            <param name="codepoint">The codepoint value.</param>
            <returns>Algorithmic name of codepoint.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupName(System.Int32,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Gets the group name of the character.
            </summary>
            <param name="ch">Character to get the group name.</param>
            <param name="choice"></param>
            <returns>Choice name choice selector to choose a unicode 1.0 or newer name.</returns>
        </member>
        <member name="P:ICU4N.Impl.UCharacterName.MaxCharNameLength">
            <summary>
            Gets the maximum length of any codepoint name.
            Equivalent to uprv_getMaxCharNameLength.
            </summary>
            <returns>The maximum length of any codepoint name.</returns>
        </member>
        <member name="P:ICU4N.Impl.UCharacterName.MaxISOCommentLength">
            <summary>
            Gets the maximum length of any iso comments.
            Equivalent to uprv_getMaxISOCommentLength.
            </summary>
            <returns>The maximum length of any codepoint name.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetCharNameCharacters(ICU4N.Text.UnicodeSet)">
            <summary>
            Fills set with characters that are used in Unicode character names.
            Equivalent to uprv_getCharNameCharacters.
            </summary>
            <param name="set">USet to receive characters. Existing contents are deleted.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetISOCommentCharacters(ICU4N.Text.UnicodeSet)">
            <summary>
            Fills set with characters that are used in Unicode character names.
            Equivalent to uprv_getISOCommentCharacters.
            </summary>
            <param name="set">USet to receive characters. Existing contents are deleted.</param>
        </member>
        <member name="T:ICU4N.Impl.UCharacterName.AlgorithmName">
            <summary>
            Algorithmic name class.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.AlgorithmName.TYPE_0_">
            <summary>
            Constant type value of the different AlgorithmName
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.SetInfo(System.Int32,System.Int32,System.Byte,System.Byte)">
            <summary>
            Sets the information for accessing the algorithmic names/
            </summary>
            <param name="rangestart">Starting code point that lies within this name group.</param>
            <param name="rangeend">End code point that lies within this name group.</param>
            <param name="type">algorithm type. There's 2 kinds of algorithmic type. First
            which uses code point as part of its name and the other uses
            variant postfix strings.</param>
            <param name="variant">Algorithmic variant.</param>
            <returns>true if values are valid.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.SetFactor(System.Char[])">
            <summary>
            Sets the factor data.
            </summary>
            <param name="factor">Array of factor.</param>
            <returns>true if factors are valid.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.SetPrefix(System.String)">
            <summary>
            Sets the name prefix.
            </summary>
            <param name="prefix"></param>
            <returns>true if prefix is set.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.SetFactorString(System.Byte[])">
            <summary>
            Sets the variant factorized name data.
            </summary>
            <param name="str">Variant factorized name data.</param>
            <returns>true if values are set.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.Contains(System.Int32)">
            <summary>
            Checks if code point lies in Algorithm object at index.
            </summary>
            <param name="ch">Code point.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.AppendName(System.Int32,System.Text.StringBuilder)">
            <summary>
            Appends algorithm name of code point into <see cref="T:System.Text.StringBuilder"/>.
            Note this method does not check for validity of code point in Algorithm,
            result is undefined if code point does not belong in Algorithm.
            </summary>
            <param name="ch">Code point.</param>
            <param name="str"><see cref="T:System.Text.StringBuilder"/> to append to.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.GetChar(System.String)">
            <summary>
            Gets the character for the argument algorithmic name.
            </summary>
            <returns>The algorithmic char or -1 otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.Add(System.Int32[],System.Int32)">
            <summary>
            Adds all chars in the set of algorithmic names into the set.
            Equivalent to part of calcAlgNameSetsLengths.
            </summary>
            <param name="set"><see cref="T:System.Int32"/> set to add the chars of the algorithm names into.</param>
            <param name="maxlength">Maximum length to compare to.</param>
            <returns>The length that is either <paramref name="maxlength"/> of the length of this
            algorithm name if it is longer than <paramref name="maxlength"/>.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.AlgorithmName.m_utilStringBuffer_">
            <summary>
            Utility StringBuffer
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.AlgorithmName.m_utilIntBuffer_">
            <summary>
            Utility int buffer
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.GetFactorString(System.Int32[],System.Int32)">
            <summary>
            Gets the indexth string in each of the argument factor block.
            </summary>
            <param name="index">Array with each index corresponding to each factor block.</param>
            <param name="length">Length of the array index.</param>
            <returns>The combined string of the array of indexth factor string in factor block.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AlgorithmName.CompareFactorString(System.Int32[],System.Int32,System.String,System.Int32)">
            <summary>
            Compares the indexth string in each of the argument factor block with
            the argument string.
            </summary>
            <param name="index">Array with each index corresponding to each factor block.</param>
            <param name="length">Index array length.</param>
            <param name="str">String to compare with.</param>
            <param name="offset">Offset of str to start comparison.</param>
            <returns>true if string matches.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.m_groupsize_">
            <summary>
            Size of each groups
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.SetToken(System.Char[],System.Byte[])">
            <summary>
            Sets the token data.
            </summary>
            <param name="token">Array of tokens.</param>
            <param name="tokenstring">Array of string values of the tokens.</param>
            <returns>false if there is a data error.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.SetAlgorithm(ICU4N.Impl.UCharacterName.AlgorithmName[])">
            <summary>
            Set the algorithm name information array.
            </summary>
            <param name="alg">Algorithm information array.</param>
            <returns>true if the group string offset has been set correctly.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.SetGroupCountSize(System.Int32,System.Int32)">
            <summary>
            Sets the number of group and size of each group in number of char.
            </summary>
            <param name="count">Number of groups.</param>
            <param name="size">Size of group in char.</param>
            <returns>true if group size is set correctly.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.SetGroup(System.Char[],System.Byte[])">
            <summary>
            Sets the group name data.
            </summary>
            <param name="group">Index information array.</param>
            <param name="groupstring">Name information array.</param>
            <returns>false if there is a data error.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.FILE_NAME_">
            <summary>
            Default name of the name datafile
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.GROUP_SHIFT_">
            <summary>
            Shift count to retrieve group information
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.GROUP_MASK_">
            <summary>
            Mask to retrieve the offset for a particular character within a group
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.OFFSET_HIGH_OFFSET_">
            <summary>
            Position of offsethigh in group information array
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.OFFSET_LOW_OFFSET_">
            <summary>
            Position of offsetlow in group information array
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.SINGLE_NIBBLE_MAX_">
            <summary>
            Double nibble indicator, any nibble > this number has to be combined
            with its following nibble
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.UCharacterName.m_nameSet_" -->
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.UCharacterName.m_ISOCommentSet_" -->
        <member name="F:ICU4N.Impl.UCharacterName.m_utilStringBuffer_">
            <summary>
            Utility <see cref="T:System.Text.StringBuilder"/>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.m_utilIntBuffer_">
            <summary>
            Utility <see cref="T:System.Int32"/> buffer
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.m_maxISOCommentLength_">
            <summary>
            Maximum ISO comment length
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.m_maxNameLength_">
            <summary>
            Maximum name length
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.TYPE_NAMES_">
            <summary>
            Type names used for extended names
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.UNKNOWN_TYPE_NAME_">
            <summary>
            Unknown type name
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.NON_CHARACTER_">
            <summary>
            Not a character type
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.LEAD_SURROGATE_">
            <summary>
            Lead surrogate type
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.TRAIL_SURROGATE_">
            <summary>
            Trail surrogate type
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterName.EXTENDED_CATEGORY_">
            <summary>
            Extended category count
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.#ctor">
            <summary>
            Protected constructor for use in <see cref="T:ICU4N.UChar"/>.
            </summary>
            <exception cref="T:System.IO.IOException">Thrown when data reading fails.</exception>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetAlgName(System.Int32,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Gets the algorithmic name for the argument character.
            </summary>
            <param name="ch">Character to determine name for.</param>
            <param name="choice">Name choice.</param>
            <returns>The algorithmic name or null if not found.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupChar(System.String,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Getting the character with the tokenized argument name.
            </summary>
            <param name="name">Name of the character.</param>
            <param name="choice"></param>
            <returns>Character with the tokenized argument name or -1 if character is not found.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetGroupChar(System.Int32,System.Char[],System.String,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Compares and retrieve character if name is found within the argument
            group.
            </summary>
            <param name="index">Index where the set of names reside in the group block.</param>
            <param name="length">List of lengths of the strings.</param>
            <param name="name">Character name to search for.</param>
            <param name="choice">Choice of either 1.0 or the most current unicode name.</param>
            <returns>Relative character in the group which matches name, otherwise if
            not found, -1 will be returned.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetType(System.Int32)">
            <summary>
            Gets the character extended type.
            </summary>
            <param name="ch">Character to be tested.</param>
            <returns>Extended type it is associated with.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.GetExtendedChar(System.String,ICU4N.Impl.UCharacterNameChoice)">
            <summary>
            Getting the character with extended name of the form &lt;....>.
            </summary>
            <param name="name">Name of the character to be found.</param>
            <param name="choice">Name choice.</param>
            <returns>Character associated with the name, -1 if such character is not
            found and -2 if we should continue with the search.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.Add(System.Int32[],System.Char)">
            <summary>
            Adds a codepoint into a set of <see cref="T:System.Int32"/>s.
            Equivalent to SET_ADD.
            </summary>
            <param name="set">Set to add to.</param>
            <param name="ch">16 bit char to add.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.Contains(System.Int32[],System.Char)">
            <summary>
            Checks if a codepoint is a part of a set of <see cref="T:System.Int32"/>s.
            Equivalent to SET_CONTAINS.
            </summary>
            <param name="set">Set to check in.</param>
            <param name="ch">16 bit char to check.</param>
            <returns>true if codepoint is part of the set, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.Add(System.Int32[],System.String)">
            <summary>
            Adds all characters of the argument <paramref name="str"/> and gets the length.
            Equivalent to calcStringSetLength.
            </summary>
            <param name="set">Set to add all chars of <paramref name="str"/> to.</param>
            <param name="str">String to add.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.Add(System.Int32[],System.Text.StringBuilder)">
            <summary>
            Adds all characters of the argument <paramref name="str"/> and gets the length.
            Equivalent to calcStringSetLength.
            </summary>
            <param name="set">Set to add all chars of <paramref name="str"/> to.</param>
            <param name="str">String to add.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AddAlgorithmName(System.Int32)">
            <summary>
            Adds all algorithmic names into the name set.
            Equivalent to part of calcAlgNameSetsLengths.
            </summary>
            <param name="maxlength">Length to compare to.</param>
            <returns>the maximum length of any possible algorithmic name if it is >
            maxlength, otherwise <paramref name="maxlength"/> is returned.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AddExtendedName(System.Int32)">
            <summary>
            Adds all extended names into the name set.
            Equivalent to part of calcExtNameSetsLengths.
            </summary>
            <param name="maxlength">Length to compare to.</param>
            <returns>The <paramref name="maxlength"/> of any possible extended name.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AddGroupName(System.Int32,System.Int32,System.Byte[],System.Int32[])">
            <summary>
            Adds names of a group to the argument set.
            Equivalent to calcNameSetLength.
            </summary>
            <param name="offset">Offset of the group name string in byte count.</param>
            <param name="length">Length of the group name string.</param>
            <param name="tokenlength">Array to store the length of each token.</param>
            <param name="set">Set to add to.</param>
            <returns>The length of the name string and the length of the group
            string parsed.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.AddGroupName(System.Int32)">
            <summary>
            Adds names of all group to the argument set.
            Sets the data member m_max*Length_.
            Method called only once.
            Equivalent to calcGroupNameSetsLength.
            </summary>
            <param name="maxlength">Length to compare to.</param>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.InitNameSetsLengths">
            <summary>
            Sets up the name sets and the calculation of the maximum lengths.
            Equivalent to calcNameSetsLengths.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterName.Convert(System.Int32[],ICU4N.Text.UnicodeSet)">
            <summary>
            Converts the char set cset into a Unicode set uset.
            Equivalent to charSetToUSet.
            </summary>
            <param name="set">Set of 256 bit flags corresponding to a set of chars.</param>
            <param name="uset">USet to receive characters. Existing contents are deleted.</param>
        </member>
        <member name="T:ICU4N.Impl.UCharacterNameChoice">
            <summary>
            Enum containing selector constants for the unicode character names.
            Constants representing the "modern" name of a Unicode character or the name 
            that was defined in Unicode version 1.0, before the Unicode standard
            merged with ISO-10646.
            <para/>
            Arguments for <see cref="T:ICU4N.Impl.UCharacterName"/>.
            </summary>
            <author>Syn Wee Quek</author>
            <since>oct0600</since>
        </member>
        <member name="T:ICU4N.Impl.UCharacterNameReader">
            <summary>
            Internal reader class for ICU data file uname.dat containing
            Unicode codepoint name data.
            </summary>
            <remarks>
            This class simply reads unames.icu, authenticates that it is a valid
            ICU data file and split its contents up into blocks of data for use in
            <see cref="T:ICU4N.Impl.UCharacterName"/>.
            <para/>
            unames.icu which is in big-endian format is jared together with this
            package.
            </remarks>
            <author>Syn Wee Quek</author>
            <since>release 2.1, February 1st 2002</since>
        </member>
        <member name="M:ICU4N.Impl.UCharacterNameReader.#ctor(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Protected constructor.
            </summary>
            <param name="bytes">ICU uprop.dat file buffer.</param>
            <exception cref="T:System.IO.IOException">If data file fails authentication.</exception>
        </member>
        <member name="M:ICU4N.Impl.UCharacterNameReader.Read(ICU4N.Impl.UCharacterName)">
            <summary>
            Read and break up the stream of data passed in as arguments
            and fills up <see cref="T:ICU4N.Impl.UCharacterName"/>.
            If unsuccessful false will be returned.
            </summary>
            <param name="data">Instance of datablock.</param>
            <exception cref="T:System.IO.IOException">Thrown when there's a data error.</exception>
        </member>
        <member name="M:ICU4N.Impl.UCharacterNameReader.Authenticate(System.Byte[],System.Byte[])">
            <summary>
            Checking the file for the correct format.
            </summary>
            <param name="dataformatid"></param>
            <param name="dataformatversion"></param>
            <returns>true if the file format version is correct.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterNameReader.m_byteBuffer_">
            <summary>
            Byte buffer for names
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterNameReader.GROUP_INFO_SIZE_">
            <summary>
            Size of the group information block in number of char
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterNameReader.m_tokenstringindex_">
            <summary>
            Index of the offset information
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterNameReader.ALG_INFO_SIZE_">
            <summary>
            Size of an algorithmic name information group
            start code point size + end code point size + type size + variant size +
            size of data size
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterNameReader.DATA_FORMAT_ID_">
            <summary>
            File format id that this class understands.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterNameReader.ReadAlg">
            <summary>
            Reads an individual record of <see cref="T:ICU4N.Impl.UCharacterName.AlgorithmName"/>s
            </summary>
            <returns>An instance of <see cref="T:ICU4N.Impl.UCharacterName.AlgorithmName"/>s if read is successful otherwise null.</returns>
            <exception cref="T:System.IO.IOException">Thrown when file read error occurs or data is corrupted.</exception>
        </member>
        <member name="T:ICU4N.Impl.UCharacterProperty">
            <summary>
            Internal class used for Unicode character property database.
            </summary>
            <remarks>
            This classes store binary data read from uprops.icu.
            It does not have the capability to parse the data into more high-level
            information. It only returns bytes of information when required.
            <para/>
            Due to the form most commonly used for retrieval, array of char is used
            to store the binary data.
            <para/>
            UCharacterPropertyDB also contains information on accessing indexes to
            significant points in the binary data.
            <para/>
            Responsibility for molding the binary data into more meaning form lies on
            <see cref="T:ICU4N.UChar"/>.
            </remarks>
            <author>Syn Wee Quek</author>
            <since>release 2.1, february 1st 2002</since>
        </member>
        <member name="P:ICU4N.Impl.UCharacterProperty.Instance">
            <summary>
            Public singleton instance.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UCharacterProperty.Trie">
            <summary>
            Trie data.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UCharacterProperty.UnicodeVersion">
            <summary>
            Unicode version.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_">
            <summary>
            Latin capital letter i with dot above
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.LATIN_SMALL_LETTER_DOTLESS_I_">
            <summary>
            Latin small letter i with dot above
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.LATIN_SMALL_LETTER_I_">
            <summary>
            Latin lowercase i
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.TYPE_MASK">
            <summary>
            Character type mask
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NONE">
            <summary>No source, not a supported property.</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_CHAR">
            <summary>From uchar.c/uprops.icu main trie</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_PROPSVEC">
            <summary>From uchar.c/uprops.icu properties vectors trie</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NAMES">
            <summary>From unames.c/unames.icu</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_CASE">
            <summary>From ucase.c/ucase.icu</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_BIDI">
            <summary>From ubidi_props.c/ubidi.icu</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_CHAR_AND_PROPSVEC">
            <summary>From uchar.c/uprops.icu main trie as well as properties vectors trie</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_CASE_AND_NORM">
            <summary>From ucase.c/ucase.icu as well as unorm.cpp/unorm.icu</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NFC">
            <summary>From normalizer2impl.cpp/nfc.nrm</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NFKC">
            <summary>From normalizer2impl.cpp/nfkc.nrm</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NFKC_CF">
            <summary>From normalizer2impl.cpp/nfkc_cf.nrm</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_NFC_CANON_ITER">
            <summary>From normalizer2impl.cpp/nfc.nrm canonical iterator data</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SRC_COUNT">
            <summary>One more than the highest UPropertySource (SRC_) constant.</summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetProperty(System.Int32)">
            <summary>
            Gets the main property value for code point <paramref name="ch"/>.
            </summary>
            <param name="ch">Code point whose property value is to be retrieved.</param>
            <returns>Property value of code point.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetAdditional(System.Int32,System.Int32)">
            <summary>
            Gets the unicode additional properties.
            .NET version of C u_getUnicodeProperties().
            </summary>
            <param name="codepoint">Codepoint whose additional properties is to be retrieved.</param>
            <param name="column">The column index.</param>
            <returns>Unicode properties.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetAge(System.Int32)">
            <summary>
            Get the "age" of the code point.
            </summary>
            <remarks>
            The "age" is the Unicode version when the code point was first
            designated (as a non-character or for Private Use) or assigned a
            character.
            <para/>
            This can be useful to avoid emitting code points to receiving
            processes that do not accept newer characters.
            <para/>
            The data is from the UCD file DerivedAge.txt.
            <para/>
            This API does not check the validity of the codepoint.
            </remarks>
            <param name="codepoint">The code point.</param>
            <returns>The Unicode version number.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.GC_Z_MASK">
            <summary>Mask constant for multiple UCharCategory bits (Z Separators).</summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.IsgraphPOSIX(System.Int32)">
            <summary>
            Checks if <paramref name="c"/> is in
            [^\p{space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}]
            with space=\p{Whitespace} and Control=Cc.
            Implements UCHAR_POSIX_GRAPH.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.gcbToHst">
            <summary>
            Map some of the Grapheme Cluster Break values to Hangul Syllable Types.
            Hangul_Syllable_Type is fully redundant with a subset of Grapheme_Cluster_Break.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetMaxValues(System.Int32)">
            <summary>
            Get the the maximum values for some enum/int properties.
            </summary>
            <param name="column"></param>
            <returns>Maximum values for the integer properties.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetMask(System.Int32)">
            <summary>
            Gets the type mask.
            </summary>
            <param name="type">Character type.</param>
            <returns>Mask.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.GetEuropeanDigit(System.Int32)">
            <summary>
            Returns the digit values of characters like 'A' - 'Z', normal,
            half-width and full-width. This method assumes that the other digit
            characters are checked by the calling method.
            </summary>
            <param name="ch">Character to test.</param>
            <returns>-1 if ch is not a character of the form 'A' - 'Z', otherwise
            its corresponding digit will be returned.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_additionalTrie_">
            <summary>
            Extra property trie
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_additionalVectors_">
            <summary>
            Extra property vectors, 1st column for age and second for binary
            properties.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_additionalColumnsCount_">
            <summary>
            Number of additional columns
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_maxBlockScriptValue_">
            <summary>
            Maximum values for block, bits used as in vector word
            0
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_maxJTGValue_">
            <summary>
            Maximum values for script, bits used as in vector word
            0
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.m_scriptExtensions_">
            <summary>
            Script_Extensions data
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.DATA_FILE_NAME_">
            <summary>
            Default name of the datafile
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NUMERIC_TYPE_VALUE_SHIFT_">
            <summary>
            Numeric types and values in the main properties words.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_NONE_">
            <summary> No numeric value.</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_DECIMAL_START_">
            <summary>Decimal digits: nv=0..9</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_DIGIT_START_">
            <summary>Other digits: nv=0..9</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_NUMERIC_START_">
            <summary>Small integers: nv=0..154</summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_FRACTION_START_">
            <summary>Fractions: ((ntv>>4)-12) / ((ntv&amp;0xf)+1) = -1..17 / 1..16</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.UCharacterProperty.NTV_LARGE_START_" -->
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.UCharacterProperty.NTV_BASE60_START_" -->
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_FRACTION20_START_">
            <summary>
            Fraction-20 values:
            <code>
            frac20 = ntv-0x324 = 0..0x17 -> 1|3|5|7 / 20|40|80|160|320|640
            numerator: num = 2*(frac20&amp;3)+1
            denominator: den = 20&lt;&lt;(frac20>>2)
            </code>
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.NTV_RESERVED_START_">
            No numeric value (yet). 
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SCRIPT_X_MASK">
            <summary>
            Script_Extensions: mask includes Script
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.EAST_ASIAN_MASK_">
            <summary>
            Integer properties mask and shift values for East Asian cell width.
            Equivalent to icu4c UPROPS_EA_MASK
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.EAST_ASIAN_SHIFT_">
            <summary>
            Integer properties mask and shift values for East Asian cell width.
            Equivalent to icu4c UPROPS_EA_SHIFT
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.BLOCK_MASK_">
            <summary>
            Integer properties mask and shift values for blocks.
            Equivalent to icu4c UPROPS_BLOCK_MASK
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.BLOCK_SHIFT_">
            <summary>
            Integer properties mask and shift values for blocks.
            Equivalent to icu4c UPROPS_BLOCK_SHIFT
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.SCRIPT_MASK_">
            <summary>
            Integer properties mask and shift values for scripts.
            Equivalent to icu4c UPROPS_SHIFT_MASK
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.WHITE_SPACE_PROPERTY_">
            Additional properties used in internal trie data
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.DECOMPOSITION_TYPE_MASK_">
            <summary>
            Integer properties mask for decomposition type.
            Equivalent to icu4c UPROPS_DT_MASK.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.FIRST_NIBBLE_SHIFT_">
            <summary>
            First nibble shift
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.LAST_NIBBLE_MASK_">
            <summary>
            Second nibble mask
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterProperty.AGE_SHIFT_">
            <summary>
            Age value shift
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UCharacterProperty.#ctor">
            <summary>
            Constructor.
            </summary>
            <exception cref="T:System.IO.IOException">Thrown when data reading fails or data corrupted.</exception>
        </member>
        <member name="T:ICU4N.Impl.UCharacterUtility">
            <summary>
            Internal character utility class for simple data type conversion and string 
            parsing functions. Does not have an analog in .NET.
            </summary>
            <author>Syn Wee Quek</author>
            <since>sep2900</since>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.IsNonCharacter(System.Int32)">
            <summary>
            Determines if codepoint is a non character.
            </summary>
            <param name="ch">Codepoint.</param>
            <returns>true if codepoint is a non character false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.ToInt(System.Char,System.Char)">
            <summary>
            Joining 2 chars to form an int.
            </summary>
            <param name="msc">Most significant char.</param>
            <param name="lsc">Least significant char.</param>
            <returns><see cref="T:System.Int32"/> form.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.GetNullTermByteSubString(System.Text.StringBuilder,System.Byte[],System.Int32)">
            <summary>
            Retrieves a null terminated substring from an array of bytes.
            Substring is a set of non-zero bytes starting from argument start to the 
            next zero byte. If the first byte is a zero, the next byte will be taken as
            the first byte.
            </summary>
            <param name="str"><see cref="T:System.Text.StringBuilder"/> to store data in, data will be store with each byte as a char.</param>
            <param name="array">Byte array.</param>
            <param name="index">Index to start substring in byte count.</param>
            <returns>The end position of the substring within the character array.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.CompareNullTermByteSubString(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compares a null terminated substring from an array of bytes.
            Substring is a set of non-zero bytes starting from argument start to the 
            next zero byte. if the first byte is a zero, the next byte will be taken as
            the first byte.
            </summary>
            <param name="str">String to compare.</param>
            <param name="array">Byte array.</param>
            <param name="strindex">Index within str to start comparing.</param>
            <param name="aindex">Array index to start in byte count.</param>
            <returns>The end position of the substring within str if matches otherwise a -1.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.SkipNullTermByteSubString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Skip null terminated substrings from an array of bytes.
            Substring is a set of non-zero bytes starting from argument start to the
            next zero byte. If the first byte is a zero, the next byte will be taken as
            the first byte.
            </summary>
            <param name="array">Byte array.</param>
            <param name="index">Index to start substrings in byte count.</param>
            <param name="skipcount">Number of null terminated substrings to skip.</param>
            <returns>The end position of the substrings within the character array.</returns>
        </member>
        <member name="M:ICU4N.Impl.UCharacterUtility.SkipByteSubString(System.Byte[],System.Int32,System.Int32,System.Byte)">
            <summary>
            Skip substrings from an array of characters, where each character is a set 
            of 2 bytes. substring is a set of non-zero bytes starting from argument 
            start to the byte of the argument value. skips up to a max number of 
            characters.
            </summary>
            <param name="array">Byte array to parse.</param>
            <param name="index">Index to start substrings in byte count.</param>
            <param name="length">The max number of bytes to skip.</param>
            <param name="skipend">Value of byte to skip to.</param>
            <returns>The number of bytes skipped.</returns>
        </member>
        <member name="F:ICU4N.Impl.UCharacterUtility.NON_CHARACTER_SUFFIX_MIN_3_0_">
            <summary>
            Minimum suffix value that indicates if a character is non character.
            Unicode 3.0 non characters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterUtility.NON_CHARACTER_MIN_3_1_">
            <summary>
            New minimum non character in Unicode 3.1
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UCharacterUtility.NON_CHARACTER_MAX_3_1_">
            <summary>
            New non character range in Unicode 3.1
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UCharArrayIterator">
            <author>Doug Felt</author>
        </member>
        <member name="M:ICU4N.Impl.UCharArrayIterator.Clone">
            <summary>
            Creates a copy of this iterator, does not clone the underlying
            <see cref="T:ICU4N.Text.IReplaceable"/> object
            </summary>
            <returns>copy of this iterator</returns>
        </member>
        <member name="T:ICU4N.Impl.UnicodeSetStringSpan">
            <summary>
            Implement <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> etc. for a set with strings.
            Avoid recursion because of its exponential complexity.
            Instead, try multiple paths at once and track them with an IndexList.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.ALL_CP_CONTAINED">
            Special spanLength short values. (since Java has not unsigned byte type)
            All code points in the string are contained in the parent set.
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.LONG_SPAN">
            <summary>The spanLength is >=0xfe.</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.spanSet">
            <summary>Set for <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>. Same as parent but without strings.</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.spanNotSet">
            <summary>
            Set for Span(not contained).
            Same as <see cref="F:ICU4N.Impl.UnicodeSetStringSpan.spanSet"/>, plus characters that start or end strings.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.strings">
            <summary>The strings of the parent set.</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.spanLengths">
            <summary>The lengths of <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>, 
            <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> etc. for each string.</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.maxLength16">
            <summary>Maximum lengths of relevant strings.</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.someRelevant">
            <summary>Are there strings that are not fully contained in the code point set?</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.all">
            <summary>Set up for all variants of <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>?</summary>
        </member>
        <member name="F:ICU4N.Impl.UnicodeSetStringSpan.offsets">
            <summary>Span helper</summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.#ctor(ICU4N.Text.UnicodeSet,System.Collections.Generic.IList{System.String},System.Int32)">
            <summary>
            Constructs for all variants of <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>, or only for any one variant.
            Initializes as little as possible, for single use.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.#ctor(ICU4N.Impl.UnicodeSetStringSpan,System.Collections.Generic.IList{System.String})">
            <summary>
            Constructs a copy of an existing UnicodeSetStringSpan.
            Assumes which==<see cref="F:ICU4N.Impl.UnicodeSetStringSpan.ALL"/> for a frozen set.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UnicodeSetStringSpan.NeedsStringSpanUTF16">
            <summary>
            Do the strings need to be checked in <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> etc.?
            Returns true if strings need to be checked (call <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> here),
            false if not (use a BMPSet for best performance).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Contains(System.Int32)">
            <summary>For fast <see cref="M:ICU4N.Text.UnicodeSet.Contains(System.Int32)"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.AddToSpanNotSet(System.Int32)">
            <summary>
            Adds a starting or ending string character to the <see cref="F:ICU4N.Impl.UnicodeSetStringSpan.spanNotSet"/>
            so that a character span ends before any string.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UnicodeSetStringSpan.OffsetList">
            <summary>
            Helper class for <see cref="T:ICU4N.Impl.UnicodeSetStringSpan"/>.
            </summary>
            <remarks>
            List of offsets from the current position from where to try matching
            a code point or a string.
            Stores offsets rather than indexes to simplify the code and use the same list
            for both increments (in <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>) and decrements (in <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>).
            
            <para/>Assumption: The maximum offset is limited, and the offsets that are stored at any one time
            are relatively dense, that is,
            there are normally no gaps of hundreds or thousands of offset values.
            
            <para/>This class optionally also tracks the minimum non-negative count for each position,
            intended to count the smallest number of elements of any path leading to that position.
            
            <para/>The implementation uses a circular buffer of count integers,
            each indicating whether the corresponding offset is in the list,
            and its path element count.
            This avoids inserting into a sorted list of offsets (or absolute indexes)
            and physically moving part of the list.
            
            <para/>Note: In principle, the caller should <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.SetMaxLength(System.Int32)"/> to
            the maximum of the max string length and U16_LENGTH/U8_LENGTH
            to account for "long" single code points.
            
            <para/>Note: An earlier version did not track counts and stored only byte flags.
            With boolean flags, if maxLength were guaranteed to be no more than 32 or 64,
            the list could be stored as bit flags in a single integer.
            Rather than handling a circular buffer with a start list index,
            the integer would simply be shifted when lower offsets are removed.
            UnicodeSet does not have a limit on the lengths of strings.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.Shift(System.Int32)">
            <summary>
            Reduces all stored offsets by delta, used when the current position moves by delta.
            There must not be any offsets lower than delta.
            If there is an offset equal to delta, it is removed.
            </summary>
            <param name="delta">[1..maxLength]</param>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.AddOffset(System.Int32)">
            <summary>
            Adds an offset. The list must not contain it yet.
            </summary>
            <param name="offset">[1..maxLength]</param>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.AddOffsetAndCount(System.Int32,System.Int32)">
            <summary>
            Adds an offset and updates its count.
            The list may already contain the offset.
            </summary>
            <param name="offset">[1..maxLength]</param>
            <param name="count"></param>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.ContainsOffset(System.Int32)">
            <param name="offset">[1..maxLength]</param>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.HasCountAtOffset(System.Int32,System.Int32)">
            <param name="offset">[1..maxLength]</param>
            <param name="count"></param>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.OffsetList.PopMinimum(System.Int32@)">
            <summary>
            Finds the lowest stored offset from a non-empty list, removes it,
            and reduces all other offsets by this minimum.
            </summary>
            <param name="outCount"></param>
            <returns>min=[1..maxLength]</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Spans a string.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Spans a string.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Span(System.Char[],System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Spans a string.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Span(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Spans a string.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanWithStrings(System.String,System.Int32,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Synchronized method for complicated spans using the offsets.
            Avoids synchronization for simple cases.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanLimit">= SpanSet.Span(s, start, Contained)</param>
            <param name="spanCondition"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanWithStrings(System.Text.StringBuilder,System.Int32,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Synchronized method for complicated spans using the offsets.
            Avoids synchronization for simple cases.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanLimit">= SpanSet.Span(s, start, Contained)</param>
            <param name="spanCondition"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanWithStrings(System.Char[],System.Int32,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Synchronized method for complicated spans using the offsets.
            Avoids synchronization for simple cases.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanLimit">= SpanSet.Span(s, start, Contained)</param>
            <param name="spanCondition"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanWithStrings(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Synchronized method for complicated spans using the offsets.
            Avoids synchronization for simple cases.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanLimit">= SpanSet.Span(s, start, Contained)</param>
            <param name="spanCondition"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanAndCount(System.String,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Spans a string and counts the smallest number of set elements on any path across the span.
            </summary>
            <remarks>
            For proper counting, we cannot ignore strings that are fully contained in code point spans.
            <para/>
            If the set does not have any fully-contained strings, then we could optimize this
            like Span(), but such sets are likely rare, and this is at least still linear.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <param name="outCount">The count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanAndCount(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Spans a string and counts the smallest number of set elements on any path across the span.
            </summary>
            <remarks>
            For proper counting, we cannot ignore strings that are fully contained in code point spans.
            <para/>
            If the set does not have any fully-contained strings, then we could optimize this
            like Span(), but such sets are likely rare, and this is at least still linear.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <param name="outCount">The count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanAndCount(System.Char[],System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Spans a string and counts the smallest number of set elements on any path across the span.
            </summary>
            <remarks>
            For proper counting, we cannot ignore strings that are fully contained in code point spans.
            <para/>
            If the set does not have any fully-contained strings, then we could optimize this
            like Span(), but such sets are likely rare, and this is at least still linear.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <param name="outCount">The count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanAndCount(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Spans a string and counts the smallest number of set elements on any path across the span.
            </summary>
            <remarks>
            For proper counting, we cannot ignore strings that are fully contained in code point spans.
            <para/>
            If the set does not have any fully-contained strings, then we could optimize this
            like Span(), but such sets are likely rare, and this is at least still linear.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <param name="outCount">The count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="length"></param>
            <param name="spanCondition">The span condition</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="length"></param>
            <param name="spanCondition">The span condition</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(System.Char[],System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="length"></param>
            <param name="spanCondition">The span condition</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanBack(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="length"></param>
            <param name="spanCondition">The span condition</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNot(System.String,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Algorithm for <c>SpanNot()==Span(SpanCondition.Contained)</c>
            </summary>
            <remarks>
            Theoretical algorithm:
            - Iterate through the string, and at each code point boundary:
              + If the code point there is in the set, then return with the current position.
              + If a set string matches at the current position, then return with the current position.
            <para/>
            Optimized implementation:
            <para/>
            (Same assumption as for Span() above.)
            <para/>
            Create and cache a spanNotSet which contains
            all of the single code points of the original set but none of its strings.
            For each set string add its initial code point to the spanNotSet.
            (Also add its final code point for <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNotBack(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.)
            <para/>
            - Loop:
              + Do spanLength=spanNotSet.Span(SpanCondition.Contained).
              + If the current code point is in the original set, then return the current position.
              + If any set string matches at the current position, then return the current position.
              + If there is no match at the current position, neither for the code point
                there nor for any set string, then skip this code point and continue the loop.
                This happens for set-string-initial code points that were added to spanNotSet
                when there is not actually a match for such a set string.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="includeCount">If true, the number of code points across the span are 
            retrieved and returnd through <paramref name="outCount"/>.</param>
            <param name="outCount">Receives the number of code points across the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNot(System.Text.StringBuilder,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Algorithm for <c>SpanNot()==Span(SpanCondition.Contained)</c>
            </summary>
            <remarks>
            Theoretical algorithm:
            - Iterate through the string, and at each code point boundary:
              + If the code point there is in the set, then return with the current position.
              + If a set string matches at the current position, then return with the current position.
            <para/>
            Optimized implementation:
            <para/>
            (Same assumption as for Span() above.)
            <para/>
            Create and cache a spanNotSet which contains
            all of the single code points of the original set but none of its strings.
            For each set string add its initial code point to the spanNotSet.
            (Also add its final code point for <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNotBack(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.)
            <para/>
            - Loop:
              + Do spanLength=spanNotSet.Span(SpanCondition.Contained).
              + If the current code point is in the original set, then return the current position.
              + If any set string matches at the current position, then return the current position.
              + If there is no match at the current position, neither for the code point
                there nor for any set string, then skip this code point and continue the loop.
                This happens for set-string-initial code points that were added to spanNotSet
                when there is not actually a match for such a set string.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="includeCount">If true, the number of code points across the span are 
            retrieved and returnd through <paramref name="outCount"/>.</param>
            <param name="outCount">Receives the number of code points across the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNot(System.Char[],System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Algorithm for <c>SpanNot()==Span(SpanCondition.Contained)</c>
            </summary>
            <remarks>
            Theoretical algorithm:
            - Iterate through the string, and at each code point boundary:
              + If the code point there is in the set, then return with the current position.
              + If a set string matches at the current position, then return with the current position.
            <para/>
            Optimized implementation:
            <para/>
            (Same assumption as for Span() above.)
            <para/>
            Create and cache a spanNotSet which contains
            all of the single code points of the original set but none of its strings.
            For each set string add its initial code point to the spanNotSet.
            (Also add its final code point for <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNotBack(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.)
            <para/>
            - Loop:
              + Do spanLength=spanNotSet.Span(SpanCondition.Contained).
              + If the current code point is in the original set, then return the current position.
              + If any set string matches at the current position, then return the current position.
              + If there is no match at the current position, neither for the code point
                there nor for any set string, then skip this code point and continue the loop.
                This happens for set-string-initial code points that were added to spanNotSet
                when there is not actually a match for such a set string.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="includeCount">If true, the number of code points across the span are 
            retrieved and returnd through <paramref name="outCount"/>.</param>
            <param name="outCount">Receives the number of code points across the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNot(ICU4N.Support.Text.ICharSequence,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Algorithm for <c>SpanNot()==Span(SpanCondition.Contained)</c>
            </summary>
            <remarks>
            Theoretical algorithm:
            - Iterate through the string, and at each code point boundary:
              + If the code point there is in the set, then return with the current position.
              + If a set string matches at the current position, then return with the current position.
            <para/>
            Optimized implementation:
            <para/>
            (Same assumption as for Span() above.)
            <para/>
            Create and cache a spanNotSet which contains
            all of the single code points of the original set but none of its strings.
            For each set string add its initial code point to the spanNotSet.
            (Also add its final code point for <see cref="M:ICU4N.Impl.UnicodeSetStringSpan.SpanNotBack(ICU4N.Support.Text.ICharSequence,System.Int32)"/>.)
            <para/>
            - Loop:
              + Do spanLength=spanNotSet.Span(SpanCondition.Contained).
              + If the current code point is in the original set, then return the current position.
              + If any set string matches at the current position, then return the current position.
              + If there is no match at the current position, neither for the code point
                there nor for any set string, then skip this code point and continue the loop.
                This happens for set-string-initial code points that were added to spanNotSet
                when there is not actually a match for such a set string.
            </remarks>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="includeCount">If true, the number of code points across the span are 
            retrieved and returnd through <paramref name="outCount"/>.</param>
            <param name="outCount">Receives the number of code points across the span.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Matches16CPB(System.String,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Compare 16-bit Unicode strings (which may be malformed UTF-16)
            at code point boundaries.
            That is, each edge of a match must not be in the middle of a surrogate pair.
            </summary>
            <param name="s">The string to match in.</param>
            <param name="start">The start index of <paramref name="s"/>.</param>
            <param name="limit">The limit of the subsequence of <paramref name="s"/> being spanned.</param>
            <param name="t">The substring to be matched in <paramref name="s"/>.</param>
            <param name="tlength">The length of <paramref name="t"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Matches16CPB(System.Text.StringBuilder,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Compare 16-bit Unicode strings (which may be malformed UTF-16)
            at code point boundaries.
            That is, each edge of a match must not be in the middle of a surrogate pair.
            </summary>
            <param name="s">The string to match in.</param>
            <param name="start">The start index of <paramref name="s"/>.</param>
            <param name="limit">The limit of the subsequence of <paramref name="s"/> being spanned.</param>
            <param name="t">The substring to be matched in <paramref name="s"/>.</param>
            <param name="tlength">The length of <paramref name="t"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Matches16CPB(System.Char[],System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Compare 16-bit Unicode strings (which may be malformed UTF-16)
            at code point boundaries.
            That is, each edge of a match must not be in the middle of a surrogate pair.
            </summary>
            <param name="s">The string to match in.</param>
            <param name="start">The start index of <paramref name="s"/>.</param>
            <param name="limit">The limit of the subsequence of <paramref name="s"/> being spanned.</param>
            <param name="t">The substring to be matched in <paramref name="s"/>.</param>
            <param name="tlength">The length of <paramref name="t"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.Matches16CPB(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Compare 16-bit Unicode strings (which may be malformed UTF-16)
            at code point boundaries.
            That is, each edge of a match must not be in the middle of a surrogate pair.
            </summary>
            <param name="s">The string to match in.</param>
            <param name="start">The start index of <paramref name="s"/>.</param>
            <param name="limit">The limit of the subsequence of <paramref name="s"/> being spanned.</param>
            <param name="t">The substring to be matched in <paramref name="s"/>.</param>
            <param name="tlength">The length of <paramref name="t"/>.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanOne(ICU4N.Text.UnicodeSet,System.String,System.Int32,System.Int32)">
            <summary>
            Does the set contain the next code point?
            If so, return its length; otherwise return its negative length.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanOne(ICU4N.Text.UnicodeSet,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Does the set contain the next code point?
            If so, return its length; otherwise return its negative length.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanOne(ICU4N.Text.UnicodeSet,System.Char[],System.Int32,System.Int32)">
            <summary>
            Does the set contain the next code point?
            If so, return its length; otherwise return its negative length.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UnicodeSetStringSpan.SpanOne(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Does the set contain the next code point?
            If so, return its length; otherwise return its negative length.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UPropertyAliases">
            <summary>
            Wrapper for the pnames.icu binary data file.  This data file is
            imported from icu4c.  It contains property and property value
            aliases from the UCD files PropertyAliases.txt and
            PropertyValueAliases.txt.  The file is built by the icu4c tool
            genpname.  It must be an ASCII big-endian file to be
            usable in ICU4N.
            </summary>
            <remarks>
            This class performs two functions.
            <list type="number">
                <item><description>It can import the flat binary data into usable objects.</description></item>
                <item><description>It provides an API to access the tree of objects.</description></item>
            </list>
            <para/>
            Needless to say, this class is tightly coupled to the binary format
            of icu4c's pnames.icu file.
            <para/>
            Each time a <see cref="T:ICU4N.Impl.UPropertyAliases"/> is constructed, the pnames.icu file is
            read, parsed, and data structures assembled.  Clients should create one
            singleton instance and cache it.
            </remarks>
            <author>Alan Liu</author>
            <since>ICU 2.4</since>
        </member>
        <member name="P:ICU4N.Impl.UPropertyAliases.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice)">
            <summary>
            Returns a property name given a <paramref name="property"/> enum.
            Multiple names may be available for each property;
            the <paramref name="nameChoice"/> selects among them.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyName(ICU4N.Globalization.UProperty,ICU4N.Globalization.NameChoice,System.String@)">
            <summary>
            Returns a property name given a <paramref name="property"/> enum.
            Multiple names may be available for each property;
            the <paramref name="nameChoice"/> selects among them.
            </summary>
            <stable>ICU4N 60.1.0</stable>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)">
            <summary>
            Returns a value name given a <paramref name="property"/> enum and a <paramref name="value"/> enum.
            Multiple names may be available for each value;
            the <paramref name="nameChoice"/> selects among them.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice,System.String@)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice,System.String@)">
            <summary>
            Gets a value name given a <paramref name="property"/> enum and a <paramref name="value"/> enum.
            Multiple names may be available for each value;
            the <paramref name="nameChoice"/> selects among them.
            <para/>
            This method is equivalent to <see cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/>
            but will return a true/false result rather than throwing exceptions.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueName(ICU4N.Globalization.UProperty,System.Int32,ICU4N.Globalization.NameChoice)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnumNoThrow(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns a value enum given a property enum and one of its value names. Does not throw.
            </summary>
            <returns>value enum, or <see cref="F:ICU4N.Globalization.UProperty.Undefined"/> if not defined for that property</returns>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.Compare(System.String,System.String)">
            <summary>
            Compare two property names, returning &lt;0, 0, or >0.  The
            comparison is that described as "loose" matching in the
            Property*Aliases.txt files.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyEnum(System.String)">
            <summary>
            Returns a property enum given one of its property names.
            If the property name is not known, this method returns
            <see cref="F:ICU4N.Globalization.UProperty.Undefined"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyEnum(System.Text.StringBuilder)">
            <summary>
            Returns a property enum given one of its property names.
            If the property name is not known, this method returns
            <see cref="F:ICU4N.Globalization.UProperty.Undefined"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyEnum(System.Char[])">
            <summary>
            Returns a property enum given one of its property names.
            If the property name is not known, this method returns
            <see cref="F:ICU4N.Globalization.UProperty.Undefined"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyEnum(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns a property enum given one of its property names.
            If the property name is not known, this method returns
            <see cref="F:ICU4N.Globalization.UProperty.Undefined"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String,System.Int32@)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder,System.Int32@)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[])">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[],System.Int32@)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence,System.Int32@)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String,System.Int32@)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.String)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder,System.Int32@)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Text.StringBuilder)"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[],System.Int32@)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,System.Char[])"/>
        </member>
        <member name="M:ICU4N.Impl.UPropertyAliases.TryGetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence,System.Int32@)">
            <summary>
            Returns a value enum given a property enum and one of its value names.
            </summary>
            <seealso cref="M:ICU4N.Impl.UPropertyAliases.GetPropertyValueEnum(ICU4N.Globalization.UProperty,ICU4N.Support.Text.ICharSequence)"/>
        </member>
        <member name="T:ICU4N.Impl.UResource">
            <summary>
            ICU resource bundle key and value types.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UResource.Key">
            <summary>
            Represents a resource bundle item's key string.
            Avoids object creations as much as possible.
            Mutable, not thread-safe.
            For permanent storage, use <see cref="M:ICU4N.Impl.UResource.Key.Clone"/> or <see cref="M:ICU4N.Impl.UResource.Key.ToString"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.#ctor">
            <summary>
            Constructs an empty resource key string object.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.#ctor(System.String)">
            <summary>
            Constructs a resource key object equal to the given string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.SetBytes(System.Byte[],System.Int32)">
            <summary>
            Mutates this key for a new NUL-terminated resource key string.
            The corresponding ASCII-character bytes are not copied and
            must not be changed during the lifetime of this key
            (or until the next <see cref="M:ICU4N.Impl.UResource.Key.SetBytes(System.Byte[],System.Int32)"/> call)
            and lifetimes of subSequences created from this key.
            </summary>
            <param name="keyBytes">New key string byte array.</param>
            <param name="keyOffset">New key string offset.</param>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.SetToEmpty">
            <summary>
            Mutates this key to an empty resource key string.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.SetString(System.String)">
            <summary>
            Mutates this key to be equal to the given string.
            </summary>
            <returns>This.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            Does not clone the byte array.
            </summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.ToString">
            <summary>
            Creates/caches/returns this resource key string as a .NET <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.Substring(System.Int32)">
            <summary>
            Creates a new .NET <see cref="T:System.String"/> for a sub-sequence of this resource key string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.Substring(System.Int32,System.Int32)">
            <summary>
            Creates a new .NET <see cref="T:System.String"/> for a sub-sequence of this resource key string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.RegionMatches(System.Int32,System.String)">
            <returns>true if the substring of this key starting from the offset
            contains the same characters as the other sequence.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.RegionMatches(System.Int32,System.Text.StringBuilder)">
            <returns>true if the substring of this key starting from the offset
            contains the same characters as the other sequence.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.RegionMatches(System.Int32,System.Char[])">
            <returns>true if the substring of this key starting from the offset
            contains the same characters as the other sequence.</returns>
        </member>
        <member name="M:ICU4N.Impl.UResource.Key.RegionMatches(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <returns>true if the substring of this key starting from the offset
            contains the same characters as the other sequence.</returns>
        </member>
        <member name="T:ICU4N.Impl.UResource.IArray">
            <summary>
            Interface for iterating over a resource bundle array resource.
            Does not use .NET enumerator to reduce object creations.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UResource.IArray.Length">
            <summary>
            Gets the number of items in the array resource.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.IArray.GetValue(System.Int32,ICU4N.Impl.UResource.Value)">
            <summary>
            Returns true if i is non-negative and less than <see cref="P:ICU4N.Impl.UResource.IArray.Length"/>.
            </summary>
            <param name="i">Array item index.</param>
            <param name="value">Output-only, receives the value of the i'th item.</param>
            <returns>true if i is non-negative and less than <see cref="P:ICU4N.Impl.UResource.IArray.Length"/>.</returns>
        </member>
        <member name="T:ICU4N.Impl.UResource.ITable">
            <summary>
            Interface for iterating over a resource bundle table resource.
            Does not use .NET enumerator to reduce object creations.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UResource.ITable.Length">
            <summary>
            Gets the number of items in the table resource.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.ITable.GetKeyAndValue(System.Int32,ICU4N.Impl.UResource.Key,ICU4N.Impl.UResource.Value)">
            <summary>
            Returns true if i is non-negative and less than <see cref="P:ICU4N.Impl.UResource.ITable.Length"/>.
            </summary>
            <param name="i">Array item index.</param>
            <param name="key">Output-only, receives the key of the i'th item.</param>
            <param name="value">Output-only, receives the value of the i'th item.</param>
            <returns>true if i is non-negative and less than <see cref="P:ICU4N.Impl.UResource.ITable.Length"/>.</returns>
        </member>
        <member name="T:ICU4N.Impl.UResource.Value">
            <summary>
            Represents a resource bundle item's value.
            Avoids object creations as much as possible.
            Mutable, not thread-safe.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.UResource.Value.Type">
            <summary>
            Gets ICU resource type like <see cref="P:ICU4N.Util.UResourceBundle.Type"/>
            for example, <see cref="F:ICU4N.Util.UResourceBundle.STRING"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetString">
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetString"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not a string resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetAliasString">
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an alias resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetInt32">
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetInt32"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an integer resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetUInt32">
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetUInt32"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an integer resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetInt32Vector">
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetInt32Vector"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an intvector resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetBinary">
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetBinary"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not a binary-blob resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetArray">
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an array resource.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetTable">
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not a table resource.</exception>
        </member>
        <member name="P:ICU4N.Impl.UResource.Value.IsNoInheritanceMarker">
            <summary>
            Is this a no-fallback/no-inheritance marker string?
            Such a marker is used for CLDR no-fallback data values of ""
            when enumerating tables with fallback from the specific resource bundle to root.
            Returns true if this is a no-inheritance marker string.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetStringArray">
            <summary>
            The array of strings in this array resource.
            </summary>
            <seealso cref="M:ICU4N.Util.UResourceBundle.GetStringArray"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is not an array resource
            or if any of the array items is not a string.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetStringArrayOrStringAsArray">
            <summary>
            Same as
            <code>
            if (Type == UResourceType.String)
            {
                return new string[] { GetString(); }
            }
            else
            {
                return GetStringArray();
            }
            </code>
            </summary>
            <seealso cref="M:ICU4N.Impl.UResource.Value.GetString"/>
            <seealso cref="M:ICU4N.Impl.UResource.Value.GetStringArray"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is
            neither a string resource nor an array resource containing strings.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.GetStringOrFirstOfArray">
            <summary>
            Same as
            <code>
            if (Type == UResourceType.String)
            {
                return GetString();
            }
            else
            {
                return GetStringArray()[0];
            }
            </code>
            </summary>
            <seealso cref="M:ICU4N.Impl.UResource.Value.GetString"/>
            <seealso cref="M:ICU4N.Impl.UResource.Value.GetStringArray"/>
            <exception cref="T:ICU4N.Util.UResourceTypeMismatchException">If this is
            neither a string resource nor an array resource containing strings.</exception>
        </member>
        <member name="M:ICU4N.Impl.UResource.Value.ToString">
            <summary>
            Only for debugging.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UResource.Sink">
            <summary>
            Sink for ICU resource bundle contents.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.UResource.Sink.Put(ICU4N.Impl.UResource.Key,ICU4N.Impl.UResource.Value,System.Boolean)">
            <summary>
            Called once for each bundle (child-parent-...-root).
            The value is normally an array or table resource,
            and implementations of this method normally iterate over the
            tree of resource items stored there.
            </summary>
            <param name="key">Initially the key string of the enumeration-start resource.
            Empty if the enumeration starts at the top level of the bundle.
            Reuse for output values from <see cref="T:ICU4N.Impl.UResource.IArray"/> and <see cref="T:ICU4N.Impl.UResource.ITable"/> getters.</param>
            <param name="value">Call <see cref="M:ICU4N.Impl.UResource.Value.GetArray"/> or <see cref="M:ICU4N.Impl.UResource.Value.GetTable"/> as appropriate.
            Then reuse for output values from <see cref="T:ICU4N.Impl.UResource.IArray"/> and <see cref="T:ICU4N.Impl.UResource.ITable"/> getters.</param>
            <param name="noFallback">true if the bundle has no parent;
            that is, its top-level table has the nofallback attribute,
            or it is the root bundle of a locale tree.</param>
        </member>
        <member name="T:ICU4N.Impl.USerializedSet">
            <summary>
            Simple class for handling serialized USet/UnicodeSet structures
            without object creation. See ICU4C icu/source/common/uset.c.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.USerializedSet.GetSet(System.Char[],System.Int32)">
            <summary>
            Fill in the given serialized set object.
            </summary>
            <param name="src">Pointer to start of array.</param>
            <param name="srcStart">Pointer to start of serialized data (length value).</param>
            <returns>true if the given array is valid, otherwise false.</returns>
        </member>
        <member name="M:ICU4N.Impl.USerializedSet.SetToOne(System.Int32)">
            <summary>
            Set the <see cref="T:ICU4N.Impl.USerializedSet"/> to contain the given character (and nothing
            else).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.USerializedSet.GetRange(System.Int32,System.Int32[])">
            <summary>
            Returns a range of characters contained in the given serialized
            set.
            </summary>
            <param name="rangeIndex">A non-negative integer in the range <c>0..GetSerializedRangeCount()-1</c>.</param>
            <param name="range">Variable to receive the data in the range.</param>
            <returns>true if rangeIndex is valid, otherwise false.</returns>
        </member>
        <member name="M:ICU4N.Impl.USerializedSet.Contains(System.Int32)">
            <summary>
            Returns true if the current <see cref="T:ICU4N.Impl.USerializedSet"/> contains the given
            character.
            </summary>
            <param name="c">The character to test for.</param>
            <returns>true if set contains c.</returns>
        </member>
        <member name="M:ICU4N.Impl.USerializedSet.CountRanges">
            <summary>
            Returns the number of disjoint ranges of characters contained in
            the given serialized set.  Ignores any strings contained in the set.
            </summary>
            <returns>A non-negative integer counting the character ranges contained in set.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayEquals(System.Object[],System.Object)">
            <summary>
            Convenience utility to compare two <see cref="T:object[]"/>s.
            Ought to be in System.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayEquals(System.Int32[],System.Object)">
            <summary>
            Convenience utility to compare two <see cref="T:int[]"/>s.
            Ought to be in System.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayEquals(System.Double[],System.Object)">
            <summary>
            Convenience utility to compare two <see cref="T:double[]"/>s.
            Ought to be in System.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayEquals(System.Object,System.Object)">
            <summary>
            Convenience utility to compare two <see cref="T:object[]"/>s.
            Ought to be in System.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayRegionMatches(System.Object[],System.Int32,System.Object[],System.Int32,System.Int32)">
            <summary>
            Convenience utility to compare two <see cref="T:object[]"/>s.
            Ought to be in System.
            </summary>
            <param name="source"></param>
            <param name="sourceStart"></param>
            <param name="target"></param>
            <param name="targetStart"></param>
            <param name="len">The length to compare. The start indices and start+len must be valid.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayRegionMatches(System.Char[],System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Convenience utility to compare two <see cref="T:char[]"/>s.
            Ought to be in System.
            </summary>
            <param name="source"></param>
            <param name="sourceStart"></param>
            <param name="target"></param>
            <param name="targetStart"></param>
            <param name="len">The length to compare. The start indices and start+len must be valid.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayRegionMatches(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Convenience utility to compare two <see cref="T:int[]"/>s.
            Ought to be in System.
            </summary>
            <param name="source"></param>
            <param name="sourceStart"></param>
            <param name="target"></param>
            <param name="targetStart"></param>
            <param name="len">The length to compare. The start indices and start+len must be valid.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayRegionMatches(System.Double[],System.Int32,System.Double[],System.Int32,System.Int32)">
            <summary>
            Convenience utility to compare two <see cref="T:double[]"/>s.
            Ought to be in System.
            </summary>
            <param name="source"></param>
            <param name="sourceStart"></param>
            <param name="target"></param>
            <param name="targetStart"></param>
            <param name="len">The length to compare. The start indices and start+len must be valid.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.SameObjects(System.Object,System.Object)">
            <summary>
            Trivial reference equality.
            This method should help document that we really want == not <see cref="M:ICU4N.Impl.Utility.Equals(System.Object,System.Object)"/>
            and to have a single place to suppress warnings from static analysis tools.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ObjectEquals(System.Object,System.Object)">
            <summary>
            Convenience utility. Does null checks on objects, then calls <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.CheckCompare(System.String,System.String)">
            <summary>
            Convenience utility. Does null checks on objects, then calls <see cref="M:ICU4N.Support.Text.StringExtensions.CompareToOrdinal(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.CheckCompare``1(``0,``0)">
            <summary>
            Convenience utility. Does null checks on objects, then calls <see cref="M:System.IComparable`1.CompareTo(`0)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.CheckCompare(System.IComparable,System.IComparable)">
            <summary>
            Convenience utility. Does null checks on objects, then calls <see cref="M:System.IComparable.CompareTo(System.Object)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.CheckHashCode(System.Object)">
            <summary>
            Convenience utility. Does null checks on object, then calls <see cref="M:System.Object.GetHashCode"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Utility.ESCAPE">
            <summary>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> character is used during run-length encoding.  It signals
            a run of identical chars.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Utility.ESCAPE_BYTE">
            <summary>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE_BYTE"/> character is used during run-length encoding.  It signals
            a run of identical bytes.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayToRLEString(System.Int32[])">
            <summary>
            Construct a string representing an <see cref="T:System.Int32"/> array.  Use run-length encoding.
            </summary>
            <remarks>
            A character represents itself, unless it is the <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> character.  Then
            the following notations are possible:
            <code>
              ESCAPE ESCAPE   ESCAPE literal
              ESCAPE n c      n instances of character c
            </code>
            Since an encoded run occupies 3 characters, we only encode runs of 4 or
            more characters.  Thus we have n > 0 and n != <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> and n &lt;= 0xFFFF.
            If we encounter a run where n == <see cref="F:ICU4N.Impl.Utility.ESCAPE"/>, we represent this as:
            <code>
              c ESCAPE n-1 c
            </code>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> value is chosen so as not to collide with commonly
            seen values.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayToRLEString(System.Int16[])">
            <summary>
            Construct a string representing a <see cref="T:System.Int16"/> array.  Use run-length encoding.
            </summary>
            <remarks>
            A character represents itself, unless it is the <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> character.  Then
            the following notations are possible:
            <code>
              ESCAPE ESCAPE   ESCAPE literal
              ESCAPE n c      n instances of character c
            </code>
            Since an encoded run occupies 3 characters, we only encode runs of 4 or
            more characters.  Thus we have n > 0 and n != <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> and n &lt;= 0xFFFF.
            If we encounter a run where n == <see cref="F:ICU4N.Impl.Utility.ESCAPE"/>, we represent this as:
            <code>
              c ESCAPE n-1 c
            </code>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> value is chosen so as not to collide with commonly
            seen values.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayToRLEString(System.Char[])">
            <summary>
            Construct a string representing a <see cref="T:System.Char"/> array.  Use run-length encoding.
            </summary>
            <remarks>
            A character represents itself, unless it is the <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> character.  Then
            the following notations are possible:
            <code>
              ESCAPE ESCAPE   ESCAPE literal
              ESCAPE n c      n instances of character c
            </code>
            Since an encoded run occupies 3 characters, we only encode runs of 4 or
            more characters.  Thus we have n > 0 and n != <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> and n &lt;= 0xFFFF.
            If we encounter a run where n == <see cref="F:ICU4N.Impl.Utility.ESCAPE"/>, we represent this as:
            <code>
              c ESCAPE n-1 c
            </code>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE"/> value is chosen so as not to collide with commonly
            seen values.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Utility.ArrayToRLEString(System.Byte[])">
            <summary>
            Construct a string representing a <see cref="T:System.Byte"/> array.  Use run-length encoding.
            </summary>
            <remarks>
            Two bytes are packed into a single <see cref="T:System.Char"/>, with a single extra zero byte at
            the end if needed.  A byte represents itself, unless it is the
            <see cref="F:ICU4N.Impl.Utility.ESCAPE_BYTE"/>.  Then the following notations are possible:
            <code>
              ESCAPE_BYTE ESCAPE_BYTE   ESCAPE_BYTE literal
              ESCAPE_BYTE n b           n instances of byte b
            </code>
            Since an encoded run occupies 3 bytes, we only encode runs of 4 or
            more bytes.  Thus we have n > 0 and n != <see cref="F:ICU4N.Impl.Utility.ESCAPE_BYTE"/> and n &lt;= 0xFF.
            If we encounter a run where n == <see cref="F:ICU4N.Impl.Utility.ESCAPE_BYTE"/>, we represent this as:
            <code>
              b ESCAPE_BYTE n-1 b
            </code>
            The <see cref="F:ICU4N.Impl.Utility.ESCAPE_BYTE"/> value is chosen so as not to collide with commonly
            seen values.
            </remarks>
        </member>
        <member name="M:ICU4N.Impl.Utility.RLEStringToIntArray(System.String)">
            <summary>
            Construct an array of <see cref="T:System.Int32"/>s from a run-length encoded <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.RLEStringToShortArray(System.String)">
            <summary>
            Construct an array of <see cref="T:System.Int16"/>s from a run-length encoded <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.RLEStringToCharArray(System.String)">
            <summary>
            Construct an array of <see cref="T:System.Char"/>s from a run-length encoded <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.RLEStringToByteArray(System.String)">
            <summary>
            Construct an array of <see cref="T:System.Byte"/>s from a run-length encoded <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.FormatForSource(System.String)">
            <summary>
            Format a string for representation in a source file.  This includes
            breaking it into lines and escaping characters using octal notation
            when necessary (control characters and double quotes).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Format1ForSource(System.String)">
            <summary>
            Format a string for representation in a source file.  Like
            <see cref="M:ICU4N.Impl.Utility.FormatForSource(System.String)"/> but does not do line breaking.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Escape(System.String)">
            <summary>
            Convert characters outside the range U+0020 to U+007F to
            Unicode escapes, and convert backslash to a double backslash.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.UnescapeAt(System.String,System.Int32[])">
            <summary>
            Convert an escape to a 32-bit code point value.  We attempt
            to parallel the icu4c unescapeAt() function.
            </summary>
            <param name="s"></param>
            <param name="offset16">An array containing offset to the character
            <em>after</em> the backslash.  Upon return offset16[0] will
            be updated to point after the escape sequence.</param>
            <returns>Character value from 0 to 10FFFF, or -1 on error.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.Unescape(System.String)">
            <summary>
            Convert all escapes in a given string using <see cref="M:ICU4N.Impl.Utility.UnescapeAt(System.String,System.Int32[])"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If an invalid escape is seen.</exception>
        </member>
        <member name="M:ICU4N.Impl.Utility.UnescapeLeniently(System.String)">
            <summary>
            Convert all escapes in a given string using <see cref="M:ICU4N.Impl.Utility.UnescapeAt(System.String,System.Int32[])"/>.
            Leave invalid escape sequences unchanged.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Int64)">
            <summary>
            Convert a char to 4 hex uppercase digits.  E.g., hex('a') =>
            "0041".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Int64,System.Int32)">
            <summary>
            Supplies a zero-padded hex representation of an integer (without 0x)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Split(System.String,System.Char,System.String[])">
            <summary>
            Split a string into pieces based on the given <paramref name="divider"/> character
            </summary>
            <param name="s">The string to split.</param>
            <param name="divider">The character on which to split.  Occurrences of
            this character are not included in the output.</param>
            <param name="output">An array to receive the substrings between
            instances of divider.  It must be large enough on entry to
            accomodate all output.  Adjacent instances of the <paramref name="divider"/>
            character will place empty strings into output.  Before
            returning, output is padded out with empty strings.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.Split(System.String,System.Char)">
            <summary>
            Split a string into pieces based on the given <paramref name="divider"/> character.
            </summary>
            <param name="s">The string to split.</param>
            <param name="divider">The character on which to split.  Occurrences of
            this character are not included in the output.</param>
            <returns>An array of the substrings between
            instances of <paramref name="divider"/>. Adjacent instances of the <paramref name="divider"/>
            character will place empty strings into output.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.Lookup(System.String,System.String[])">
            <summary>
            Look up a given string in a string array.  Returns the index at
            which the first occurrence of the string was found in the
            array, or -1 if it was not found.
            </summary>
            <param name="source">The string to search for.</param>
            <param name="target">The array of zero or more strings in which to
            look for source.</param>
            <returns>The index of target at which source first occurs, or -1
            if not found.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParseChar(System.String,System.Int32[],System.Char)">
            <summary>
            Parse a single non-whitespace character '<paramref name="ch"/>', optionally
            preceded by whitespace.
            </summary>
            <param name="id">The string to be parsed.</param>
            <param name="pos">INPUT-OUTPUT parameter.  On input, pos[0] is the
            offset of the first character to be parsed.  On output, pos[0]
            is the index after the last parsed character.  If the parse
            fails, pos[0] will be unchanged.</param>
            <param name="ch">The non-whitespace character to be parsed.</param>
            <returns>true if '<paramref name="ch"/>' is seen preceded by zero or more
            whitespace characters.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParsePattern(System.String,System.Int32,System.Int32,System.String,System.Int32[])">
            <summary>
            Parse a pattern string starting at offset pos.  Keywords are
            matched case-insensitively.  Spaces may be skipped and may be
            optional or required.  Integer values may be parsed, and if
            they are, they will be returned in the given array.  If
            successful, the offset of the next non-space character is
            returned.  On failure, -1 is returned.
            </summary>
            <param name="rule"></param>
            <param name="pos"></param>
            <param name="limit"></param>
            <param name="pattern">Must only contain lowercase characters, which
            will match their uppercase equivalents as well.  A space
            character matches one or more required spaces.  A '~' character
            matches zero or more optional spaces.  A '#' character matches
            an integer and stores it in <paramref name="parsedInts"/>, which the caller must
            ensure has enough capacity.</param>
            <param name="parsedInts">Array to receive parsed integers.  Caller
            must ensure that parsedInts.Length is >= the number of '#'
            signs in 'pattern'.</param>
            <returns>The position after the last character parsed, or -1 if
            the parse failed.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParsePattern(System.String,ICU4N.Text.IReplaceable,System.Int32,System.Int32)">
            <summary>
            Parse a pattern string within the given <see cref="T:ICU4N.Text.IReplaceable"/> and a parsing
            pattern.  Characters are matched literally and case-sensitively
            except for the following special characters:
            <code>
            ~  zero or more Pattern_White_Space chars
            </code>
            If end of pattern is reached with all matches along the way,
            pos is advanced to the first unparsed index and returned.
            Otherwise -1 is returned.
            </summary>
            <param name="pat">Pattern that controls parsing.</param>
            <param name="text">Text to be parsed, starting at index.</param>
            <param name="index">Offset to first character to parse.</param>
            <param name="limit">Offset after last character to parse.</param>
            <returns>Index after last parsed character, or -1 on parse failure.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParseInteger(System.String,System.Int32[],System.Int32)">
            <summary>
            Parse an integer at pos, either of the form \d+ or of the form
            0x[0-9A-Fa-f]+ or 0[0-7]+, that is, in standard decimal, hex,
            or octal format.
            </summary>
            <param name="rule"></param>
            <param name="pos">INPUT-OUTPUT parameter.  On input, the first
            character to parse.  On output, the character after the last
            parsed character.</param>
            <param name="limit"></param>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParseUnicodeIdentifier(System.String,System.Int32[])">
            <summary>
            Parse a Unicode identifier from the given string at the given
            position.  Return the identifier, or null if there is no
            identifier.
            </summary>
            <param name="str">The string to parse.</param>
            <param name="pos">INPUT-OUPUT parameter.  On INPUT, pos[0] is the
            first character to examine.  It must be less than str.Length,
            and it must not point to a whitespace character.  That is, must
            have pos[0] &lt; str.Length.  On
            OUTPUT, the position after the last parsed character.</param>
            <returns>The Unicode identifier, or null if there is no valid
            identifier at pos[0].</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ParseNumber(System.String,System.Int32[],System.Int32)">
            <summary>
            Parse an unsigned 31-bit integer at the given offset.  Use
            <see cref="M:ICU4N.UChar.Digit(System.Int32,System.Int32)"/> to parse individual characters into digits.
            </summary>
            <param name="text">The text to be parsed.</param>
            <param name="pos">INPUT-OUTPUT parameter.  On entry, pos[0] is the
            offset within text at which to start parsing; it should point
            to a valid digit.  On exit, pos[0] is the offset after the last
            parsed character.  If the parse failed, it will be unchanged on
            exit.  Must be >= 0 on entry.</param>
            <param name="radix">The radix in which to parse; must be >= 2 and &lt;= 36.</param>
            <returns>A non-negative parsed number, or -1 upon parse failure.
            Parse fails if there are no digits, that is, if pos[0] does not
            point to a valid digit on entry, or if the number to be parsed
            does not fit into a 31-bit unsigned integer.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.IsUnprintable(System.Int32)">
            <summary>
            Return true if the character is NOT printable ASCII.  The tab,
            newline and linefeed characters are considered unprintable.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.QuotedIndexOf(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Returns the index of the first character in a set, ignoring quoted text.
            For example, in the string "abc'hide'h", the 'h' in "hide" will not be
            found by a search for "h".  Unlike <see cref="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)"/>, this method searches
            not for a single character, but for any character of the string <paramref name="setOfChars"/>.
            </summary>
            <param name="text">Text to be searched.</param>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= start &lt;= limit</c>.</param>
            <param name="limit">The ending index, exclusive; <c>start &lt;= limit &lt;= text.Length</c>.</param>
            <param name="setOfChars">String with one or more distinct characters.</param>
            <returns>Offset of the first character in <paramref name="setOfChars"/>
            found, or -1 if not found.</returns>
            <seealso cref="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendToRule(System.Text.StringBuilder,System.Int32,System.Boolean,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Append a character to a rule that is being built up.  To flush
            the <paramref name="quoteBuf"/> to <paramref name="rule"/>, make one final call with <paramref name="isLiteral"/> == true.
            If there is no final character, pass in (int)-1 as <paramref name="c"/>.
            </summary>
            <param name="rule">The string to append the character to.</param>
            <param name="c">The character to append, or (int)-1 if none.</param>
            <param name="isLiteral">If true, then the given character should not be
            quoted or escaped.  Usually this means it is a syntactic element
            such as > or $.</param>
            <param name="escapeUnprintable">If true, then unprintable characters
            should be escaped using <see cref="M:ICU4N.Impl.Utility.EscapeUnprintable(System.Text.StringBuilder,System.Int32)"/>.  These escapes will
            appear outside of quotes.</param>
            <param name="quoteBuf">A buffer which is used to build up quoted
            substrings.  The caller should initially supply an empty buffer,
            and thereafter should not modify the buffer.  The buffer should be
            cleared out by, at the end, calling this method with a literal
            character (which may be -1).</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendToRule(System.Text.StringBuilder,System.String,System.Boolean,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Append the given string to the rule.  Calls the single-character
            version of <see cref="M:ICU4N.Impl.Utility.AppendToRule(System.Text.StringBuilder,System.Int32,System.Boolean,System.Boolean,System.Text.StringBuilder)"/> for each character.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendToRule(System.Text.StringBuilder,ICU4N.Text.IUnicodeMatcher,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Given a matcher reference, which may be null, append its
            pattern as a literal to the given rule.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.CompareUnsigned(System.Int32,System.Int32)">
            <summary>
            Compares 2 unsigned integers.
            </summary>
            <param name="source">32 bit unsigned integer.</param>
            <param name="target">32 bit unsigned integer.</param>
            <returns>0 if equals, 1 if source is greater than target and -1 otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.HighBit(System.Int32)">
            <summary>
            Find the highest bit in a positive integer. This is done
            by doing a binary search through the bits.
            </summary>
            <remarks>
            Return type changed from byte in ICU4J to short in ICU4N because it can
            have negative values, which <see cref="T:System.Byte"/> doesn't support in .NET, and 
            <see cref="T:System.SByte"/> is not CLS compliant.
            </remarks>
            <param name="n">The integer.</param>
            <returns>the bit number of the highest bit, with 0 being
            the low order bit, or -1 if <paramref name="n"/> is not positive.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ValueOf(System.Int32[])">
            <summary>
            Utility method to take a <see cref="T:int[]"/> containing codepoints and return
            a string representation with code units.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Repeat(System.String,System.Int32)">
            <summary>
            Utility to duplicate a string count times.
            </summary>
            <param name="s">String to be duplicated.</param>
            <param name="count">Number of times to duplicate a string.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.SplitWhitespace(System.String)">
            <summary>
            Split the string at runs of ascii whitespace characters.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.FromHex(System.String,System.Int32,System.String)">
            <summary>
            Parse a list of hex numbers and return a string.
            </summary>
            <param name="str">String of hex numbers.</param>
            <param name="minLength">Minimal length.</param>
            <param name="separator">Separator.</param>
            <returns>A string from hex numbers.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.FromHex(System.String,System.Int32,System.Text.RegularExpressions.Regex)">
            <summary>
            Parse a list of hex numbers and return a string.
            </summary>
            <param name="str">String of hex numbers.</param>
            <param name="minLength">Minimal length.</param>
            <param name="separator">Separator.</param>
            <returns>A string from hex numbers.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.Equals(System.Object,System.Object)">
            <summary>
            This implementation is equivalent to Java 7+ Objects.equals(Object a, Object b).
            Note this compares the values in any nested collections.
            </summary>
            <param name="a">An object.</param>
            <param name="b">An object to be compared with a for equality.</param>
            <returns>true if the arguments are equal to each other and false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hash(System.Object[])">
            <summary>
            This implementation is equivalent to Java 7+ Objects.hash(Object... values).
            Note this takes into consideration the values in any nested collections.
            </summary>
            <param name="values">The values to be hashed.</param>
            <returns>A hash value of the sequence of input values.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.GetHashCode(System.Object)">
            <summary>
            This implementation is equivalent to Java 7+ Objects.hashCode(Object o).
            Note this takes into consideration the values in any nested collections.
            </summary>
            <param name="o">An object.</param>
            <returns>A hash value of a non-null argument and 0 for null argument.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.ToString(System.Object)">
            <summary>
            This implementation is equivalent to Java 7+ Objects.toString(Object o).
            Note this takes into consideration the values in any nested collections.
            </summary>
            <param name="o">An object.</param>
            <returns>the result of calling <see cref="M:ICU4N.Support.Collections.CollectionUtil.ToString(System.Object)"/> for a non-null argument and "null" for a
            null argument.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(ICU4N.Support.Text.IAppendable,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(System.Text.StringBuilder,System.Int16,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(ICU4N.Support.Text.IAppendable,System.Int16,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(System.Text.StringBuilder,System.Byte,System.Int32,System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Utility.EncodeRun(ICU4N.Support.Text.IAppendable,System.Byte,System.Int32,System.Byte[])" -->
        <member name="M:ICU4N.Impl.Utility.AppendEncodedByte(System.Text.StringBuilder,System.Byte,System.Byte[])">
            <summary>
            Append a byte to the given <see cref="T:System.Text.StringBuilder"/>, packing two bytes into each
            character.  The state parameter maintains intermediary data between
            calls.
            </summary>
            <param name="buffer"></param>
            <param name="value"></param>
            <param name="state">A two-element array, with state[0] == 0 if this is the
            first byte of a pair, or state[0] != 0 if this is the second byte
            of a pair, in which case state[1] is the first byte.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendEncodedByte(ICU4N.Support.Text.IAppendable,System.Byte,System.Byte[])">
            <summary>
            Append a byte to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>, packing two bytes into each
            character.  The state parameter maintains intermediary data between
            calls.
            </summary>
            <param name="buffer"></param>
            <param name="value"></param>
            <param name="state">A two-element array, with state[0] == 0 if this is the
            first byte of a pair, or state[0] != 0 if this is the second byte
            of a pair, in which case state[1] is the first byte.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[])">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.String,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.Text.StringBuilder,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.Char[],System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.String,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.Char[],System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.String,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.Text.StringBuilder,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.Char[],System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.String,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.Text.StringBuilder,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.Char[],System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,System.Text.StringBuilder)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.String,System.Int32,System.String,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.String,System.Int32,System.Text.StringBuilder,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.String,System.Int32,System.Char[],System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.String,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Text.StringBuilder,System.Int32,System.String,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Text.StringBuilder,System.Int32,System.Char[],System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Text.StringBuilder,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Char[],System.Int32,System.String,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Char[],System.Int32,System.Text.StringBuilder,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Char[],System.Int32,System.Char[],System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(System.Char[],System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(ICU4N.Support.Text.ICharSequence,System.Int32,System.String,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(ICU4N.Support.Text.ICharSequence,System.Int32,System.Text.StringBuilder,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(ICU4N.Support.Text.ICharSequence,System.Int32,System.Char[],System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex``1(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Support.Text.ICharSequence,System.Boolean,``0)">
            <summary>
            Convert a string to separated groups of hex uppercase
            digits.  E.g., hex('ab'...) => "0041,0042".  Append the output
            to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.String)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,System.Char[])">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.String,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,System.Char[])">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Text.StringBuilder,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.String)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,System.Char[])">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(System.Char[],System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.String)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,System.Char[])">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.Hex(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Convert a string to comma-separated groups of 4 hex uppercase
            digits.  E.g., hex('ab') => "0041,0042".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.RecursiveAppendNumber(System.Text.StringBuilder,System.Int32,System.Int32,System.Int32)">
            <summary>
            Append the digits of a positive integer to the given
            <see cref="T:System.Text.StringBuilder"/> in the given radix. This is
            done recursively since it is easiest to generate the low-
            order digit first, but it must be appended last.
            </summary>
            <param name="result">The <see cref="T:System.Text.StringBuilder"/> to append to.</param>
            <param name="n">The positive integer.</param>
            <param name="radix">The radix, from 2 to 36 inclusive.</param>
            <param name="minDigits">The minimum number of digits to append.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.RecursiveAppendNumber(ICU4N.Support.Text.IAppendable,System.Int32,System.Int32,System.Int32)">
            <summary>
            Append the digits of a positive integer to the given
            <see cref="T:ICU4N.Support.Text.IAppendable"/> in the given radix. This is
            done recursively since it is easiest to generate the low-
            order digit first, but it must be appended last.
            </summary>
            <param name="result">The <see cref="T:ICU4N.Support.Text.IAppendable"/> to append to.</param>
            <param name="n">The positive integer.</param>
            <param name="radix">The radix, from 2 to 36 inclusive.</param>
            <param name="minDigits">The minimum number of digits to append.</param>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendNumber(System.Text.StringBuilder,System.Int32,System.Int32,System.Int32)">
            <summary>
            Append a number to the given <see cref="T:System.Text.StringBuilder"/> in the given radix.
            Standard digits '0'-'9' are used and letters 'A'-'Z' for
            radices 11 through 36.
            </summary>
            <param name="result">The digits of the number are appended here.</param>
            <param name="n">The number to be converted to digits; may be negative. If negative, a '-' is prepended to the digits.</param>
            <param name="radix">A radix from 2 to 36 inclusive.</param>
            <param name="minDigits">
            The minimum number of digits, not including
            any '-', to produce.  Values less than 2 have no effect.  One
            digit is always emitted regardless of this parameter.
            </param>
            <returns>A reference to result.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.AppendNumber``1(``0,System.Int32,System.Int32,System.Int32)">
            <summary>
            Append a number to the given <see cref="T:ICU4N.Support.Text.IAppendable"/> in the given radix.
            Standard digits '0'-'9' are used and letters 'A'-'Z' for
            radices 11 through 36.
            </summary>
            <param name="result">The digits of the number are appended here.</param>
            <param name="n">The number to be converted to digits; may be negative. If negative, a '-' is prepended to the digits.</param>
            <param name="radix">A radix from 2 to 36 inclusive.</param>
            <param name="minDigits">
            The minimum number of digits, not including
            any '-', to produce.  Values less than 2 have no effect.  One
            digit is always emitted regardless of this parameter.
            </param>
            <returns>A reference to result.</returns>
        </member>
        <member name="M:ICU4N.Impl.Utility.EscapeUnprintable(System.Text.StringBuilder,System.Int32)">
            <summary>
            Escape unprintable characters using \uxxxx notation
            for U+0000 to U+FFFF and \Uxxxxxxxx for U+10000 and
            above. If the character is printable ASCII, then do nothing
            and return FALSE. Otherwise, append the escaped notation and
            return TRUE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Utility.EscapeUnprintable(ICU4N.Support.Text.IAppendable,System.Int32)">
            <summary>
            Escape unprintable characters using \uxxxx notation
            for U+0000 to U+FFFF and \Uxxxxxxxx for U+10000 and
            above. If the character is printable ASCII, then do nothing
            and return FALSE. Otherwise, append the escaped notation and
            return TRUE.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.UTS46Options">
            <summary>
            Options for <see cref="T:ICU4N.Impl.UTS46"/>/<see cref="T:ICU4N.Text.IDNA"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.Default">
            <summary>
            Default options value: None of the other options are set.
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.UseSTD3Rules">
            <summary>
            Option to check whether the input conforms to the STD3 ASCII rules,
            for example the restriction of labels to LDH characters
            (ASCII Letters, Digits and Hyphen-Minus).
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.CheckBiDi">
            <summary>
            IDNA option to check for whether the input conforms to the BiDi rules.
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.CheckContextJ">
            <summary>
            IDNA option to check for whether the input conforms to the CONTEXTJ rules.
            For use in static worker and factory methods.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.NontransitionalToASCII">
            <summary>
            IDNA option for nontransitional processing in ToASCII().
            For use in static worker and factory methods.
            <para/>
            By default, ToASCII() uses transitional processing.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.NontransitionalToUnicode">
            <summary>
            IDNA option for nontransitional processing in ToUnicode().
            For use in static worker and factory methods.
            <para/>
            By default, ToUnicode() uses transitional processing.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Impl.UTS46Options.CheckContextO">
            <summary>
            IDNA option to check for whether the input conforms to the CONTEXTO rules.
            For use in static worker and factory methods.
            <para/>
            This is for use by registries for IDNA2008 conformance.
            UTS #46 does not require the CONTEXTO check.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Impl.UTS46">
            <summary>
            UTS #46 (IDNA2008) implementation.
            </summary>
            <author>Markus Scherer</author>
            <since>2010jul09</since>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.GetManifestResourceBaseName(System.Reflection.Assembly,System.String)">
            <summary>
            Uses the assembly name + '.' + suffix to determine whether any resources begin with the concatenation.
            If not, the assembly name will be truncated at the '.' beginning from the right side of the string
            until a base name is found.
            </summary>
            <param name="assembly">This <see cref="T:System.Reflection.Assembly"/>.</param>
            <param name="suffix">A suffix to use on the assembly name to limit the possible resource names to match. 
            This value can be null to match any resource name in the assembly.</param>
            <returns>A base name if found, otherwise <see cref="F:System.String.Empty"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.FindAndGetManifestResourceStream(System.Reflection.Assembly,System.String)">
            <summary>
            Aggressively searches for a resource and, if found, returns an open <see cref="T:System.IO.Stream"/>
            where it can be read.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="name">the resource name to locate</param>
            <returns>an open <see cref="T:System.IO.Stream"/> that can be used to read the resource, or <c>null</c> if the resource cannot be found.</returns>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.FindAndGetManifestResourceStream(System.Reflection.Assembly,System.Type,System.String)">
            <summary>
            Aggressively searches for a resource and, if found, returns an open <see cref="T:System.IO.Stream"/>
            where it can be read.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>an open <see cref="T:System.IO.Stream"/> that can be used to read the resource, or <c>null</c> if the resource cannot be found.</returns>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.FindResource(System.Reflection.Assembly,System.String)">
            <summary>
            Aggressively searches to find a resource based on a resource name.
            Attempts to find the resource file by prepending the assembly name
            with the resource name and then removing the segements of the
            name from left to right until a match is found.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="name">the resource name to locate</param>
            <returns>the resource, if found; if not found, returns <c>null</c></returns>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.FindResource(System.Reflection.Assembly,System.Type,System.String)">
            <summary>
            Aggressively searches to find a resource based on a <see cref="T:System.Type"/> and resource name.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>the resource, if found; if not found, returns <c>null</c></returns>
        </member>
        <member name="M:ICU4N.Support.AssemblyExtensions.ConvertResourceName(System.String)">
            <summary>
            Change from JDK-style resource path (Impl/Data/icudt60b/brkitr) to .NET style (Impl.Data.brkitr).
            This method also removes the version number from the path so we don't have to change it internally
            from one release to the next.
            </summary>
        </member>
        <member name="T:ICU4N.Support.AtomicInt32">
            <summary>
            NOTE: This was AtomicInteger in the JDK
            </summary>
        </member>
        <member name="T:ICU4N.Support.AtomicReferenceArray`1">
            <summary>
            Mimics Java's AtomicReferenceArray class (partial implementation)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.Equals``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            The same implementation of Equals from Java's AbstractList
            (the default implementation for all lists)
            <para/>
            This algorithm depends on the order of the items in the list. 
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.ToString``1(``0[])">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists)
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.ToString``1(``0,System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.Fill``1(``0[],``0)">
            <summary>
            Assigns the specified value to each element of the specified array.
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="val">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Assigns the specified value to each element of the specified array.
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="fromIndex">the index of the first element (inclusive) to be filled with the specified value</param>
            <param name="toIndex">he index of the last element (exclusive) to be filled with the specified value</param>
            <param name="val">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:ICU4N.Support.Collections.Arrays.RangeCheck(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks that <paramref name="fromIndex"/> and <paramref name="toIndex"/> are in
            the range and throws an appropriate exception, if they aren't.
            </summary>
        </member>
        <member name="T:ICU4N.Support.Collections.BitSet">
            <summary>
            The <see cref="T:ICU4N.Support.Collections.BitSet"/> class implements a bit field. Each element in a
            <see cref="T:ICU4N.Support.Collections.BitSet"/> can be on(1) or off(0). A <see cref="T:ICU4N.Support.Collections.BitSet"/> is created with a
            given size and grows if this size is exceeded. Growth is always rounded to a
            64 bit boundary.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.#ctor">
            Create a new {@code BitSet} with size equal to 64 bits.
            
            @see #clear(int)
            @see #set(int)
            @see #clear()
            @see #clear(int, int)
            @see #set(int, boolean)
            @see #set(int, int)
            @see #set(int, int, boolean)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.#ctor(System.Int32)">
            Create a new {@code BitSet} with size equal to nbits. If nbits is not a
            multiple of 64, then create a {@code BitSet} with size nbits rounded to
            the next closest multiple of 64.
            
            @param nbits
                       the size of the bit set.
            @throws NegativeArraySizeException
                        if {@code nbits} is negative.
            @see #clear(int)
            @see #set(int)
            @see #clear()
            @see #clear(int, int)
            @see #set(int, boolean)
            @see #set(int, int)
            @see #set(int, int, boolean)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.#ctor(System.Int64[],System.Boolean,System.Int32,System.Boolean)">
            Private constructor called from get(int, int) method
            
            @param bits
                       the size of the bit set
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Clone">
            Creates a copy of this {@code BitSet}.
            
            @return a copy of this {@code BitSet}.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Equals(System.Object)">
            Compares the argument to this {@code BitSet} and returns whether they are
            equal. The object must be an instance of {@code BitSet} with the same
            bits set.
            
            @param obj
                       the {@code BitSet} object to compare.
            @return a {@code boolean} indicating whether or not this {@code BitSet} and
                    {@code obj} are equal.
            @see #hashCode
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.GrowLength(System.Int32)">
            Increase the size of the internal array to accommodate {@code pos} bits.
            The new array max index will be a multiple of 64.
            
            @param len
                       the index the new array needs to be able to access.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.GetHashCode">
            Computes the hash code for this {@code BitSet}. If two {@code BitSet}s are equal
            the have to return the same result for {@code hashCode()}.
            
            @return the {@code int} representing the hash code for this bit
                    set.
            @see #equals
            @see java.util.Hashtable
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Get(System.Int32)">
            Retrieves the bit at index {@code pos}. Grows the {@code BitSet} if
            {@code pos > size}.
            
            @param pos
                       the index of the bit to be retrieved.
            @return {@code true} if the bit at {@code pos} is set,
                    {@code false} otherwise.
            @throws IndexOutOfBoundsException
                        if {@code pos} is negative.
            @see #clear(int)
            @see #set(int)
            @see #clear()
            @see #clear(int, int)
            @see #set(int, boolean)
            @see #set(int, int)
            @see #set(int, int, boolean)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Get(System.Int32,System.Int32)">
            Retrieves the bits starting from {@code pos1} to {@code pos2} and returns
            back a new bitset made of these bits. Grows the {@code BitSet} if
            {@code pos2 > size}.
            
            @param pos1
                       beginning position.
            @param pos2
                       ending position.
            @return new bitset of the range specified.
            @throws IndexOutOfBoundsException
                        if {@code pos1} or {@code pos2} is negative, or if
                        {@code pos2} is smaller than {@code pos1}.
            @see #get(int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Set(System.Int32)">
            Sets the bit at index {@code pos} to 1. Grows the {@code BitSet} if
            {@code pos > size}.
            
            @param pos
                       the index of the bit to set.
            @throws IndexOutOfBoundsException
                        if {@code pos} is negative.
            @see #clear(int)
            @see #clear()
            @see #clear(int, int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Set(System.Int32,System.Boolean)">
            Sets the bit at index {@code pos} to {@code val}. Grows the
            {@code BitSet} if {@code pos > size}.
            
            @param pos
                       the index of the bit to set.
            @param val
                       value to set the bit.
            @throws IndexOutOfBoundsException
                        if {@code pos} is negative.
            @see #set(int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Set(System.Int32,System.Int32)">
            Sets the bits starting from {@code pos1} to {@code pos2}. Grows the
            {@code BitSet} if {@code pos2 > size}.
            
            @param pos1
                       beginning position.
            @param pos2
                       ending position.
            @throws IndexOutOfBoundsException
                        if {@code pos1} or {@code pos2} is negative, or if
                        {@code pos2} is smaller than {@code pos1}.
            @see #set(int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Set(System.Int32,System.Int32,System.Boolean)">
            Sets the bits starting from {@code pos1} to {@code pos2} to the given
            {@code val}. Grows the {@code BitSet} if {@code pos2 > size}.
            
            @param pos1
                       beginning position.
            @param pos2
                       ending position.
            @param val
                       value to set these bits.
            @throws IndexOutOfBoundsException
                        if {@code pos1} or {@code pos2} is negative, or if
                        {@code pos2} is smaller than {@code pos1}.
            @see #set(int,int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Clear">
            Clears all the bits in this {@code BitSet}.
            
            @see #clear(int)
            @see #clear(int, int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Clear(System.Int32)">
            Clears the bit at index {@code pos}. Grows the {@code BitSet} if
            {@code pos > size}.
            
            @param pos
                       the index of the bit to clear.
            @throws IndexOutOfBoundsException
                        if {@code pos} is negative.
            @see #clear(int, int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Clear(System.Int32,System.Int32)">
            Clears the bits starting from {@code pos1} to {@code pos2}. Grows the
            {@code BitSet} if {@code pos2 > size}.
            
            @param pos1
                       beginning position.
            @param pos2
                       ending position.
            @throws IndexOutOfBoundsException
                        if {@code pos1} or {@code pos2} is negative, or if
                        {@code pos2} is smaller than {@code pos1}.
            @see #clear(int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Flip(System.Int32)">
            Flips the bit at index {@code pos}. Grows the {@code BitSet} if
            {@code pos > size}.
            
            @param pos
                       the index of the bit to flip.
            @throws IndexOutOfBoundsException
                        if {@code pos} is negative.
            @see #flip(int, int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Flip(System.Int32,System.Int32)">
            Flips the bits starting from {@code pos1} to {@code pos2}. Grows the
            {@code BitSet} if {@code pos2 > size}.
            
            @param pos1
                       beginning position.
            @param pos2
                       ending position.
            @throws IndexOutOfBoundsException
                        if {@code pos1} or {@code pos2} is negative, or if
                        {@code pos2} is smaller than {@code pos1}.
            @see #flip(int)
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Intersects(ICU4N.Support.Collections.BitSet)">
            Checks if these two {@code BitSet}s have at least one bit set to true in the same
            position.
            
            @param bs
                       {@code BitSet} used to calculate the intersection.
            @return {@code true} if bs intersects with this {@code BitSet},
                    {@code false} otherwise.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.And(ICU4N.Support.Collections.BitSet)">
            Performs the logical AND of this {@code BitSet} with another
            {@code BitSet}. The values of this {@code BitSet} are changed accordingly.
            
            @param bs
                       {@code BitSet} to AND with.
            @see #or
            @see #xor
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.AndNot(ICU4N.Support.Collections.BitSet)">
            Clears all bits in the receiver which are also set in the parameter
            {@code BitSet}. The values of this {@code BitSet} are changed accordingly.
            
            @param bs
                       {@code BitSet} to ANDNOT with.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Or(ICU4N.Support.Collections.BitSet)">
             Performs the logical OR of this {@code BitSet} with another {@code BitSet}.
             The values of this {@code BitSet} are changed accordingly.
            
             @param bs
                        {@code BitSet} to OR with.
             @see #xor
             @see #and
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Xor(ICU4N.Support.Collections.BitSet)">
             Performs the logical XOR of this {@code BitSet} with another {@code BitSet}.
             The values of this {@code BitSet} are changed accordingly.
            
             @param bs
                        {@code BitSet} to XOR with.
             @see #or
             @see #and
        </member>
        <member name="P:ICU4N.Support.Collections.BitSet.Count">
            Returns the number of bits this {@code BitSet} has.
            
            @return the number of bits contained in this {@code BitSet}.
            @see #length
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.GetLength">
            Returns the number of bits up to and including the highest bit set.
            
            @return the length of the {@code BitSet}.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.ToString">
            Returns a string containing a concise, human-readable description of the
            receiver.
            
            @return a comma delimited list of the indices of all bits that are set.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.NextSetBit(System.Int32)">
            Returns the position of the first bit that is {@code true} on or after {@code pos}.
            
            @param pos
                       the starting position (inclusive).
            @return -1 if there is no bits that are set to {@code true} on or after {@code pos}.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.NextClearBit(System.Int32)">
            Returns the position of the first bit that is {@code false} on or after {@code pos}.
            
            @param pos
                       the starting position (inclusive).
            @return the position of the next bit set to {@code false}, even if it is further
                    than this {@code BitSet}'s size.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.IsEmpty">
            Returns true if all the bits in this {@code BitSet} are set to false.
            
            @return {@code true} if the {@code BitSet} is empty,
                    {@code false} otherwise.
        </member>
        <member name="M:ICU4N.Support.Collections.BitSet.Cardinality">
            Returns the number of bits that are {@code true} in this {@code BitSet}.
            
            @return the number of {@code true} bits in the set.
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.Equals``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            The same implementation of Equals from Java's AbstractList
            (the default implementation for all lists)
            <para/>
            This algorithm depends on the order of the items in the list. 
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.Equals``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0})">
            <summary>
            The same implementation of Equals from Java's AbstractSet
            (the default implementation for all sets)
            <para/>
            This algoritm does not depend on the order of the items in the set.
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.Equals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            This is the same implemenation of Equals from Java's AbstractMap
            (the default implementation of all dictionaries)
            <para/>
            This algoritm does not depend on the order of the items in the dictionary.
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.Equals(System.Object,System.Object)">
            <summary>
            A helper method to recursively determine equality based on
            the values of the collection and all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.GetHashCode``1(System.Collections.Generic.IList{``0})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractList
            (the default implementation for all lists).
            <para/>
            This algorithm depends on the order of the items in the list.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.GetHashCode``1(System.Collections.Generic.ISet{``0})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractSet
            (the default implementation for all sets)
            <para/>
            This algorithm does not depend on the order of the items in the set.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.GetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractMap
            (the default implementation for all dictionaries)
            <para/>
            This algoritm does not depend on the order of the items in the dictionary.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.GetHashCode(System.Object)">
            <summary>
            This method generally assists with the recursive GetHashCode() that
            builds a hash code based on all of the values in a collection 
            including any nested collections (lists, sets, arrays, and dictionaries).
            <para/>
            Note this currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="obj">the object to build the hash code for</param>
            <returns>a value that represents the unique state of all of the values and 
            nested collection values in the object, provided the main object itself is 
            a collection, otherwise calls <see cref="M:System.Object.GetHashCode"/> on the 
            object that is passed.</returns>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists)
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString``1(System.Collections.Generic.ICollection{``0},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries)
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString``2(System.Collections.Generic.IDictionary{``0,``1},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString(System.Object)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.CollectionUtil.ToString(System.Object,System.Globalization.CultureInfo)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections, plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.GenericComparer.NaturalComparer``1">
            <summary>
            Get the natural <see cref="T:System.Collections.Generic.IComparer`1"/> for the provided object class.
            <para/>
            The comparer returned depends on the <typeparam name="T"/> argument:
            <list type="number">
                <item><description>If the type is <see cref="T:System.String"/>, the comparer returned uses
                    the <see cref="M:System.String.CompareOrdinal(System.String,System.String)"/> to make the comparison
                    to ensure that the current culture doesn't affect the results. This is the
                    default string comparison used in Java.</description></item>
                <item><description>If the type implements <see cref="T:System.IComparable`1"/>, the comparer uses
                    <see cref="M:System.IComparable`1.CompareTo(`0)"/> for the comparison. This allows
                    the use of types with custom comparison schemes.</description></item>
                <item><description>If neither of the above conditions are true, will default to <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</description></item>
            </list>
            <para/>
            </summary>
        </member>
        <member name="M:ICU4N.Support.Collections.ListExtensions.CopyTo``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from an <see cref="T:System.Collections.Generic.IList`1"/> starting at the specified source index and pastes them to another <see cref="T:System.Collections.Generic.IList`1"/> starting at the specified 
            destination index. The length and the indexes are specified as 32-bit integers.
            </summary>
            <typeparam name="T">The type of elements to copy.</typeparam>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> that contains the data to copy.</param>
            <param name="sourceIndex">A 32-bit integer that represents the index in the <paramref name="sourceIndex"/> at which copying begins.</param>
            <param name="destination">The <see cref="T:System.Collections.Generic.IList`1"/> that receives the data.</param>
            <param name="destinationIndex">A 32-bit integer that represents the index in the <paramref name="destination"/> at which storing begins.</param>
            <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        </member>
        <member name="T:ICU4N.Support.Collections.ReferenceQueue`1">
            <summary>
            The <see cref="T:ICU4N.Support.Collections.ReferenceQueue`1"/> is the container on which reference objects are
            enqueued when the garbage collector detects the reachability type specified
            for the referent.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ICU4N.Support.Collections.ReferenceQueue`1.#ctor">
            Constructs a new instance of this class.
        </member>
        <member name="M:ICU4N.Support.Collections.ReferenceQueue`1.Poll">
             Returns the next available reference from the queue, removing it in the
             process. Does not wait for a reference to become available.
            
             @return the next available reference, or {@code null} if no reference is
                     immediately available
        </member>
        <member name="M:ICU4N.Support.Collections.ReferenceQueue`1.Remove">
             Returns the next available reference from the queue, removing it in the
             process. Waits indefinitely for a reference to become available.
            
             @return the next available reference
            
             @throws InterruptedException
                         if the blocking call was interrupted for some reason
        </member>
        <member name="M:ICU4N.Support.Collections.ReferenceQueue`1.Remove(System.Int32)">
             Returns the next available reference from the queue, removing it in the
             process. Waits for a reference to become available or the given timeout
             period to elapse, whichever happens first.
            
             @param timeout
                        maximum time (in ms) to spend waiting for a reference object
                        to become available. A value of zero results in the method
                        waiting indefinitely.
             @return the next available reference, or {@code null} if no reference
                     becomes available within the timeout period
             @throws IllegalArgumentException
                         if the wait period is negative.
             @throws InterruptedException
                         if the blocking call was interrupted for some reason
        </member>
        <member name="M:ICU4N.Support.Collections.ReferenceQueue`1.Enqueue(ICU4N.Support.Reference{`0})">
             Enqueue the reference object on the receiver.
            
             @param reference
                        reference object to be enqueued.
             @return boolean true if reference is enqueued. false if reference failed
                     to enqueue.
        </member>
        <member name="T:ICU4N.Support.Globalization.CultureContext">
            <summary>
            Allows switching the current thread to a new culture in a using block that will automatically 
            return the culture to its previous state upon completion.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IntegerExtensions.AsFlagsToEnum``1(System.Int32,``0)">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:System.Enum"/> of type <typeparamref name="T"/>.
            If the <see cref="T:System.Enum"/> defines the <see cref="T:System.FlagsAttribute"/>, the <see cref="T:System.Int32"/>
            is assumed to be a bitmask that may contain multiple flags. If not, the <see cref="T:System.Int32"/>
            must exactly match only one <see cref="T:System.Enum"/> symbol's value (not including a symbol 
            representing 0), or an <see cref="T:System.ArgumentOutOfRangeException"/>is thrown.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Enum"/>.</typeparam>
            <param name="options">An <see cref="T:System.Int32"/> representing one or more symbols in the <see cref="T:System.Enum"/>.</param>
            <param name="defaultValue">The default to use if <paramref name="options"/> doesn't match any symbols in <typeparamref name="T"/>.</param>
            <returns>The symbol or symbols of <typeparamref name="T"/> that are set by <paramref name="options"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <typeparamref name="T"/> doesn't define the 
            <see cref="T:System.FlagsAttribute"/> and <paramref name="options"/> matches more than one enum symbol.</exception>
        </member>
        <member name="M:ICU4N.Support.IntegerExtensions.AsFlagsToEnum``1(System.Int32)">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:System.Enum"/> of type <typeparamref name="T"/>.
            If the <see cref="T:System.Enum"/> defines the <see cref="T:System.FlagsAttribute"/>, the <see cref="T:System.Int32"/>
            is assumed to be a bitmask that may contain multiple flags. If not, the <see cref="T:System.Int32"/>
            must exactly match only one <see cref="T:System.Enum"/> symbol's value (not including a symbol 
            representing 0), or an <see cref="T:System.ArgumentOutOfRangeException"/>is thrown.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.Enum"/>.</typeparam>
            <param name="options">An <see cref="T:System.Int32"/> representing one or more symbols in the <see cref="T:System.Enum"/>.</param>
            <returns>The symbol or symbols of <typeparamref name="T"/> that are set by <paramref name="options"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <typeparamref name="T"/> doesn't define the 
            <see cref="T:System.FlagsAttribute"/> and <paramref name="options"/> matches more than one enum symbol.</exception>
        </member>
        <member name="T:ICU4N.Support.IO.Buffer">
            <summary>
            A buffer is a list of elements of a specific primitive type.
            <para/>
            A buffer can be described by the following properties:
            <list type="bullet">
                <item><description>
                    Capacity:
                    The number of elements a buffer can hold. Capacity may not be
                    negative and never changes.
                </description></item>
                <item><description>
                    Position:
                    A cursor of this buffer. Elements are read or written at the
                    position if you do not specify an index explicitly. Position may not be
                    negative and not greater than the limit.
                </description></item>
                <item><description>
                    Limit:
                    Controls the scope of accessible elements. You can only read or
                    write elements from index zero to <c>limit - 1</c>. Accessing
                    elements out of the scope will cause an exception. Limit may not be negative
                    and not greater than capacity.
                </description></item>
                <item><description>
                    Mark: 
                    Used to remember the current position, so that you can reset the
                    position later. Mark may not be negative and no greater than position.
                </description></item>
                <item><description>
                    A buffer can be read-only or read-write. Trying to modify the elements
                    of a read-only buffer will cause a <see cref="T:ICU4N.Support.IO.ReadOnlyBufferException"/>,
                    while changing the position, limit and mark of a read-only buffer is OK.
                </description></item>
                <item><description>
                    A buffer can be direct or indirect. A direct buffer will try its best to
                    take advantage of native memory APIs and it may not stay in the heap,
                    thus it is not affected by garbage collection.
                </description></item>
            </list>
            <para/>
            Buffers are not thread-safe. If concurrent access to a buffer instance is
            required, then the callers are responsible to take care of the
            synchronization issues.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.Buffer.UNSET_MARK">
            <summary>
            <c>UNSET_MARK</c> means the mark has not been set.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.Buffer.capacity">
            <summary>
            The capacity of this buffer, which never change.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.Buffer.limit">
            <summary>
            <c>limit - 1</c> is the last element that can be read or written.
            Limit must be no less than zero and no greater than <see cref="F:ICU4N.Support.IO.Buffer.capacity"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.Buffer.mark">
            <summary>
            Mark is where position will be set when <see cref="M:ICU4N.Support.IO.Buffer.Reset"/> is called.
            Mark is not set by default. Mark is always no less than zero and no
            greater than <see cref="F:ICU4N.Support.IO.Buffer.position"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.Buffer.position">
            <summary>
            The current position of this buffer. Position is always no less than zero
            and no greater than <see cref="F:ICU4N.Support.IO.Buffer.limit"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.#ctor(System.Int32)">
            <summary>
            Construct a buffer with the specified capacity.
            </summary>
            <param name="capacity">The capacity of this buffer</param>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.Capacity">
            <summary>
            Returns the capacity of this buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.Clear">
            <summary>
            Clears this buffer.
            <para>
            While the content of this buffer is not changed, the following internal
            changes take place: the current position is reset back to the start of
            the buffer, the value of the buffer limit is made equal to the capacity
            and mark is cleared.
            </para>
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.Flip">
            <summary>
            Flips this buffer.
            <para/>
            The limit is set to the current position, then the position is set to
            zero, and the mark is cleared.
            <para/>
            The content of this buffer is not changed.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.HasRemaining">
            <summary>
            Indicates if there are elements remaining in this buffer, that is if
            <c>position &lt; limit</c>.
            </summary>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.IsReadOnly">
            <summary>
            Indicates whether this buffer is read-only.
            </summary>
            <returns>
            <c>true</c> if, this buffer is read-only; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.Limit">
            <summary>
            Gets or Sets the limit of this buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.SetLimit(System.Int32)">
            <summary>
            Sets the limit of this buffer.
            <para/>
            If the current position in the buffer is in excess of
            <c>newLimit</c> then, on returning from this call, it will have
            been adjusted to be equivalent to <c>newLimit</c>. If the mark
            is set and is greater than the new limit, then it is cleared.
            </summary>
            <param name="newLimit">The new limit value; must be non-negative and no larger than this buffer's capacity</param>
            <returns>This buffer</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="newLimit"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.Mark">
            <summary>
            Marks the current position, so that the position may return to this point
            later by calling <see cref="M:ICU4N.Support.IO.Buffer.Reset"/>.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.Position">
            <summary>
            Returns the position of this buffer.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.SetPosition(System.Int32)">
            <summary>
            Sets the position of this buffer.
            <para/>
            If the mark is set and it is greater than the new position, then it is
            cleared.
            </summary>
            <param name="newPosition">The new position, must be not negative and not greater than limit.</param>
            <returns>This buffer</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="newPosition"/> is invalid.</exception>
        </member>
        <member name="P:ICU4N.Support.IO.Buffer.Remaining">
            <summary>
            Returns the number of remaining elements in this buffer, that is
            <c>limit - position</c>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.Reset">
            <summary>
            Resets the position of this buffer to the <see cref="F:ICU4N.Support.IO.Buffer.mark"/>.
            </summary>
            <returns>This buffer</returns>
            <exception cref="T:ICU4N.Support.IO.InvalidMarkException">If the mark has not been set</exception>
        </member>
        <member name="M:ICU4N.Support.IO.Buffer.Rewind">
            <summary>
            Rewinds this buffer.
            <para/>
            The position is set to zero, and the mark is cleared. The content of this]
            buffer is not changed.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="T:ICU4N.Support.IO.ByteBuffer">
            <summary>
            A buffer for bytes.
            <para/>
            A byte buffer can be created in either one of the following ways:
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.IO.ByteBuffer.Allocate(System.Int32)"/> a new byte array and create a
                buffer based on it</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.ByteBuffer.AllocateDirect(System.Int32)"/> a memory block and create a direct
                buffer based on it</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.ByteBuffer.Wrap(System.Byte[])"/> an existing byte array to create a new buffer</description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Allocate(System.Int32)">
            <summary>
            Creates a byte buffer based on a newly allocated byte array.
            </summary>
            <param name="capacity">the capacity of the new buffer</param>
            <returns>The created byte buffer.</returns>
            <exception cref="T:System.ArgumentException">If the <c>capacity &lt; 0</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AllocateDirect(System.Int32)">
            <summary>
            Creates a direct byte buffer based on a newly allocated memory block. (NOT IMPLEMENTED)
            </summary>
            <param name="capacity">the capacity of the new buffer</param>
            <returns>The new byte buffer</returns>
            <exception cref="T:System.ArgumentException">If the <c>capacity &lt; 0</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Wrap(System.Byte[])">
            <summary>
            Creates a new byte buffer by wrapping the given byte array.
            <para/>
            Calling this method has the same effect as
            <c>Wrap(array, 0, array.Length)</c>.
            </summary>
            <param name="array">The byte array which the new buffer will be based on</param>
            <returns>The new byte buffer</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Wrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new byte buffer by wrapping the given byte array.
            <para/>
            The new buffer's position will be <paramref name="start"/>, limit will be
            <c>start + len</c>, capacity will be the length of the array.
            </summary>
            <param name="array">The byte array which the new buffer will be based on.</param>
            <param name="start">
            The start index, must not be negative and not greater than <c>array.Length</c>.
            </param>
            <param name="length">
            The length, must not be negative and not greater than
            <c>array.Length - start</c>.
            </param>
            <returns>The new byte buffer</returns>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="start"/> or <paramref name="length"/> are invalid.</exception>
        </member>
        <member name="F:ICU4N.Support.IO.ByteBuffer.order">
            <summary>
            The byte order of this buffer, default is <see cref="F:ICU4N.Support.IO.ByteOrder.BIG_ENDIAN"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.#ctor(System.Int32)">
            <summary>
            Constructs a <see cref="T:ICU4N.Support.IO.ByteBuffer"/> with given capacity.
            </summary>
            <param name="capacity">the capacity of the buffer.</param>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.Array">
            <summary>
            Returns the byte array which this buffer is based on, if there is one.
            </summary>
            <returns>the byte array which this buffer is based on.</returns>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if this buffer is based on a read-only array.</exception>
            <exception cref="T:System.InvalidOperationException">if this buffer is not based on an array.</exception>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.ArrayOffset">
            <summary>
            Returns the offset of the byte array which this buffer is based on, if
            there is one.
            <para/>
            The offset is the index of the array which corresponds to the zero
            position of the buffer.
            </summary>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if this buffer is based on a read-only array.</exception>
            <exception cref="T:System.InvalidOperationException">if this buffer is not based on an array.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AsCharBuffer">
            <summary>
            Returns a char buffer which is based on the remaining content of this
            byte buffer.
            </summary>
            <remarks>
            The new buffer's position is zero, its limit and capacity is the number
            of remaining bytes divided by two, and its mark is not set. The new
            buffer's read-only property and byte order are the same as this buffer's.
            The new buffer is direct if this byte buffer is direct.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </remarks>
            <returns>A <see cref="T:System.Char"/> buffer which is based on the content of this byte buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AsInt32Buffer">
            <summary>
            Returns a <see cref="T:System.Int32"/> buffer which is based on the remaining content of this byte
            buffer.
            <para/>
            The new buffer's position is zero, its limit and capacity is the number
            of remaining bytes divided by four, and its mark is not set. The new
            buffer's read-only property and byte order are the same as this buffer's.
            The new buffer is direct if this byte buffer is direct.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>A <see cref="T:System.Int32"/> buffer which is based on the content of this byte buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AsInt64Buffer">
            <summary>
            Returns a long buffer which is based on the remaining content of this
            byte buffer.
            <para/>
            The new buffer's position is zero, its limit and capacity is the number
            of remaining bytes divided by eight, and its mark is not set. The new
            buffer's read-only property and byte order are the same as this buffer's.
            The new buffer is direct if this byte buffer is direct.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>a long buffer which is based on the content of this byte buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AsReadOnlyBuffer">
            <summary>
            Returns a read-only buffer that shares its content with this buffer.
            <para/>
            The returned buffer is guaranteed to be a new instance, even if this
            buffer is read-only itself. The new buffer's position, limit, capacity
            and mark are the same as this buffer.
            <para/>
            The new buffer shares its content with this buffer, which means this
            buffer's change of content will be visible to the new buffer. The two
            buffer's position, limit and mark are independent.
            </summary>
            <returns>A read-only version of this buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.AsInt16Buffer">
            <summary>
            Returns a short buffer which is based on the remaining content of this
            byte buffer.
            </summary>
            <remarks>
            The new buffer's position is zero, its limit and capacity is the number
            of remaining bytes divided by two, and its mark is not set. The new
            buffer's read-only property and byte order are the same as this buffer's.
            The new buffer is direct if this byte buffer is direct.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </remarks>
            <returns>A short buffer which is based on the content of this byte buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Compact">
            <summary>
            Compacts this byte buffer.
            <para/>
            The remaining bytes will be moved to the head of the
            buffer, starting from position zero. Then the position is set to
            <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/>; the limit is set to capacity; the mark is
            cleared.
            </summary>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.CompareTo(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Compares the remaining bytes of this buffer to another byte buffer's
            remaining bytes.
            </summary>
            <param name="otherBuffer">another byte buffer.</param>
            <returns>
            a negative value if this is less than <c>other</c>; 0 if this
            equals to <c>other</c>; a positive value if this is greater
            than <c>other</c>.
            </returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Duplicate">
            <summary>
            Returns a duplicated buffer that shares its content with this buffer.
            <para/>
            The duplicated buffer's position, limit, capacity and mark are the same
            as this buffer's. The duplicated buffer's read-only property and byte
            order are the same as this buffer's too.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>a duplicated buffer that shares its content with this buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Equals(System.Object)">
            <summary>
            Checks whether this byte buffer is equal to another object.
            <para/>
            If <paramref name="other"/> is not a byte buffer then <c>false</c> is returned. Two
            byte buffers are equal if and only if their remaining bytes are exactly
            the same. Position, limit, capacity and mark are not considered.
            </summary>
            <param name="other">the object to compare with this byte buffer.</param>
            <returns>
            <c>true</c> if this byte buffer is equal to <paramref name="other"/>,
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Get">
            <summary>
            Returns the byte at the current position and increases the position by 1.
            </summary>
            <returns>the byte at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is equal or greater than limit.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Get(System.Byte[])">
            <summary>
            Reads bytes from the current position into the specified byte array and
            increases the position by the number of bytes read.
            <para/>
            Calling this method has the same effect as
            <c>Get(dest, 0, dest.Length)</c>.
            </summary>
            <param name="dest">the destination byte array.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if <c>dest.Length</c> is greater than <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Get(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the current position into the specified byte array,
            starting at the specified offset, and increases the position by the
            number of bytes read.
            </summary>
            <param name="dest">the target byte array.</param>
            <param name="off">
            the offset of the byte array, must not be negative and
            not greater than <c>dest.Length</c>.</param>
            <param name="len">
            the number of bytes to read, must not be negative and not
            greater than <c>dest.Length - off</c>
            </param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="off"/> or <paramref name="len"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if <paramref name="len"/> is greater than <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Get(System.Int32)">
            <summary>
            Returns the byte at the specified index and does not change the position.
            
            </summary>
            <param name="index">the index, must not be negative and less than limit.</param>
            <returns>the byte at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if index is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetChar">
            <summary>
            Returns the char at the current position and increases the position by 2.
            <para/>
            The 2 bytes starting at the current position are composed into a char
            according to the current byte order and returned.
            </summary>
            <returns>the char at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 2</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetChar(System.Int32)">
            <summary>
            Returns the char at the specified index.
            <para/>
            The 2 bytes starting from the specified index are composed into a char
            according to the current byte order and returned. The position is not
            changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <returns>the char at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetDouble">
            <summary>
            Returns the double at the current position and increases the position by 8.
            <para/>
            The 8 bytes starting from the current position are composed into a double
            according to the current byte order and returned.
            </summary>
            <returns>the double at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 8</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetDouble(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Double"/> at the specified index.
            <para/>
            The 8 bytes starting at the specified index are composed into a <see cref="T:System.Double"/>
            according to the current byte order and returned. The position is not
            changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <returns>the <see cref="T:System.Double"/> at the specified index.</returns>
            <returns>the <see cref="T:System.Double"/> at the current position.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetSingle">
            <summary>
            Returns the <see cref="T:System.Single"/> at the current position and increases the position by 4.
            <para/>
            The 4 bytes starting at the current position are composed into a <see cref="T:System.Single"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getFloat() in the JDK
            </summary>
            <returns>the <see cref="T:System.Single"/> at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 4</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetSingle(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Single"/> at the specified index.
            <para/>
            The 4 bytes starting at the specified index are composed into a <see cref="T:System.Single"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getFloat() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <returns>the <see cref="T:System.Single"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt32">
            <summary>
            Returns the <see cref="T:System.Int32"/> at the current position and increases the position by 4.
            <para/>
            The 4 bytes starting at the current position are composed into a <see cref="T:System.Int32"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getInt() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int32"/> at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 4</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt32(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int32"/> at the specified index.
            <para/>
            The 4 bytes starting at the specified index are composed into a <see cref="T:System.Int32"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getInt() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <returns>the <see cref="T:System.Int32"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt64">
            <summary>
            Returns the <see cref="T:System.Int64"/> at the current position and increases the position by 8.
            <para/>
            The 8 bytes starting at the current position are composed into a <see cref="T:System.Int64"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getLong() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int64"/> at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 8</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt64(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int64"/> at the specified index.
            <para/>
            The 8 bytes starting at the specified index are composed into a <see cref="T:System.Int64"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getLong() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <returns>the <see cref="T:System.Int64"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt16">
            <summary>
            Returns the <see cref="T:System.Int16"/> at the current position and increases the position by 2.
            <para/>
            The 2 bytes starting at the current position are composed into a <see cref="T:System.Int16"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getShort() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int16"/> at the current position.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 2</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetInt16(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int16"/> at the specified index.
            <para/>
            The 2 bytes starting at the specified index are composed into a <see cref="T:System.Int16"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getShort() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <returns>the <see cref="T:System.Int16"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.HasArray">
            <summary>
            Indicates whether this buffer is based on a byte array and provides
            read/write access.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.GetHashCode">
            <summary>
            Calculates this buffer's hash code from the remaining chars. The
            position, limit, capacity and mark don't affect the hash code.
            </summary>
            <returns>the hash code calculated from the remaining bytes.</returns>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.IsDirect">
            <summary>
            Indicates whether this buffer is direct.
            </summary>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.Order">
            <summary>
            Returns the byte order used by this buffer when converting bytes from/to
            other primitive types.
            <para/>
            The default byte order of byte buffer is always
            <see cref="F:ICU4N.Support.IO.ByteOrder.BIG_ENDIAN"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.SetOrder(ICU4N.Support.IO.ByteOrder)">
            <summary>
            Sets the byte order of this buffer.
            </summary>
            <param name="byteOrder">the byte order to set.</param>
            <returns>this buffer.</returns>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.ProtectedArray">
            <summary>
            Child class implements this method to realize <see cref="P:ICU4N.Support.IO.ByteBuffer.Array"/>.
            </summary>
            <seealso cref="P:ICU4N.Support.IO.ByteBuffer.Array"/>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.ProtectedArrayOffset">
            <summary>
            Child class implements this method to realize <see cref="P:ICU4N.Support.IO.ByteBuffer.ArrayOffset"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Support.IO.ByteBuffer.ProtectedHasArray">
            <summary>
            Child class implements this method to realize <seealso cref="P:ICU4N.Support.IO.ByteBuffer.HasArray"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Put(System.Byte)">
            <summary>
            Writes the given byte to the current position and increases the position
            by 1.
            </summary>
            <param name="b">the byte to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is equal or greater than limit.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Put(System.Byte[])">
            <summary>
            Writes bytes in the given byte array to the current position and
            increases the position by the number of bytes written.
            <para/>
            Calling this method has the same effect as
            <c>Put(src, 0, src.Length)</c>.
            </summary>
            <param name="src">the source byte array.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/> is less than <c>src.Length</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Put(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes in the given byte array, starting from the specified offset,
            to the current position and increases the position by the number of bytes
            written.
            </summary>
            <param name="src">the source byte array.</param>
            <param name="off">
            the offset of byte array, must not be negative and not greater
            than <c>src.Length</c>.
            </param>
            <param name="len">
            the number of bytes to write, must not be negative and not
            greater than <c>src.Length - off</c>.
            </param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/> is less than <paramref name="len"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="off"/> or <paramref name="len"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Put(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Writes all the remaining bytes of the <paramref name="src"/> byte buffer to this
            buffer's current position, and increases both buffers' position by the
            number of bytes copied.
            </summary>
            <param name="src">the source byte buffer.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if <c>src.Remaining</c> is greater than this buffer's <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/>.</exception>
            <exception cref="T:System.ArgumentException">if <paramref name="src"/> is this buffer.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Put(System.Int32,System.Byte)">
            <summary>
            Write a <see cref="T:System.Byte"/> to the specified index of this buffer without changing the
            position.
            </summary>
            <param name="index">the index, must not be negative and less than the limit.</param>
            <param name="b">the <see cref="T:System.Byte"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutChar(System.Char)">
            <summary>
            Writes the given <see cref="T:System.Char"/> to the current position and increases the position
            by 2.
            <para/>
            The <see cref="T:System.Char"/> is converted to bytes using the current byte order.
            </summary>
            <param name="value">the <see cref="T:System.Char"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 2</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutChar(System.Int32,System.Char)">
            <summary>
            Writes the given <see cref="T:System.Char"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Char"/> is converted to bytes using the current byte order. The position
            is not changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <param name="value">the <see cref="T:System.Char"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutDouble(System.Double)">
            <summary>
            Writes the given <see cref="T:System.Double"/> to the current position and increases the position
            by 8.
            <para/>
            The <see cref="T:System.Double"/> is converted to bytes using the current byte order.
            </summary>
            <param name="value">the <see cref="T:System.Double"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 8</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutDouble(System.Int32,System.Double)">
            <summary>
            Writes the given <see cref="T:System.Double"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Double"/> is converted to bytes using the current byte order. The
            position is not changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <param name="value">the <see cref="T:System.Double"/> to write.</param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutSingle(System.Single)">
            <summary>
            Writes the given <see cref="T:System.Single"/> to the current position and increases the position
            by 4.
            <para/>
            The <see cref="T:System.Single"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putSingle() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Single"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 4</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutSingle(System.Int32,System.Single)">
            <summary>
            Writes the given <see cref="T:System.Single"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Single"/> is converted to bytes using the current byte order. The
            position is not changed.
            <para/>
            NOTE: This was putSingle() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <param name="value">the <see cref="T:System.Single"/> to write.</param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt32(System.Int32)">
            <summary>
            Writes the given <see cref="T:System.Int32"/> to the current position and increases the position by
            4.
            <para/>
            The <see cref="T:System.Int32"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putInt() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int32"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 4</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt32(System.Int32,System.Int32)">
            <summary>
            Writes the given <see cref="T:System.Int32"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Int32"/> is converted to bytes using the current byte order. The position
            is not changed.
            <para/>
            NOTE: This was putInt() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <param name="value">the <see cref="T:System.Int32"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt64(System.Int64)">
            <summary>
            Writes the given <see cref="T:System.Int64"/> to the current position and increases the position
            by 8.
            <para/>
            The <see cref="T:System.Int64"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putLong() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int64"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 8</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt64(System.Int32,System.Int64)">
            <summary>
            Writes the given <see cref="T:System.Int64"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Int64"/> is converted to bytes using the current byte order. The position
            is not changed.
            <para/>
            NOTE: This was putLong() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <param name="value">the <see cref="T:System.Int64"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt16(System.Int16)">
            <summary>
            Writes the given <see cref="T:System.Int16"/> to the current position and increases the position
            by 2.
            <para/>
            The <see cref="T:System.Int16"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putShort() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int16"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:ICU4N.Support.IO.BufferOverflowException">if position is greater than <c>limit - 2</c>.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.PutInt16(System.Int32,System.Int16)">
            <summary>
            Writes the given <see cref="T:System.Int16"/> to the specified index of this buffer.
            <para/>
            The <see cref="T:System.Int16"/> is converted to bytes using the current byte order. The
            position is not changed.
            <para/>
            NOTE: This was putShort() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <param name="value">the <see cref="T:System.Int16"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:ICU4N.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.Slice">
            <summary>
            Returns a sliced buffer that shares its content with this buffer.
            <para/>
            The sliced buffer's capacity will be this buffer's
            <see cref="P:ICU4N.Support.IO.Buffer.Remaining"/>, and it's zero position will correspond to
            this buffer's current position. The new buffer's position will be 0,
            limit will be its capacity, and its mark is cleared. The new buffer's
            read-only property and byte order are the same as this buffer's.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>A sliced buffer that shares its content with this buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.ByteBuffer.ToString">
            <summary>
            Returns a string representing the state of this byte buffer.
            </summary>
            <returns>A string representing the state of this byte buffer.</returns>
        </member>
        <member name="T:ICU4N.Support.IO.ByteOrder">
            <summary>
            Defines byte order constants.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.ByteOrder.BIG_ENDIAN">
            <summary>
            This constant represents big endian.
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.ByteOrder.LITTLE_ENDIAN">
            <summary>
            This constant represents little endian.
            </summary>
        </member>
        <member name="P:ICU4N.Support.IO.ByteOrder.NativeOrder">
            <summary>
            Returns the current platform byte order.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.ByteOrder.ToString">
            <summary>
            Returns a string that describes this object.
            </summary>
            <returns>
            "BIG_ENDIAN" for <see cref="F:ICU4N.Support.IO.ByteOrder.BIG_ENDIAN"/> objects,
            "LITTLE_ENDIAN" for <see cref="F:ICU4N.Support.IO.ByteOrder.LITTLE_ENDIAN"/> objects.
            </returns>
        </member>
        <member name="T:ICU4N.Support.IO.CharArrayBuffer">
            <summary>
            CharArrayBuffer, ReadWriteCharArrayBuffer and ReadOnlyCharArrayBuffer compose
            the implementation of array based char buffers.
            <para/>
            CharArrayBuffer implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.CharBuffer">
            <summary>
            A buffer of chars.
            </summary>
            <remarks>
            A char buffer can be created in either one of the following ways:
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.IO.CharBuffer.Allocate(System.Int32)"/> a new char array and create a buffer based on it;</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.CharBuffer.Wrap(System.Char[])"/> an existing char array to create a new buffer;</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.CharBuffer.Wrap(ICU4N.Support.Text.ICharSequence)"/> an existing char sequence to create a new buffer;</description></item>
                <item><description>Use <see cref="M:ICU4N.Support.IO.ByteBuffer.AsCharBuffer"/> to create a char buffer based on a byte buffer.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Allocate(System.Int32)">
            Creates a char buffer based on a newly allocated char array.
            
            @param capacity
                       the capacity of the new buffer.
            @return the created char buffer.
            @throws IllegalArgumentException
                        if {@code capacity} is less than zero.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Wrap(System.Char[])" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Wrap(System.Char[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Wrap(ICU4N.Support.Text.ICharSequence)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Wrap(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.#ctor(System.Int32)">
            Constructs a {@code CharBuffer} with given capacity.
            
            @param capacity
                       the capacity of the buffer.
        </member>
        <member name="P:ICU4N.Support.IO.CharBuffer.Array">
            Returns the char array which this buffer is based on, if there is one.
            
            @return the char array which this buffer is based on.
            @exception ReadOnlyBufferException
                           if this buffer is based on an array, but it is read-only.
            @exception UnsupportedOperationException
                           if this buffer is not based on an array.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.CharBuffer.ArrayOffset" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.AsReadOnlyBuffer" -->
        <member name="P:ICU4N.Support.IO.CharBuffer.Item(System.Int32)">
            Returns the character located at the specified index in the buffer. The
            index value is referenced from the current buffer position.
            
            @param index
                       the index referenced from the current buffer position. It must
                       not be less than zero but less than the value obtained from a
                       call to {@code remaining()}.
            @return the character located at the specified index (referenced from the
                    current position) in the buffer.
            @exception IndexOutOfBoundsException
                           if the index is invalid.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Compact" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.CompareTo(ICU4N.Support.IO.CharBuffer)">
            Compare the remaining chars of this buffer to another char
            buffer's remaining chars.
            
            @param otherBuffer
                       another char buffer.
            @return a negative value if this is less than {@code otherBuffer}; 0 if
                    this equals to {@code otherBuffer}; a positive value if this is
                    greater than {@code otherBuffer}.
            @exception InvalidCastException
                           if {@code otherBuffer} is not a char buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Duplicate" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Equals(System.Object)" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.Get">
            Returns the char at the current position and increases the position by 1.
            
            @return the char at the current position.
            @exception BufferUnderflowException
                           if the position is equal or greater than limit.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Get(System.Char[])" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.Get(System.Char[],System.Int32,System.Int32)">
            Reads chars from the current position into the specified char array,
            starting from the specified offset, and increases the position by the
            number of chars read.
            
            @param dest
                       the target char array.
            @param off
                       the offset of the char array, must not be negative and not
                       greater than {@code dest.length}.
            @param len
                       The number of chars to read, must be no less than zero and no
                       greater than {@code dest.length - off}.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception BufferUnderflowException
                           if {@code len} is greater than {@code remaining()}.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Get(System.Int32)">
            Returns a char at the specified index; the position is not changed.
            
            @param index
                       the index, must not be negative and less than limit.
            @return a char at the specified index.
            @exception IndexOutOfBoundsException
                           if index is invalid.
        </member>
        <member name="P:ICU4N.Support.IO.CharBuffer.HasArray">
             Indicates whether this buffer is based on a char array and is read/write.
            
             @return {@code true} if this buffer is based on a byte array and provides
                     read/write access, {@code false} otherwise.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.GetHashCode">
             Calculates this buffer's hash code from the remaining chars. The
             position, limit, capacity and mark don't affect the hash code.
            
             @return the hash code calculated from the remaining chars.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.CharBuffer.IsDirect" -->
        <member name="P:ICU4N.Support.IO.CharBuffer.Length">
            Returns the number of remaining chars.
            
            @return the number of remaining chars.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.CharBuffer.Order" -->
        <member name="P:ICU4N.Support.IO.CharBuffer.ProtectedArray">
             Child class implements this method to realize {@code array()}.
            
             @see #array()
        </member>
        <member name="P:ICU4N.Support.IO.CharBuffer.ProtectedArrayOffset">
             Child class implements this method to realize {@code arrayOffset()}.
            
             @see #arrayOffset()
        </member>
        <member name="P:ICU4N.Support.IO.CharBuffer.ProtectedHasArray">
             Child class implements this method to realize {@code hasArray()}.
            
             @see #hasArray()
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Put(System.Char)">
            Writes the given char to the current position and increases the position
            by 1.
            
            @param c
                       the char to write.
            @return this buffer.
            @exception BufferOverflowException
                           if position is equal or greater than limit.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Put(System.Char[])" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.Put(System.Char[],System.Int32,System.Int32)">
            Writes chars from the given char array, starting from the specified offset,
            to the current position and increases the position by the number of chars
            written.
            
            @param src
                       the source char array.
            @param off
                       the offset of char array, must not be negative and not greater
                       than {@code src.length}.
            @param len
                       the number of chars to write, must be no less than zero and no
                       greater than {@code src.length - off}.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code remaining()} is less than {@code len}.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Put(ICU4N.Support.IO.CharBuffer)">
            Writes all the remaining chars of the {@code src} char buffer to this
            buffer's current position, and increases both buffers' position by the
            number of chars copied.
            
            @param src
                       the source char buffer.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code src.remaining()} is greater than this buffer's
                           {@code remaining()}.
            @exception IllegalArgumentException
                           if {@code src} is this buffer.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Put(System.Int32,System.Char)">
            Writes a char to the specified index of this buffer; the position is not
            changed.
            
            @param index
                       the index, must be no less than zero and less than the limit.
            @param c
                       the char to write.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if index is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Put(System.String)" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.Put(System.String,System.Int32,System.Int32)">
            Writes chars of the given string to the current position of this buffer,
            and increases the position by the number of chars written.
            
            @param str
                       the string to write.
            @param start
                       the first char to write, must not be negative and not greater
                       than {@code str.length()}.
            @param end
                       the last char to write (excluding), must be less than
                       {@code start} and not greater than {@code str.length()}.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code remaining()} is less than {@code end - start}.
            @exception IndexOutOfBoundsException
                           if either {@code start} or {@code end} is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Slice" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.SubSequence(System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.ToString">
            Returns a string representing the current remaining chars of this buffer.
            
            @return a string representing the current remaining chars of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Append(System.Char)">
             Writes the given char to the current position and increases the position
             by 1.
            
             @param c
                        the char to write.
             @return this buffer.
             @exception BufferOverflowException
                            if position is equal or greater than limit.
             @exception ReadOnlyBufferException
                            if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.CharBuffer.Append(ICU4N.Support.Text.ICharSequence)" -->
        <member name="M:ICU4N.Support.IO.CharBuffer.Append(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
             Writes chars of the given {@code CharSequence} to the current position of
             this buffer, and increases the position by the number of chars written.
            
             @param csq
                        the {@code CharSequence} to write.
             @param start
                        the first char to write, must not be negative and not greater
                        than {@code csq.length()}.
             @param end
                        the last char to write (excluding), must be less than
                        {@code start} and not greater than {@code csq.length()}.
             @return this buffer.
             @exception BufferOverflowException
                            if {@code remaining()} is less than {@code end - start}.
             @exception IndexOutOfBoundsException
                            if either {@code start} or {@code end} is invalid.
             @exception ReadOnlyBufferException
                            if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.CharBuffer.Read(ICU4N.Support.IO.CharBuffer)">
             Reads characters from this buffer and puts them into {@code target}. The
             number of chars that are copied is either the number of remaining chars
             in this buffer or the number of remaining chars in {@code target},
             whichever is smaller.
            
             @param target
                        the target char buffer.
             @throws IllegalArgumentException
                         if {@code target} is this buffer.
             @throws IOException
                         if an I/O error occurs.
             @throws ReadOnlyBufferException
                         if no changes may be made to the contents of {@code target}.
             @return the number of chars copied or -1 if there are no chars left to be
                     read from this buffer.
        </member>
        <member name="T:ICU4N.Support.IO.CharSequenceAdapter">
            <summary>
            This class wraps a char sequence to be a char buffer.
            <para/>
            Implementation notice:
            <list type="bullet">
                <item><description>Char sequence based buffer is always readonly.</description></item>
            </list>
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.CharToByteBufferAdapter">
            <summary>
            This class wraps a byte buffer to be a char buffer.
            </summary>
            <remarks>
            Implementation notice:
            <list type="bullet">
                <item><description>
                    After a byte buffer instance is wrapped, it becomes privately owned by
                    the adapter. It must NOT be accessed outside the adapter any more.
                </description></item>
                <item><description>
                    The byte buffer's position and limit are NOT linked with the adapter.
                    The adapter extends Buffer, thus has its own position and limit.
                </description></item>
            </list>
            </remarks>
        </member>
        <member name="T:ICU4N.Support.IO.IDataOutput">
            <summary>
            Equivalent to Java's DataOutut interface
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.IDataOutput.WriteSingle(System.Single)">
            <summary>
            NOTE: This was writeFloat() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.IDataOutput.WriteInt32(System.Int32)">
            <summary>
            NOTE: This was writeInt() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.IDataOutput.WriteInt64(System.Int64)">
            <summary>
            NOTE: This was writeInt64() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.IDataOutput.WriteInt16(System.Int32)">
            <summary>
            NOTE: This was writeShort() in Java
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.DataOutputStream">
            <summary>
            Java's DataOutputStream is similar to .NET's BinaryWriter. However, it writes
            in a modified UTF-8 format that cannot be read (or duplicated) using BinaryWriter.
            This is a port of DataOutputStream that is fully compatible with Java's DataInputStream.
            <para>
            Usage Note: Always favor BinaryWriter over DataOutputStream unless you specifically need
            the modified UTF-8 format and/or the <see cref="M:ICU4N.Support.IO.DataOutputStream.WriteUTF(System.String)"/> method.
            </para>
            </summary>
        </member>
        <member name="F:ICU4N.Support.IO.DataOutputStream.written">
            <summary>
            The number of bytes written out so far.
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.DataOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Support.IO.DataOutputStream"/> on the <see cref="T:System.IO.Stream"/>
            <paramref name="out"/>. Note that data written by this stream is not in a human
            readable form but can be reconstructed by using a <see cref="!:DataInputStream"/>
            on the resulting output.
            </summary>
            <param name="out">the target stream for writing.</param>
            <seealso cref="!:DataInputStream"/>
        </member>
        <member name="M:ICU4N.Support.IO.DataOutputStream.WriteSingle(System.Single)">
            <summary>
            NOTE: This was writeFloat() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.DataOutputStream.WriteInt32(System.Int32)">
            <summary>
            NOTE: This was writeInt() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.DataOutputStream.WriteInt64(System.Int64)">
            <summary>
            NOTE: This was writeLong() in Java
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.DataOutputStream.WriteInt16(System.Int32)">
            <summary>
            NOTE: This was writeShort() in Java
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.HeapByteBuffer">
            <summary>
            HeapByteBuffer, ReadWriteHeapByteBuffer and ReadOnlyHeapByteBuffer compose
            the implementation of array based byte buffers.
            <para/>
            HeapByteBuffer implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int32ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt32ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt32ArrayBuffer"/> compose
            the implementation of array based int buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/> implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int32Buffer">
            <summary>
            A buffer of <see cref="T:System.Int32"/>s.
            </summary>
            <remarks>
            A <see cref="T:System.Int32"/> buffer can be created in either of the following ways:
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.IO.Int32Buffer.Allocate(System.Int32)"/> a new <see cref="T:System.Int32"/> array and create a buffer based on it;</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.Int32Buffer.Wrap(System.Int32[])"/> an existing <see cref="T:System.Int32"/> array to create a new buffer;</description></item>
                <item><description>Use <see cref="M:ICU4N.Support.IO.ByteBuffer.AsInt32Buffer"/> to create a <see cref="T:System.Int32"/> buffer based on a byte buffer.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.Allocate(System.Int32)">
            Creates an int buffer based on a newly allocated int array.
            
            @param capacity
                       the capacity of the new buffer.
            @return the created int buffer.
            @throws IllegalArgumentException
                        if {@code capacity} is less than zero.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Wrap(System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Wrap(System.Int32[],System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.#ctor(System.Int32)">
             Constructs a {@code IntBuffer} with given capacity.
            
             @param capacity
                        the capacity of the buffer.
        </member>
        <member name="P:ICU4N.Support.IO.Int32Buffer.Array">
            Returns the int array which this buffer is based on, if there is one.
            
            @return the int array which this buffer is based on.
            @exception ReadOnlyBufferException
                           if this buffer is based on an array, but it is read-only.
            @exception UnsupportedOperationException
                           if this buffer is not based on an array.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int32Buffer.ArrayOffset" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.AsReadOnlyBuffer" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Compact" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.CompareTo(ICU4N.Support.IO.Int32Buffer)">
            Compares the remaining ints of this buffer to another int buffer's
            remaining ints.
            
            @param otherBuffer
                       another int buffer.
            @return a negative value if this is less than {@code other}; 0 if this
                    equals to {@code other}; a positive value if this is greater
                    than {@code other}.
            @exception ClassCastException
                           if {@code other} is not an int buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Duplicate" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Equals(System.Object)" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.Get">
            Returns the int at the current position and increases the position by 1.
            
            @return the int at the current position.
            @exception BufferUnderflowException
                           if the position is equal or greater than limit.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Get(System.Int32[])" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.Get(System.Int32[],System.Int32,System.Int32)">
            Reads ints from the current position into the specified int array,
            starting from the specified offset, and increases the position by the
            number of ints read.
            
            @param dest
                       the target int array.
            @param off
                       the offset of the int array, must not be negative and not
                       greater than {@code dest.length}.
            @param len
                       the number of ints to read, must be no less than zero and not
                       greater than {@code dest.length - off}.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception BufferUnderflowException
                           if {@code len} is greater than {@code remaining()}.
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.Get(System.Int32)">
            Returns an int at the specified index; the position is not changed.
            
            @param index
                       the index, must not be negative and less than limit.
            @return an int at the specified index.
            @exception IndexOutOfBoundsException
                           if index is invalid.
        </member>
        <member name="P:ICU4N.Support.IO.Int32Buffer.HasArray">
             Indicates whether this buffer is based on a int array and is read/write.
            
             @return {@code true} if this buffer is based on a int array and provides
                     read/write access, {@code false} otherwise.
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.GetHashCode">
             Calculates this buffer's hash code from the remaining chars. The
             position, limit, capacity and mark don't affect the hash code.
            
             @return the hash code calculated from the remaining ints.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int32Buffer.IsDirect" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int32Buffer.Order" -->
        <member name="P:ICU4N.Support.IO.Int32Buffer.ProtectedArray">
             Child class implements this method to realize {@code array()}.
            
             @return see {@code array()}
        </member>
        <member name="P:ICU4N.Support.IO.Int32Buffer.ProtectedArrayOffset">
             Child class implements this method to realize {@code arrayOffset()}.
            
             @return see {@code arrayOffset()}
        </member>
        <member name="P:ICU4N.Support.IO.Int32Buffer.ProtectedHasArray">
             Child class implements this method to realize {@code hasArray()}.
            
             @return see {@code hasArray()}
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.Put(System.Int32)">
            Writes the given int to the current position and increases the position
            by 1.
            
            @param i
                       the int to write.
            @return this buffer.
            @exception BufferOverflowException
                           if position is equal or greater than limit.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Put(System.Int32[])" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.Put(System.Int32[],System.Int32,System.Int32)">
            Writes ints from the given int array, starting from the specified offset,
            to the current position and increases the position by the number of ints
            written.
            
            @param src
                       the source int array.
            @param off
                       the offset of int array, must not be negative and not greater
                       than {@code src.length}.
            @param len
                       the number of ints to write, must be no less than zero and not
                       greater than {@code src.length - off}.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code remaining()} is less than {@code len}.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.Put(ICU4N.Support.IO.Int32Buffer)">
            Writes all the remaining ints of the {@code src} int buffer to this
            buffer's current position, and increases both buffers' position by the
            number of ints copied.
            
            @param src
                       the source int buffer.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code src.remaining()} is greater than this buffer's
                           {@code remaining()}.
            @exception IllegalArgumentException
                           if {@code src} is this buffer.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.Int32Buffer.Put(System.Int32,System.Int32)">
            Write a int to the specified index of this buffer; the position is not
            changed.
            
            @param index
                       the index, must not be negative and less than the limit.
            @param i
                       the int to write.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if index is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int32Buffer.Slice" -->
        <member name="M:ICU4N.Support.IO.Int32Buffer.ToString">
            Returns a string represents of the state of this int buffer.
            
            @return a string represents of the state of this int buffer.
        </member>
        <member name="T:ICU4N.Support.IO.Int32ToByteBufferAdapter">
            <summary>
            This class wraps a byte buffer to be a int buffer.
            </summary>
            <remarks>
            Implementation notice:
            <list type="bullet">
                <item><description>
                    After a byte buffer instance is wrapped, it becomes privately owned by
                    the adapter. It must NOT be accessed outside the adapter any more.
                </description></item>
                <item><description>
                    The byte buffer's position and limit are NOT linked with the adapter.
                    The adapter extends <see cref="T:ICU4N.Support.IO.Buffer"/>, thus has its own position and limit.
                </description></item>
            </list>
            </remarks>
        </member>
        <member name="T:ICU4N.Support.IO.Int64ArrayBuffer">
            <summary>
            LongArrayBuffer, ReadWriteLongArrayBuffer and ReadOnlyLongArrayBuffer compose
            the implementation of array based long buffers.
            <para/>
            LongArrayBuffer implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are marked final for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int64Buffer">
            <summary>
            A buffer of longs.
            <para/>
            A long buffer can be created in either of the following ways:
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.IO.Int64Buffer.Allocate(System.Int32)"/> a new long array and create a buffer
                based on it</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.Int64Buffer.Wrap(System.Int64[])"/> an existing long array to create a new
                buffer</description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Int64Buffer.Allocate(System.Int32)">
            <summary>
            Creates a long buffer based on a newly allocated long array.
            </summary>
            <param name="capacity">the capacity of the new buffer.</param>
            <returns>the created long buffer.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="capacity"/> is less than zero.</exception>
        </member>
        <member name="M:ICU4N.Support.IO.Int64Buffer.Wrap(System.Int64[])">
            <summary>
            Creates a new long buffer by wrapping the given long array.
            <para/>
            Calling this method has the same effect as
            <c>Wrap(array, 0, array.Length)</c>.
            </summary>
            <param name="array">the long array which the new buffer will be based on.</param>
            <returns>the created long buffer.</returns>
        </member>
        <member name="M:ICU4N.Support.IO.Int64Buffer.#ctor(System.Int32)">
            <summary>
            Constructs a <see cref="T:ICU4N.Support.IO.Int64Buffer"/> with given capacity.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int64ToByteBufferAdapter">
            <summary>
            This class wraps a byte buffer to be a long buffer.
            <para/>
            Implementation notice:
            <list type="bullet">
                <item><description>After a byte buffer instance is wrapped, it becomes privately owned by
                the adapter. It must NOT be accessed outside the adapter any more.</description></item>
                <item><description>The byte buffer's position and limit are NOT linked with the adapter.
                The adapter extends Buffer, thus has its own position and limit.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt16">
            <summary>
            NOTE: This was getShort() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt16(System.Int32)">
            <summary>
            NOTE: This was getShort() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt16(System.Int16)">
            <summary>
            NOTE: This was putShort() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt16(System.Int32,System.Int16)">
            <summary>
            NOTE: This was putShort() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt32">
            <summary>
            NOTE: This was getInt() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt32(System.Int32)">
            <summary>
            NOTE: This was getInt() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt32(System.Int32)">
            <summary>
            NOTE: This was putInt() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt32(System.Int32,System.Int32)">
            <summary>
            NOTE: This was putInt() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt64">
            <summary>
            NOTE: This was getLong() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetInt64(System.Int32)">
            <summary>
            NOTE: This was getLong() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt64(System.Int64)">
            <summary>
            NOTE: This was putLong() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutInt64(System.Int32,System.Int64)">
            <summary>
            NOTE: This was putLong() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetSingle">
            <summary>
            NOTE: This was getFloat() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.GetSingle(System.Int32)">
            <summary>
            NOTE: This was getFloat() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutSingle(System.Single)">
            <summary>
            NOTE: This was putFloat() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.PutSingle(System.Int32,System.Single)">
            <summary>
            NOTE: This was putFloat() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.AsCharBuffer">
            <summary>
            NOTE: This was asCharBuffer() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.AsInt16Buffer">
            <summary>
            NOTE: This was asShortBuffer() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.AsInt32Buffer">
            <summary>
            NOTE: This was asIntBuffer() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.AsInt64Buffer">
            <summary>
            NOTE: This was asLongBuffer() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.NextGetIndex">
            <summary>
            Checks the current position against the limit, throwing a
            <see cref="T:ICU4N.Support.IO.BufferUnderflowException"/> if it is not smaller than the limit, and then
            increments the position.
            </summary>
            <returns>The current position value, before it is incremented</returns>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.NextPutIndex">
            <summary>
            Checks the current position against the limit, throwing a <see cref="T:ICU4N.Support.IO.BufferOverflowException"/>
            if it is not smaller than the limit, and then
            increments the position.
            </summary>
            <returns>The current position value, before it is incremented</returns>
        </member>
        <member name="M:ICU4N.Support.IO.MemoryMappedFileByteBuffer.CheckIndex(System.Int32)">
            <summary>
            Checks the given index against the limit, throwing an <see cref="T:System.IndexOutOfRangeException"/> 
            if it is not smaller than the limit or is smaller than zero.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:ICU4N.Support.IO.ReadOnlyCharArrayBuffer">
            <summary>
            CharArrayBuffer, ReadWriteCharArrayBuffer and ReadOnlyCharArrayBuffer compose
            the implementation of array based char buffers.
            <para/>
            ReadOnlyCharArrayBuffer extends CharArrayBuffer with all the write methods
            throwing read only exception.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadOnlyHeapByteBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.HeapByteBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteHeapByteBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyHeapByteBuffer"/> compose
            the implementation of array based byte buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.ReadOnlyHeapByteBuffer"/> extends <see cref="T:ICU4N.Support.IO.HeapByteBuffer"/> with all the write methods
            throwing read only exception.
            <para/>
            This class is sealed final for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadOnlyInt32ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt32ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt32ArrayBuffer"/> compose
            the implementation of array based <see cref="T:System.Int32"/> buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.ReadOnlyInt32ArrayBuffer"/> extends <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/> with all the write methods
            throwing read only exception.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadOnlyInt16ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt16ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt16ArrayBuffer"/>
            compose the implementation of array based short buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.ReadOnlyInt16ArrayBuffer"/> extends <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/> with all the write
            methods throwing read only exception.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadWriteCharArrayBuffer">
            <summary>
            CharArrayBuffer, ReadWriteCharArrayBuffer and ReadOnlyCharArrayBuffer compose
            the implementation of array based char buffers.
            <para/>
            ReadWriteCharArrayBuffer extends CharArrayBuffer with all the write methods.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadWriteHeapByteBuffer">
            <summary>
            HeapByteBuffer, ReadWriteHeapByteBuffer and ReadOnlyHeapByteBuffer compose
            the implementation of array based byte buffers.
            <para/>
            ReadWriteHeapByteBuffer extends HeapByteBuffer with all the write methods.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadWriteInt32ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt32ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt32ArrayBuffer"/> compose
            the implementation of array based int buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.ReadWriteInt32ArrayBuffer"/> extends <see cref="T:ICU4N.Support.IO.Int32ArrayBuffer"/> with all the write methods.
            <para/>
            All methods are marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadWriteInt64ArrayBuffer">
            <summary>
            LongArrayBuffer, ReadWriteLongArrayBuffer and ReadOnlyLongArrayBuffer compose
            the implementation of array based long buffers.
            <para/>
            ReadWriteLongArrayBuffer extends LongArrayBuffer with all the write methods.
            <para/>
            This class is marked final for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.ReadWriteInt16ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt16ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt16ArrayBuffer"/>
            compose the implementation of array based short buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.ReadWriteInt16ArrayBuffer"/> extends <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/> with all the write
            methods.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int16ArrayBuffer">
            <summary>
            <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/>, <see cref="T:ICU4N.Support.IO.ReadWriteInt16ArrayBuffer"/> and <see cref="T:ICU4N.Support.IO.ReadOnlyInt16ArrayBuffer"/>
            compose the implementation of array based short buffers.
            <para/>
            <see cref="T:ICU4N.Support.IO.Int16ArrayBuffer"/> implements all the shared readonly methods and is extended
            by the other two classes.
            <para/>
            All methods are marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:ICU4N.Support.IO.Int16Buffer">
            <summary>
            A buffer of shorts.
            <para/>
            A short buffer can be created in either of the following ways:
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.IO.Int16Buffer.Allocate(System.Int32)"/> a new long array and create a buffer
                based on it</description></item>
                <item><description><see cref="M:ICU4N.Support.IO.Int16Buffer.Wrap(System.Int16[])"/> an existing long array to create a new
                buffer</description></item>
                <item><description>Use <see cref="M:ICU4N.Support.IO.ByteBuffer.AsInt16Buffer"/> to create a short 
                buffer based on a byte buffer.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.Allocate(System.Int32)">
            Creates a short buffer based on a newly allocated short array.
            
            @param capacity
                       the capacity of the new buffer.
            @return the created short buffer.
            @throws IllegalArgumentException
                        if {@code capacity} is less than zero.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Wrap(System.Int16[])" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Wrap(System.Int16[],System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.#ctor(System.Int32)">
             Constructs a {@code ShortBuffer} with given capacity.
            
             @param capacity
                        The capacity of the buffer
        </member>
        <member name="P:ICU4N.Support.IO.Int16Buffer.Array">
            Returns the short array which this buffer is based on, if there is one.
            
            @return the short array which this buffer is based on.
            @exception ReadOnlyBufferException
                           if this buffer is based on an array, but it is read-only.
            @exception UnsupportedOperationException
                           if this buffer is not based on an array.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int16Buffer.ArrayOffset" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.AsReadOnlyBuffer" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Compact" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.CompareTo(ICU4N.Support.IO.Int16Buffer)">
            Compare the remaining shorts of this buffer to another short buffer's
            remaining shorts.
            
            @param otherBuffer
                       another short buffer.
            @return a negative value if this is less than {@code otherBuffer}; 0 if
                    this equals to {@code otherBuffer}; a positive value if this is
                    greater than {@code otherBuffer}.
            @exception ClassCastException
                           if {@code otherBuffer} is not a short buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Duplicate" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Equals(System.Object)" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.Get">
            Returns the short at the current position and increases the position by
            1.
            
            @return the short at the current position.
            @exception BufferUnderflowException
                           if the position is equal or greater than limit.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Get(System.Int16[])" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.Get(System.Int16[],System.Int32,System.Int32)">
            Reads shorts from the current position into the specified short array,
            starting from the specified offset, and increases the position by the
            number of shorts read.
            
            @param dest
                       the target short array.
            @param off
                       the offset of the short array, must not be negative and not
                       greater than {@code dest.length}.
            @param len
                       the number of shorts to read, must be no less than zero and
                       not greater than {@code dest.length - off}.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception BufferUnderflowException
                           if {@code len} is greater than {@code remaining()}.
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.Get(System.Int32)">
            Returns the short at the specified index; the position is not changed.
            
            @param index
                       the index, must not be negative and less than limit.
            @return a short at the specified index.
            @exception IndexOutOfBoundsException
                           if index is invalid.
        </member>
        <member name="P:ICU4N.Support.IO.Int16Buffer.HasArray">
             Indicates whether this buffer is based on a short array and is
             read/write.
            
             @return {@code true} if this buffer is based on a short array and
                     provides read/write access, {@code false} otherwise.
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.GetHashCode">
             Calculates this buffer's hash code from the remaining chars. The
             position, limit, capacity and mark don't affect the hash code.
            
             @return the hash code calculated from the remaining shorts.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int16Buffer.IsDirect" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Support.IO.Int16Buffer.Order" -->
        <member name="P:ICU4N.Support.IO.Int16Buffer.ProtectedArray">
             Child class implements this method to realize {@code array()}.
            
             @return see {@code array()}
        </member>
        <member name="P:ICU4N.Support.IO.Int16Buffer.ProtectedArrayOffset">
             Child class implements this method to realize {@code arrayOffset()}.
            
             @return see {@code arrayOffset()}
        </member>
        <member name="P:ICU4N.Support.IO.Int16Buffer.ProtectedHasArray">
             Child class implements this method to realize {@code hasArray()}.
            
             @return see {@code hasArray()}
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.Put(System.Int16)">
            Writes the given short to the current position and increases the position
            by 1.
            
            @param s
                       the short to write.
            @return this buffer.
            @exception BufferOverflowException
                           if position is equal or greater than limit.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Put(System.Int16[])" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.Put(System.Int16[],System.Int32,System.Int32)">
            Writes shorts from the given short array, starting from the specified
            offset, to the current position and increases the position by the number
            of shorts written.
            
            @param src
                       the source short array.
            @param off
                       the offset of short array, must not be negative and not
                       greater than {@code src.length}.
            @param len
                       the number of shorts to write, must be no less than zero and
                       not greater than {@code src.length - off}.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code remaining()} is less than {@code len}.
            @exception IndexOutOfBoundsException
                           if either {@code off} or {@code len} is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.Put(ICU4N.Support.IO.Int16Buffer)">
            Writes all the remaining shorts of the {@code src} short buffer to this
            buffer's current position, and increases both buffers' position by the
            number of shorts copied.
            
            @param src
                       the source short buffer.
            @return this buffer.
            @exception BufferOverflowException
                           if {@code src.remaining()} is greater than this buffer's
                           {@code remaining()}.
            @exception IllegalArgumentException
                           if {@code src} is this buffer.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <member name="M:ICU4N.Support.IO.Int16Buffer.Put(System.Int32,System.Int16)">
            Writes a short to the specified index of this buffer; the position is not
            changed.
            
            @param index
                       the index, must not be negative and less than the limit.
            @param s
                       the short to write.
            @return this buffer.
            @exception IndexOutOfBoundsException
                           if index is invalid.
            @exception ReadOnlyBufferException
                           if no changes may be made to the contents of this buffer.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.IO.Int16Buffer.Slice" -->
        <member name="M:ICU4N.Support.IO.Int16Buffer.ToString">
            Returns a string representing the state of this short buffer.
            
            @return a string representing the state of this short buffer.
        </member>
        <member name="T:ICU4N.Support.IO.Int16ToByteBufferAdapter">
            <summary>
            This class wraps a byte buffer to be a short buffer.
            <para/>
            Implementation notice:
            <list type="bullet">
                <item><description>After a byte buffer instance is wrapped, it becomes privately owned by
                the adapter. It must NOT be accessed outside the adapter any more.</description></item>
                <item><description>The byte buffer's position and limit are NOT linked with the adapter.
                The adapter extends <see cref="T:ICU4N.Support.IO.Buffer"/>, thus has its own position and limit.</description></item>
            </list>
            </summary>
        </member>
        <member name="T:ICU4N.Support.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.ToString(System.Double)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Number.Signum(System.Int32)">
            <summary>
            Returns the signum function of the specified <see cref="T:System.Int32"/> value.  (The
            return value is -1 if the specified value is negative; 0 if the
            specified value is zero; and 1 if the specified value is positive.)
            <para/>
            This can be useful for testing the results of two <see cref="M:System.IComparable`1.CompareTo(`0)"/>
            methods against each other, since only the sign is guaranteed to be the same between impementations.
            </summary>
            <returns>the signum function of the specified <see cref="T:System.Int32"/> value.</returns>
        </member>
        <member name="M:ICU4N.Support.Number.Int32BitsToSingle(System.Int32)">
            <summary>
            NOTE: This was intBitsToFloat() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.SingleToInt32Bits(System.Single)">
            <summary>
            NOTE: This was floatToIntBits() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.DoubleToRawInt64Bits(System.Double)">
            <summary>
            NOTE: This was doubleToRawLongBits() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.DoubleToInt64Bits(System.Double)">
            <summary>
            NOTE: This was doubleToLongBits() in the JDK
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.TripleShift(System.Int64,System.Int32)">
            <summary>
            Replacement for Java triple shift (>>>) operator.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.TripleShift(System.Int32,System.Int32)">
            <summary>
            Replacement for Java triple shift (>>>) operator.
            See http://stackoverflow.com/a/6625912
            </summary>
        </member>
        <member name="M:ICU4N.Support.Number.TripleShift(System.Char,System.Int32)">
            <summary>
            Replacement for Java triple shift (>>>) operator.
            See http://stackoverflow.com/a/6625912
            </summary>
        </member>
        <member name="M:ICU4N.Support.ObjectExtensions.ConvertToCharSequence``1(``0)">
            <summary>
            If <paramref name="obj"/> is type <see cref="T:System.String"/>, <see cref="T:System.Text.StringBuilder"/>, or
            <see cref="T:char[]"/>, it is wrapped in an adapter class that implements <see cref="T:ICU4N.Support.Text.ICharSequence"/>
            and returned. If the object already is <see cref="T:ICU4N.Support.Text.ICharSequence"/> it is cast to <see cref="T:ICU4N.Support.Text.ICharSequence"/>
            unchanged. If <paramref name="obj"/> is another type, the result is null.
            </summary>
        </member>
        <member name="T:ICU4N.Support.SystemProperties">
            <summary>
            Helper for environment variables. This class helps to convert the environment
            variables to int or bool data types and also silently handles read permission
            errors.
            <para/>
            For instructions how to set environment variables for your OS, see 
            <a href="https://www.schrodinger.com/kb/1842">https://www.schrodinger.com/kb/1842</a>.
            <para/>
            Note that if you want to load any of these settings for your application from a
            configuration file, it is recommended your application load them at startup and
            call <see cref="M:ICU4N.Support.SystemProperties.SetProperty(System.String,System.String)"/> to set them.
            <para/>
            Set the environment variable <c>icu4n.ignoreSecurityExceptions</c> to <c>false</c>
            to change the read behavior of these methods to throw the underlying exception 
            instead of returning the default value.
            </summary>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetProperty(System.String)">
            <summary>
            Retrieves the value of an environment variable from the current process.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetProperty(System.String,System.String)">
            <summary>
            Retrieves the value of an environment variable from the current process, 
            with a default value if it doens't exist or the caller doesn't have 
            permission to read the value.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <param name="defaultValue">The value to use if the environment variable does not exist 
            or the caller doesn't have permission to read the value.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetPropertyAsBoolean(System.String)">
            <summary>
            Retrieves the value of an environment variable from the current process
            as <see cref="T:System.Boolean"/>. If the value cannot be cast to <see cref="T:System.Boolean"/>, returns <c>false</c>.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetPropertyAsBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves the value of an environment variable from the current process as <see cref="T:System.Boolean"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <param name="defaultValue">The value to use if the environment variable does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Boolean"/>.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetPropertyAsInt32(System.String)">
            <summary>
            Retrieves the value of an environment variable from the current process
            as <see cref="T:System.Int32"/>. If the value cannot be cast to <see cref="T:System.Int32"/>, returns <c>0</c>.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.GetPropertyAsInt32(System.String,System.Int32)">
            <summary>
            Retrieves the value of an environment variable from the current process as <see cref="T:System.Int32"/>, 
            with a default value if it doens't exist, the caller doesn't have permission to read the value, 
            or the value cannot be cast to a <see cref="T:System.Int32"/>.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <param name="defaultValue">The value to use if the environment variable does not exist,
            the caller doesn't have permission to read the value, or the value cannot be cast to <see cref="T:System.Int32"/>.</param>
            <returns>The environment variable value.</returns>
        </member>
        <member name="M:ICU4N.Support.SystemProperties.SetProperty(System.String,System.String)">
            <summary>
            Creates, modifies, or deletes an environment variable stored in the current process.
            </summary>
            <param name="key">The name of the environment variable.</param>
            <param name="value">The new environment variable value.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        </member>
        <member name="T:ICU4N.Support.Text.AttributedCharacterIterator">
            <summary>
            Extends the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> class, adding support for iterating over
            attributes and not only characters. An
            <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> also allows the user to find runs and
            their limits. Runs are defined as ranges of characters that all have the same
            attributes with the same values.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetAllAttributeKeys">
            <summary>
            Returns a set of attributes present in the <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.
            An empty set is returned if no attributes were defined.
            </summary>
            <returns>A set of attribute keys; may be empty.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetAttribute(ICU4N.Support.Text.AttributedCharacterIteratorAttribute)">
            <summary>
            Returns the value stored in the attribute for the current character. If
            the attribute was not defined then <c>null</c> is returned.
            </summary>
            <param name="attribute">The attribute for which the value should be returned.</param>
            <returns>the value of the requested attribute for the current character or <c>null</c>
            if it was not defined.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetAttributes">
            <summary>
            Returns a map of all attributes of the current character. If no
            attributes were defined for the current character then an empty map is
            returned.
            </summary>
            <returns>A dictionary of all attributes for the current character or an empty dictionary.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunLimit">
            <summary>
            Returns the index of the last character in the run having the same
            attributes as the current character.
            </summary>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunLimit(ICU4N.Support.Text.AttributedCharacterIteratorAttribute)">
            <summary>
            Returns the index of the last character in the run that has the same
            attribute value for the given attribute as the current character.
            </summary>
            <param name="attribute">The attribute which the run is based on.</param>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunLimit``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns the index of the last character in the run that has the same
            attribute values for the attributes in the set as the current character.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="attributes">The set of attributes which the run is based on.</param>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunStart">
            <summary>
            Returns the index of the first character in the run that has the same
            attributes as the current character.
            </summary>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunStart(ICU4N.Support.Text.AttributedCharacterIteratorAttribute)">
            <summary>
            Returns the index of the first character in the run that has the same
            attribute value for the given attribute as the current character.
            </summary>
            <param name="attribute">The attribute which the run is based on.</param>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIterator.GetRunStart``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns the index of the first character in the run that has the same
            attribute values for the attributes in the set as the current character.
            </summary>
            <typeparam name="T">The type of attribute, <see cref="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute"/> or a subclass of it.</typeparam>
            <param name="attributes">The set of attributes which the run is based on.</param>
            <returns>The index of the last character of the current run.</returns>
        </member>
        <member name="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute">
            <summary>
            Defines keys for text attributes.
            </summary>
        </member>
        <member name="F:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.InputMethodSegment">
            <summary>
            This attribute marks segments from an input method. Most input
            methods create these segments for words.
            <para/>
            The value objects are of the type <c>Annotation</c> which contain <c>null</c>.
            </summary>
        </member>
        <member name="F:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.Language">
            <summary>
            The attribute describing the language of a character. The value
            objects are of type <see cref="T:System.Globalization.CultureInfo"/> or a subtype of it.
            </summary>
        </member>
        <member name="F:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.Reading">
            <summary>
            For languages that have different reading directions of text (like
            Japanese), this attribute allows to define which reading should be
            used. The value objects are of type <c>Annotation</c> which
            contain a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.#ctor(System.String)">
            <summary>
            The constructor for an <see cref="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute"/> with the name passed.
            </summary>
            <param name="name">The name of the new <see cref="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute"/>.</param>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.Equals(System.Object)">
            <summary>
            Compares this attribute with the specified object. Checks if both
            objects are the same instance. It is defined sealed so all subclasses
            have the same behavior for this method.
            </summary>
            <param name="obj">The object to compare against.</param>
            <returns><c>true</c> if the object passed is equal to this instance; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.Name">
            <summary>
            Gets the name of this attribute.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.GetHashCode">
            <summary>
            Calculates the hash code for objects of type <see cref="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute"/>. It
            is defined final so all sub types calculate their hash code
            identically.
            </summary>
            <returns>the hash code for this instance of <see cref="T:ICU4N.Support.Text.AttributedCharacterIteratorAttribute"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.ReadResolve">
             Resolves a deserialized instance to the correct constant attribute.
            
             @return the {@code Attribute} this instance represents.
             @throws InvalidObjectException
                         if this instance is not of type {@code Attribute.class}
                         or if it is not a known {@code Attribute}.
        </member>
        <member name="M:ICU4N.Support.Text.AttributedCharacterIteratorAttribute.ToString">
            <summary>
            Returns the name of the class followed by a "(", the name of the
            attribute, and a ")".
            </summary>
            <returns>the string representing this instance.</returns>
        </member>
        <member name="T:ICU4N.Support.Text.AttributedString">
            <summary>
            Holds a string with attributes describing the characters of
            this string.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.AttributedIterator.Clone">
            <summary>
            Returns a new <see cref="T:ICU4N.Support.Text.AttributedString.AttributedIterator"/> with the same source string,
            begin, end, and current index as this attributed iterator.
            </summary>
            <returns>A shallow copy of this attributed iterator.</returns>
        </member>
        <member name="P:ICU4N.Support.Text.AttributedString.AttributedIterator.BeginIndex">
            <summary>
            Gets the begin index in the source string.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.AttributedString.AttributedIterator.EndIndex">
            <summary>
            Gets the end index in the source String. The index is one past the last character to iterate.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.AttributedString.AttributedIterator.Index">
            <summary>
            Gets the current index in the source String.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.AttributedIterator.GetAllAttributeKeys">
            <summary>
            Returns a set of attributes present in the <see cref="T:ICU4N.Support.Text.AttributedString"/>.
            An empty set returned indicates that no attributes where defined.
            </summary>
            <returns>A set of attribute keys that may be empty.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.#ctor(ICU4N.Support.Text.AttributedCharacterIterator)">
            <summary>
            Constructs an <see cref="T:ICU4N.Support.Text.AttributedString"/> from an 
            <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>, which represents attributed text.
            </summary>
            <param name="iterator">The <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that contains the text
            for this attributed string.</param>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.#ctor(ICU4N.Support.Text.AttributedCharacterIterator,System.Int32,System.Int32)">
            <summary>
            Constructs an <see cref="T:ICU4N.Support.Text.AttributedString"/> from a range of the text contained
            in the specified <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>, starting at 
            <paramref name="start"/> and ending at <paramref name="end"/>. All attributes will be copied to this
            attributed string.
            </summary>
            <param name="iterator">The <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that contains the text
            for this attributed string.</param>
            <param name="start">the start index of the range of the copied text.</param>
            <param name="end">the end index of the range of the copied text.</param>
            <exception cref="T:System.ArgumentException">if <paramref name="start"/> is less than first index of
            <paramref name="iterator"/>, <paramref name="end"/> is greater than the last index +
            1 in <paramref name="iterator"/> or if <paramref name="start"/> &gt; <paramref name="end"/>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.#ctor(ICU4N.Support.Text.AttributedCharacterIterator,System.Int32,System.Int32,ICU4N.Support.Text.AttributedCharacterIteratorAttribute[])">
            <summary>
            Constructs an <see cref="T:ICU4N.Support.Text.AttributedString"/> from a range of the text contained
            in the specified <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>, starting at 
            <paramref name="start"/>, ending at <paramref name="end"/> and it will copy the attributes defined in
            the specified set. If the set is <c>null</c> then all attributes are
            copied.
            </summary>
            <param name="iterator">The <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that contains the text
            for this attributed string.</param>
            <param name="start">The start index of the range of the copied text.</param>
            <param name="end">The end index of the range of the copied text.</param>
            <param name="attributes">The set of attributes that will be copied, or all if it is
            <c>null</c>.</param>
            <exception cref="T:System.ArgumentException">if <paramref name="start"/> is less than first index of
            <paramref name="iterator"/>, <paramref name="end"/> is greater than the last index +
            1 in <paramref name="iterator"/> or if <paramref name="start"/> &gt; <paramref name="end"/>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.#ctor(System.String)">
            <summary>
            Creates an <see cref="T:ICU4N.Support.Text.AttributedString"/> from the given text.
            </summary>
            <param name="value">the text to take as base for this attributed string.</param>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.#ctor(System.String,System.Collections.Generic.IDictionary{ICU4N.Support.Text.AttributedCharacterIteratorAttribute,System.Object})">
            <summary>
            Creates an <see cref="T:ICU4N.Support.Text.AttributedString"/> from the given text and the
            <paramref name="attributes"/>. The whole text has the given attributes applied.
            </summary>
            <param name="value">the text to take as base for this attributed string.</param>
            <param name="attributes">the attributes that the text is associated with.</param>
            <exception cref="T:System.ArgumentException">if the length of <paramref name="value"/> is 0 but the size of
            <paramref name="attributes"/> is greater than 0.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.AddAttribute(ICU4N.Support.Text.AttributedCharacterIteratorAttribute,System.Object)">
            <summary>
            Applies a given attribute to this string.
            </summary>
            <param name="attribute">The attribute that will be applied to this string.</param>
            <param name="value">The value of the attribute that will be applied to this string.</param>
            <exception cref="T:System.ArgumentException">If the length of this attributed string is 0.</exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="attribute"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.AddAttribute(ICU4N.Support.Text.AttributedCharacterIteratorAttribute,System.Object,System.Int32,System.Int32)">
            <summary>
            Applies a given attribute to the given range of this string.
            </summary>
            <param name="attribute">The attribute that will be applied to this string.</param>
            <param name="value">The value of the attribute that will be applied to this string.</param>
            <param name="start">The start of the range where the attribute will be applied.</param>
            <param name="end">The end of the range where the attribute will be applied.</param>
            <exception cref="T:System.ArgumentException">If <c>start &lt; 0</c>, <paramref name="end"/> is greater than the length
            of this string, or if <c>start &gt;= end</c>.</exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="attribute"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.AddAttributes(System.Collections.Generic.IDictionary{ICU4N.Support.Text.AttributedCharacterIteratorAttribute,System.Object},System.Int32,System.Int32)">
            <summary>
            Applies a given set of attributes to the given range of the string.
            </summary>
            <param name="attributes">the set of attributes that will be applied to this string.</param>
            <param name="start">the start of the range where the attribute will be applied.</param>
            <param name="end">the end of the range where the attribute will be applied.</param>
            <exception cref="T:System.ArgumentException">If <c>start &lt; 0</c>, <paramref name="end"/> is greater than the length
            of this string, or if <c>start &gt;= end</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.GetIterator">
            <summary>
            Returns an <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that gives access to the
            complete content of this attributed string.
            </summary>
            <returns>The newly created <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.GetIterator(ICU4N.Support.Text.AttributedCharacterIteratorAttribute[])">
            <summary>
            Returns an <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that gives access to the
            complete content of this attributed string. Only attributes contained in
            <paramref name="attributes"/> are available from this iterator if they are defined
            for this text.
            </summary>
            <param name="attributes">the array containing attributes that will be in the new
            iterator if they are defined for this text.</param>
            <returns>The newly created <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.AttributedString.GetIterator(ICU4N.Support.Text.AttributedCharacterIteratorAttribute[],System.Int32,System.Int32)">
            <summary>
            Returns an <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that gives access to the
            contents of this attributed string starting at index <paramref name="start"/> up to
            index <paramref name="end"/>. Only attributes contained in <paramref name="attributes"/> are
            available from this iterator if they are defined for this text.
            </summary>
            <param name="attributes">the array containing attributes that will be in the new
            iterator if they are defined for this text.</param>
            <param name="start">the start index of the iterator on the underlying text.</param>
            <param name="end">the end index of the iterator on the underlying text.</param>
            <returns>The newly created <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.Character.Digit(System.Char,System.Int32)">
            <summary>
            Convenience method to determine the value of the specified character
            <paramref name="c"/> in the supplied radix. The value of <paramref name="radix"/> must be
            between <see cref="F:ICU4N.Support.Text.Character.MIN_RADIX"/> and <see cref="F:ICU4N.Support.Text.Character.MAX_RADIX"/>.
            </summary>
            <param name="c">The character to determine the value of.</param>
            <param name="radix">The radix.</param>
            <returns>
            The value of <paramref name="c"/> in <paramref name="radix"/> if <paramref name="radix"/> lies
            between <see cref="F:ICU4N.Support.Text.Character.MIN_RADIX"/> and <see cref="F:ICU4N.Support.Text.Character.MAX_RADIX"/>; -1 otherwise.
            </returns>
        </member>
        <member name="M:ICU4N.Support.Text.Character.BinarySearchRange(System.String,System.Char)">
            <summary>
            Search the sorted characters in the string and return the nearest index.
            </summary>
            <param name="data">The String to search.</param>
            <param name="c">The character to search for.</param>
            <returns>The nearest index.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.Character.ForDigit(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="digit"></param>
             <param name="radix"></param>
             <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Text.Character.CodePointCount(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the text range of the specified char sequence. 
            The text range begins at the specified <paramref name="beginIndex"/> and extends to the char at index <c>endIndex - 1</c>. 
            Thus the length (in <see cref="T:System.Char"/>s) of the text range is <c>endIndex-beginIndex</c>. 
            Unpaired surrogates within the text range count as one code point each.
            </summary>
            <param name="seq">the char sequence</param>
            <param name="beginIndex">the index to the first char of the text range.</param>
            <param name="endIndex">the index after the last char of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/> 
            is larger than the length of the given sequence, or <paramref name="beginIndex"/> 
            is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:ICU4N.Support.Text.Character.CodePointCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the text range of the specified char sequence. 
            The text range begins at the specified <paramref name="beginIndex"/> and extends to the char at index <c>endIndex - 1</c>. 
            Thus the length (in <see cref="T:System.Char"/>s) of the text range is <c>endIndex-beginIndex</c>. 
            Unpaired surrogates within the text range count as one code point each.
            </summary>
            <param name="seq">the char sequence</param>
            <param name="beginIndex">the index to the first char of the text range.</param>
            <param name="endIndex">the index after the last char of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/> 
            is larger than the length of the given sequence, or <paramref name="beginIndex"/> 
            is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:ICU4N.Support.Text.Character.CodePointCount(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the text range of the specified char sequence. 
            The text range begins at the specified <paramref name="beginIndex"/> and extends to the char at index <c>endIndex - 1</c>. 
            Thus the length (in <see cref="T:System.Char"/>s) of the text range is <c>endIndex-beginIndex</c>. 
            Unpaired surrogates within the text range count as one code point each.
            </summary>
            <param name="seq">the char sequence</param>
            <param name="beginIndex">the index to the first char of the text range.</param>
            <param name="endIndex">the index after the last char of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/> 
            is larger than the length of the given sequence, or <paramref name="beginIndex"/> 
            is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:ICU4N.Support.Text.Character.OffsetByCodePoints(System.String,System.Int32,System.Int32)">
            <summary>
            Copy of the implementation from Character class in Java
            
            http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Character.java
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.Character.OffsetByCodePoints(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Copy of the implementation from Character class in Java
            
            http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Character.java
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.Character.OffsetByCodePoints(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy of the implementation from Character class in Java
            
            http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Character.java
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.Character.GetType(System.Int32)">
            <summary>
            A safe way to get unicode category. The .NET <see cref="M:System.Char.ConvertFromUtf32(System.Int32)"/>
            method should be used first to be safe for surrogate pairs. However, if the value falls between
            0x00d800 and 0x00dfff, that method throws an exception. So this is a wrapper that converts the
            codepoint to a char in those cases.
            
            This mimics the behavior of the Java Character.GetUnicodeCategory class, but returns the .NET UnicodeCategory
            enumeration for easy consumption.
            </summary>
            <param name="codePoint"></param>
            <returns> A <see cref="T:System.Globalization.UnicodeCategory"/> representing the <paramref name="codePoint"/>. </returns>
        </member>
        <member name="T:ICU4N.Support.Text.CharacterIterator">
            <summary>
            An interface for the bidirectional iteration over a group of characters. The
            iteration starts at the begin index in the group of characters and continues
            to one index before the end index.
            </summary>
        </member>
        <member name="F:ICU4N.Support.Text.CharacterIterator.Done">
            <summary>
            A constant which indicates that there is no character at the current
            index.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.Clone">
            <summary>
            Returns a new <see cref="T:ICU4N.Support.Text.CharacterIterator"/> with the same properties.
            </summary>
            <returns>A shallow copy of this character iterator.</returns>
        </member>
        <member name="P:ICU4N.Support.Text.CharacterIterator.Current">
            <summary>
            Returns the character at the current index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the current index is
            past the beginning or end of the sequence.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.First">
            <summary>
            Sets the current position to the begin index and returns the character at
            the new position.
            </summary>
            <returns>The character at the begin index.</returns>
        </member>
        <member name="P:ICU4N.Support.Text.CharacterIterator.BeginIndex">
            <summary>
            Gets the begin index. Returns the index of the first character of the iteration.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.CharacterIterator.EndIndex">
            <summary>
            Gets the end index. Returns the index one past the last character of the iteration.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.CharacterIterator.Index">
            <summary>
            Gets the current index.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.Last">
            <summary>
            Sets the current position to the end index - 1 and returns the character
            at the new position.
            </summary>
            <returns>The character before the end index.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.Next">
            <summary>
            Increments the current index and returns the character at the new index.
            </summary>
            <returns>The character at the next index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the next
            index would be past the end.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.Previous">
            <summary>
            Decrements the current index and returns the character at the new index.
            </summary>
            <returns>The character at the previous index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the
            previous index would be past the beginning.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.CharacterIterator.SetIndex(System.Int32)">
            <summary>
            Sets the current index to a new position and returns the character at the
            new index.
            </summary>
            <param name="location">The new index that this character iterator is set to.</param>
            <returns>The character at the new index, or <see cref="F:ICU4N.Support.Text.CharacterIterator.Done"/> if the index is
            past the end.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="location"/> is less than 
            the begin index or greater than the end index.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.CharArrayExtensions.ToCharSequence(System.Char[])">
            <summary>
            Convenience method to wrap a string in a <see cref="T:ICU4N.Support.Text.CharArrayCharSequence"/>
            so a <see cref="T:char[]"/> can be used as <see cref="T:ICU4N.Support.Text.ICharSequence"/> in .NET.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.Text.ChoiceFormat.#ctor(System.Double[],System.String[])" -->
        <member name="M:ICU4N.Support.Text.ChoiceFormat.#ctor(System.String)">
            Constructs a new {@code ChoiceFormat} with the strings and limits parsed
            from the specified pattern.
            
            @param template
                       the pattern of strings and ranges.
            @throws IllegalArgumentException
                       if an error occurs while parsing the pattern.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.ApplyPattern(System.String)">
            Parses the pattern to determine new strings and ranges for this
            {@code ChoiceFormat}.
            
            @param template
                       the pattern of strings and ranges.
            @throws IllegalArgumentException
                       if an error occurs while parsing the pattern.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.Clone">
            Returns a new instance of {@code ChoiceFormat} with the same ranges and
            strings as this {@code ChoiceFormat}.
            
            @return a shallow copy of this {@code ChoiceFormat}.
            
            @see java.lang.Cloneable
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.Equals(System.Object)">
            Compares the specified object with this {@code ChoiceFormat}. The object
            must be an instance of {@code ChoiceFormat} and have the same limits and
            formats to be equal to this instance.
            
            @param object
                       the object to compare with this instance.
            @return {@code true} if the specified object is equal to this instance;
                    {@code false} otherwise.
            @see #hashCode
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.Format(System.Double,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            Appends the string associated with the range in which the specified
            double value fits to the specified string buffer.
            
            @param value
                       the double to format.
            @param buffer
                       the target string buffer to append the formatted value to.
            @param field
                       a {@code FieldPosition} which is ignored.
            @return the string buffer.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.Format(System.Int64,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            Appends the string associated with the range in which the specified long
            value fits to the specified string buffer.
            
            @param value
                       the long to format.
            @param buffer
                       the target string buffer to append the formatted value to.
            @param field
                       a {@code FieldPosition} which is ignored.
            @return the string buffer.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.GetFormats">
            Returns the strings associated with the ranges of this {@code
            ChoiceFormat}.
            
            @return an array of format strings.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.GetLimits">
            Returns the limits of this {@code ChoiceFormat}.
            
            @return the array of doubles which make up the limits of this {@code
                    ChoiceFormat}.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.GetHashCode">
            Returns an integer hash code for the receiver. Objects which are equal
            return the same value for this method.
            
            @return the receiver's hash.
            
            @see #equals
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.NextDouble(System.Double)">
            Returns the double value which is closest to the specified double but
            larger.
            
            @param value
                       a double value.
            @return the next larger double value.
        </member>
        <member name="M:ICU4N.Support.Text.ChoiceFormat.NextDouble(System.Double,System.Boolean)">
            Returns the double value which is closest to the specified double but
            either larger or smaller as specified.
            
            @param value
                       a double value.
            @param increment
                       {@code true} to get the next larger value, {@code false} to
                       get the previous smaller value.
            @return the next larger or smaller double value.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.Text.ChoiceFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)" -->
        <member name="M:ICU4N.Support.Text.ChoiceFormat.PreviousDouble(System.Double)">
            Returns the double value which is closest to the specified double but
            smaller.
            
            @param value
                       a double value.
            @return the next smaller double value.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.Text.ChoiceFormat.SetChoices(System.Double[],System.String[])" -->
        <member name="M:ICU4N.Support.Text.ChoiceFormat.ToPattern">
            Returns the pattern of this {@code ChoiceFormat} which specifies the
            ranges and their associated strings.
            
            @return the pattern.
        </member>
        <member name="T:ICU4N.Support.Text.FieldPosition">
            <summary>
            Identifies fields in formatted strings. If a <see cref="T:ICU4N.Support.Text.FieldPosition"/> is passed
            to the format method with such a parameter, then the indices will be set to
            the start and end indices of the field in the formatted string.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Support.Text.FieldPosition"/> can be created by using the integer constants in the
            various format classes (for example <c>NumberFormat.IntegerField</c>) or
            one of the fields of type
            </remarks>
        </member>
        <member name="M:ICU4N.Support.Text.FieldPosition.#ctor(System.Int32)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Support.Text.FieldPosition"/> for the specified field.
            </summary>
            <param name="field">The field to identify.</param>
        </member>
        <member name="M:ICU4N.Support.Text.FieldPosition.#ctor(ICU4N.Support.Text.FormatField)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Support.Text.FieldPosition"/> for the specified <see cref="T:ICU4N.Support.Text.FormatField"/>
            <paramref name="attribute"/>.
            </summary>
            <param name="attribute">the field attribute to identify.</param>
        </member>
        <member name="M:ICU4N.Support.Text.FieldPosition.#ctor(ICU4N.Support.Text.FormatField,System.Int32)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Support.Text.FieldPosition"/> for the specified <see cref="T:ICU4N.Support.Text.FormatField"/>
            <paramref name="attribute"/> and <paramref name="field"/> id.
            </summary>
            <param name="attribute">the field attribute to identify.</param>
            <param name="field">the field to identify.</param>
        </member>
        <member name="M:ICU4N.Support.Text.FieldPosition.Equals(System.Object)">
            <summary>
            Compares the specified object to this field position and indicates if
            they are equal. In order to be equal, <paramref name="obj"/> must be an instance
            of <see cref="T:ICU4N.Support.Text.FieldPosition"/> with the same field, begin index and end index.
            </summary>
            <param name="obj">the object to compare with this object.</param>
            <returns><c>true</c> if the specified object is equal to this field
            position; <c>false</c> otherwise.</returns>
            <seealso cref="M:ICU4N.Support.Text.FieldPosition.GetHashCode"/>
        </member>
        <member name="P:ICU4N.Support.Text.FieldPosition.BeginIndex">
            <summary>
            Gets or sets the index of the beginning of the field.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.FieldPosition.EndIndex">
            <summary>
            Gets or sets the index one past the end of the field.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.FieldPosition.Field">
            <summary>
            Gets the field which is being identified.
            </summary>
        </member>
        <member name="P:ICU4N.Support.Text.FieldPosition.FieldAttribute">
            <summary>
            Gets the attribute which is being identified.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.FieldPosition.ToString">
            <summary>
            Returns the string representation of this field position.
            </summary>
            <returns>the string representation of this field position.</returns>
        </member>
        <member name="T:ICU4N.Support.Text.Formatter">
            <summary>
            The base class for all formats. This class resembles the Format
            class in Java, but was renamed Formatter because we want the main
            methods to be named Format and there was a collision.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.#ctor">
            <summary>
            Constructs a new <see cref="T:ICU4N.Support.Text.Formatter"/> instance.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.Clone">
            <summary>
            Returns a copy of this <see cref="T:ICU4N.Support.Text.Formatter"/> instance.
            </summary>
            <returns>A shallow copy of this format.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.Format(System.Object)">
            <summary>
            Formats the specified object using the rules of this format.
            </summary>
            <param name="obj">The object to format.</param>
            <returns>the formatted string.</returns>
            <exception cref="T:System.ArgumentException">If the object cannot be formatted by this format.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.Format(System.Object,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Appends the specified object to the specified string buffer using the
            rules of this format.
            <para/>
            <paramref name="field"/> is an input/output parameter. If its <paramref name="field"/>
            member contains an enum value specifying a field on input, then its
            <c>BeginIndex</c> and <c>EndIndex</c> members will be updated with the
            text offset of the first occurrence of this field in the formatted text.
            </summary>
            <param name="obj">the object to format.</param>
            <param name="buffer">the string buffer where the formatted string is appended to.</param>
            <param name="field">on input: an optional alignment field; on output: the offsets
            of the alignment field in the formatted text.</param>
            <returns>The <see cref="T:System.Text.StringBuilder"/>.</returns>
            <exception cref="T:System.ArgumentException">If the object cannot be formatted by this format.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.FormatToCharacterIterator(System.Object)">
            <summary>
            Formats the specified object using the rules of this format and returns
            an <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> with the formatted string and no
            attributes.
            <para/>
            Subclasses should return an <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> with the
            appropriate attributes.
            </summary>
            <param name="obj">The object to format.</param>
            <returns>An <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> with the formatted object
            and attributes.</returns>
            <exception cref="T:System.ArgumentException">if the object cannot be formatted by this format.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.ParseObject(System.String)">
            <summary>
            Parses the specified string using the rules of this format.
            </summary>
            <param name="str">The string to parse.</param>
            <returns>The object resulting from the parse.</returns>
            <exception cref="T:System.FormatException">If an error occurs during parsing.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            Parses the specified string starting at the index specified by
            <paramref name="position"/>. If the <paramref name="str"/> is successfully parsed then the index of
            the <see cref="T:ICU4N.Support.Text.ParsePosition"/> is updated to the index following the parsed
            text. On error, the index is unchanged and the error index of
            <see cref="T:ICU4N.Support.Text.ParsePosition"/> is set to the index where the error occurred.
            </summary>
            <param name="str">the string to parse.</param>
            <param name="position">input/output parameter, specifies the start index in
            <paramref name="str"/> from where to start parsing. If parsing is
            successful, it is updated with the index following the parsed
            text; on error, the index is unchanged and the error index is
            set to the index where the error occurred.</param>
            <returns>The object resulting from the parse or <c>null</c> if there is
            an error.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.Formatter.UpTo(System.String,ICU4N.Support.Text.ParsePosition,System.Text.StringBuilder,System.Char)">
            *
        </member>
        <member name="T:ICU4N.Support.Text.FormatField">
            <summary>
            Class used to represet <see cref="T:ICU4N.Support.Text.Formatter"/> attributes in the
            <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that the
            <see cref="M:ICU4N.Support.Text.Formatter.FormatToCharacterIterator(System.Object)"/> method returns
            in subclasses.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.FormatField.#ctor(System.String)">
            <summary>
            Constructs a new instance of <see cref="T:ICU4N.Support.Text.FormatField"/> with the given field name.
            </summary>
            <param name="fieldName">the field name</param>
        </member>
        <member name="T:ICU4N.Support.Text.ParsePosition">
            <summary>
            Tracks the current position in a parsed string. In case of an error the error
            index can be set to the position where the error occurred without having to
            change the parse position.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.ParsePosition.#ctor(System.Int32)">
            Constructs a new {@code ParsePosition} with the specified index.
            
            @param index
                       the index to begin parsing.
        </member>
        <member name="M:ICU4N.Support.Text.ParsePosition.Equals(System.Object)">
            Compares the specified object to this {@code ParsePosition} and indicates
            if they are equal. In order to be equal, {@code object} must be an
            instance of {@code ParsePosition} and it must have the same index and
            error index.
            
            @param object
                       the object to compare with this object.
            @return {@code true} if the specified object is equal to this
                    {@code ParsePosition}; {@code false} otherwise.
            @see #hashCode
        </member>
        <member name="P:ICU4N.Support.Text.ParsePosition.ErrorIndex">
            Returns the index at which the parse could not continue.
            
            @return the index of the parse error or -1 if there is no error.
        </member>
        <member name="P:ICU4N.Support.Text.ParsePosition.Index">
            Returns the current parse position.
            
            @return the current position.
        </member>
        <member name="M:ICU4N.Support.Text.ParsePosition.ToString">
            Returns the string representation of this parse position.
            
            @return the string representation of this parse position.
        </member>
        <member name="T:ICU4N.Support.Text.SimpleStringInterner">
            <summary> Simple lockless and memory barrier free String intern cache that is guaranteed
            to return the same String instance as String.intern() does.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.SimpleStringInterner.#ctor(System.Int32,System.Int32)">
            <param name="tableSize"> Size of the hash table, should be a power of two.
            </param>
            <param name="maxChainLength"> Maximum length of each bucket, after which the oldest item inserted is dropped.
            </param>
        </member>
        <member name="M:ICU4N.Support.Text.SimpleStringInterner.NextHighestPowerOfTwo(System.Int32)">
            <summary>
            Returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Reverse(System.Text.StringBuilder)">
            <summary>
            Causes this character sequence to be replaced by the reverse of
            the sequence. If there are any surrogate pairs included in the
            sequence, these are treated as single characters for the
            reverse operation. Thus, the order of the high-low surrogates
            is never reversed.
            <para/>
            Let <c>n</c> be the character length of this character sequence
            (not the length in <see cref="T:System.Char"/> values) just prior to
            execution of the <see cref="M:ICU4N.Support.Text.StringBuilderExtensions.Reverse(System.Text.StringBuilder)"/> method. Then the
            character at index <c>k</c> in the new character sequence is
            equal to the character at index <c>n-k-1</c> in the old
            character sequence.
            <para/>
            Note that the reverse operation may result in producing
            surrogate pairs that were unpaired low-surrogates and
            high-surrogates before the operation. For example, reversing
            "&#92;uDC00&#92;uD800" produces "&#92;uD800&#92;uDC00" which is
            a valid surrogate pair.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <returns>a reference to this <see cref="T:System.Text.StringBuilder"/>.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.CodePointCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the specified text
            range of this <see cref="T:System.Text.StringBuilder"/>. The text range begins at the specified
            <paramref name="beginIndex"/> and extends to the <see cref="T:System.Char"/> at
            index <c>endIndex - 1</c>. Thus the length (in
            <see cref="T:System.Char"/>s) of the text range is
            <c>endIndex-beginIndex</c>. Unpaired surrogates within
            this sequence count as one code point each.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <param name="beginIndex">the index to the first <see cref="T:System.Char"/> of the text range.</param>
            <param name="endIndex">the index after the last <see cref="T:System.Char"/> of the text range.</param>
            <returns>the number of Unicode code points in the specified text range.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/>
            is larger than the length of this sequence, or
            <paramref name="beginIndex"/> is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.CodePointAt(System.Text.StringBuilder,System.Int32)">
            <summary>
            Returns the character (Unicode code point) at the specified index. 
            The index refers to char values (Unicode code units) and ranges from 0 to Length - 1.
            <para/>
            If the char value specified at the given index is in the high-surrogate range, 
            the following index is less than the length of this sequence, and the char value 
            at the following index is in the low-surrogate range, then the 
            supplementary code point corresponding to this surrogate pair is returned. 
            Otherwise, the char value at the given index is returned.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <param name="index">the index to the char values</param>
            <returns>the code point value of the character at the index</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the index argument is negative or not less than the length of this sequence.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.GetChars(System.Text.StringBuilder)">
            <summary>
            Copies the array from the <see cref="T:System.Text.StringBuilder"/> into a new array
            and returns it.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.AppendCodePoint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Appends the string representation of the <paramref name="codePoint"/>
            argument to this sequence.
            
            <para>
            The argument is appended to the contents of this sequence.
            The length of this sequence increases by <see cref="M:ICU4N.Support.Text.Character.CharCount(System.Int32)"/>.
            </para>
            <para>
            The overall effect is exactly as if the argument were
            converted to a <see cref="T:System.Char"/> array by the method
            <see cref="M:ICU4N.Support.Text.Character.ToChars(System.Int32)"/> and the character in that array
            were then <see cref="M:System.Text.StringBuilder.Append(System.Char[])">appended</see> to this 
            <see cref="T:System.Text.StringBuilder"/>.
            </para>
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="codePoint">a Unicode code point</param>
            <returns>a reference to this object.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Insert(System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Inserts the string representation of the specified subsequence of the
            <see cref="T:System.Text.StringBuilder"/> at the specified <paramref name="index"/>.
            If the <see cref="T:System.Text.StringBuilder"/> is <c>null</c>, then the string "null"
            is used to determine the subsequence.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="index">The index to insert at.</param>
            <param name="value">The <see cref="T:System.Text.StringBuilder"/> to insert.</param>
            <param name="startIndex">The start of the subsequence of <paramref name="value"/>.</param>
            <param name="length">The number of characters to insert from <paramref name="value"/>.</param>
            <returns>This <see cref="T:System.Text.StringBuilder"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is negative or greater than the current length,
            or <paramref name="startIndex"/> and <paramref name="length"/> do not specify a valid subsequence.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.IndexOf(System.Text.StringBuilder,System.String)">
            <summary>
            Searches for the first index of the specified character. The search for
            the character starts at the beginning and moves towards the end.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">The string to find.</param>
            <returns>The index of the specified character, or -1 if the character isn't found.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.IndexOf(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Searches for the index of the specified character. The search for the
            character starts at the specified offset and moves towards the end.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">The string to find.</param>
            <param name="startIndex">The starting offset.</param>
            <returns>The index of the specified character, or -1 if the character isn't found.</returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.LastIndexOf(System.Text.StringBuilder,System.String)">
            <summary>
            Searches for the last index of the specified character. The search for
            the character starts at the end and moves towards the beginning.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">The string to find.</param>
            <returns>The index of the specified character, -1 if the character isn't found.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.LastIndexOf(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Searches for the index of the specified character. The search for the
            character starts at the specified offset and moves towards the beginning.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">The string to find.</param>
            <param name="start">The starting offset.</param>
            <returns>The index of the specified character, -1 if the character isn't found.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.ToCharSequence(System.Text.StringBuilder)">
            <summary>
            Convenience method to wrap a string in a <see cref="T:ICU4N.Support.Text.StringBuilderCharSequence"/>
            so a <see cref="T:System.Text.StringBuilder"/> can be used as <see cref="T:ICU4N.Support.Text.ICharSequence"/> in .NET.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Append(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Appends the give <see cref="T:ICU4N.Support.Text.ICharSequence"/> to this <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Append(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Appends the given <see cref="T:ICU4N.Support.Text.ICharSequence"/> to this <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Append(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Appends the given <see cref="T:System.Text.StringBuilder"/> to this <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Append(System.Text.StringBuilder,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Appends the given <see cref="T:System.Text.StringBuilder"/> to this <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.Replace(System.Text.StringBuilder,System.Int32,System.Int32,System.String)">
            <summary>
            Replaces the specified subsequence in this builder with the specified
            string.
            </summary>
            <param name="text">this builder.</param>
            <param name="start">the inclusive begin index.</param>
            <param name="end">the exclusive end index.</param>
            <param name="str">the replacement string.</param>
            <returns>this builder.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if <paramref name="start"/> is negative, greater than the current
            <see cref="P:System.Text.StringBuilder.Length"/> or greater than <paramref name="end"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="str"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.OffsetByCodePoints(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Returns the index that is offset <paramref name="codePointOffset"/> code points from
            <paramref name="index"/>.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="index">The index to calculate the offset from.</param>
            <param name="codePointOffset">The number of code points to count.</param>
            <returns>The index that is <paramref name="codePointOffset"/> code points away from <paramref name="index"/>.</returns>
            <seealso cref="T:ICU4N.Support.Text.Character"/>
            <seealso cref="M:ICU4N.Support.Text.Character.OffsetByCodePoints(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.CodePointBefore(System.Text.StringBuilder,System.Int32)">
            <summary>
            Retrieves the Unicode code point value that precedes the <paramref name="index"/>.
            </summary>
            <param name="text"></param>
            <param name="index">The index to the <see cref="T:System.Char"/> code unit within this object.</param>
            <returns>The Unicode code point value.</returns>
            <seealso cref="T:ICU4N.Support.Text.Character"/>
            <seealso cref="M:ICU4N.Support.Text.Character.CodePointBefore(System.Char[],System.Int32)"/>
        </member>
        <member name="M:ICU4N.Support.Text.StringBuilderExtensions.ToAppendable(System.Text.StringBuilder)">
            <summary>
            Convenience method to wrap a <see cref="T:System.Text.StringBuilder"/> in an
            <see cref="T:ICU4N.Support.Text.StringBuilderAppendable"/> adapter class so it can be
            used with the <see cref="T:ICU4N.Support.Text.IAppendable"/> interface.
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <returns>An <see cref="T:ICU4N.Support.Text.StringBuilderAppendable"/>.</returns>
        </member>
        <member name="T:ICU4N.Support.Text.StringCharacterIterator">
            <summary>
            An implementation of <see cref="T:ICU4N.Support.Text.CharacterIterator"/> for strings.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.#ctor(System.String)">
            Constructs a new {@code StringCharacterIterator} on the specified string.
            The begin and current indices are set to the beginning of the string, the
            end index is set to the length of the string.
            
            @param value
                       the source string to iterate over.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.#ctor(System.String,System.Int32)">
            Constructs a new {@code StringCharacterIterator} on the specified string
            with the current index set to the specified value. The begin index is set
            to the beginning of the string, the end index is set to the length of the
            string.
            
            @param value
                       the source string to iterate over.
            @param location
                       the current index.
            @throws IllegalArgumentException
                       if {@code location} is negative or greater than the length
                       of the source string.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.Text.StringCharacterIterator.#ctor(System.String,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.Clone">
            Returns a new {@code StringCharacterIterator} with the same source
            string, begin, end, and current index as this iterator.
            
            @return a shallow copy of this iterator.
            @see java.lang.Cloneable
        </member>
        <member name="P:ICU4N.Support.Text.StringCharacterIterator.Current">
            Returns the character at the current index in the source string.
            
            @return the current character, or {@code DONE} if the current index is
                    past the end.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.Equals(System.Object)">
            Compares the specified object with this {@code StringCharacterIterator}
            and indicates if they are equal. In order to be equal, {@code object}
            must be an instance of {@code StringCharacterIterator} that iterates over
            the same sequence of characters with the same index.
            
            @param object
                       the object to compare with this object.
            @return {@code true} if the specified object is equal to this
                    {@code StringCharacterIterator}; {@code false} otherwise.
            @see #hashCode
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.First">
            Sets the current position to the begin index and returns the character at
            the new position in the source string.
            
            @return the character at the begin index or {@code DONE} if the begin
                    index is equal to the end index.
        </member>
        <member name="P:ICU4N.Support.Text.StringCharacterIterator.BeginIndex">
            Returns the begin index in the source string.
            
            @return the index of the first character of the iteration.
        </member>
        <member name="P:ICU4N.Support.Text.StringCharacterIterator.EndIndex">
            Returns the end index in the source string.
            
            @return the index one past the last character of the iteration.
        </member>
        <member name="P:ICU4N.Support.Text.StringCharacterIterator.Index">
            Returns the current index in the source string.
            
            @return the current index.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.Last">
            Sets the current position to the end index - 1 and returns the character
            at the new position.
            
            @return the character before the end index or {@code DONE} if the begin
                    index is equal to the end index.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.Next">
             Increments the current index and returns the character at the new index.
            
             @return the character at the next index, or {@code DONE} if the next
                     index would be past the end.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.Previous">
            Decrements the current index and returns the character at the new index.
            
            @return the character at the previous index, or {@code DONE} if the
                    previous index would be past the beginning.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.SetIndex(System.Int32)">
            Sets the current index in the source string.
            
            @param location
                       the index the current position is set to.
            @return the character at the new index, or {@code DONE} if
                    {@code location} is set to the end index.
            @throws IllegalArgumentException
                       if {@code location} is smaller than the begin index or greater
                       than the end index.
        </member>
        <member name="M:ICU4N.Support.Text.StringCharacterIterator.SetText(System.String)">
            Sets the source string to iterate over. The begin and end positions are
            set to the start and end of this string.
            
            @param value
                       the new source string.
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.ToCharSequence(System.String)">
            <summary>
            Convenience method to wrap a string in a <see cref="T:ICU4N.Support.Text.StringCharSequence"/>
            so a <see cref="T:System.String"/> can be used as <see cref="T:ICU4N.Support.Text.ICharSequence"/> in .NET.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.CompareToOrdinal(System.String,System.String)">
            <summary>
            This method mimics the Java String.compareTo(String) method in that it
            <list type="number">
            <item><description>Compares the strings using lexographic sorting rules</description></item>
            <item><description>Performs a culture-insensitive comparison</description></item>
            </list>
            This method is a convenience to replace the .NET CompareTo method 
            on all strings, provided the logic does not expect specific values
            but is simply comparing them with <c>&gt;</c> or <c>&lt;</c>.
            </summary>
            <param name="str"></param>
            <param name="value">The string to compare with.</param>
            <returns>
            An integer that indicates the lexical relationship between the two comparands.
            Less than zero indicates the comparison value is greater than the current string.
            Zero indicates the strings are equal.
            Greater than zero indicates the comparison value is less than the current string.
            </returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.CodePointCount(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the specified text
            range of this <see cref="T:System.String"/>. The text range begins at the
            specified <paramref name="beginIndex"/> and extends to the
            <see cref="T:System.Char"/> at index <c>endIndex - 1</c>. Thus the
            length (in <see cref="T:System.Char"/>s) of the text range is
            <c>endIndex-beginIndex</c>. Unpaired surrogates within
            the text range count as one code point each.
            </summary>
            <param name="str"></param>
            <param name="beginIndex">the index to the first <see cref="T:System.Char"/> of the text range.</param>
            <param name="endIndex">the index after the last <see cref="T:System.Char"/> of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the <paramref name="beginIndex"/> is negative, or
            <paramref name="endIndex"/> is larger than the length of this <see cref="T:System.String"/>, or
            <paramref name="beginIndex"/> is larger than <paramref name="endIndex"/>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.IndexOf(System.String,System.Int32)">
            <summary>
            Returns the index within this string of the first occurrence of
            the specified character. If a character with value
            <paramref name="ch"/> occurs in the character sequence represented by
            this <see cref="T:System.String"/> object, then the index (in Unicode
            code units) of the first such occurrence is returned. For
            values of <paramref name="ch"/> in the range from 0 to 0xFFFF
            (inclusive), this is the smallest value <i>k</i> such that:
            <code>
                this[(<i>k</i>] == ch
            </code>
            is true. For other values of <paramref name="ch"/>, it is the
            smallest value <i>k</i> such that:
            <code>
                this.CodePointAt(<i>k</i>) == ch
            </code>
            is true. In either case, if no such character occurs in this
            string, then <c>-1</c> is returned.
            </summary>
            <param name="text">This <see cref="T:System.String"/>.</param>
            <param name="ch">A character (Unicode code point).</param>
            <returns>The index of the first occurrence of the character in the
            character sequence represented by this object, or
            <c>-1</c> if the character does not occur.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Support.Text.StringExtensions.IndexOf(System.String,System.Int32,System.Int32)" -->
        <member name="M:ICU4N.Support.Text.StringExtensions.IndexOfSupplementary(System.String,System.Int32,System.Int32)">
            <summary>
            Handles (rare) calls of indexOf with a supplementary character.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.RegionMatches(System.String,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares the specified string to this string and compares the specified
            range of characters to determine if they are the same.
            </summary>
            <param name="seq">This string.</param>
            <param name="thisStart">the starting offset in this string.</param>
            <param name="str">the string to compare.</param>
            <param name="start">the starting offset in the specified string.</param>
            <param name="length">the number of characters to compare.</param>
            <returns><c>true</c> if the ranges of characters are equal, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="str"/> is <c>null</c></exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.RegionMatches(System.String,System.Boolean,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares the specified string to this string and compares the specified
            range of characters to determine if they are the same. When ignoreCase is
            true, the case of the characters is ignored during the comparison.
            </summary>
            <param name="seq">This string.</param>
            <param name="ignoreCase">Specifies if case should be ignored.</param>
            <param name="thisStart">The starting offset in this string.</param>
            <param name="str">The string to compare.</param>
            <param name="start">The starting offset in the specified string.</param>
            <param name="length">The number of characters to compare.</param>
            <returns><c>true</c> if the ranges of characters are equal, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="str"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.RegionMatches(System.String,System.Globalization.CultureInfo,System.Boolean,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares the specified string to this string and compares the specified
            range of characters to determine if they are the same. When ignoreCase is
            true, the case of the characters is ignored during the comparison.
            </summary>
            <param name="seq">This string.</param>
            <param name="culture">The culture to use when correcting case for comparison (only applies if <paramref name="ignoreCase"/> is true).</param>
            <param name="ignoreCase">Specifies if case should be ignored.</param>
            <param name="thisStart">The starting offset in this string.</param>
            <param name="str">The string to compare.</param>
            <param name="start">The starting offset in the specified string.</param>
            <param name="length">The number of characters to compare.</param>
            <returns><c>true</c> if the ranges of characters are equal, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="str"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.StartsWith(System.String,System.String,System.Int32)">
            <summary>
            Compares the specified string to this string, starting at the specified
            offset, to determine if the specified string is a prefix.
            </summary>
            <param name="text">This string.</param>
            <param name="prefix">the string to look for.</param>
            <param name="start">the starting offset.</param>
            <returns><c>true</c> if the specified string occurs in this string at the specified offset, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="prefix"/> is <c>null</c>.</exception>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.ContentEquals(System.String,System.String)">
            <summary>
            Compares a <see cref="T:System.String"/> to this <see cref="T:System.String"/> to determine if
            their contents are equal.
            </summary>
            <param name="text">This <see cref="T:System.String"/>.</param>
            <param name="cs">The character sequence to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.ContentEquals(System.String,System.Text.StringBuilder)">
            <summary>
            Compares a <see cref="T:System.Text.StringBuilder"/> to this <see cref="T:System.String"/> to determine if
            their contents are equal.
            </summary>
            <param name="text">This <see cref="T:System.String"/>.</param>
            <param name="cs">The character sequence to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.ContentEquals(System.String,System.Char[])">
            <summary>
            Compares a <see cref="T:char[]"/> to this <see cref="T:System.String"/> to determine if
            their contents are equal.
            </summary>
            <param name="text">This <see cref="T:System.String"/>.</param>
            <param name="cs">The character sequence to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.ContentEquals(System.String,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares a <see cref="T:ICU4N.Support.Text.ICharSequence"/> to this <see cref="T:System.String"/> to determine if
            their contents are equal.
            </summary>
            <param name="text">This <see cref="T:System.String"/>.</param>
            <param name="cs">The character sequence to compare to.</param>
            <returns></returns>
        </member>
        <member name="F:ICU4N.Support.Text.StringExtensions.interner">
            <summary> Expert:
            A string interner cache.
            This shouldn't be changed to an incompatible implementation after other APIs have been used.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringExtensions.Intern(System.String)">
            <summary>
            Searches an internal table of strings for a string equal to this string.
            If the string is not in the table, it is added. Returns the string
            contained in the table which is equal to this string. The same string
            object is always returned for strings which are equal.
            </summary>
            <returns>The interned string equal to this string.</returns>
        </member>
        <member name="T:ICU4N.Support.Text.StringInterner">
            <summary> Subclasses of StringInterner are required to
            return the same single String object for all equal strings.
            Depending on the implementation, this may not be
            the same object returned as String.intern().
            
            This StringInterner base class simply delegates to String.Intern().
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringInterner.Intern(System.String)">
            <summary>Returns a single object instance for each equal string. </summary>
        </member>
        <member name="M:ICU4N.Support.Text.StringInterner.Intern(System.Char[],System.Int32,System.Int32)">
            <summary>Returns a single object instance for each equal string. </summary>
        </member>
        <member name="T:ICU4N.Support.Text.UnicodeSetExtensions">
            <summary>
            ICU4J compatible method names, in case you don't like the rewiring of ICU4N.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Char[]})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="set">This set.</param>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="set">This set.</param>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Int32,System.Int32)">
            <summary>
            Adds all characters in range (uses preferred naming convention).
            </summary>
            <param name="set">This set.</param>
            <param name="start">The index of where to start on adding all characters.</param>
            <param name="end">The index of where to end on adding all characters.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.AddAllTo``1(ICU4N.Text.UnicodeSet,``0)">
            <summary>
            Add the contents of the UnicodeSet (as strings) into a collection.
            </summary>
            <typeparam name="T">Collection type.</typeparam>
            <param name="set">This set.</param>
            <param name="target">Collection to add into.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,System.Int32,System.Int32)">
            <summary>
            Complements the specified range in this set.  Any character in
            the range will be removed if it is in this set, or will be
            added if it is not in this set.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c>
            then an empty range is complemented, leaving the set unchanged.
            </summary>
            <param name="set">This set.</param>
            <param name="start">First character, inclusive, of range to be removed from this set.</param>
            <param name="end">Last character, inclusive, of range to be removed from this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,System.Int32)">
            <summary>
            Complements the specified character in this set.  The character
            will be removed if it is in this set, or will be added if it is
            not in this set.
            </summary>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.ComplementAll(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet)">
            <summary>
            Complements in this set all elements contained in the specified
            set.  Any character in the other set will be removed if it is
            in this set, or will be added if it is not in this set.
            </summary>
            <param name="set">This set.</param>
            <param name="c">Set that defines which elements will be complemented from
            this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains all the characters and strings
            of the given set.
            </summary>
            <param name="set">This set.</param>
            <param name="b">Set to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Returns true if there is a partition of the string such that this set contains each of the partitioned strings.
            For example, for the Unicode set [a{bc}{cd}]
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.String)"/> is true for each of: "a", "bc", ""cdbca"</description></item>
                <item><description><see cref="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.String)"/> is false for each of: "acb", "bcda", "bcx"</description></item>
            </list>
            </summary>
            <param name="set">This set.</param>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Int32,System.Int32)">
            <summary>
            Returns true if this set contains one or more of the characters
            in the given range.
            </summary>
            <param name="set">This set.</param>
            <param name="start">First character, inclusive, of the range.</param>
            <param name="end">Last character, inclusive, of the range.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains one or more of the characters
            and strings of the given set.
            </summary>
            <param name="set">This set.</param>
            <param name="s">Set to be checked for containment.</param>
            <returns>True if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet)">
            <summary>
            Removes from this set all of its elements that are contained in the
            specified set.  This operation effectively modifies this
            set so that its value is the <i>asymmetric set difference</i> of
            the two sets.
            </summary>
            <param name="set">This set.</param>
            <param name="c">Set that defines which elements will be removed from
            this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.RemoveAllStrings(ICU4N.Text.UnicodeSet)">
            <summary>
            Remove all strings from this <see cref="T:ICU4N.Text.UnicodeSet"/>
            </summary>
            <param name="set">This set.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,System.Int32,System.Int32)">
            <summary>
            Retain only the elements in this set that are contained in the
            specified range.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c> 
            then an empty range is retained, leaving the set empty.
            </summary>
            <param name="set">This set.</param>
            <param name="start">First character, inclusive, of range to be retained
            to this set.</param>
            <param name="end">Last character, inclusive, of range to be retained
            to this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,System.Int32)">
            <summary>
            Retain the specified character from this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="c"/>, or
            will only contain c if it did contain <paramref name="c"/>.
            </summary>
            <param name="set">This set.</param>
            <param name="c">The character to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Support.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet)">
            <summary>
            Retains only the elements in this set that are contained in the
            specified set.  In other words, removes from this set all of
            its elements that are not contained in the specified set.  This
            operation effectively modifies this set so that its value is
            the <i>intersection</i> of the two sets.
            </summary>
            <param name="set">This set.</param>
            <param name="c">Set that defines which elements this set will retain.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="T:ICU4N.Support.Threading.ThreadWrapper">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:ICU4N.Support.Threading.ThreadWrapper._threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="name">The name of the thread</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="name">The name of the thread</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="P:ICU4N.Support.Threading.ThreadWrapper.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:ICU4N.Support.Threading.ThreadWrapper.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:ICU4N.Support.Threading.ThreadWrapper.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:ICU4N.Support.Threading.ThreadWrapper.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:ICU4N.Support.Threading.ThreadWrapper.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="milliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="milliSeconds">Time of wait in milliseconds</param>
            <param name="nanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread. Calling this method
            usually terminates the thread
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread while also providing
            exception information about the thread termination.
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.ToString">
            <summary>
            Obtain a String that represents the current object
            </summary>
            <returns>A String that represents the current object</returns>
        </member>
        <member name="M:ICU4N.Support.Threading.ThreadWrapper.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="M:ICU4N.Support.TypeExtensions.FindAndGetManifestResourceStream(System.Type,System.String)">
            <summary>
            Aggressively searches for a resource and, if found, returns an open <see cref="T:System.IO.Stream"/>
            where it can be read.
            </summary>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>an open <see cref="T:System.IO.Stream"/> that can be used to read the resource, or <c>null</c> if the resource cannot be found.</returns>
        </member>
        <member name="M:ICU4N.Support.TypeExtensions.FindResource(System.Type,System.String)">
            <summary>
            Aggressively searches to find a resource based on a <see cref="T:System.Type"/> and resource name.
            </summary>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>the resource, if found; if not found, returns <c>null</c></returns>
        </member>
        <member name="T:ICU4N.Logging.ILog">
            <summary>
            Simple interface that represent a logger.
            </summary>
        </member>
        <member name="M:ICU4N.Logging.ILog.Log(ICU4N.Logging.LogLevel,System.Func{System.String},System.Exception,System.Object[])">
            <summary>
            Log a message the specified log level.
            </summary>
            <param name="logLevel">The log level.</param>
            <param name="messageFunc">The message function.</param>
            <param name="exception">An optional exception.</param>
            <param name="formatParameters">Optional format parameters for the message generated by the messagefunc. </param>
            <returns>true if the message was logged. Otherwise false.</returns>
            <remarks>
            Note to implementers: the message func should not be called if the loglevel is not enabled
            so as not to incur performance penalties.
            
            To check IsEnabled call Log with only LogLevel and check the return value, no event will be written.
            </remarks>
        </member>
        <member name="T:ICU4N.Logging.LogLevel">
            <summary>
            The log level.
            </summary>
        </member>
        <member name="T:ICU4N.Logging.ILogProvider">
            <summary>
            Represents a way to get a <see cref="T:ICU4N.Logging.ILog"/>
            </summary>
        </member>
        <member name="M:ICU4N.Logging.ILogProvider.GetLogger(System.String)">
            <summary>
            Gets the specified named logger.
            </summary>
            <param name="name">Name of the logger.</param>
            <returns>The logger reference.</returns>
        </member>
        <member name="M:ICU4N.Logging.ILogProvider.OpenNestedContext(System.String)">
            <summary>
            Opens a nested diagnostics context. Not supported in EntLib logging.
            </summary>
            <param name="message">The message to add to the diagnostics context.</param>
            <returns>A disposable that when disposed removes the message from the context.</returns>
        </member>
        <member name="M:ICU4N.Logging.ILogProvider.OpenMappedContext(System.String,System.Object,System.Boolean)">
            <summary>
            Opens a mapped diagnostics context. Not supported in EntLib logging.
            </summary>
            <param name="key">A key.</param>
            <param name="value">A value.</param>
            <returns>A disposable that when disposed removes the map from the context.</returns>
        </member>
        <member name="T:ICU4N.Logging.LogProvider">
            <summary>
            Provides a mechanism to create instances of <see cref="T:ICU4N.Logging.ILog" /> objects.
            </summary>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.SetCurrentLogProvider(ICU4N.Logging.ILogProvider)">
            <summary>
            Sets the current log provider.
            </summary>
            <param name="logProvider">The log provider.</param>
        </member>
        <member name="P:ICU4N.Logging.LogProvider.IsDisabled">
            <summary>
            Gets or sets a value indicating whether this is logging is disabled.
            </summary>
            <value>
            <c>true</c> if logging is disabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICU4N.Logging.LogProvider.OnCurrentLogProviderSet">
            <summary>
            Sets an action that is invoked when a consumer of your library has called SetCurrentLogProvider. It is 
            important that hook into this if you are using child libraries (especially ilmerged ones) that are using
            LibLog (or other logging abstraction) so you adapt and delegate to them.
            <see cref="M:ICU4N.Logging.LogProvider.SetCurrentLogProvider(ICU4N.Logging.ILogProvider)"/> 
            </summary>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.For``1">
            <summary>
            Gets a logger for the specified type.
            </summary>
            <typeparam name="T">The type whose name will be used for the logger.</typeparam>
            <returns>An instance of <see cref="T:ICU4N.Logging.ILog"/></returns>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.GetCurrentClassLogger">
            <summary>
            Gets a logger for the current class.
            </summary>
            <returns>An instance of <see cref="T:ICU4N.Logging.ILog"/></returns>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.GetLogger(System.Type,System.String)">
            <summary>
            Gets a logger for the specified type.
            </summary>
            <param name="type">The type whose name will be used for the logger.</param>
            <param name="fallbackTypeName">If the type is null then this name will be used as the log name instead</param>
            <returns>An instance of <see cref="T:ICU4N.Logging.ILog"/></returns>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.GetLogger(System.String)">
            <summary>
            Gets a logger with the specified name.
            </summary>
            <param name="name">The name.</param>
            <returns>An instance of <see cref="T:ICU4N.Logging.ILog"/></returns>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.OpenNestedContext(System.String)">
            <summary>
            Opens a nested diagnostics context.
            </summary>
            <param name="message">A message.</param>
            <returns>An <see cref="T:System.IDisposable"/> that closes context when disposed.</returns>
        </member>
        <member name="M:ICU4N.Logging.LogProvider.OpenMappedContext(System.String,System.Object,System.Boolean)">
            <summary>
            Opens a mapped diagnostics context.
            </summary>
            <param name="key">A key.</param>
            <param name="value">A value.</param>
            <returns>An <see cref="T:System.IDisposable"/> that closes context when disposed.</returns>
        </member>
        <member name="T:ICU4N.Logging.LogProviders.LoupeLogProvider.WriteDelegate">
            <summary>
            The form of the Loupe Log.Write method we're using
            </summary>
        </member>
        <member name="P:ICU4N.Logging.LogProviders.LoupeLogProvider.ProviderIsAvailableOverride">
            <summary>
            Gets or sets a value indicating whether [provider is available override]. Used in tests.
            </summary>
            <value>
            <c>true</c> if [provider is available override]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:ICU4N.Logging.LogProviders.LogMessageFormatter.SimulateStructuredLogging(System.Func{System.String},System.Object[])">
            <summary>
            Some logging frameworks support structured logging, such as serilog. This will allow you to add names to structured data in a format string:
            For example: Log("Log message to {user}", user). This only works with serilog, but as the user of LibLog, you don't know if serilog is actually 
            used. So, this class simulates that. it will replace any text in {curly braces} with an index number. 
            
            "Log {message} to {user}" would turn into => "Log {0} to {1}". Then the format parameters are handled using regular .net string.Format.
            </summary>
            <param name="messageBuilder">The message builder.</param>
            <param name="formatParameters">The format parameters.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.String[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Text.StringBuilder[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Char[][])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.AddAll(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="set">This set.</param>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="set">This set.</param>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="set">This set.</param>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Complement(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="set">This set.</param>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ComplementAll(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ComplementAll(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ComplementAll(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ComplementAll(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsAll``1(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="set">This set.</param>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="set">This set.</param>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="set">This set.</param>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="set">This set.</param>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.ContainsSome``1(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RemoveAll``1(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="set">This set.</param>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="set">This set.</param>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="set">This set.</param>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.Retain(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="set">This set.</param>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll``1(ICU4N.Text.UnicodeSet,System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.String)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.Text.StringBuilder)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,System.Char[])">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetExtensions.RetainAll(ICU4N.Text.UnicodeSet,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="set">This set.</param>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.UnicodeSet">
            <summary>
            A mutable set of Unicode characters and multicharacter strings.
            Objects of this class represent <em>character classes</em> used
            in regular expressions. A character specifies a subset of Unicode
            code points.  Legal code points are U+0000 to U+10FFFF, inclusive.
            </summary>
            <remarks>
            Note: method <see cref="M:ICU4N.Text.UnicodeSet.Freeze"/> will not only make the set immutable, but
            also makes important methods much higher performance:
            <see cref="M:ICU4N.Text.UnicodeSet.Contains(System.Int32)"/>, <see cref="M:ICU4N.Text.UnicodeSet.ContainsNone(System.String)"/>, 
            <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>,
            <see cref="M:ICU4N.Text.UnicodeSet.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)"/>, etc.
            After the object is frozen, any subsequent call that wants to change
            the object will throw <see cref="T:System.NotSupportedException"/>.
            <para/>
            The <see cref="T:ICU4N.Text.UnicodeSet"/> class is not designed to be subclassed.
            <para/>
            <see cref="T:ICU4N.Text.UnicodeSet"/> supports two APIs. The first is the
            <em>operand</em> API that allows the caller to modify the value of
            a <code>UnicodeSet</code> object. It conforms to .NET's <see cref="T:System.Collections.Generic.ISet`1"/>
            interface, although <see cref="T:ICU4N.Text.UnicodeSet"/> does not actually implement that
            interface. All methods of <see cref="T:System.Collections.Generic.ISet`1"/> are supported, with the
            modification that they take a character range or single character
            instead of a <see cref="T:System.String"/>, and they take a
            <see cref="T:ICU4N.Text.UnicodeSet"/> instead of a <see cref="T:System.Collections.Generic.ICollection`1"/>. The
            operand API may be thought of in terms of boolean logic: a boolean
            OR is implemented by <see cref="M:ICU4N.Text.UnicodeSet.Add(System.String)"/>, a boolean AND is implemented
            by <see cref="M:ICU4N.Text.UnicodeSet.Retain(System.String)"/>, a boolean XOR is implemented by
            <see cref="M:ICU4N.Text.UnicodeSet.Complement(System.String)"/> taking an argument, and a boolean NOT is
            implemented by <see cref="M:ICU4N.Text.UnicodeSet.Complement"/> with no argument.  In terms
            of traditional set theory function names, <see cref="M:ICU4N.Text.UnicodeSet.Add(System.String)"/> is a
            union, <see cref="M:ICU4N.Text.UnicodeSet.Retain(System.String)"/> is an intersection, <see cref="M:ICU4N.Text.UnicodeSet.Remove(System.String)"/>
            is an asymmetric difference, and <see cref="M:ICU4N.Text.UnicodeSet.Complement"/> with no
            argument is a set complement with respect to the superset range
            <c><see cref="F:ICU4N.Text.UnicodeSet.MinValue"/>-<see cref="F:ICU4N.Text.UnicodeSet.MaxValue"/></c>.
            <para/>
            The second API is the
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/>/<see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Text.StringBuilder,System.Boolean)"/> API from the
            <c>java.text.Format</c>-derived classes.  Unlike the
            methods that add characters, add categories, and control the logic
            of the set, the method <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/> sets all
            attributes of a <see cref="T:ICU4N.Text.UnicodeSet"/> at once, based on a
            string pattern.
            
            <para/>
            <b>Pattern syntax</b>
            
            <para/>
            Patterns are accepted by the constructors and the
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/> methods and returned by the
            <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Text.StringBuilder,System.Boolean)"/> method.  These patterns follow a syntax
            similar to that employed by .NET regular expression character
            classes.  Here are some simple examples:
            
            <list type="table">
                <item>
                    <term><c>[]</c></term>
                    <term>No characters</term>
                </item>
                <item>
                    <term><c>[a]</c></term>
                    <term>The character 'a'</term>
                </item>
                <item>
                    <term><c>[ae]</c></term>
                    <term>The characters 'a' and 'e'</term>
                </item>
                <item>
                    <term><c>[a-e]</c></term>
                    <term>The characters 'a' through 'e' inclusive, in Unicode code
                    point order</term>
                </item>
                <item>
                    <term><c>[\\u4E01]</c></term>
                    <term>The character U+4E01</term>
                </item>
                <item>
                    <term><c>[a{ab}{ac}]</c></term>
                    <term>The character 'a' and the multicharacter strings &quot;ab&quot; and
                    &quot;ac&quot;</term>
                </item>
                <item>
                    <term><c>[\p{Lu}]</c></term>
                    <term>All characters in the general category Uppercase Letter</term>
                </item>
            </list>
            
            <para/>
            Any character may be preceded by a backslash in order to remove any special
            meaning.  White space characters, as defined by the Unicode Pattern_White_Space property, are
            ignored, unless they are escaped.
            
            <para/>
            Property patterns specify a set of characters having a certain
            property as defined by the Unicode standard.  Both the POSIX-like
            "[:Lu:]" and the Perl-like syntax "\p{Lu}" are recognized.  For a
            complete list of supported property patterns, see the User's Guide
            for UnicodeSet at
            <a href="http://www.icu-project.org/userguide/unicodeSet.html">
            http://www.icu-project.org/userguide/unicodeSet.html</a>.
            Actual determination of property data is defined by the underlying
            Unicode database as implemented by <see cref="T:ICU4N.UChar"/>.
            
            <para/>
            Patterns specify individual characters, ranges of characters, and
            Unicode property sets.  When elements are concatenated, they
            specify their union.  To complement a set, place a '^' immediately
            after the opening '['.  Property patterns are inverted by modifying
            their delimiters; "[:^foo]" and "\P{foo}".  In any other location,
            '^' has no special meaning.
            
            <para/>
            Ranges are indicated by placing two a '-' between two
            characters, as in "a-z".  This specifies the range of all
            characters from the left to the right, in Unicode order.  If the
            left character is greater than or equal to the
            right character it is a syntax error.  If a '-' occurs as the first
            character after the opening '[' or '[^', or if it occurs as the
            last character before the closing ']', then it is taken as a
            literal.  Thus "[a\\-b]", "[-ab]", and "[ab-]" all indicate the same
            set of three characters, 'a', 'b', and '-'.
            
            <para/>
            Sets may be intersected using the '&amp;' operator or the asymmetric
            set difference may be taken using the '-' operator, for example,
            "[[:L:]&amp;[\\u0000-\\u0FFF]]" indicates the set of all Unicode letters
            with values less than 4096.  Operators ('&amp;' and '|') have equal
            precedence and bind left-to-right.  Thus
            "[[:L:]-[a-z]-[\\u0100-\\u01FF]]" is equivalent to
            "[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]".  This only really matters for
            difference; intersection is commutative.
            
            <list type="table">
                <item>
                    <term><c>[a]</c></term>
                    <term>The set containing 'a'</term>
                </item>
                <item>
                    <term><c>[a-z]</c></term>
                    <term>The set containing 'a'
                    through 'z' and all letters in between, in Unicode order</term>
                </item>
                <item>
                    <term><c>[^a-z]</c></term>
                    <term>The set containing
                    all characters but 'a' through 'z',
                    that is, U+0000 through 'a'-1 and 'z'+1 through U+10FFFF</term>
                </item>
                <item>
                    <term><c>[[<em>pat1</em>][<em>pat2</em>]]</c></term>
                    <term>The union of sets specified by <em>pat1</em> and <em>pat2</em></term>
                </item>
                <item>
                    <term><c>[[<em>pat1</em>]&amp;[<em>pat2</em>]]</c></term>
                    <term>The intersection of sets specified by <em>pat1</em> and <em>pat2</em></term>
                </item>
                <item>
                    <term><c>[[<em>pat1</em>]-[<em>pat2</em>]]</c></term>
                    <term>The asymmetric difference of sets specified by <em>pat1</em> and <em>pat2</em></term>
                </item>
                <item>
                    <term><c>[:Lu:] or \p{Lu}</c></term>
                    <term>The set of characters having the specified
                    Unicode property; in
                    this case, Unicode uppercase letters</term>
                </item>
                <item>
                    <term><c>[:^Lu:] or \P{Lu}</c></term>
                    <term>The set of characters <em>not</em> having the given
                    Unicode property</term>
                </item>
            </list>
            
            <para/>
            <b>Warning</b>: you cannot add an empty string ("") to a UnicodeSet.
            
            <para/>
            <b>Formal syntax</b>
            
            <list type="table">
                <item>
                    <term><c>pattern :=&amp;nbsp; </c></term>
                    <term><c>('[' '^'? item* ']') | property</c></term>
                </item>
                <item>
                    <term><c>item :=&amp;nbsp; </c></term>
                    <term><c>char | (char '-' char) | pattern-expr<br/></c></term>
                </item>
                <item>
                    <term><c>pattern-expr :=&amp;nbsp; </c></term>
                    <term><c>pattern | pattern-expr pattern | pattern-expr op pattern<br/></c></term>
                </item>
                <item>
                    <term><c>op :=&amp;nbsp; </c></term>
                    <term><c>'&amp;' | '-'<br/></c></term>
                </item>
                <item>
                    <term><c>special :=&amp;nbsp; </c></term>
                    <term><c>'[' | ']' | '-'<br/></c></term>
                </item>
                <item>
                    <term><c>char :=&amp;nbsp; </c></term>
                    <term><em>any character that is not</em><c> special<br/>
                    | ('\\' </c><em>any character</em><c>)<br/>
                    | ('&#92;u' hex hex hex hex)<br/>
                    </c></term>
                </item>
                <item>
                    <term><c>hex :=&amp;nbsp; </c></term>
                    <term><em>any character for which
                    </em><c>Character.Digit(c, 16)</c><em>
                    returns a non-negative result</em></term>
                </item>
                <item>
                    <term><c>property :=&amp;nbsp; </c></term>
                    <term><em>a Unicode property set pattern</em></term>
                </item>
            </list>
            
            <list type="table">
                <item>
                    <term>Legend:
                        <list type="table">
                            <item>
                                <term><c>a := b</c></term>
                                <term>&#160;</term>
                                <term><c>a</c> may be replaced by <c>b</c></term>
                            </item>
                            <item>
                                <term><c>a?</c></term>
                                <term></term>
                                <term>zero or one instance of <c>a</c></term>
                            </item>
                            <item>
                                <term><c>a*</c></term>
                                <term></term>
                                <term>one or more instances of <c>a</c></term>
                            </item>
                            <item>
                                <term><c>a | b</c></term>
                                <term></term>
                                <term>either <c>a</c> or <c>b</c></term>
                            </item>
                            <item>
                                <term><c>'a'</c></term>
                                <term></term>
                                <term>the literal string between the quotes</term>
                            </item>
                        </list>
                    </term>
                </item>
            </list>
            
            <para/>
            To iterate over contents of <see cref="T:ICU4N.Text.UnicodeSet"/>, the following are available:
            <list type="bullet">
                <item><description>
                    <see cref="P:ICU4N.Text.UnicodeSet.Ranges"/> to iterate through the ranges
                </description></item>
                <item><description>
                    <see cref="P:ICU4N.Text.UnicodeSet.Strings"/> to iterate through the strings
                </description></item>
                <item><description>
                    <see cref="M:ICU4N.Text.UnicodeSet.GetEnumerator"/> to iterate through the entire contents in a single loop.
                    That method is, however, not particularly efficient, since it "boxes" each code point into a <see cref="T:System.String"/>.
                </description></item>
            </list>
            All of the above can be used in <b>for</b> loops.
            The <see cref="T:ICU4N.Text.UnicodeSetIterator"/> can also be used, but not in <b>for</b> loops.
            
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </remarks>
            <seealso cref="T:ICU4N.Text.UnicodeSetIterator"/>
            <seealso cref="T:ICU4N.Text.UnicodeSetSpanner"/>
            <author>Alan Liu</author>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(System.Collections.Generic.IEnumerable{System.Char[]})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <typeparam name="T">The type of element to add (this method calls ToString() to convert this type to a string).</typeparam>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWithChars(System.Int32,System.Int32)">
            <summary>
            Adds all characters in range (uses preferred naming convention).
            </summary>
            <param name="start">The index of where to start on adding all characters.</param>
            <param name="end">The index of where to end on adding all characters.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Text.UnicodeSet)">
            <summary>
            Adds all of the elements in the specified set to this set if
            they're not already present.  This operation effectively
            modifies this set so that its value is the <i>union</i> of the two
            sets.  The behavior of this operation is unspecified if the specified
            collection is modified while the operation is in progress.
            </summary>
            <param name="c">Set whose elements are to be added to this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CopyTo``1(``0)">
            <summary>
            Add the contents of the UnicodeSet (as strings) into a collection.
            </summary>
            <typeparam name="T">Collection type.</typeparam>
            <param name="target">Collection to add into.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars(System.Int32,System.Int32)">
            <summary>
            Complements the specified range in this set.  Any character in
            the range will be removed if it is in this set, or will be
            added if it is not in this set.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c>
            then an empty range is complemented, leaving the set unchanged.
            </summary>
            <param name="start">First character, inclusive, of range to be removed from this set.</param>
            <param name="end">Last character, inclusive, of range to be removed from this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(System.Int32)">
            <summary>
            Complements the specified character in this set.  The character
            will be removed if it is in this set, or will be added if it is
            not in this set.
            </summary>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars">
            <summary>
            This is equivalent to
            <c>Complement(<see cref="F:ICU4N.Text.UnicodeSet.MinValue"/>, <see cref="F:ICU4N.Text.UnicodeSet.MaxValue"/>)</c>
            </summary>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(ICU4N.Text.UnicodeSet)">
            <summary>
            Complements in this set all elements contained in the specified
            set.  Any character in the other set will be removed if it is
            in this set, or will be added if it is not in this set.
            </summary>
            <param name="c">Set that defines which elements will be complemented from
            this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf(System.String)">
            <summary>
            Returns true if there is a partition of the string such that this set contains each of the partitioned strings.
            For example, for the Unicode set [a{bc}{cd}]
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String)"/> is true for each of: "a", "bc", ""cdbca"</description></item>
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String)"/> is false for each of: "acb", "bcda", "bcx"</description></item>
            </list>
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf(ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains all the characters and strings
            of the given set.
            </summary>
            <param name="b">Set to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Int32,System.Int32)">
            <summary>
            Returns true if this set contains one or more of the characters
            in the given range.
            </summary>
            <param name="start">First character, inclusive, of the range.</param>
            <param name="end">Last character, inclusive, of the range.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains one or more of the characters
            and strings of the given set.
            </summary>
            <param name="s">Set to be checked for containment.</param>
            <returns>True if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Any">
            <summary>
            Returns <c>true</c> if this set contains elements.
            </summary>
            <remarks>
            This method will override the default behavior of the LINQ Any() extension method.
            </remarks>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWith(ICU4N.Text.UnicodeSet)">
            <summary>
            Removes from this set all of its elements that are contained in the
            specified set.  This operation effectively modifies this
            set so that its value is the <i>asymmetric set difference</i> of
            the two sets.
            </summary>
            <param name="c">Set that defines which elements will be removed from
            this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ClearStrings">
            <summary>
            Remove all strings from this <see cref="T:ICU4N.Text.UnicodeSet"/>
            </summary>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(ICU4N.Text.UnicodeSet)">
            <summary>
            Retains only the elements in this set that are contained in the
            specified set.  In other words, removes from this set all of
            its elements that are not contained in the specified set.  This
            operation effectively modifies this set so that its value is
            the <i>intersection</i> of the two sets.
            </summary>
            <param name="c">Set that defines which elements this set will retain.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Int32)">
            <summary>
            Retain the specified character from this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="c"/>, or
            will only contain c if it did contain <paramref name="c"/>.
            </summary>
            <param name="c">The character to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWithChars(System.Int32,System.Int32)">
            <summary>
            Retain only the elements in this set that are contained in the
            specified range.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c> 
            then an empty range is retained, leaving the set empty.
            </summary>
            <param name="start">First character, inclusive, of range to be retained
            to this set.</param>
            <param name="end">Last character, inclusive, of range to be retained
            to this set.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.IsReadOnly">
            <summary>
            Whether this set is readonly. This is always the same value as <see cref="P:ICU4N.Text.UnicodeSet.IsFrozen"/>.
            </summary>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CopyTo(System.String[],System.Int32)">
            <summary>
            Copies the elements of a <see cref="T:ICU4N.Text.UnicodeSet"/> collection to an array.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements
            copied from the <see cref="T:ICU4N.Text.UnicodeSet"/> object. The array must have zero-based indexing.</param>
            <param name="arrayIndex">The index of the array to begin copying elements to.</param>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsProperSubsetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a <see cref="T:ICU4N.Text.UnicodeSet"/> object is a proper subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>true if the <see cref="T:ICU4N.Text.UnicodeSet"/> object is a proper subset of other; otherwise, false.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsProperSupersetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a <see cref="T:ICU4N.Text.UnicodeSet"/> object is a proper superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>true if the <see cref="T:ICU4N.Text.UnicodeSet"/> object is a proper superset of other; otherwise, false.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSubsetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a <see cref="T:ICU4N.Text.UnicodeSet"/> object is a subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>true if the <see cref="T:ICU4N.Text.UnicodeSet"/> object is a subset of other; otherwise, false.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SetEquals(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(System.String[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(System.Text.StringBuilder[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(System.Char[][])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Support.Text.ICharSequence[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.UnionWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWithChars(System.String)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWithChars(System.Text.StringBuilder)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWithChars(System.Char[])">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.UnionWithChars(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(System.String)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(System.Text.StringBuilder)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(System.Char[])">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWith(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars(System.String)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars(System.Text.StringBuilder)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars(System.Char[])">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SymmetricExceptWithChars(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.IsSupersetOf(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.IsSupersetOf(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.IsSupersetOf(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.IsSupersetOf(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.String)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Text.StringBuilder)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Char[])">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Overlaps``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.Overlaps(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWith(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ExceptWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWith(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ExceptWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWith(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ExceptWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWith``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ExceptWith(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWithChars(System.String)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWithChars(System.Text.StringBuilder)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWithChars(System.Char[])">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ExceptWithChars(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.String)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Text.StringBuilder)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Char[])">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWith``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWithChars(System.String)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWithChars(System.Text.StringBuilder)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWithChars(System.Char[])">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IntersectWithChars(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <draft>ICU4N 60.1</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.Empty">
            <summary>
            Constant for the empty set.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.AllCodePoints">
            <summary>
            Constant for the set of all code points. (Since <see cref="T:ICU4N.Text.UnicodeSet"/>s can include strings, 
            does not include everything that a <see cref="T:ICU4N.Text.UnicodeSet"/> can.)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.MinValue">
            <summary>
            Minimum value that can be stored in a <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.MaxValue">
            <summary>
            Maximum value that can be stored in a <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.pat">
            <summary>
            The pattern representation of this set.  This may not be the
            most economical pattern.  It is the pattern supplied to
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/>, with variables substituted and whitespace
            removed.  For sets constructed without <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/>, or
            modified using the non-pattern API, this string will be null,
            indicating that <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Text.StringBuilder,System.Boolean)"/> must generate a pattern
            representation from the inversion list.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.INCLUSIONS">
            <summary>
            A set of all characters _except_ the second through last characters of
            certain ranges.  These ranges are ranges of characters whose
            properties are all exactly alike, e.g. CJK Ideographs from
            U+4E00 to U+9FA5.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor">
            <summary>
            Constructs an empty set.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(ICU4N.Text.UnicodeSet)">
            <summary>
            Constructs a copy of an existing set.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a set containing the given range. If <c><paramref name="end"/> &gt;
            <paramref name="start"/></c> then an empty set is created.
            </summary>
            <param name="start">First character, inclusive, of range.</param>
            <param name="end">Last character, inclusive, of range.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.Int32[])">
            <summary>
            Quickly constructs a set from a set of ranges &lt;s0, e0, s1, e1, s2, e2, ..., sn, en&gt;.
            There must be an even number of integers, and they must be all greater than zero,
            all less than or equal to <see cref="F:ICU4N.Support.Text.Character.MAX_CODE_POINT"/>.
            In each pair (..., si, ei, ...) it must be true that si &lt;= ei
            Between adjacent pairs (...ei, sj...), it must be true that ei+1 &lt; sj.
            </summary>
            <param name="pairs">Pairs of character representing ranges.</param>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.String)">
            <summary>
            Constructs a set from the <paramref name="pattern"/> pattern.  See the 
            <see cref="T:ICU4N.Text.UnicodeSet"/> class description
            for the syntax of the <paramref name="pattern"/> language.
            Whitespace is ignored.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/>
            contains a syntax error.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a set from the <paramref name="pattern"/> pattern.  See the 
            <see cref="T:ICU4N.Text.UnicodeSet"/> class description
            for the syntax of the <paramref name="pattern"/> language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="ignoreWhitespace">If true, ignore Unicode Pattern_White_Space characters.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/>
            contains a syntax error.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)">
            <summary>
            Constructs a set from the <paramref name="pattern"/> pattern.  See the 
            <see cref="T:ICU4N.Text.UnicodeSet"/> class description
            for the syntax of the <paramref name="pattern"/> language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="options">A bitmask indicating which options to apply.
            Valid options are <see cref="F:ICU4N.Text.UnicodeSet.IgnoreSpace"/> and <see cref="F:ICU4N.Text.UnicodeSet.Case"/>.
            </param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/>
            contains a syntax error.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Support.Text.ParsePosition,ICU4N.Text.ISymbolTable)">
            <summary>
            Constructs a set from the given <paramref name="pattern"/>.  See the 
            <see cref="T:ICU4N.Text.UnicodeSet"/> class description
            for the syntax of the <paramref name="pattern"/> language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="pos">On input, the position in pattern at which to start parsing.
            On output, the position after the last character parsed.</param>
            <param name="symbols">A symbol table mapping variables to char[] arrays
            and chars to <see cref="T:ICU4N.Text.UnicodeSet"/>s.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/>
            contains a syntax error.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Support.Text.ParsePosition,ICU4N.Text.ISymbolTable,ICU4N.Text.PatternOptions)">
            <summary>
            Constructs a set from the given <paramref name="pattern"/>.  See the
            <see cref="T:ICU4N.Text.UnicodeSet"/> class description
            for the syntax of the <paramref name="pattern"/> language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="pos">On input, the position in pattern at which to start parsing.
            On output, the position after the last character parsed.</param>
            <param name="symbols">A symbol table mapping variables to char[] arrays
            and chars to <see cref="T:ICU4N.Text.UnicodeSet"/>s.</param>
            <param name="options">A bitmask indicating which options to apply.
            Valid options are <see cref="F:ICU4N.Text.UnicodeSet.IgnoreSpace"/> and <see cref="F:ICU4N.Text.UnicodeSet.Case"/>.
            </param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/>
            contains a syntax error.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Clone">
            <summary>
            Return a new set that is equivalent to this one.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Set(System.Int32,System.Int32)">
            <summary>
            Make this object represent the range <code>start - end</code>.
            If <code>end &gt; start</code> then this object is set to an
            an empty range.
            </summary>
            <param name="start">First character in the set, inclusive.</param>
            <param name="end">Last character in the set, inclusive.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Set(ICU4N.Text.UnicodeSet)">
            <summary>
            Make this object represent the same set as <paramref name="other"/>.
            </summary>
            <param name="other">A <see cref="T:ICU4N.Text.UnicodeSet"/> whose value will be
            copied to this object.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)">
            <summary>
            Modifies this set to represent the set specified by the given <paramref name="pattern"/>.
            See the <see cref="T:ICU4N.Text.UnicodeSet"/> class description for the syntax of the <paramref name="pattern"/> language.
            Whitespace is ignored.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/> contains a syntax error.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,System.Boolean)">
            <summary>
            Modifies this set to represent the set specified by the given <paramref name="pattern"/>,
            optionally ignoring whitespace.
            See the <see cref="T:ICU4N.Text.UnicodeSet"/> class description for the syntax of the <paramref name="pattern"/> language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="ignoreWhitespace">If true then Unicode Pattern_White_Space characters are ignored.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/> contains a syntax error.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)">
            <summary>
            Modifies this set to represent the set specified by the given <paramref name="pattern"/>,
            optionally ignoring whitespace.
            See the class description for the syntax of the pattern language.
            </summary>
            <param name="pattern">A string specifying what characters are in the set.</param>
            <param name="options">A bitmask indicating which options to apply.
            Valid options are <see cref="F:ICU4N.Text.UnicodeSet.IgnoreSpace"/> and <see cref="F:ICU4N.Text.UnicodeSet.Case"/>.</param>
            <exception cref="T:System.ArgumentException">If the <paramref name="pattern"/> contains a syntax error.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ResemblesPattern(System.String,System.Int32)">
            <summary>
            Return true if the given position, in the given <paramref name="pattern"/>, appears
            to be the start of a <see cref="T:ICU4N.Text.UnicodeSet"/> pattern.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ToPattern(System.Boolean)">
            <summary>
            Returns a string representation of this set.  If the result of
            calling this function is passed to a <see cref="T:ICU4N.Text.UnicodeSet"/> constructor, it
            will produce another set that is equal to this one.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GeneratePattern(System.Text.StringBuilder,System.Boolean)">
            <summary>
            Generate and append a string representation of this set to result.
            This does not use <see cref="F:ICU4N.Text.UnicodeSet.pat"/>, the cleaned up copy of the string
            passed to <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/>
            </summary>
            <param name="result">The buffer into which to generate the pattern.</param>
            <param name="escapeUnprintable">Escape unprintable characters if true.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GeneratePattern(System.Text.StringBuilder,System.Boolean,System.Boolean)">
            <summary>
            Generate and append a string representation of this set to <paramref name="result"/>.
            This does not use <see cref="F:ICU4N.Text.UnicodeSet.pat"/>, the cleaned up copy of the string
            passed to <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String)"/>
            </summary>
            <param name="result">The buffer into which to generate the pattern.</param>
            <param name="escapeUnprintable">Escape unprintable characters if true.</param>
            <param name="includeStrings">If false, doesn't include the strings.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.Count">
            <summary>
            Returns the number of elements in this set (its cardinality)
            Note than the elements of a set may include both individual
            codepoints and strings.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesIndexValue(System.Int32)">
            <summary>
            Implementation of UnicodeMatcher API.  Returns <c>true</c> if
            this set contains any character whose low byte is the given
            value.  This is used by <c>RuleBasedTransliterator</c> for
            indexing.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Implementation of <see cref="M:ICU4N.Text.IUnicodeMatcher.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)"/>.  Always matches the
            longest possible multichar string.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchRest(ICU4N.Text.IReplaceable,System.Int32,System.Int32,System.String)">
            <summary>
            Returns the longest match for <paramref name="s"/> in text at the given position.
            If <paramref name="limit"/> > <paramref name="start"/> then match forward from <paramref name="start"/>+1 to <paramref name="limit"/>
            matching all characters except s[0].  If <paramref name="limit"/> &lt; start,
            go backward starting from <paramref name="start"/>-1 matching all characters
            except s[s.Length-1].  This method assumes that the
            first character, text[<paramref name="start"/>], matches <paramref name="s"/>, so it does not
            check it.
            </summary>
            <param name="text">The text to match.</param>
            <param name="start">The first character to match.  In the forward
            direction, <paramref name="text"/>[<paramref name="start"/>] is matched against <paramref name="s"/>[0].
            In the reverse direction, it is matched against
            <paramref name="s"/>[<paramref name="s"/>.Length-1].
            </param>
            <param name="limit">The limit offset for matching, either last+1 in
            the forward direction, or last-1 in the reverse direction,
            where last is the index of the last character to match.
            </param>
            <param name="s"></param>
            <returns>If part of <paramref name="s"/> matches up to the limit, return |limit -
            start|.  If all of <paramref name="s"/> matches before reaching the limit, return
            <paramref name="s"/>.Length.  If there is a mismatch between <paramref name="s"/> and text, return
            0.
            </returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddMatchSetTo(ICU4N.Text.UnicodeSet)">
            <summary>
            Implementation of <see cref="T:ICU4N.Text.IUnicodeMatcher"/> API.  Union the set of all
            characters that may be matched by this object into the given
            set.
            </summary>
            <param name="toUnionTo">The set into which to union the source characters.</param>
            <stable>ICU 2.2</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.IndexOf(System.Int32)">
            <summary>
            Returns the index of the given character within this set, where
            the set is ordered by ascending code point.  If the character
            is not in this set, return -1.  The inverse of this method is
            <see cref="P:ICU4N.Text.UnicodeSet.Item(System.Int32)"/>.
            </summary>
            <returns>An index from 0..Count-1, or -1.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.Item(System.Int32)">
            <summary>
            Returns the character at the given index within this set, where
            the set is ordered by ascending code point.  If the index is
            out of range, return -1.  The inverse of this method is
            <see cref="M:ICU4N.Text.UnicodeSet.IndexOf(System.Int32)"/>.
            </summary>
            <remarks>
            NOTE: This is equivalent to CharAt(index) in ICU4J.
            </remarks>
            <param name="index">An index from 0..Count-1.</param>
            <returns>The character at the given index, or -1.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(System.Int32,System.Int32)">
            <summary>
            Adds the specified range to this set if it is not already
            present.  If this set already contains the specified range,
            the call leaves this set unchanged.  If 
            <c><paramref name="end"/> &gt; <paramref name="start"/></c>
            then an empty range is added, leaving the set unchanged.
            </summary>
            <param name="start">First character, inclusive, of range to be added
            to this set.</param>
            <param name="end">Last character, inclusive, of range to be added
            to this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Int32,System.Int32)">
            <summary>
            Adds all characters in range (uses preferred naming convention).
            </summary>
            <param name="start">The index of where to start on adding all characters.</param>
            <param name="end">The index of where to end on adding all characters.</param>
            <returns>A reference to this object.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(System.Int32)">
            <summary>
            Adds the specified character to this set if it is not already
            present.  If this set already contains the specified character,
            the call leaves this set unchanged.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAllStrings">
            <summary>
            Remove all strings from this <see cref="T:ICU4N.Text.UnicodeSet"/>
            </summary>
            <returns>This object, for chaining.</returns>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(System.Int32,System.Int32)">
            <summary>
            Retain only the elements in this set that are contained in the
            specified range.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c> 
            then an empty range is retained, leaving the set empty.
            </summary>
            <param name="start">First character, inclusive, of range to be retained
            to this set.</param>
            <param name="end">Last character, inclusive, of range to be retained
            to this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(System.Int32)">
            <summary>
            Retain the specified character from this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="c"/>, or
            will only contain c if it did contain <paramref name="c"/>.
            </summary>
            <param name="c">The character to be retained.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(System.Int32,System.Int32)">
            <summary>
            Removes the specified range from this set if it is present.
            The set will not contain the specified range once the call
            returns.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c> 
            then an empty range is removed, leaving the set unchanged.
            </summary>
            <param name="start">First character, inclusive, of range to be removed
            from this set.</param>
            <param name="end">Last character, inclusive, of range to be removed
            from this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(System.Int32)">
            <summary>
            Removes the specified character from this set if it is present.
            The set will not contain the specified character once the call
            returns.
            </summary>
            <param name="c">The character to be removed.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(System.Int32,System.Int32)">
            <summary>
            Complements the specified range in this set.  Any character in
            the range will be removed if it is in this set, or will be
            added if it is not in this set.  If <c><paramref name="end"/> &gt; <paramref name="start"/></c>
            then an empty range is complemented, leaving the set unchanged.
            </summary>
            <param name="start">First character, inclusive, of range to be removed from this set.</param>
            <param name="end">Last character, inclusive, of range to be removed from this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(System.Int32)">
            <summary>
            Complements the specified character in this set.  The character
            will be removed if it is in this set, or will be added if it is
            not in this set.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement">
            <summary>
            This is equivalent to
            <c>Complement(<see cref="F:ICU4N.Text.UnicodeSet.MinValue"/>, <see cref="F:ICU4N.Text.UnicodeSet.MaxValue"/>)</c>
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(System.Int32)">
            <summary>
            Returns true if this set contains the given character.
            </summary>
            <param name="c">Character to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindCodePoint(System.Int32)">
            <summary>
            Returns the smallest value i such that c &lt; list[i].  Caller
            must ensure that <paramref name="c"/> is a legal value or this method will enter
            an infinite loop.  This method performs a binary search.
            </summary>
            <param name="c">A character in the range <see cref="F:ICU4N.Text.UnicodeSet.MinValue"/>..<see cref="F:ICU4N.Text.UnicodeSet.MaxValue"/>.</param>
            <returns>The smallest integer i in the range 0..len-1,
            inclusive, such that <paramref name="c"/> &lt; list[i].</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true if this set contains every character
            of the given range.
            </summary>
            <param name="start">First character, inclusive, of the range.</param>
            <param name="end">Last character, inclusive, of the range.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains all the characters and strings
            of the given set.
            </summary>
            <param name="b">Set to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String)">
            <summary>
            Returns true if there is a partition of the string such that this set contains each of the partitioned strings.
            For example, for the Unicode set [a{bc}{cd}]
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String)"/> is true for each of: "a", "bc", ""cdbca"</description></item>
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String)"/> is false for each of: "acb", "bcda", "bcx"</description></item>
            </list>
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String,System.Int32)">
            <summary>
            Recursive routine called if we fail to find a match in <see cref="M:ICU4N.Text.UnicodeSet.ContainsAll(System.String,System.Int32)"/>, and there are strings.
            </summary>
            <param name="s">Source string.</param>
            <param name="i">Point to match to the end on.</param>
            <returns>true if ok.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetRegexEquivalent">
            <summary>
            Get the Regex equivalent for this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
            <returns>Regex pattern equivalent to this <see cref="T:ICU4N.Text.UnicodeSet"/>.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Int32,System.Int32)">
            <summary>
            Returns true if this set contains none of the characters
            of the given range.
            </summary>
            <param name="start">First character, inclusive, of the range.</param>
            <param name="end">Last character, inclusive, of the range.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if none of the characters or strings in this <see cref="T:ICU4N.Text.UnicodeSet"/> appears in the string.
            For example, for the Unicode set [a{bc}{cd}]
            <list type="bullet">
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/> is true for: "xy", "cb"</description></item>
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/> is false for: "a", "bc", "bcd"</description></item>
            </list>
            </summary>
            <param name="b">Set to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Int32,System.Int32)">
            <summary>
            Returns true if this set contains one or more of the characters
            in the given range.
            </summary>
            <param name="start">First character, inclusive, of the range.</param>
            <param name="end">Last character, inclusive, of the range.</param>
            <returns>true if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)">
            <summary>
            Returns true if this set contains one or more of the characters
            and strings of the given set.
            </summary>
            <param name="s">Set to be checked for containment.</param>
            <returns>True if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)">
            <summary>
            Adds all of the elements in the specified set to this set if
            they're not already present.  This operation effectively
            modifies this set so that its value is the <i>union</i> of the two
            sets.  The behavior of this operation is unspecified if the specified
            collection is modified while the operation is in progress.
            </summary>
            <param name="c">Set whose elements are to be added to this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)">
            <summary>
            Retains only the elements in this set that are contained in the
            specified set.  In other words, removes from this set all of
            its elements that are not contained in the specified set.  This
            operation effectively modifies this set so that its value is
            the <i>intersection</i> of the two sets.
            </summary>
            <param name="c">Set that defines which elements this set will retain.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)">
            <summary>
            Removes from this set all of its elements that are contained in the
            specified set.  This operation effectively modifies this
            set so that its value is the <i>asymmetric set difference</i> of
            the two sets.
            </summary>
            <param name="c">Set that defines which elements will be removed from
            this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ComplementAll(ICU4N.Text.UnicodeSet)">
            <summary>
            Complements in this set all elements contained in the specified
            set.  Any character in the other set will be removed if it is
            in this set, or will be added if it is not in this set.
            </summary>
            <param name="c">Set that defines which elements will be complemented from
            this set.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Clear">
            <summary>
            Removes all of the elements from this set.  This set will be
            empty after this call returns.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.RangeCount">
            <summary>
            Iteration method that returns the number of ranges contained in
            this set.
            </summary>
            <seealso cref="M:ICU4N.Text.UnicodeSet.GetRangeStart(System.Int32)"/>
            <seealso cref="M:ICU4N.Text.UnicodeSet.GetRangeEnd(System.Int32)"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetRangeStart(System.Int32)">
            <summary>
            Iteration method that returns the first character in the
            specified range of this set.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is outside the range <c>0..<see cref="P:ICU4N.Text.UnicodeSet.RangeCount"/>-1</c>.</exception>
            <seealso cref="P:ICU4N.Text.UnicodeSet.RangeCount"/>
            <seealso cref="M:ICU4N.Text.UnicodeSet.GetRangeEnd(System.Int32)"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetRangeEnd(System.Int32)">
            <summary>
            Iteration method that returns the last character in the
            specified range of this set.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is outside the range <c>0..<see cref="P:ICU4N.Text.UnicodeSet.RangeCount"/>-1</c>.</exception>
            <seealso cref="M:ICU4N.Text.UnicodeSet.GetRangeStart(System.Int32)"/>
            <seealso cref="P:ICU4N.Text.UnicodeSet.RangeCount"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compact">
            <summary>
            Reallocate this objects internal structures to take up the least
            possible space, without changing this object's value.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Equals(System.Object)">
            <summary>
            Compares the specified object with this set for equality.  Returns
            <c>true</c> if the specified object is also a set, the two sets
            have the same size, and every member of the specified set is
            contained in this set (or equivalently, every member of this set is
            contained in the specified set).
            </summary>
            <param name="o">Object to be compared for equality with this set.</param>
            <returns><c>true</c> if the specified Object is equal to this set.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetHashCode">
            <summary>
            Returns the hash code value for this set.
            </summary>
            <returns>The hash code value for this set.</returns>
            <seealso cref="M:System.Object.GetHashCode"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ToString">
            <summary>
            Return a programmer-readable string representation of this object.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Support.Text.ParsePosition,ICU4N.Text.ISymbolTable,ICU4N.Text.PatternOptions)">
            <summary>
            Parses the given pattern, starting at the given position.  The character
            at pattern[pos.Index] must be '[', or the parse fails.
            Parsing continues until the corresponding closing ']'.  If a syntax error
            is encountered between the opening and closing brace, the parse fails.
            Upon return from a successful parse, the ParsePosition is updated to
            point to the character following the closing ']', and an inversion
            list for the parsed pattern is returned.  This method
            calls itself recursively to parse embedded subpatterns.
            </summary>
            <param name="pattern">the string containing the pattern to be parsed.  The
            portion of the string from pos.Index, which must be a '[', to the
            corresponding closing ']', is parsed.
            </param>
            <param name="pos">upon entry, the position at which to being parsing.  The
            character at pattern[pos.Index] must be a '['.  Upon return
            from a successful parse, pos.Index is either the character after the
            closing ']' of the parsed pattern, or pattern.Length if the closing ']'
            is the last character of the pattern string.
            </param>
            <param name="symbols"></param>
            <param name="options"></param>
            <returns>An inversion list for the parsed substring of <paramref name="pattern"/>.</returns>
            <exception cref="T:System.ArgumentException">If the parse fails.</exception>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPattern(ICU4N.Impl.RuleCharacterIterator,ICU4N.Text.ISymbolTable,ICU4N.Support.Text.IAppendable,ICU4N.Text.PatternOptions)">
            <summary>
            Parse the pattern from the given <see cref="T:ICU4N.Impl.RuleCharacterIterator"/>.  The
            iterator is advanced over the parsed pattern.
            </summary>
            <param name="chars">
            Iterator over the pattern characters.  Upon return
            it will be advanced to the first character after the parsed
            pattern, or the end of the iteration if all characters are
            parsed.
            </param>
            <param name="symbols">
            Symbol table to use to parse and dereference
            variables, or null if none.
            </param>
            <param name="rebuiltPat">
            The pattern that was parsed, rebuilt or
            copied from the input pattern, as appropriate.
            </param>
            <param name="options">
            A bit mask of zero or more of the following:
            <see cref="F:ICU4N.Text.UnicodeSet.IgnoreSpace"/>, <see cref="F:ICU4N.Text.UnicodeSet.Case"/>.
            </param>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAllTo``1(``0)">
            <summary>
            Add the contents of the UnicodeSet (as strings) into a collection.
            </summary>
            <typeparam name="T">Collection type.</typeparam>
            <param name="target">Collection to add into.</param>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ToArray(ICU4N.Text.UnicodeSet)">
            <summary>
            Add the contents of the <see cref="T:ICU4N.Text.UnicodeSet"/> (as strings) into an array.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the contents of the collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            The collection must not contain null.
            </summary>
            <typeparam name="T">The type of element to add (this method calls ToString() to convert this type to a string).</typeparam>
            <param name="source">The collection to add.</param>
            <returns>A reference to this object.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Collections.Generic.IEnumerable{System.Char[]})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a collection (as strings) into this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Uses standard naming convention.
            </summary>
            <typeparam name="T">The type of element to add (this method calls ToString() to convert this type to a string).</typeparam>
            <param name="source">Source collection to add into.</param>
            <returns>A reference to this object.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Range(System.Int32,System.Int32)">
            <summary>
            Assumes start &lt;= end.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyFilter(ICU4N.Text.UnicodeSet.IFilter,System.Int32)">
            <summary>
            Generic filter-based scanning code for UCD property <see cref="T:ICU4N.Text.UnicodeSet"/>s.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MungeCharName(System.String)">
            <summary>
            Remove leading and trailing Pattern_White_Space and compress
            internal Pattern_White_Space to a single space character.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyInt32PropertyValue(ICU4N.Globalization.UProperty,System.Int32)">
            <summary>
            Modifies this set to contain those code points which have the
            given value for the given binary or enumerated property, as
            returned by <see cref="M:ICU4N.UChar.GetIntPropertyValue(System.Int32,ICU4N.Globalization.UProperty)"/>.  
            Prior contents of this set are lost.
            </summary>
            <param name="prop">
            A property in the range
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Globalization.UProperty.Binary_Start"/>..<see cref="F:ICU4N.Globalization.UProperty.Binary_Limit"/>-1 or</description></item>
                <item><description><see cref="F:ICU4N.Globalization.UProperty.Int_Start"/>..<see cref="F:ICU4N.Globalization.UProperty.Int_Limit"/>-1 or</description></item>
                <item><description><see cref="F:ICU4N.Globalization.UProperty.Mask_Start"/>..<see cref="F:ICU4N.Globalization.UProperty.Mask_Limit"/>-1</description></item>
            </list>
            </param>
            <param name="value">
            A value in the range <see cref="M:ICU4N.UChar.GetIntPropertyMinValue(ICU4N.Globalization.UProperty)"/>..
            <see cref="M:ICU4N.UChar.GetIntPropertyMaxValue(ICU4N.Globalization.UProperty)"/>, with one exception.
            If prop is <see cref="F:ICU4N.Globalization.UProperty.General_Category_Mask"/>, then value should not be
            a <see cref="!:UChar.GetType(int)"/> result, but rather a mask value produced
            by logically ORing (1 &lt;&lt; <see cref="!:UChar.GetType(int)"/>) values together.
            <para/>
            This allows grouped categories such as [:L:] to be represented.
            </param>
            <returns>A reference to this set.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPropertyAlias(System.String,System.String)">
            <summary>
            Modifies this set to contain those code points which have the
            given value for the given property.  Prior contents of this
            set are lost.
            </summary>
            <param name="propertyAlias">
            A property alias, either short or long.
            The name is matched loosely.  See PropertyAliases.txt for names
            and a description of loose matching.  If the value string is
            empty, then this string is interpreted as either a
            General_Category value alias, a Script value alias, a binary
            property alias, or a special ID.  Special IDs are matched
            loosely and correspond to the following sets:
            <list type="bullet">
                <item><description>"ANY" = [\\u0000-\\U0010FFFF]</description></item>
                <item><description>"ASCII" = [\\u0000-\\u007F]</description></item>
            </list>
            </param>
            <param name="valueAlias">
            A value alias, either short or long.  The
            name is matched loosely.  See PropertyValueAliases.txt for
            names and a description of loose matching.  In addition to
            aliases listed, numeric values and canonical combining classes
            may be expressed numerically, e.g., ("nv", "0.5") or ("ccc",
            "220").  The value string may also be empty.
            </param>
            <returns>A reference to this set.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPropertyAlias(System.String,System.String,ICU4N.Text.ISymbolTable)">
            <summary>
            Modifies this set to contain those code points which have the
            given value for the given property.  Prior contents of this
            set are lost.
            </summary>
            <param name="propertyAlias">A string of the property alias.</param>
            <param name="valueAlias">A string of the value alias.</param>
            <param name="symbols">If not null, then symbols are first called to see if a property
            is available. If true, then everything else is skipped.</param>
            <returns>This set.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ResemblesPropertyPattern(System.String,System.Int32)">
            <summary>
            Return true if the given position, in the given pattern, appears
            to be the start of a property set pattern.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ResemblesPropertyPattern(ICU4N.Impl.RuleCharacterIterator,ICU4N.Impl.RuleCharacterIteratorOptions)">
            <summary>
            Return true if the given iterator appears to point at a
            property pattern.  Regardless of the result, return with the
            iterator unchanged.
            </summary>
            <param name="chars">Iterator over the pattern characters.  Upon return
            it will be unchanged.</param>
            <param name="iterOpts"><see cref="T:ICU4N.Impl.RuleCharacterIteratorOptions"/> options.</param>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPropertyPattern(System.String,ICU4N.Support.Text.ParsePosition,ICU4N.Text.ISymbolTable)">
            <summary>
            Parse the given property pattern at the given parse position.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ApplyPropertyPattern(ICU4N.Impl.RuleCharacterIterator,ICU4N.Support.Text.IAppendable,ICU4N.Text.ISymbolTable)">
            <summary>
            Parse a property pattern.
            </summary>
            <param name="chars">Iterator over the pattern characters.  Upon return
            it will be advanced to the first character after the parsed
            pattern, or the end of the iteration if all characters are
            parsed.
            </param>
            <param name="rebuiltPat">The pattern that was parsed, rebuilt or
            copied from the input pattern, as appropriate.</param>
            <param name="symbols">TODO</param>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.IgnoreSpace">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.Case">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            <para/>
            Enable case insensitive matching.  E.g., "[ab]" with this flag
            will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
            match all except 'a', 'A', 'b', and 'B'. This performs a full
            closure over case mappings, e.g. U+017F for s.
            <para/>
            The resulting set is a superset of the input for the code points but
            not for the strings.
            It performs a case mapping closure of the code points and adds
            full case folding strings for the code points, and reduces strings of
            the original set to their full case folding equivalents.
            </summary>
            <remarks>
            This is designed for case-insensitive matches, for example
            in regular expressions. The full code point case closure allows checking of
            an input character directly against the closure set.
            Strings are matched by comparing the case-folded form from the closure
            set with an incremental case folding of the string in question.
            <para/>
            The closure set will also contain single code points if the original
            set contained case-equivalent strings (like U+00DF for "ss" or "Ss" etc.).
            This is not necessary (that is, redundant) for the above matching method
            but results in the same closure sets regardless of whether the original
            set contained the code point or a string.
            </remarks>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.CaseInsensitive">
            <summary>
            Alias for <see cref="F:ICU4N.Text.UnicodeSet.Case"/>, for ease of porting from C++ where ICU4C
            also has both USET_CASE and USET_CASE_INSENSITIVE (see uset.h).
            </summary>
            <seealso cref="F:ICU4N.Text.UnicodeSet.Case"/>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSet.AddCaseMappings">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            <para/>
            Enable case insensitive matching.  E.g., "[ab]" with this flag
            will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
            match all except 'a', 'A', 'b', and 'B'. This adds the lower-,
            title-, and uppercase mappings as well as the case folding
            of each existing element in the set.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)">
            <summary>
            Close this set over the given <paramref name="attribute"/>. 
            </summary>
            <remarks>
            For the attribute <see cref="F:ICU4N.Text.UnicodeSet.Case"/>, the result is to modify 
            this set so that:
            <list type="number">
                <item><description>
                    For each character or string 'a' in this set, all strings
                    'b' such that FoldCase(a) == FoldCase(b) are added to this set.
                    (For most 'a' that are single characters, 'b' will have
                    b.Length == 1.)
                </description></item>
                <item><description>
                    For each string 'e' in the resulting set, if e !=
                    FoldCase(e), 'e' will be removed.
                </description></item>
            </list>
            <para/>
            Example: [aq\u00DF{Bc}{bC}{Fi}] =&gt; [aAqQ\u00DF\uFB01{ss}{bc}{fi}]
            <para/>
            (Here FoldCase(x) refers to the operation
            UChar.FoldCase(x, true), and a == b actually denotes
            a.Equals(b), not pointer comparison.)
            </remarks>
            <param name="attribute">Bitmask for attributes to close over.
            Currently only the CASE bit is supported.  Any undefined bits
            are ignored.
            </param>
            <returns>A reference to this set.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Text.UnicodeSet.XSymbolTable">
            <summary>
            Internal class for customizing <see cref="T:ICU4N.Text.UnicodeSet"/> parsing of properties.
            </summary>
            <author>medavis</author>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.XSymbolTable.#ctor">
            <summary>
            Default constructor.
            </summary>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.XSymbolTable.LookupMatcher(System.Int32)">
            <summary>
            Supplies default implementation for <see cref="T:ICU4N.Text.ISymbolTable"/> (no action).
            </summary>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.XSymbolTable.ApplyPropertyAlias(System.String,System.String,ICU4N.Text.UnicodeSet)">
            <summary>
            Override the interpretation of the sequence [:<paramref name="propertyName"/>=<paramref name="propertyValue"/>:] (and its negated and Perl-style
            variant). The <paramref name="propertyName"/> and <paramref name="propertyValue"/> may be existing Unicode aliases, or may not be.
            <para/>
            This routine will be called whenever the parsing of a UnicodeSet pattern finds such a
            <paramref name="propertyName"/>+<paramref name="propertyValue"/> combination.
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="propertyValue">The name of the property value.</param>
            <param name="result"><see cref="T:ICU4N.Text.UnicodeSet"/> value to change
            a set to which the characters having the <paramref name="propertyName"/>+<paramref name="propertyValue"/> are to be added.
            </param>
            <returns>true if the <paramref name="propertyName"/>+<paramref name="propertyValue"/> combination is to be overridden, and the characters
            with that property have been added to the <see cref="T:ICU4N.Text.UnicodeSet"/>, and returns false if the
            <paramref name="propertyName"/>+<paramref name="propertyValue"/> combination is not recognized (in which case result is unaltered).
            </returns>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.XSymbolTable.Lookup(System.String)">
            <summary>
            Supplies default implementation for <see cref="T:ICU4N.Text.ISymbolTable"/> (no action).
            </summary>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.XSymbolTable.ParseReference(System.String,ICU4N.Support.Text.ParsePosition,System.Int32)">
            <summary>
            Supplies default implementation for <see cref="T:ICU4N.Text.ISymbolTable"/> (no action).
            </summary>
            <draft>ICU3.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.IsFrozen">
            <summary>
            Is this frozen, according to the <see cref="T:ICU4N.Util.IFreezable`1"/> interface?
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Freeze">
            <summary>
            Freeze this class, according to the <see cref="T:ICU4N.Util.IFreezable`1"/> interface.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CloneAsThawed">
            <summary>
            Clone a thawed version of this class, according to the <see cref="T:ICU4N.Util.IFreezable`1"/> interface.
            </summary>
            <returns>The clone, not frozen.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.UnicodeSet.EntryRange">
            <summary>
            A struct-like class used for iteration through ranges, for faster iteration than by String.
            Read about the restrictions on usage in <see cref="P:ICU4N.Text.UnicodeSet.Ranges"/>.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.EntryRange.Codepoint">
            <summary>
            The starting code point of the range.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.EntryRange.CodepointEnd">
            <summary>
            The ending code point of the range.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.EntryRange.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>A string that represents the current object.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.Ranges">
            <summary>
            Provide for faster enumeration than by <see cref="T:System.String"/>. Returns an Enumerable/Enumerator over ranges of code points.
            The <see cref="T:ICU4N.Text.UnicodeSet"/> must not be altered during the iteration.
            The <see cref="T:ICU4N.Text.UnicodeSet.EntryRange"/> instance is the same each time; the contents are just reset.
            </summary>
            <remarks>
            <b>Warning: </b>To iterate over the full contents, you have to also iterate over the strings.
            <para/>
            <b>Warning: </b>For speed, <see cref="T:ICU4N.Text.UnicodeSet"/> iteration does not check for concurrent modification.
            Do not alter the <see cref="T:ICU4N.Text.UnicodeSet"/> while iterating.
            <code>
            // Sample code
            foreach (EntryRange range in us1.Ranges)
            {
                // do something with code points between range.Codepoint and range.CodepointEnd;
            }
            foreach (string s in us1.Strings)
            {
                // do something with each string;
            }
            </code>
            </remarks>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetEnumerator">
            <summary>
            Returns a string enumerator. Uses the same order of iteration as <see cref="T:ICU4N.Text.UnicodeSetIterator"/>.
            <para/>
            <b>Warning: </b>For speed, <see cref="T:ICU4N.Text.UnicodeSet"/> iteration does not check for concurrent modification.
            <para/>
            Do not alter the <see cref="T:ICU4N.Text.UnicodeSet"/> while iterating.
            </summary>
            <seealso cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CompareTo(ICU4N.Text.UnicodeSet)">
            <summary>
            Compares <see cref="T:ICU4N.Text.UnicodeSet"/>s, where shorter come first, and otherwise lexigraphically
            (according to the comparison of the first characters that differ).
            </summary>
            <seealso cref="M:System.IComparable.CompareTo(System.Object)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CompareTo(ICU4N.Text.UnicodeSet,ICU4N.Text.ComparisonStyle)">
            <summary>
            Compares <see cref="T:ICU4N.Text.UnicodeSet"/>s, in three different ways.
            </summary>
            <seealso cref="M:System.IComparable.CompareTo(System.Object)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.CompareTo(System.Collections.Generic.IEnumerable{System.String})">
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Utility to compare two enumerators. Warning: the ordering in enumerables is important. For Collections that are ordered,
            like Lists, that is expected. However, Sets in .NET violate Leibniz's law when it comes to iteration.
            That means that sets can't be compared directly with this method, unless they are <see cref="T:System.Collections.Generic.SortedSet`1"/>s without
            (or with the same) comparer. Unfortunately, it is impossible to reliably detect in .NET whether subclass of
            Collection satisfies the right criteria, so it is left to the user to avoid those circumstances.
            </summary>
            <typeparam name="T">The type of items to compare.</typeparam>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare``1(System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Utility to compare two enumerators. Warning: the ordering in enumerables is important. For Collections that are ordered,
            like Lists, that is expected. However, Sets in .NET violate Leibniz's law when it comes to iteration.
            That means that sets can't be compared directly with this method, unless they are <see cref="T:System.Collections.Generic.SortedSet`1"/>s without
            (or with the same) comparer. Unfortunately, it is impossible to reliably detect in .NET whether subclass of
            Collection satisfies the right criteria, so it is left to the user to avoid those circumstances.
            </summary>
            <typeparam name="T">The type of items to compare.</typeparam>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0},ICU4N.Text.ComparisonStyle)">
            <summary>
            Utility to compare two collections, optionally by size, and then lexicographically.
            </summary>
            <typeparam name="T">The type of items to compare.</typeparam>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAllTo``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            Utility for adding the contents of an enumerable to a collection.
            </summary>
            <typeparam name="T">The source element type.</typeparam>
            <typeparam name="U">The target type (must implement <see cref="T:System.Collections.Generic.ICollection`1"/>).</typeparam>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAllTo``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Utility for adding the contents of an enumerable to a collection.
            </summary>
            <typeparam name="T">The type of items to add.</typeparam>
            <stable>ICU 4.4</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.Strings">
            <summary>
            For iterating through the strings in the set. Example:
            <code>
            foreach (string key in myUnicodeSet.Strings)
            {
                DoSomethingWith(key);
            }
            </code>
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddBridges(ICU4N.Text.UnicodeSet)">
            <summary>
            Simplify the ranges in a Unicode set by merging any ranges that are only separated by characters in the <paramref name="dontCare"/> set.
            For example, the ranges: \\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E change to \\u2E80-\\u303E
            if the <paramref name="dontCare"/> set includes unassigned characters (for a particular version of Unicode).
            </summary>
            <param name="dontCare">Set with the don't-care characters for spanning.</param>
            <returns>The input set, modified.</returns>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.UnicodeSet.DefaultXSymbolTable">
            <summary>
            Get the default symbol table. Null means ordinary processing. For internal use only.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SetDefaultXSymbolTable(ICU4N.Text.UnicodeSet.XSymbolTable)">
            <summary>
            Set the default symbol table. Null means ordinary processing. For internal use only. Will affect all subsequent parsing
            of <see cref="T:ICU4N.Text.UnicodeSet"/>s.
            <para/>
            WARNING: If this function is used with a UnicodeProperty, and the
            Unassigned characters (gc=Cn) are different than in ICU other than in ICU, you MUST call
            <c>UnicodeProperty.ResetCacheProperties</c> afterwards. If you then set <see cref="P:ICU4N.Text.UnicodeSet.DefaultXSymbolTable"/>
            with null to clear the value, you MUST also call <c>UnicodeProperty.ResetCacheProperties</c>.
            </summary>
            <param name="xSymbolTable">The new default symbol table.</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.String[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Text.StringBuilder[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Char[][])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Support.Text.ICharSequence[])">
            <seealso cref="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.String)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Text.StringBuilder)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(System.Char[])">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AddAll(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>this object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(System.String)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(System.Text.StringBuilder)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(System.Char[])">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Complement(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement the specified string in this set.
            The set will not contain the specified string once the call
            returns.
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The string to complement.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ComplementAll(System.String)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ComplementAll(System.Text.StringBuilder)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ComplementAll(System.Char[])">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ComplementAll(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.String)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Text.StringBuilder)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Char[])">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns true if this set contains one or more of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsSome``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsSome(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.String)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.Text.StringBuilder)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(System.Char[])">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RemoveAll(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(System.String)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(System.Text.StringBuilder)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(System.Char[])">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Retain(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retain the specified string in this set if it is present.
            Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
            will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
            </summary>
            <param name="cs">The string to be retained.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.String)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.Text.StringBuilder)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(System.Char[])">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.RetainAll(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
            If this set already any particular character, it has no effect on that character.
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendCodePoint(System.Text.StringBuilder,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendCodePoint(ICU4N.Support.Text.IAppendable,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(System.Text.StringBuilder,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(System.Text.StringBuilder,System.Text.StringBuilder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(System.Text.StringBuilder,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(ICU4N.Support.Text.IAppendable,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(ICU4N.Support.Text.IAppendable,System.Text.StringBuilder)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(ICU4N.Support.Text.IAppendable,System.Char[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Append(ICU4N.Support.Text.IAppendable,ICU4N.Support.Text.ICharSequence)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendToPat(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            Append the <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Boolean)"/> representation of a
            string to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendToPat``1(``0,System.String,System.Boolean)">
            <summary>
            Append the <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Boolean)"/> representation of a
            string to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendToPat(System.Text.StringBuilder,System.Int32,System.Boolean)">
            <summary>
            Append the <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Boolean)"/> representation of a
            character to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.AppendToPat``1(``0,System.Int32,System.Boolean)">
            <summary>
            Append the <see cref="M:ICU4N.Text.UnicodeSet.ToPattern(System.Boolean)"/> representation of a
            character to the given <see cref="T:ICU4N.Support.Text.IAppendable"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ToPattern(System.Text.StringBuilder,System.Boolean)">
            <summary>
            Append a string representation of this set to result.  This will be
            a cleaned version of the string passed to ApplyPattern(), if there
            is one.  Otherwise it will be generated.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ToPattern``1(``0,System.Boolean)">
            <summary>
            Append a string representation of this set to result.  This will be
            a cleaned version of the string passed to ApplyPattern(), if there
            is one.  Otherwise it will be generated.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.String,System.Int32)">
            <summary>
            Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Text.StringBuilder,System.Int32)">
            <summary>
            Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Char[],System.Int32)">
            <summary>
            Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.String,System.Int32,System.String)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.String,System.Int32,System.Text.StringBuilder)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.String,System.Int32,System.Char[])">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.String,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Text.StringBuilder,System.Int32,System.Text.StringBuilder)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Text.StringBuilder,System.Int32,System.Char[])">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Text.StringBuilder,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Char[],System.Int32,System.String)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Char[],System.Int32,System.Text.StringBuilder)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Char[],System.Int32,System.Char[])">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(System.Char[],System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(ICU4N.Support.Text.ICharSequence,System.Int32,System.String)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(ICU4N.Support.Text.ICharSequence,System.Int32,System.Text.StringBuilder)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(ICU4N.Support.Text.ICharSequence,System.Int32,System.Char[])">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.MatchesAt(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Does one string contain another, starting at a specific offset?
            </summary>
            <param name="text">Text to match.</param>
            <param name="offsetInText">Offset within that text.</param>
            <param name="substring">Substring to match at offset in text.</param>
            <returns>-1 if match fails, otherwise other.Length.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(System.String)">
            <summary>
            Adds the specified multicharacter to this set if it is not already
            present.  If this set already contains the multicharacter,
            the call leaves this set unchanged.
            Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(System.Text.StringBuilder)">
            <summary>
            Adds the specified multicharacter to this set if it is not already
            present.  If this set already contains the multicharacter,
            the call leaves this set unchanged.
            Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(System.Char[])">
            <summary>
            Adds the specified multicharacter to this set if it is not already
            present.  If this set already contains the multicharacter,
            the call leaves this set unchanged.
            Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Add(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Adds the specified multicharacter to this set if it is not already
            present.  If this set already contains the multicharacter,
            the call leaves this set unchanged.
            Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCP(System.String)">
            <summary>
            Utility for getting code point from single code point <see cref="T:System.String"/>.
            See the public <see cref="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.String)"/>.
            </summary>
            <param name="s">To test.</param>
            <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCP(System.Text.StringBuilder)">
            <summary>
            Utility for getting code point from single code point <see cref="T:System.Text.StringBuilder"/>.
            See the public <see cref="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.Text.StringBuilder)"/>.
            </summary>
            <param name="s">To test.</param>
            <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCP(System.Char[])">
            <summary>
            Utility for getting code point from single code point <see cref="T:char[]"/>.
            See the public <see cref="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.Char[])"/>.
            </summary>
            <param name="s">To test.</param>
            <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCP(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for getting code point from single code point <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            See the public <see cref="M:ICU4N.Text.UTF16.GetSingleCodePoint(ICU4N.Support.Text.ICharSequence)"/>.
            </summary>
            <param name="s">To test.</param>
            <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.From(System.String)">
            <summary>
            Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.From(System.Text.StringBuilder)">
            <summary>
            Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.From(System.Char[])">
            <summary>
            Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.From(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
            <para/>
            <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FromAll(System.String)">
            <summary>
            Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given characters.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FromAll(System.Text.StringBuilder)">
            <summary>
            Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given characters.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FromAll(System.Char[])">
            <summary>
            Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given characters.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FromAll(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
            </summary>
            <param name="s">The source string.</param>
            <returns>A newly created set containing the given characters.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(System.String)">
            <summary>
            Removes the specified string from this set if it is present.
            The set will not contain the specified string once the call
            returns.
            </summary>
            <param name="s">The string to be removed.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(System.Text.StringBuilder)">
            <summary>
            Removes the specified string from this set if it is present.
            The set will not contain the specified string once the call
            returns.
            </summary>
            <param name="s">The string to be removed.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(System.Char[])">
            <summary>
            Removes the specified string from this set if it is present.
            The set will not contain the specified string once the call
            returns.
            </summary>
            <param name="s">The string to be removed.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Remove(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Removes the specified string from this set if it is present.
            The set will not contain the specified string once the call
            returns.
            </summary>
            <param name="s">The string to be removed.</param>
            <returns>This object, for chaining.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(System.String)">
            <summary>
            Returns <tt>true</tt> if this set contains the given
            multicharacter string.
            </summary>
            <param name="s">String to be checked for containment.</param>
            <returns><tt>true</tt> if this set contains the specified string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(System.Text.StringBuilder)">
            <summary>
            Returns <tt>true</tt> if this set contains the given
            multicharacter string.
            </summary>
            <param name="s">String to be checked for containment.</param>
            <returns><tt>true</tt> if this set contains the specified string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(System.Char[])">
            <summary>
            Returns <tt>true</tt> if this set contains the given
            multicharacter string.
            </summary>
            <param name="s">String to be checked for containment.</param>
            <returns><tt>true</tt> if this set contains the specified string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Contains(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns <tt>true</tt> if this set contains the given
            multicharacter string.
            </summary>
            <param name="s">String to be checked for containment.</param>
            <returns><tt>true</tt> if this set contains the specified string.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.String)">
            <summary>
            Returns true if this set contains none of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Text.StringBuilder)">
            <summary>
            Returns true if this set contains none of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Char[])">
            <summary>
            Returns true if this set contains none of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns true if this set contains none of the characters
            of the given string.
            </summary>
            <param name="s">String containing characters to be checked for containment.</param>
            <returns>true if the test condition is met.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.String,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this UnicodeSet.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The length of the span.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.Text.StringBuilder,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this UnicodeSet.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The length of the span.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.Char[],ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this UnicodeSet.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The length of the span.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(ICU4N.Support.Text.ICharSequence,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this UnicodeSet.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The length of the span.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <list type="bullet">
                <item><description>If the start index is less than 0, span will start from 0.</description></item>
                <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
            </list>
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which ends the span (i.e. exclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <list type="bullet">
                <item><description>If the start index is less than 0, span will start from 0.</description></item>
                <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
            </list>
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which ends the span (i.e. exclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(System.Char[],System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <list type="bullet">
                <item><description>If the start index is less than 0, span will start from 0.</description></item>
                <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
            </list>
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which ends the span (i.e. exclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Span(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <list type="bullet">
                <item><description>If the start index is less than 0, span will start from 0.</description></item>
                <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
            </list>
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="start">The start index that the span begins.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which ends the span (i.e. exclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanAndCount(System.String,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Same as <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,ICU4N.Text.SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanCondition"></param>
            <param name="outCount">Returns the count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanAndCount(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Same as <see cref="M:ICU4N.Text.UnicodeSet.Span(System.Text.StringBuilder,ICU4N.Text.SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanCondition"></param>
            <param name="outCount">Returns the count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanAndCount(System.Char[],System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Same as <see cref="M:ICU4N.Text.UnicodeSet.Span(System.Char[],ICU4N.Text.SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanCondition"></param>
            <param name="outCount">Returns the count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanAndCount(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition,System.Int32@)">
            <summary>
            Same as <see cref="M:ICU4N.Text.UnicodeSet.Span(ICU4N.Support.Text.ICharSequence,ICU4N.Text.SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="spanCondition"></param>
            <param name="outCount">Returns the count.</param>
            <returns>The limit (exclusive end) of the span.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.String,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the end) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.Text.StringBuilder,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the end) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.Char[],ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the end) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(ICU4N.Support.Text.ICharSequence,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the end) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
            If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.Text.StringBuilder,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
            If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(System.Char[],System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
            If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.SpanBack(ICU4N.Support.Text.ICharSequence,System.Int32,ICU4N.Text.SpanCondition)">
            <summary>
            Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="T:ICU4N.Text.UnicodeSet"/>.
            If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
            If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
            <para/>
            To replace, count elements, or delete spans, see <see cref="T:ICU4N.Text.UnicodeSetSpanner"/>.
            </summary>
            <param name="s">The string to be spanned.</param>
            <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
            <param name="spanCondition">The span condition.</param>
            <returns>The string index which starts the span (i.e. inclusive).</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Collections.Generic.IEnumerable{System.Text.StringBuilder})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone(System.Collections.Generic.IEnumerable{System.Char[]})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.ContainsNone``1(System.Collections.Generic.IEnumerable{``0})">
            <seealso cref="M:ICU4N.Text.UnicodeSet.ContainsNone(ICU4N.Text.UnicodeSet)"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.String,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Text.StringBuilder,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Char[],System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
            and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Int32,System.String)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Int32,System.Text.StringBuilder)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Int32,System.Char[])">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.Compare(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility to compare a string to a code point.
            Same results as turning the code point into a string and comparing, but much faster (no object creation).
            Actually, there is one difference; a null compares as less.
            Note that this (=String) order is UTF-16 order -- *not* code point order.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCodePoint(System.String)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. 
            Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCodePoint(System.Text.StringBuilder)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. 
            Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCodePoint(System.Char[])">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. 
            Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.GetSingleCodePoint(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Return the value of the first code point, if the string is exactly one code point. 
            Otherwise return <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindIn(System.String,System.Int32,System.Boolean)">
            <summary>
            Find the first index at or after <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, length is returned.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindIn(System.Text.StringBuilder,System.Int32,System.Boolean)">
            <summary>
            Find the first index at or after <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, length is returned.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindIn(System.Char[],System.Int32,System.Boolean)">
            <summary>
            Find the first index at or after <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, length is returned.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindIn(ICU4N.Support.Text.ICharSequence,System.Int32,System.Boolean)">
            <summary>
            Find the first index at or after <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, length is returned.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindLastIn(System.String,System.Int32,System.Boolean)">
            <summary>
            Find the last index before <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, -1 is returned.
            BEFORE index is not in the <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindLastIn(System.Text.StringBuilder,System.Int32,System.Boolean)">
            <summary>
            Find the last index before <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, -1 is returned.
            BEFORE index is not in the <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindLastIn(System.Char[],System.Int32,System.Boolean)">
            <summary>
            Find the last index before <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, -1 is returned.
            BEFORE index is not in the <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.FindLastIn(ICU4N.Support.Text.ICharSequence,System.Int32,System.Boolean)">
            <summary>
            Find the last index before <paramref name="fromIndex"/> where the <see cref="T:ICU4N.Text.UnicodeSet"/> matches at that index.
            If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="T:ICU4N.Text.UnicodeSet"/> doesn't match.
            If there is no match, -1 is returned.
            BEFORE index is not in the <see cref="T:ICU4N.Text.UnicodeSet"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.StripFrom(System.String,System.Boolean)">
            <summary>
            Strips code points from source. If matches is true, script all that match <i>this</i>. 
            If matches is false, then strip all that <i>don't</i> match.
            </summary>
            <param name="source">The source of the <see cref="T:System.String"/> to strip from.</param>
            <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>The string after it has been stripped.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.StripFrom(System.Text.StringBuilder,System.Boolean)">
            <summary>
            Strips code points from source. If matches is true, script all that match <i>this</i>. 
            If matches is false, then strip all that <i>don't</i> match.
            </summary>
            <param name="source">The source of the <see cref="T:System.Text.StringBuilder"/> to strip from.</param>
            <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>The string after it has been stripped.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.StripFrom(System.Char[],System.Boolean)">
            <summary>
            Strips code points from source. If matches is true, script all that match <i>this</i>. 
            If matches is false, then strip all that <i>don't</i> match.
            </summary>
            <param name="source">The source of the <see cref="T:char[]"/> to strip from.</param>
            <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>The string after it has been stripped.</returns>
        </member>
        <member name="M:ICU4N.Text.UnicodeSet.StripFrom(ICU4N.Support.Text.ICharSequence,System.Boolean)">
            <summary>
            Strips code points from source. If matches is true, script all that match <i>this</i>. 
            If matches is false, then strip all that <i>don't</i> match.
            </summary>
            <param name="source">The source of the <see cref="T:ICU4N.Support.Text.ICharSequence"/> to strip from.</param>
            <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="T:ICU4N.Text.UnicodeSet"/> object.</param>
            <returns>The string after it has been stripped.</returns>
        </member>
        <member name="T:ICU4N.Text.RuleStatus">
            <summary>
            For <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/>s, the status tag from the
            break rule that determined the most recently
            returned break position. Other <see cref="T:ICU4N.Text.BreakIterator"/> types
            always return <see cref="F:ICU4N.Text.RuleStatus.WordNone"/>
            </summary>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordNone">
            <summary>
            Tag value for "words" that do not fit into any of other categories.
            Includes spaces and most punctuation.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordNoneLimit">
            <summary>
            Upper bound for tags for uncategorized words.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordNumber">
            <summary>
            Tag value for words that appear to be numbers, lower limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordNumberLimit">
            <summary>
            Tag value for words that appear to be numbers, upper limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordLetter">
            <summary>
            Tag value for words that contain letters, excluding
            hiragana, katakana or ideographic characters, lower limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordLetterLimit">
            <summary>
            Tag value for words containing letters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordKana">
            <summary>
            Tag value for words containing kana characters, lower limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordKanaLimit">
            <summary>
            Tag value for words containing kana characters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordIdeo">
            <summary>
            Tag value for words containing ideographic characters, lower limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.RuleStatus.WordIdeoLimit">
            <summary>
            Tag value for words containing ideographic characters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="T:ICU4N.Text.BreakIterator">
            <summary>
            A class that locates boundaries in text.  This class defines a protocol for
            objects that break up a piece of natural-language text according to a set
            of criteria.  Instances or subclasses of <see cref="T:ICU4N.Text.BreakIterator"/> can be provided, for
            example, to break a piece of text into words, sentences, or logical characters
            according to the conventions of some language or group of languages.
            </summary>
            <remarks>
            We provide five built-in types of <see cref="T:ICU4N.Text.BreakIterator"/>:
            <list type="table">
                <item>
                    <term><see cref="M:ICU4N.Text.BreakIterator.GetTitleInstance"/></term>
                    <description>Returns a <see cref="T:ICU4N.Text.BreakIterator"/> that locates boundaries between title breaks.</description></item>
                <item>
                    <term><see cref="M:ICU4N.Text.BreakIterator.GetSentenceInstance"/></term>
                    <description>
                        Returns a <see cref="T:ICU4N.Text.BreakIterator"/> that locates boundaries
                        between sentences.  This is useful for triple-click selection, for example.
                    </description></item>
                <item>
                    <term><see cref="M:ICU4N.Text.BreakIterator.GetWordInstance"/></term>
                    <description>
                        Returns a <see cref="T:ICU4N.Text.BreakIterator"/> that locates boundaries between
                        words.  This is useful for double-click selection or "find whole words" searches.
                        This type of <see cref="T:ICU4N.Text.BreakIterator"/> makes sure there is a boundary position at the
                        beginning and end of each legal word.  (Numbers count as words, too.)  Whitespace
                        and punctuation are kept separate from real words.
                    </description>
                </item>
                <item>
                    <term><see cref="M:ICU4N.Text.BreakIterator.GetLineInstance"/></term>
                    <description>
                        Returns a <see cref="T:ICU4N.Text.BreakIterator"/> that locates positions where it is
                        legal for a text editor to wrap lines.  This is similar to word breaking, but
                        not the same: punctuation and whitespace are generally kept with words (you don't
                        want a line to start with whitespace, for example), and some special characters
                        can force a position to be considered a line-break position or prevent a position
                        from being a line-break position.
                    </description>
                </item>
                <item>
                    <term><see cref="M:ICU4N.Text.BreakIterator.GetCharacterInstance"/></term>
                    <description>
                        Returns a <see cref="T:ICU4N.Text.BreakIterator"/> that locates boundaries between
                        logical characters.  Because of the structure of the Unicode encoding, a logical
                        character may be stored internally as more than one Unicode code point.  (A with an
                        umlaut may be stored as an a followed by a separate combining umlaut character,
                        for example, but the user still thinks of it as one character.)  This iterator allows
                        various processes (especially text editors) to treat as characters the units of text
                        that a user would think of as characters, rather than the units of text that the
                        computer sees as "characters".
                    </description>
                </item>
            </list>
            The text boundary positions are found according to the rules
            described in Unicode Standard Annex #29, Text Boundaries, and
            Unicode Standard Annex #14, Line Breaking Properties.  These
            are available at <a href="http://www.unicode.org/reports/tr14/">http://www.unicode.org/reports/tr14/</a> and
            <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>.
            <para/>
            BreakIterator's interface follows an "iterator" model (hence the name), meaning it
            has a concept of a "current position" and methods like <see cref="M:ICU4N.Text.BreakIterator.First"/>, <see cref="M:ICU4N.Text.BreakIterator.Last"/>, <see cref="M:ICU4N.Text.BreakIterator.Next"/>,
            and <see cref="M:ICU4N.Text.BreakIterator.Previous"/> that update the current position.  All <see cref="T:ICU4N.Text.BreakIterator"/>s uphold the
            following invariants:
            <list type="bullet">
                <item><description>
                    
                </description></item>
                <item><description>
                    The beginning and end of the text are always treated as boundary positions.
                </description></item>
                <item><description>
                    The current position of the iterator is always a boundary position (random-
                    access methods move the iterator to the nearest boundary position before or
                    after the specified position, not _to_ the specified position).
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.BreakIterator.Done"/> is used as a flag to indicate when iteration has stopped.  <see cref="F:ICU4N.Text.BreakIterator.Done"/> is only
                    returned when the current position is the end of the text and the user calls <see cref="M:ICU4N.Text.BreakIterator.Next"/>,
                    or when the current position is the beginning of the text and the user calls
                    <see cref="M:ICU4N.Text.BreakIterator.Previous"/>.
                </description></item>
                <item><description>
                    Break positions are numbered by the positions of the characters that follow
                    them.  Thus, under normal circumstances, the position before the first character
                    is 0, the position after the first character is 1, and the position after the
                    last character is 1 plus the length of the string.
                </description></item>
                <item><description>
                    The client can change the position of an iterator, or the text it analyzes,
                    at will, but cannot change the behavior.  If the user wants different behavior, he
                    must instantiate a new iterator.
                </description></item>
            </list>
            <para/>
            <see cref="T:ICU4N.Text.BreakIterator"/> accesses the text it analyzes through a <see cref="T:ICU4N.Support.Text.CharacterIterator"/>, which makes
            it possible to use <see cref="T:ICU4N.Text.BreakIterator"/> to analyze text in any text-storage vehicle that
            provides a <see cref="T:ICU4N.Support.Text.CharacterIterator"/> interface.
            <para/>
            <b>Note:</b>  Some types of BreakIterator can take a long time to create, and
            instances of BreakIterator are not currently cached by the system.  For
            optimal performance, keep instances of BreakIterator around as long as makes
            sense.  For example, when word-wrapping a document, don't create and destroy a
            new <see cref="T:ICU4N.Text.BreakIterator"/> for each line.  Create one break iterator for the whole document
            (or whatever stretch of text you're wrapping) and use it to do the whole job of
            wrapping the text.
            
            <para/>
            Creating and using text boundaries
            <code>
            public static void Main(string args[])
            {
                if (args.Length == 1)
                {
                    string stringToExamine = args[0];
                    //print each word in order
                    BreakIterator boundary = BreakIterator.GetWordInstance();
                    boundary.SetText(stringToExamine);
                    PrintEachForward(boundary, stringToExamine);
                    //print each sentence in reverse order
                    boundary = BreakIterator.GetSentenceInstance(new CultureInfo("en-US"));
                    boundary.SetText(stringToExamine);
                    PrintEachBackward(boundary, stringToExamine);
                    PrintFirst(boundary, stringToExamine);
                    PrintLast(boundary, stringToExamine);
                }
            }
            </code>
            Print each element in order
            <code>
            public static void PrintEachForward(BreakIterator boundary, string source)
            {
                int start = boundary.First();
                for (int end = boundary.Next();
                    end != BreakIterator.Done;
                    start = end, end = boundary.Next())
                {
                    Console.WriteLine(source.Substring(start, end - start));
                }
            }
            </code>
            Print each element in reverse order
            <code>
            public static void PrintEachBackward(BreakIterator boundary, string source)
            {
                int end = boundary.Last();
                for (int start = boundary.Previous();
                    start != BreakIterator.Done;
                    end = start, start = boundary.Previous())
                {
                    Console.WriteLine(source.Substring(start, end - start));
                }
            }
            </code>
            Print first element
            <code>
            public static void PrintFirst(BreakIterator boundary, string source)
            {
                int start = boundary.First();
                int end = boundary.Next();
                Console.WriteLine(source.Substring(start, end - start));
            }
            </code>
            Print last element
            <code>
            public static void PrintLast(BreakIterator boundary, string source)
            {
                int end = boundary.Last();
                int start = boundary.Previous();
                Console.WriteLine(source.Substring(start, end - start));
            }
            </code>
            Print the element at a specified position
            <code>
            public static void PrintAt(BreakIterator boundary, int pos, string source)
            {
                int end = boundary.Following(pos);
                int start = boundary.Previous();
                Console.WriteLine(source.Substring(start, end - start));
            }
            </code>
            Find the next word
            <code>
            public static int NextWordStartAfter(int pos, string text)
            {
                BreakIterator wb = BreakIterator.GetWordInstance();
                wb.SetText(text);
                int wordStart = wb.Following(pos);
                while (true)
                {
                    int wordLimit = wb.Next();
                    if (wordLimit == BreakIterator.Done)
                    {
                        return BreakIterator.Done;
                    }
                    int wordStatus = wb.RuleStatus;
                    if (wordStatus != RuleStatus.WordNone)
                    {
                        return wordStart;
                    }
                    wordStart = wordLimit;
                }
            }
            </code>
            <para/>
            The iterator returned by <see cref="M:ICU4N.Text.BreakIterator.GetWordInstance"/> is unique in that
            the break positions it returns don't represent both the start and end of the
            thing being iterated over.  That is, a sentence-break iterator returns breaks
            that each represent the end of one sentence and the beginning of the next.
            With the word-break iterator, the characters between two boundaries might be a
            word, or they might be the punctuation or whitespace between two words.  The
            above code uses <see cref="P:ICU4N.Text.BreakIterator.RuleStatus"/> to identify and ignore boundaries associated
            with punctuation or other non-word characters.
            </remarks>
            <seealso cref="T:ICU4N.Support.Text.CharacterIterator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.#ctor">
            <summary>
            Default constructor.  There is no state that is carried by this abstract
            base class.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Clone">
            <summary>
            Clone method.  Creates another <see cref="T:ICU4N.Text.BreakIterator"/> with the same behavior and
            current state as this one.
            </summary>
            <returns>The clone.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.Done">
            <summary>
            DONE is returned by <see cref="M:ICU4N.Text.BreakIterator.Previous"/> and <see cref="M:ICU4N.Text.BreakIterator.Next"/> after all valid
            boundaries have been returned.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.First">
            <summary>
            Set the iterator to the first boundary position.  This is always the beginning
            index of the text this iterator iterates over.  For example, if
            the iterator iterates over a whole string, this function will
            always return 0.
            </summary>
            <returns>The character offset of the beginning of the stretch of text
            being broken.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Last">
            <summary>
            Set the iterator to the last boundary position.  This is always the "past-the-end"
            index of the text this iterator iterates over.  For example, if the
            iterator iterates over a whole string (call it "text"), this function
            will always return text.Length.
            </summary>
            <returns>The character offset of the end of the stretch of text
            being broken.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Next(System.Int32)">
            <summary>
            Move the iterator by the specified number of steps in the text.
            A positive number moves the iterator forward; a negative number
            moves the iterator backwards. If this causes the iterator
            to move off either end of the text, this function returns <see cref="F:ICU4N.Text.BreakIterator.Done"/>;
            otherwise, this function returns the position of the appropriate
            boundary.  Calling this function is equivalent to calling <see cref="M:ICU4N.Text.BreakIterator.Next"/> or
            <see cref="M:ICU4N.Text.BreakIterator.Previous"/> <paramref name="n"/> times.
            </summary>
            <param name="n">The number of boundaries to advance over (if positive, moves
            forward; if negative, moves backwards).</param>
            <returns>The position of the boundary <paramref name="n"/> boundaries from the current
            iteration position, or <see cref="F:ICU4N.Text.BreakIterator.Done"/> if moving <paramref name="n"/> boundaries causes the iterator
            to advance off either end of the text.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Next">
            <summary>
            Advances the iterator forward one boundary.  The current iteration
            position is updated to point to the next boundary position after the
            current position, and this is also the value that is returned.  If
            the current position is equal to the value returned by <see cref="M:ICU4N.Text.BreakIterator.Last"/>, or to
            <see cref="F:ICU4N.Text.BreakIterator.Done"/>, this function returns <see cref="F:ICU4N.Text.BreakIterator.Done"/> and sets the current position to
            <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
            </summary>
            <returns>The position of the first boundary position following the
            iteration position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Previous">
            <summary>
            Move the iterator backward one boundary.  The current iteration
            position is updated to point to the last boundary position before
            the current position, and this is also the value that is returned.  If
            the current position is equal to the value returned by <see cref="M:ICU4N.Text.BreakIterator.First"/>, or to
            <see cref="F:ICU4N.Text.BreakIterator.Done"/>, this function returns <see cref="F:ICU4N.Text.BreakIterator.Done"/> and sets the current position to
            <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
            </summary>
            <returns>position of the last boundary position preceding the
            iteration position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Following(System.Int32)">
            <summary>
            Sets the iterator's current iteration position to be the first
            boundary position following the specified position.  (Whether the
            specified position is itself a boundary position or not doesn't
            matter-- this function always moves the iteration position to the
            first boundary after the specified position.)  If the specified
            position is the past-the-end position, returns <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
            </summary>
            <param name="offset">The character position to start searching from.</param>
            <returns>The position of the first boundary position following
            "<paramref name="offset"/>" (whether or not "offset" itself is a boundary position),
            or <see cref="F:ICU4N.Text.BreakIterator.Done"/> if "<paramref name="offset"/>" is the past-the-end offset.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Preceding(System.Int32)">
            <summary>
            Sets the iterator's current iteration position to be the last
            boundary position preceding the specified position.  (Whether the
            specified position is itself a boundary position or not doesn't
            matter-- this function always moves the iteration position to the
            last boundary before the specified position.)  If the specified
            position is the starting position, returns <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
            </summary>
            <param name="offset">The character position to start searching from.</param>
            <returns>The position of the last boundary position preceding
            "<paramref name="offset"/>" (whether of not "offset" itself is a boundary position),
            or <see cref="F:ICU4N.Text.BreakIterator.Done"/> if "<paramref name="offset"/>" is the starting offset of the iterator.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.IsBoundary(System.Int32)">
            <summary>
            Return true if the specified position is a boundary position.  If the
            function returns true, the current iteration position is set to the
            specified position; if the function returns false, the current
            iteration position is set as though <see cref="M:ICU4N.Text.BreakIterator.Following(System.Int32)"/> had been called.
            </summary>
            <param name="offset">The offset to check.</param>
            <returns>True if "<paramref name="offset"/>" is a boundary position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.BreakIterator.Current">
            <summary>
            Gets the iterator's current position.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordNone">
            <summary>
            Tag value for "words" that do not fit into any of other categories.
            Includes spaces and most punctuation.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordNoneLimit">
            <summary>
            Upper bound for tags for uncategorized words.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordNumber">
            <summary>
            Tag value for words that appear to be numbers, lower limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordNumberLimit">
            <summary>
            Tag value for words that appear to be numbers, upper limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordLetter">
            <summary>
            Tag value for words that contain letters, excluding
            hiragana, katakana or ideographic characters, lower limit.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordLetterLimit">
            <summary>
            Tag value for words containing letters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordKana">
            <summary>
            Tag value for words containing kana characters, lower limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordKanaLimit">
            <summary>
            Tag value for words containing kana characters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordIdeo">
            <summary>
            Tag value for words containing ideographic characters, lower limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.WordIdeoLimit">
            <summary>
            Tag value for words containing ideographic characters, upper limit
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="P:ICU4N.Text.BreakIterator.RuleStatus">
            <summary>
            For <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/>s, return the status tag from the
            break rule that determined the most recently
            returned break position.
            <para/>
            For break iterator types that do not support a rule status,
            a default value of 0 is returned.
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetRuleStatusVec(System.Int32[])">
            <summary>
            For <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/>s, get the status (tag) values from the break rule(s)
            that determined the most recently returned break position.
            <para/>
            For break iterator types that do not support rule status,
            no values are returned.
            <para/>
            If the size of the output array is insufficient to hold the data,
            the output will be truncated to the available length.  No exception
            will be thrown.
            </summary>
            <param name="fillInArray">An array to be filled in with the status values.</param>
            <returns>
            The number of rule status values from rules that determined
            the most recent boundary returned by the break iterator.
            In the event that the array is too small, the return value
            is the total number of status values that were available,
            not the reduced number that were actually returned.
            </returns>
            <stable>ICU 52</stable>
        </member>
        <member name="P:ICU4N.Text.BreakIterator.Text">
            <summary>
            Gets a <see cref="T:ICU4N.Support.Text.CharacterIterator"/> over the text being analyzed.
            For at least some subclasses of <see cref="T:ICU4N.Text.BreakIterator"/>, this is a reference
            to the <b>actual iterator being used</b> by the <see cref="T:ICU4N.Text.BreakIterator"/>,
            and therefore, this function's return value should be treated as
            <c>const</c>.  No guarantees are made about the current position
            of this iterator when it is returned.  If you need to move that
            position to examine the text, clone this function's return value first.
            </summary>
            <returns>A <see cref="T:ICU4N.Support.Text.CharacterIterator"/> over the text being analyzed.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetText(System.String)">
            <summary>
            Sets the iterator to analyze a new piece of text.  The new
            piece of text is passed in as a <see cref="T:System.String"/>, and the current
            iteration position is reset to the beginning of the string.
            (The old text is dropped.)
            </summary>
            <param name="newText">A <see cref="T:System.String"/> containing the text to analyze with
            this <see cref="T:ICU4N.Text.BreakIterator"/>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetText(System.Text.StringBuilder)">
            <summary>
            Sets the iterator to analyze a new piece of text.  The new
            piece of text is passed in as a <see cref="T:System.Text.StringBuilder"/>, and the current
            iteration position is reset to the beginning of the string.
            (The old text is dropped.)
            </summary>
            <param name="newText">A <see cref="T:System.Text.StringBuilder"/> containing the text to analyze with
            this <see cref="T:ICU4N.Text.BreakIterator"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetText(System.Char[])">
            <summary>
            Sets the iterator to analyze a new piece of text.  The new
            piece of text is passed in as a <see cref="T:char[]"/>, and the current
            iteration position is reset to the beginning of the string.
            (The old text is dropped.)
            </summary>
            <param name="newText">A <see cref="T:char[]"/> containing the text to analyze with
            this <see cref="T:ICU4N.Text.BreakIterator"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetText(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Sets the iterator to analyze a new piece of text.  The new
            piece of text is passed in as a <see cref="T:ICU4N.Support.Text.ICharSequence"/>, and the current
            iteration position is reset to the beginning of the text.
            (The old text is dropped.)
            </summary>
            <param name="newText">A <see cref="T:ICU4N.Support.Text.ICharSequence"/> containing the text to analyze with
            this <see cref="T:ICU4N.Text.BreakIterator"/>.</param>
            <draft>ICU 60</draft>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetText(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Sets the iterator to analyze a new piece of text.  The
            <see cref="T:ICU4N.Text.BreakIterator"/> is passed a <see cref="T:ICU4N.Support.Text.CharacterIterator"/> through which
            it will access the text itself.  The current iteration
            position is reset to the <see cref="T:ICU4N.Support.Text.CharacterIterator"/>'s start index.
            (The old iterator is dropped.)
            </summary>
            <param name="newText">A <see cref="T:ICU4N.Support.Text.CharacterIterator"/> referring to the text
            to analyze with this BreakIterator (the iterator's current
            position is ignored, but its other state is significant).</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_CHARACTER">
            <icu/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_WORD">
            <icu/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_LINE">
            <icu/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_SENTENCE">
            <icu/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_TITLE">
            <icu/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.KIND_COUNT">
            <since>ICU 2.8</since>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetWordInstance">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.
            This function assumes that the text being analyzed is in the default
            locale's language.
            </summary>
            <returns>An instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetWordInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.
            </summary>
            <param name="where">A <see cref="T:System.Globalization.CultureInfo"/> specifying the language of the text to be
            analyzed.</param>
            <returns>An instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetWordInstance(ICU4N.Util.ULocale)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.
            </summary>
            <param name="where">A <see cref="T:ICU4N.Util.ULocale"/> specifying the language of the text to be
            analyzed.</param>
            <returns>An instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates word boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetLineInstance">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal line-
            wrapping positions.  This function assumes the text being broken
            is in the default locale's language.
            </summary>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal
            line-wrapping positions.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetLineInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal line-
            wrapping positions.
            </summary>
            <param name="where">A <see cref="T:System.Globalization.CultureInfo"/> specifying the language of the text being broken.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal
            line-wrapping positions.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetLineInstance(ICU4N.Util.ULocale)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal line-
            wrapping positions.
            </summary>
            <param name="where">A <see cref="T:ICU4N.Util.ULocale"/> specifying the language of the text being broken.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates legal
            line-wrapping positions.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetCharacterInstance">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.  This function assumes that the text being analyzed is
            in the default locale's language.
            </summary>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetCharacterInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.
            </summary>
            <param name="where">A <see cref="T:System.Globalization.CultureInfo"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetCharacterInstance(ICU4N.Util.ULocale)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.
            </summary>
            <param name="where">A <see cref="T:ICU4N.Util.ULocale"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates logical-character
            boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetSentenceInstance">
            <summary>
            Returns a new instance of BreakIterator that locates sentence boundaries.
            This function assumes the text being analyzed is in the default locale's
            language.
            </summary>
            <returns>A new instance of BreakIterator that locates sentence boundaries.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetSentenceInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates sentence boundaries.
            </summary>
            <param name="where">A <see cref="T:System.Globalization.CultureInfo"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates sentence boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetSentenceInstance(ICU4N.Util.ULocale)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates sentence boundaries.
            </summary>
            <param name="where">A <see cref="T:ICU4N.Util.ULocale"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates sentence boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetTitleInstance">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.
            This function assumes the text being analyzed is in the default locale's
            language. The iterator returned locates title boundaries as described for
            Unicode 3.2 only. For Unicode 4.0 and above title boundary iteration,
            please use a word boundary iterator. <see cref="M:ICU4N.Text.BreakIterator.GetWordInstance"/>
            </summary>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetTitleInstance(System.Globalization.CultureInfo)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.
            The iterator returned locates title boundaries as described for
            Unicode 3.2 only. For Unicode 4.0 and above title boundary iteration,
            please use Word Boundary iterator. <see cref="M:ICU4N.Text.BreakIterator.GetWordInstance(System.Globalization.CultureInfo)"/>
            </summary>
            <param name="where">A <see cref="T:System.Globalization.CultureInfo"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetTitleInstance(ICU4N.Util.ULocale)">
            <icu/>
            <summary>
            Returns a new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.
            The iterator returned locates title boundaries as described for
            Unicode 3.2 only. For Unicode 4.0 and above title boundary iteration,
            please use Word Boundary iterator. <see cref="M:ICU4N.Text.BreakIterator.GetWordInstance(ICU4N.Util.ULocale)"/>
            </summary>
            <param name="where">A <see cref="T:ICU4N.Util.ULocale"/> specifying the language of the text being analyzed.</param>
            <returns>A new instance of <see cref="T:ICU4N.Text.BreakIterator"/> that locates title boundaries.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="where"/> is null.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator,System.Globalization.CultureInfo,System.Int32)">
            <icu/>
            <summary>
            Registers a new break iterator of the indicated kind, to use in the given
            locale.  Clones of the iterator will be returned if a request for a break iterator
            of the given kind matches or falls back to this locale.
            <para/>
            Because ICU may choose to cache <see cref="T:ICU4N.Text.BreakIterator"/> objects internally, this must
            be called at application startup, prior to any calls to
            BreakIterator.GetXYZInstance(where) to avoid undefined behavior.
            </summary>
            <param name="iter">The <see cref="T:ICU4N.Text.BreakIterator"/> instance to adopt.</param>
            <param name="locale">The <see cref="T:System.Globalization.CultureInfo"/> for which this instance is to be registered.</param>
            <param name="kind">The type of iterator for which this instance is to be registered.</param>
            <returns>A registry key that can be used to unregister this instance.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator,ICU4N.Util.ULocale,System.Int32)">
            <icu/>
            <summary>
            Registers a new break iterator of the indicated kind, to use in the given
            locale.  Clones of the iterator will be returned if a request for a break iterator
            of the given kind matches or falls back to this locale.
            <para/>
            Because ICU may choose to cache <see cref="T:ICU4N.Text.BreakIterator"/> objects internally, this must
            be called at application startup, prior to any calls to
            BreakIterator.GetXYZInstance(where) to avoid undefined behavior.
            </summary>
            <param name="iter">The <see cref="T:ICU4N.Text.BreakIterator"/> instance to adopt.</param>
            <param name="locale">The <see cref="T:ICU4N.Util.ULocale"/> for which this instance is to be registered.</param>
            <param name="kind">The type of iterator for which this instance is to be registered.</param>
            <returns>A registry key that can be used to unregister this instance.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.Unregister(System.Object)">
            <icu/>
            <summary>
            Unregisters a previously-registered <see cref="T:ICU4N.Text.BreakIterator"/> using the key returned
            from the register call.  Key becomes invalid after this call and should not be used
            again.
            </summary>
            <param name="key">The registry key returned by a previous call to 
            <see cref="M:ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator,System.Globalization.CultureInfo,System.Int32)"/>
            or <see cref="M:ICU4N.Text.BreakIterator.RegisterInstance(ICU4N.Text.BreakIterator,ICU4N.Util.ULocale,System.Int32)"/>.</param>
            <returns>true if the iterator for the key was successfully unregistered.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetBreakInstance(ICU4N.Util.ULocale,System.Int32)">
            <summary>
            Returns a particular kind of <see cref="T:ICU4N.Text.BreakIterator"/> for a locale.
            Avoids writing a switch statement with GetXYZInstance(where) calls.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetAvailableCultures">
            <summary>
            Returns a list of locales for which <see cref="T:ICU4N.Text.BreakIterator"/>s can be used.
            </summary>
            <returns>An array of <see cref="T:System.Globalization.CultureInfo"/>s.  All of the locales in the array can
            be used when creating a <see cref="T:ICU4N.Text.BreakIterator"/>.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetAvailableULocales">
            <summary>
            Returns a list of locales for which <see cref="T:ICU4N.Text.BreakIterator"/>s can be used.
            </summary>
            <returns>An array of <see cref="T:ICU4N.Util.ULocale"/>s.  All of the locales in the array can
            be used when creating a <see cref="T:ICU4N.Text.BreakIterator"/>.</returns>
            <draft>ICU 3.2 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.GetLocale(ICU4N.Util.ULocale.Type)">
            <icu/>
            <summary>
            Returns the locale that was used to create this object, or null.
            This may may differ from the locale requested at the time of
            this object's creation.  For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <tt>en_US</tt> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: The <i>actual</i> locale is returned correctly, but the <i>valid</i>
            locale is not, in most cases.
            </summary>
            <param name="type">Type of information requested, either 
            <see cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            or <see cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>.</param>
            <returns>The information specified by <i>type</i>, or null if
            this object was not constructed from locale data.</returns>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.BreakIterator.SetLocale(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            <summary>
            Set information about the locales that were used to create this
            object.  If the object was not constructed from locale data,
            both arguments should be set to null.  Otherwise, neither
            should be null.  The actual locale must be at the same level or
            less specific than the valid locale.  This method is intended
            for use by factories or other entities that create objects of
            this class.
            </summary>
            <param name="valid">The most specific locale containing any resource
            data, or null.</param>
            <param name="actual">The locale containing data used to construct this
            object, or null.</param>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.validLocale">
            <summary>
            The most specific locale containing any resource data, or null.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
        </member>
        <member name="F:ICU4N.Text.BreakIterator.actualLocale">
            <summary>
            The locale containing data used to construct this object, or
            null.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
        </member>
        <member name="T:ICU4N.Text.BreakIteratorFactory">
            <author>Ram</author>
        </member>
        <member name="M:ICU4N.Text.BreakIteratorFactory.BFService.ValidateFallbackLocale">
            <summary>
            <see cref="M:ICU4N.Text.BreakIteratorFactory.CreateBreakInstance(ICU4N.Util.ULocale,System.Int32)"/> returns an appropriate <see cref="T:ICU4N.Text.BreakIterator"/> for any locale.
            It falls back to root if there is no specific data.
            <para/>
            Without this override, the service code would fall back to the default locale
            which is not desirable for an algorithm with a good Unicode default,
            like break iteration.
            </summary>
        </member>
        <member name="F:ICU4N.Text.BreakIteratorFactory.KIND_NAMES">
            <summary>
            KIND_NAMES are the resource key to be used to fetch the name of the
                        pre-compiled break rules.  The resource bundle name is "boundaries".
                        The value for each key will be the rules to be used for the
                        specified locale - "word" -> "word_th" for Thai, for example.            
            </summary>
        </member>
        <member name="T:ICU4N.Text.CanonicalIterator">
            <summary>
            This class allows one to iterate through all the strings that are canonically equivalent to a given
            string. 
            </summary>
            <remarks>
            For example, here are some sample results:
            Results for: {A WITH RING ABOVE}{d}{DOT ABOVE}{CEDILLA}
            <list type="number">
                <item><description>{A}{RING ABOVE}{d}{DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{A}{RING ABOVE}{d}{CEDILLA}{DOT ABOVE}</description></item>
                <item><description>{A}{RING ABOVE}{d WITH DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{A}{RING ABOVE}{d WITH CEDILLA}{DOT ABOVE}</description></item>
                <item><description>{A WITH RING ABOVE}{d}{DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{A WITH RING ABOVE}{d}{CEDILLA}{DOT ABOVE}</description></item>
                <item><description>{A WITH RING ABOVE}{d WITH DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{A WITH RING ABOVE}{d WITH CEDILLA}{DOT ABOVE}</description></item>
                <item><description>{ANGSTROM SIGN}{d}{DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{ANGSTROM SIGN}{d}{CEDILLA}{DOT ABOVE}</description></item>
                <item><description>{ANGSTROM SIGN}{d WITH DOT ABOVE}{CEDILLA}</description></item>
                <item><description>{ANGSTROM SIGN}{d WITH CEDILLA}{DOT ABOVE}</description></item>
            </list>
            <para/>
            Note: the code is intended for use with small strings, and is not suitable for larger ones,
            since it has not been optimized for that situation.
            </remarks>
            <author>M. Davis</author>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.#ctor(System.String)">
            <summary>
            Construct a <see cref="T:ICU4N.Text.CanonicalIterator"/> object.
            </summary>
            <param name="source">String to get results for.</param>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.CanonicalIterator.Source">
            <summary>
            Gets the NFD form of the current source we are iterating over.
            NOTE: it is the NFD form of the source originally passed in.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.Reset">
            <summary>
            Resets the iterator so that one can start again from the beginning.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.Next">
            <summary>
            Get the next canonically equivalent string.
            <para/>
            <b>Warning: The strings are not guaranteed to be in any particular order.</b>
            </summary>
            <returns>The next string that is canonically equivalent. The value null is returned when
            the iteration is done.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.SetSource(System.String)">
            <summary>
            Set a new source for this iterator. Allows object reuse.
            </summary>
            <param name="newSource">The source string to iterate against. This allows the same iterator to be used
            while changing the source string, saving object creation.</param>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.Permute(System.String,System.Boolean,System.Collections.Generic.ISet{System.String})">
            <summary>
            Simple implementation of permutation.
            <para/>
            <b>Warning: The strings are not guaranteed to be in any particular order.</b>
            </summary>
            <param name="source">The string to find permutations for.</param>
            <param name="skipZeros">Set to true to skip characters with canonical combining class zero.</param>
            <param name="output">The set to add the results to.</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.CanonicalIterator.Extract(System.Int32,System.String,System.Int32,System.Text.StringBuilder)">
            <summary>
            See if the decomposition of cp2 is at segment starting at <paramref name="segmentPos"/>
            (with canonical rearrangment!).
            If so, take the remainder, and return the equivalents.
            </summary>
            <param name="comp"></param>
            <param name="segment"></param>
            <param name="segmentPos"></param>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="T:ICU4N.Text.CaseMap">
            <summary>
            Low-level case mapping options and methods. Immutable.
            "Setters" return instances with the union of the current and new options set.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.ToLower">
            <summary>
            Returns lowercasing object with default options.
            </summary>
            <returns>Lowercasing object with default options.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.ToUpper">
            <summary>
            Returns uppercasing object with default options.
            </summary>
            <returns>Uppercasing object with default options.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.ToTitle">
            <summary>
            Returns titlecasing object with default options.
            </summary>
            <returns>Titlecasing object with default options.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.ToFold">
            <summary>
            Returns case folding object with default options.
            </summary>
            <returns>Case folding object with default options.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.CaseMap.Lower">
            <summary>
            Lowercasing options and methods. Immutable.
            </summary>
            <seealso cref="M:ICU4N.Text.CaseMap.ToLower"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText">
            <summary>
            Returns an instance that behaves like this one but
            omits unchanged text when case-mapping with <see cref="T:ICU4N.Text.Edits"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.String)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Text.StringBuilder)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Char[])">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.String)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.Text.StringBuilder)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.Char[])">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Lowercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Globalization.CultureInfo,System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Globalization.CultureInfo,System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Globalization.CultureInfo,System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Lower.Apply``1(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Lowercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Lower.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToLower(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.CaseMap.Upper">
            <summary>
            Uppercasing options and methods. Immutable.
            </summary>
            <seealso cref="M:ICU4N.Text.CaseMap.ToUpper"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText">
            <summary>
            Returns an instance that behaves like this one but
            omits unchanged text when case-mapping with <see cref="T:ICU4N.Text.Edits"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.String)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Text.StringBuilder)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Char[])">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.String)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.Text.StringBuilder)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.Char[])">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Uppercases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Globalization.CultureInfo,System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Globalization.CultureInfo,System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Globalization.CultureInfo,System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Upper.Apply``1(System.Globalization.CultureInfo,ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Uppercases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Upper.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="dest"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToUpper(System.Globalization.CultureInfo,System.String)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.CaseMap.Title">
            <summary>
            Titlecasing options and methods. Immutable.
            </summary>
            <seealso cref="M:ICU4N.Text.CaseMap.ToTitle"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.WholeString">
            <summary>
            Returns an instance that behaves like this one but
            titlecases the string as a whole rather than each word.
            (Titlecases only the character at index 0, possibly adjusted.)
            <para/>
            It is an error to specify multiple titlecasing iterator options together,
            including both an option and an explicit <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <seealso cref="M:ICU4N.Text.CaseMap.Title.AdjustToCased"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Sentences">
            <summary>
            Returns an instance that behaves like this one but
            titlecases sentences rather than words.
            (Titlecases only the first character of each sentence, possibly adjusted.)
            <para/>
            It is an error to specify multiple titlecasing iterator options together,
            including both an option and an explicit <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <seealso cref="M:ICU4N.Text.CaseMap.Title.AdjustToCased"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText">
            <summary>
            Returns an instance that behaves like this one but
            omits unchanged text when case-mapping with <see cref="T:ICU4N.Text.Edits"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.NoLowercase">
            <summary>
            Returns an instance that behaves like this one but
            does not lowercase non-initial parts of words when titlecasing.
            <para/>
            By default, titlecasing will titlecase the character at each
            (possibly adjusted) <see cref="T:ICU4N.Text.BreakIterator"/> index and
            lowercase all other characters up to the next iterator index.
            With this option, the other characters will not be modified.
            </summary>
            <returns>An options object with this option.</returns>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoLowerCase"/>
            <seealso cref="M:ICU4N.Text.CaseMap.Title.AdjustToCased"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.NoBreakAdjustment">
            <summary>
            Returns an instance that behaves like this one but
            does not adjust the titlecasing <see cref="T:ICU4N.Text.BreakIterator"/> indexes;
            titlecases exactly the characters at breaks from the iterator.
            <para/>
            By default, titlecasing will take each break iterator index,
            adjust it to the next relevant character (see <see cref="M:ICU4N.Text.CaseMap.Title.AdjustToCased"/>),
            and titlecase that one.
            <para/>
            Other characters are lowercased.
            </summary>
            <returns>An options object with this option.</returns>
            <seealso cref="F:ICU4N.UChar.TitleCaseNoBreakAdjustment"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.AdjustToCased">
            <summary>
            Returns an instance that behaves like this one but
            adjusts each titlecasing <see cref="T:ICU4N.Text.BreakIterator"/> index to the next cased character.
            (See the Unicode Standard, chapter 3, Default Case Conversion, R3 toTitlecase(X).)
            </summary>
            <remarks>
            This used to be the default index adjustment in ICU.
            Since ICU 60, the default index adjustment is to the next character that is
            a letter, number, symbol, or private use code point.
            (Uncased modifier letters are skipped.)
            The difference in behavior is small for word titlecasing,
            but the new adjustment is much better for whole-string and sentence titlecasing:
            It yields "49ers" and "(abc)" instead of "49Ers" and "(Abc)".
            <para/>
            It is an error to specify multiple titlecasing adjustment options together.
            </remarks>
            <returns>An options object with this option.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
            <seealso cref="M:ICU4N.Text.CaseMap.Title.NoBreakAdjustment"/>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.String)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.Text.StringBuilder)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.Char[])">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.String)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Text.StringBuilder)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Char[])">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Titlecases a string.
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(ICU4N.Text.BreakIterator,System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(ICU4N.Text.BreakIterator,System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(ICU4N.Text.BreakIterator,System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU4N 60.1.0</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Title.Apply``1(System.Globalization.CultureInfo,ICU4N.Text.BreakIterator,ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Titlecases a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Title.OmitUnchangedText"/>).
            Casing is locale-dependent and context-sensitive.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Titlecasing uses a break iterator to find the first characters of words
            that are to be titlecased. It titlecases those characters and lowercases
            all others. (This can be modified with options bits.)
            </remarks>
            <param name="locale">The locale ID. Can be null for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.</param>
            <param name="iter">
            A break iterator to find the first characters of words that are to be titlecased.
            It is set to the source string (SetText())
            and used one or more times for iteration (First() and Next()).
            If null, then a word break iterator for the locale is used
            (or something equivalent).
            </param>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.ToTitleCase(System.Globalization.CultureInfo,System.String,ICU4N.Text.BreakIterator,System.Int32)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.CaseMap.Fold">
            <summary>
            Case folding options and methods. Immutable.
            </summary>
            <seealso cref="M:ICU4N.Text.CaseMap.ToFold"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText">
            <summary>
            Returns an instance that behaves like this one but
            omits unchanged text when case-mapping with <see cref="T:ICU4N.Text.Edits"/>.
            </summary>
            <returns>An options object with this option.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Turkic">
            <summary>
            Returns an instance that behaves like this one but
            handles dotted I and dotless i appropriately for Turkic languages (tr, az).
            <para/>
            Uses the Unicode CaseFolding.txt mappings marked with 'T' that
            are to be excluded for default mappings and
            included for the Turkic-specific mappings.
            </summary>
            <returns>An options object with this option.</returns>
            <seealso cref="F:ICU4N.UChar.FoldCaseExcludeSpecialI"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.String)">
            <summary>
            Case-folds a string.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.Text.StringBuilder)">
            <summary>
            Case-folds a string.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.Char[])">
            <summary>
            Case-folds a string.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Case-folds a string.
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <returns>The result string.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.String,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(System.Char[],System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply``1(System.String,``0,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply``1(System.Text.StringBuilder,``0,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply``1(System.Char[],``0,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.CaseMap.Fold.Apply``1(ICU4N.Support.Text.ICharSequence,``0,ICU4N.Text.Edits)">
            <summary>
            Case-folds a string and optionally records edits (see <see cref="M:ICU4N.Text.CaseMap.Fold.OmitUnchangedText"/>).
            The result may be longer or shorter than the original.
            </summary>
            <remarks>
            Case-folding is locale-independent and not context-sensitive,
            but there is an option for whether to include or exclude mappings for dotted I
            and dotless i that are marked with 'T' in CaseFolding.txt.
            </remarks>
            <param name="src">The original string.</param>
            <param name="dest">A buffer for the result string. Must not be null.</param>
            <param name="edits">
            Records edits for index mapping, working with styled text,
            and getting only changes (if any).
            This function calls <see cref="M:ICU4N.Text.Edits.Reset"/> first. <paramref name="edits"/> can be null.
            </param>
            <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
            <seealso cref="M:ICU4N.UChar.FoldCase(System.String,ICU4N.Globalization.FoldCase)"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.ComposedCharIter">
            <summary>
            This class has been deprecated since ICU 2.2.
            One problem is that this class is not designed to return supplementary characters.
            Use the <see cref="T:ICU4N.Text.Normalizer2"/> and <see cref="T:ICU4N.UChar"/> classes instead.
            </summary>
            <remarks>
            <see cref="T:ICU4N.Text.ComposedCharIter"/> is an iterator class that returns all
            of the precomposed characters defined in the Unicode standard, along
            with their decomposed forms.  This is often useful when building
            data tables (<i>e.g.</i> collation tables) which need to treat composed
            and decomposed characters equivalently.
            <para/>
            For example, imagine that you have built a collation table with ordering
            rules for the canonically decomposed (<see cref="F:ICU4N.Text.Normalizer.DECOMP"/>) forms of all
            characters used in a particular language.  When you process input text using
            this table, the text must first be decomposed so that it matches the form
            used in the table.  This can impose a performance penalty that may be
            unacceptable in some situations.
            <para/>
            You can avoid this problem by ensuring that the collation table contains
            rules for both the decomposed <i>and</i> composed versions of each character.
            To do so, use a <see cref="T:ICU4N.Text.ComposedCharIter"/> to iterate through all of the
            composed characters in Unicode.  If the decomposition for that character
            consists solely of characters that are listed in your ruleset, you can
            add a new rule for the composed character that makes it equivalent to
            its decomposition sequence.
            <para/>
            Note that <see cref="T:ICU4N.Text.ComposedCharIter"/> iterates over a <em>static</em> table
            of the composed characters in Unicode.  If you want to iterate over the
            composed characters in a particular string, use <see cref="T:ICU4N.Text.Normalizer"/> instead.
            <para/>
            When constructing a <see cref="T:ICU4N.Text.ComposedCharIter"/> there is one
            optional feature that you can enable or disable:
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Text.Normalizer.IGNORE_HANGUL"/> - Do not iterate over the Hangul
                     characters and their corresponding Jamo decompositions.
                     This option is off by default (<i>i.e.</i> Hangul processing is enabled)
                     since the Unicode standard specifies that Hangul to Jamo 
                     is a canonical decomposition.</description></item>
            </list>
            <para/>
            <see cref="T:ICU4N.Text.ComposedCharIter"/> is currently based on version 2.1.8 of the
            <a href="http://www.unicode.org" target="unicode">Unicode Standard</a>.
            It will be updated as later versions of Unicode are released.
            </remarks>
        </member>
        <member name="F:ICU4N.Text.ComposedCharIter.DONE">
            <summary>
            Constant that indicates the iteration has completed.
            <see cref="M:ICU4N.Text.ComposedCharIter.Next"/> returns this value when there are no more composed characters
            over which to iterate.
            </summary>
        </member>
        <member name="M:ICU4N.Text.ComposedCharIter.#ctor">
            <summary>
            Construct a new <see cref="T:ICU4N.Text.ComposedCharIter"/>.  The iterator will return
            all Unicode characters with canonical decompositions, including Korean
            Hangul characters.
            </summary>
        </member>
        <member name="M:ICU4N.Text.ComposedCharIter.#ctor(System.Boolean,System.Int32)">
            <summary>
            Constructs a non-default <see cref="T:ICU4N.Text.ComposedCharIter"/> with optional behavior.
            </summary>
            <param name="compat"><tt>false</tt> for canonical decompositions only;
            <tt>true</tt> for both canonical and compatibility decompositions.</param>
            <param name="options">Optional decomposition features. None are supported, so this is ignored.</param>
        </member>
        <member name="P:ICU4N.Text.ComposedCharIter.HasNext">
            <summary>
            Determines whether there any precomposed Unicode characters not yet returned
            by <see cref="M:ICU4N.Text.ComposedCharIter.Next"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.ComposedCharIter.Next">
            <summary>
            Returns the next precomposed Unicode character.
            Repeated calls to <see cref="M:ICU4N.Text.ComposedCharIter.Next"/> return all of the precomposed characters defined
            by Unicode, in ascending order.  After all precomposed characters have
            been returned, <see cref="P:ICU4N.Text.ComposedCharIter.HasNext"/> will return <c>false</c> and further calls
            to <see cref="M:ICU4N.Text.ComposedCharIter.Next"/> will return <see cref="F:ICU4N.Text.ComposedCharIter.DONE"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.ComposedCharIter.Decomposition">
            <summary>
            Returns the Unicode decomposition of the current character.
            This method returns the decomposition of the precomposed character most
            recently returned by <see cref="M:ICU4N.Text.ComposedCharIter.Next"/>.  The resulting decomposition is
            affected by the settings of the options passed to the constructor.
            </summary>
        </member>
        <member name="T:ICU4N.Text.CurrencyDisplayNames">
            <summary>
            Returns currency names localized for a locale.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(ICU4N.Util.ULocale)">
            <summary>
            Return an instance of <see cref="T:ICU4N.Text.CurrencyDisplayNames"/> that provides information
            localized for display in the provided locale.  If there is no data for the
            provided locale, this falls back to the current default locale; if there
            is no data for that either, it falls back to the root locale.  Substitute
            values are returned from APIs when there is no data for the requested ISO
            code.
            </summary>
            <param name="locale">The locale into which to localize the names.</param>
            <returns>A <see cref="T:ICU4N.Text.CurrencyDisplayNames"/>.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Return an instance of CurrencyDisplayNames that provides information
            localized for display in the provided locale.  If there is no data for the
            provided locale, this falls back to the current default locale; if there
            is no data for that either, it falls back to the root locale.  Substitute
            values are returned from APIs when there is no data for the requested ISO
            code.
            </summary>
            <param name="locale">The locale into which to localize the names.</param>
            <returns>A CurrencyDisplayNames.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(ICU4N.Util.ULocale,System.Boolean)">
            <summary>
            Return an instance of <see cref="T:ICU4N.Text.CurrencyDisplayNames"/> that provides information
            localized for display in the provided locale.  If noSubstitute is false,
            this behaves like <see cref="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(ICU4N.Util.ULocale)"/>.  Otherwise, 1) if there
            is no supporting data for the locale at all, there is no fallback through
            the default locale or root, and null is returned, and 2) if there is data
            for the locale, but not data for the requested ISO code, null is returned
            from those APIs instead of a substitute value.
            </summary>
            <param name="locale">The locale into which to localize the names.</param>
            <param name="noSubstitute">If true, do not return substitute values.</param>
            <returns>A <see cref="T:ICU4N.Text.CurrencyDisplayNames"/>.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Return an instance of CurrencyDisplayNames that provides information
            localized for display in the provided locale.  If noSubstitute is false,
            this behaves like <see cref="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(System.Globalization.CultureInfo)"/>.  Otherwise, 1) if there
            is no supporting data for the locale at all, there is no fallback through
            the default locale or root, and null is returned, and 2) if there is data
            for the locale, but not data for the requested ISO code, null is returned
            from those APIs instead of a substitute value.
            </summary>
            <param name="locale">The <see cref="T:System.Globalization.CultureInfo"/> into which to localize the names.</param>
            <param name="noSubstitute">If true, do not return substitute values.</param>
            <returns>A <see cref="T:ICU4N.Text.CurrencyDisplayNames"/>.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="P:ICU4N.Text.CurrencyDisplayNames.HasData">
            <summary>
            Returns true if currency display name data is available.
            </summary>
        </member>
        <member name="P:ICU4N.Text.CurrencyDisplayNames.ULocale">
            <summary>
            Returns the locale used to determine how to translate the currency names.
            This is not necessarily the same locale passed to <see cref="M:ICU4N.Text.CurrencyDisplayNames.GetInstance(ICU4N.Util.ULocale)"/>.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetSymbol(System.String)">
            <summary>
            Returns the symbol for the currency with the provided ISO code.  If
            there is no data for the ISO code, substitutes isoCode or returns null.
            </summary>
            <param name="isoCode">The three-letter ISO code.</param>
            <returns>The display name.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetName(System.String)">
            <summary>
            Returns the 'long name' for the currency with the provided ISO code.
            If there is no data for the ISO code, substitutes isoCode or returns null.
            </summary>
            <param name="isoCode">The three-letter ISO code.</param>
            <returns>The display name.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.GetPluralName(System.String,System.String)">
            <summary>
            Returns a 'plural name' for the currency with the provided ISO code corresponding to
            the <paramref name="pluralKey"/>.  If there is no data for the ISO code, substitutes <paramref name="isoCode"/> or
            returns null.  If there is data for the ISO code but no data for the plural key,
            substitutes the 'other' value (and failing that the <paramref name="isoCode"/>) or returns null.
            </summary>
            <param name="isoCode">The three-letter ISO code.</param>
            <param name="pluralKey">The plural key, for example "one", "other".</param>
            <returns>The display name.</returns>
            <seealso cref="T:ICU4N.Text.PluralRules"/>
            <stable>ICU 4.4</stable>
        </member>
        <member name="P:ICU4N.Text.CurrencyDisplayNames.SymbolMap">
            <summary>
            Returns a mapping from localized symbols and currency codes to currency codes.
            The returned map is unmodifiable.
            </summary>
            <returns>The map.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="P:ICU4N.Text.CurrencyDisplayNames.NameMap">
            <summary>
            Returns a mapping from localized names (standard and plural) to currency codes.
            The returned map is unmodifiable.
            </summary>
            <returns>The map.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.CurrencyDisplayNames.#ctor">
            <summary>
            Sole constructor.  (For invocation by subclass constructors,
            typically implicit.)
            </summary>
        </member>
        <member name="T:ICU4N.Text.DictionaryBreakEngine.PossibleWord">
            <summary>
            Helper class for improving readability of the Thai/Lao/Khmer word break
            algorithm.
            </summary>
        </member>
        <member name="T:ICU4N.Text.DictionaryBreakEngine.DequeI">
            <summary>
            A deque-like structure holding raw <see cref="T:System.Int32"/>s.
            Partial, limited implementation, only what is needed by the dictionary implementation.
            For internal use only.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.DictionaryBreakEngine.#ctor(System.Int32[])">
            <param name="breakTypes">The types of break iterators that can use this engine.
            For example, <see cref="F:ICU4N.Text.BreakIterator.KIND_LINE"/>.</param>
        </member>
        <member name="M:ICU4N.Text.DictionaryBreakEngine.DivideUpDictionaryRange(ICU4N.Support.Text.CharacterIterator,System.Int32,System.Int32,ICU4N.Text.DictionaryBreakEngine.DequeI)">
            <summary>
            Divide up a range of known dictionary characters handled by this break engine.
            </summary>
            <param name="text">A <see cref="T:ICU4N.Support.Text.CharacterIterator"/> representing the text.</param>
            <param name="rangeStart">The start of the range of dictionary characters.</param>
            <param name="rangeEnd">The end of the range of dictionary characters.</param>
            <param name="foundBreaks">Output of break positions. Positions are pushed.
            Pre-existing contents of the output stack are unaltered.</param>
            <returns>The number of breaks found.</returns>
        </member>
        <member name="T:ICU4N.Text.DictionaryMatcher">
            <summary>
            The <see cref="T:ICU4N.Text.DictionaryMatcher"/> interface is used to allow arbitrary "types" of
            back-end data structures to be used with the break iteration code.
            </summary>
        </member>
        <member name="M:ICU4N.Text.DictionaryMatcher.Matches(ICU4N.Support.Text.CharacterIterator,System.Int32,System.Int32[],System.Int32[],System.Int32,System.Int32[])">
            <summary>
            Find dictionary words that match the text.
            </summary>
            <param name="text">A <see cref="T:ICU4N.Support.Text.CharacterIterator"/> representing the text. The iterator is
            left after the longest prefix match in the dictionary.</param>
            <param name="maxLength">The maximum number of code units to match.</param>
            <param name="lengths">An array that is filled with the lengths of words that matched.</param>
            <param name="count">Filled with the number of elements output in lengths.</param>
            <param name="limit">The maximum amount of words to output. Must be less than or equal to lengths.Length.</param>
            <param name="values">Filled with the weight values associated with the various words.</param>
            <returns>The number of characters in text that were matched.</returns>
        </member>
        <member name="P:ICU4N.Text.DictionaryMatcher.Type">
            <summary>
            Gets the kind of dictionary that this matcher is using.
            </summary>
        </member>
        <member name="T:ICU4N.Text.DisplayContext">
            <summary>
            Display context settings.
            Note, the specific numeric values are internal and may change.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.StandardNames">
            ================================
            Settings for DIALECT_HANDLING (use one)
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.DialectHandling"/>:
            use standard names when generating a locale name,
            e.g. en_GB displays as 'English (United Kingdom)'.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.DialectNames">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.DialectHandling"/>:
            use dialect names, when generating a locale name,
            e.g. en_GB displays as 'British English'.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.CapitalizationNone">
            ================================
            Settings for CAPITALIZATION (use one)
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>:
            The capitalization context to be used is unknown (this is the default value).
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.CapitalizationForMiddleOfSentence">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>:
            The capitalization context if a date, date symbol or display name is to be
            formatted with capitalization appropriate for the middle of a sentence.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.CapitalizationForBeginningOfSentence">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>:
            The capitalization context if a date, date symbol or display name is to be
            formatted with capitalization appropriate for the beginning of a sentence.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.CapitalizationForUIListOrMenu">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>:
            The capitalization context if a date, date symbol or display name is to be
            formatted with capitalization appropriate for a user-interface list or menu item.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.CapitalizationForStandalone">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>:
            The capitalization context if a date, date symbol or display name is to be
            formatted with capitalization appropriate for stand-alone usage such as an
            isolated name on a calendar page.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.LengthFull">
            ================================
            Settings for DISPLAY_LENGTH (use one)
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.DisplayLength"/>:
            use full names when generating a locale name,
            e.g. "United States" for US.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.LengthShort">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.DisplayLength"/>:
            use short names when generating a locale name,
            e.g. "U.S." for US.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.Substitute">
            ================================
            Settings for SUBSTITUTE_HANDLING (choose one)
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.SubstituteHandling"/>:
            Returns a fallback value (e.g., the input code) when no data is available.
            This is the default behavior.
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContext.NoSubstitute">
            <summary>
            A possible setting for <see cref="F:ICU4N.Text.DisplayContextType.SubstituteHandling"/>:
            Returns a null value when no data is available.
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="T:ICU4N.Text.DisplayContextType">
            <summary>
            Type values for <see cref="T:ICU4N.Text.DisplayContext"/>.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContextType.DialectHandling">
            <summary>
            <see cref="F:ICU4N.Text.DisplayContextType.DialectHandling"/> can be set to <see cref="F:ICU4N.Text.DisplayContext.StandardNames"/> 
            or <see cref="F:ICU4N.Text.DisplayContext.DialectNames"/>.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContextType.Capitalization">
            <summary>
            <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/> can be set to one of <see cref="F:ICU4N.Text.DisplayContext.CapitalizationNone"/> through
            <see cref="F:ICU4N.Text.DisplayContext.CapitalizationForStandalone"/>.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContextType.DisplayLength">
            <summary>
            <see cref="F:ICU4N.Text.DisplayContextType.DisplayLength"/> can be set to <see cref="F:ICU4N.Text.DisplayContext.LengthFull"/> 
            or <see cref="F:ICU4N.Text.DisplayContext.LengthShort"/>.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.DisplayContextType.SubstituteHandling">
            <summary>
            <see cref="F:ICU4N.Text.DisplayContextType.SubstituteHandling"/> can be set to <see cref="F:ICU4N.Text.DisplayContext.Substitute"/> 
            or <see cref="F:ICU4N.Text.DisplayContext.NoSubstitute"/>.
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="T:ICU4N.Text.DisplayContextExtensions">
            <summary>
            Extension methods for <see cref="T:ICU4N.Text.DisplayContext"/>.
            </summary>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.DisplayContextExtensions.Type(ICU4N.Text.DisplayContext)">
            <summary>
            Get the <see cref="T:ICU4N.Text.DisplayContextType"/> part of the enum item
            (e.g. <see cref="F:ICU4N.Text.DisplayContextType.Capitalization"/>)
            </summary>
            <param name="displayContext">This <see cref="T:ICU4N.Text.DisplayContext"/>.</param>
            <returns>The <see cref="T:ICU4N.Text.DisplayContextType"/> part of the enum item.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.DisplayContextExtensions.Value(ICU4N.Text.DisplayContext)">
            <summary>
            Get the value part of the enum item
            (e.g. <see cref="F:ICU4N.Text.DisplayContext.CapitalizationForStandalone"/>)
            </summary>
            <param name="displayContext">This <see cref="T:ICU4N.Text.DisplayContext"/>.</param>
            <returns>The value part of the enum item.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="T:ICU4N.Text.Edits">
            <summary>
            Records lengths of string edits but not replacement text.
            Supports replacements, insertions, deletions in linear progression.
            Does not support moving/reordering of text.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.#ctor">
            <summary>
            Constructs an empty object.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.Reset">
            <summary>
            Resets the data but may not release memory.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.AddUnchanged(System.Int32)">
            <summary>
            Adds a record for an unchanged segment of text.
            Normally called from inside ICU string transformation functions, not user code.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.AddReplace(System.Int32,System.Int32)">
            <summary>
            Adds a record for a text replacement/insertion/deletion.
            Normally called from inside ICU string transformation functions, not user code.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.LengthDelta">
            <summary>
            How much longer is the new text compared with the old text?
            Returns new length minus old length.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.HasChanges">
            <summary>
            Returns true if there are any change edits.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.NumberOfChanges">
            <summary>
            Gets the number of change edits.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.Edits.Enumerator">
            <summary>
            Access to the list of edits.
            </summary>
            <seealso cref="M:ICU4N.Text.Edits.GetCoarseEnumerator"/>
            <seealso cref="M:ICU4N.Text.Edits.GetFineEnumerator"/>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.Edits.Enumerator.remaining">
            <summary>
            0 if we are not within compressed equal-length changes.
            Otherwise the number of remaining changes, including the current one.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.MoveNext">
            <summary>
            Advances to the next edit.
            </summary>
            <returns>true if there is another edit.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.FindSourceIndex(System.Int32)">
            <summary>
            Finds the edit that contains the source index.
            The source index may be found in a non-change
            even if normal iteration would skip non-changes.
            Normal iteration can continue from a found edit.
            <para/>
            The iterator state before this search logically does not matter.
            (It may affect the performance of the search.)
            <para/>
            The iterator state after this search is undefined
            if the source index is out of bounds for the source string.
            </summary>
            <param name="i">Source index.</param>
            <returns>true if the edit for the source index was found.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.FindDestinationIndex(System.Int32)">
            <summary>
            Finds the edit that contains the destination index.
            The destination index may be found in a non-change
            even if normal iteration would skip non-changes.
            Normal iteration can continue from a found edit.
            <para/>
            The iterator state before this search logically does not matter.
            (It may affect the performance of the search.)
            <para/>
            The iterator state after this search is undefined
            if the source index is out of bounds for the source string.
            </summary>
            <param name="i">Destination index.</param>
            <returns>true if the edit for the destination index was found.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.FindIndex(System.Int32,System.Boolean)">
            <returns>-1: error or i&lt;0; 0: found; 1: i>=string length</returns>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.DestinationIndexFromSourceIndex(System.Int32)">
            <summary>
            Returns the destination index corresponding to the given source index.
            If the source index is inside a change edit (not at its start),
            then the destination index at the end of that edit is returned,
            since there is no information about index mapping inside a change edit.
            <para/>
            (This means that indexes to the start and middle of an edit,
            for example around a grapheme cluster, are mapped to indexes
            encompassing the entire edit.
            The alternative, mapping an interior index to the start,
            would map such an interval to an empty one.)
            <para/>
            This operation will usually but not always modify this object.
            The iterator state after this search is undefined.
            </summary>
            <param name="i">Source index.</param>
            <returns>Destination index; undefined if i is not 0..string length.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.Enumerator.SourceIndexFromDestinationIndex(System.Int32)">
            <summary>
            Returns the source index corresponding to the given destination index.
            If the destination index is inside a change edit (not at its start),
            then the source index at the end of that edit is returned,
            since there is no information about index mapping inside a change edit.
            <para/>
            (This means that indexes to the start and middle of an edit,
            for example around a grapheme cluster, are mapped to indexes
            encompassing the entire edit.
            The alternative, mapping an interior index to the start,
            would map such an interval to an empty one.)
            <para/>
            This operation will usually but not always modify this object.
            The iterator state after this search is undefined.
            </summary>
            <param name="i">Destination index.</param>
            <returns>Source index; undefined if i is not 0..string length.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.HasChange">
            <summary>
            Returns true if this edit replaces <see cref="P:ICU4N.Text.Edits.Enumerator.OldLength"/> units with <see cref="P:ICU4N.Text.Edits.Enumerator.NewLength"/> different ones.
            false if <see cref="P:ICU4N.Text.Edits.Enumerator.OldLength"/> units remain unchanged.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.OldLength">
            <summary>
            Gets the number of units in the original string which are replaced or remain unchanged.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.NewLength">
            <summary>
            Gets the number of units in the modified string, if <see cref="P:ICU4N.Text.Edits.Enumerator.HasChange"/> is true.
            Same as <see cref="P:ICU4N.Text.Edits.Enumerator.OldLength"/> if <see cref="P:ICU4N.Text.Edits.Enumerator.HasChange"/> is false.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.SourceIndex">
            @return the current index into the source string
            @draft ICU 59
            @provisional This API might change or be removed in a future release.
            <summary>
            Gets the number of units in the original string which are replaced or remain unchanged.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.ReplacementIndex">
            <summary>
            Gets the current index into the replacement-characters-only string,
            not counting unchanged spans.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Edits.Enumerator.DestinationIndex">
            <summary>
            Gets the current index into the full destination string.
            </summary>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.GetCoarseChangesEnumerator">
            <summary>
            Returns an <see cref="T:ICU4N.Text.Edits.Enumerator"/> for coarse-grained changes for simple string updates.
            Skips non-changes.
            </summary>
            <returns>An <see cref="T:ICU4N.Text.Edits.Enumerator"/> that merges adjacent changes.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.GetCoarseEnumerator">
            <summary>
            Returns an <see cref="T:ICU4N.Text.Edits.Enumerator"/> for coarse-grained changes and non-changes for simple string updates.
            </summary>
            <returns>An <see cref="T:ICU4N.Text.Edits.Enumerator"/> that merges adjacent changes.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.GetFineChangesEnumerator">
            <summary>
            Returns an <see cref="T:ICU4N.Text.Edits.Enumerator"/> for fine-grained changes for modifying styled text.
            Skips non-changes.
            </summary>
            <returns>An <see cref="T:ICU4N.Text.Edits.Enumerator"/> that separates adjacent changes.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.GetFineEnumerator">
            <summary>
            Returns an <see cref="T:ICU4N.Text.Edits.Enumerator"/> for fine-grained changes and non-changes for modifying styled text.
            </summary>
            <returns>An <see cref="T:ICU4N.Text.Edits.Enumerator"/> that separates adjacent changes.</returns>
            <draft>ICU 59</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Edits.MergeAndAppend(ICU4N.Text.Edits,ICU4N.Text.Edits)">
            <summary>
            Merges the two input Edits and appends the result to this object.
            </summary>
            <remarks>
            Consider two string transformations (for example, normalization and case mapping)
            where each records Edits in addition to writing an output string.
            <para/>
            Edits <paramref name="ab"/> reflect how substrings of input string a
            map to substrings of intermediate string b.
            <para/>
            Edits <paramref name="bc"/> reflect how substrings of intermediate string b
            map to substrings of output string c.
            <para/>
            This function merges <paramref name="ab"/> and <paramref name="bc"/> such that the additional edits
            recorded in this object reflect how substrings of input string a
            map to substrings of output string c.
            <para/>
            If unrelated <see cref="T:ICU4N.Text.Edits"/> are passed in where the output string of the first
            has a different length than the input string of the second,
            then an <see cref="T:System.ArgumentException"/> is thrown.
            </remarks>
            <param name="ab">Reflects how substrings of input string a
            map to substrings of intermediate string b.</param>
            <param name="bc">Reflects how substrings of intermediate string b
            map to substrings of output string c.</param>
            <returns>This, with the merged edits appended.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.FilteredBreakIteratorBuilder">
            <summary>
            The <see cref="T:ICU4N.Text.FilteredBreakIteratorBuilder"/> is used to modify the behavior of a <see cref="T:ICU4N.Text.BreakIterator"/>
            by constructing a new <see cref="T:ICU4N.Text.BreakIterator"/> which suppresses certain segment boundaries.
            See  http://www.unicode.org/reports/tr35/tr35-general.html#Segmentation_Exceptions .
            For example, a typical English Sentence Break Iterator would break on the space
            in the string "Mr. Smith" (resulting in two segments),
            but with "Mr." as an exception, a filtered break iterator
            would consider the string "Mr. Smith" to be a single segment.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Construct a <see cref="T:ICU4N.Text.FilteredBreakIteratorBuilder"/> based on sentence break exception rules in a locale.
            The rules are taken from CLDR exception data for the locale,
            see http://www.unicode.org/reports/tr35/tr35-general.html#Segmentation_Exceptions
            This is the equivalent of calling createInstance(UErrorCode&amp;)
            and then repeatedly calling addNoBreakAfter(...) with the contents
            of the CLDR exception data.
            </summary>
            <param name="where">The locale.</param>
            <returns>The new builder.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.GetInstance(ICU4N.Util.ULocale)">
            <summary>
            Construct a <see cref="T:ICU4N.Text.FilteredBreakIteratorBuilder"/> based on sentence break exception rules in a locale.
            The rules are taken from CLDR exception data for the locale,
            see http://www.unicode.org/reports/tr35/tr35-general.html#Segmentation_Exceptions
            This is the equivalent of calling createInstance(UErrorCode&amp;)
            and then repeatedly calling addNoBreakAfter(...) with the contents
            of the CLDR exception data.
            </summary>
            <param name="where">The locale.</param>
            <returns>The new builder.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.GetEmptyInstance">
            <summary>
            Construct an empty <see cref="T:ICU4N.Text.FilteredBreakIteratorBuilder"/>.
            In this state, it will not suppress any segment boundaries.
            </summary>
            <returns>The new builder.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.SuppressBreakAfter(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Suppress a certain string from being the end of a segment.
            For example, suppressing "Mr.", then segments ending in "Mr." will not be returned
            by the iterator.
            </summary>
            <param name="str">The string to suppress, such as "Mr."</param>
            <returns>true if the string was not present and now added,
            false if the call was a no-op because the string was already being suppressed.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.UnsuppressBreakAfter(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Stop suppressing a certain string from being the end of the segment.
            This function does not create any new segment boundaries, but only serves to un-do
            the effect of earlier calls to <see cref="M:ICU4N.Text.FilteredBreakIteratorBuilder.SuppressBreakAfter(ICU4N.Support.Text.ICharSequence)"/>, or to un-do the effect of
            locale data which may be suppressing certain strings.
            </summary>
            <param name="str">The str the string to unsuppress, such as "Mr."</param>
            <returns>true if the string was present and now removed,
            false if the call was a no-op because the string was not being suppressed.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.WrapIteratorWithFilter(ICU4N.Text.BreakIterator)">
            <summary>
            Wrap (adopt) an existing break iterator in a new filtered instance.
            Note that the <paramref name="wrappedBreakIterator"/> is adopted by the new <see cref="T:ICU4N.Text.BreakIterator"/>
            and should no longer be used by the caller.
            The <see cref="T:ICU4N.Text.FilteredBreakIteratorBuilder"/> may be reused.
            </summary>
            <param name="wrappedBreakIterator">The break iterator to wrap.</param>
            <returns>The new <see cref="T:ICU4N.Text.BreakIterator"/>.</returns>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.FilteredBreakIteratorBuilder.#ctor">
            <summary>
            For subclass use.
            </summary>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.FilteredNormalizer2">
            <summary>
            Normalization filtered by a <see cref="T:ICU4N.Text.UnicodeSet"/>.
            Normalizes portions of the text contained in the filter set and leaves
            portions not contained in the filter set unchanged.
            Filtering is done via <c>UnicodeSet.Span(..., SpanCondition.Simple)</c>.
            Not-in-the-filter text is treated as "is normalized" and "quick check yes".
            This class implements all of (and only) the <see cref="T:ICU4N.Text.Normalizer2"/> API.
            An instance of this class is unmodifiable/immutable.
            </summary>
            <stable>ICU 4.4</stable>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.#ctor(ICU4N.Text.Normalizer2,ICU4N.Text.UnicodeSet)">
            <summary>
            Constructs a filtered normalizer wrapping any <see cref="T:ICU4N.Text.Normalizer2"/> instance
            and a filter set.
            Both are aliased and must not be modified or deleted while this object
            is used.
            The filter set should be frozen; otherwise the performance will suffer greatly.
            </summary>
            <param name="n2">Wrapped <see cref="T:ICU4N.Text.Normalizer2"/> instance.</param>
            <param name="filterSet"><see cref="T:ICU4N.Text.UnicodeSet"/> which determines the characters to be normalized.</param>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Normalize(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.IAppendable)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.GetDecomposition(System.Int32)">
            <summary>
            Gets the decomposition mapping of <paramref name="codePoint"/>.
            Roughly equivalent to normalizing the <see cref="T:System.String"/> form of <paramref name="codePoint"/>
            on a DECOMPOSE Normalizer2 instance, but much faster, and except that this function
            returns null if c does not have a decomposition mapping in this instance's data.
            This function is independent of the mode of the Normalizer2.
            </summary>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s decomposition mapping, if any; otherwise null.</returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.GetRawDecomposition(System.Int32)">
            <summary>
            Gets the raw decomposition mapping of <paramref name="codePoint"/>.
            </summary>
            <remarks>
            This is similar to the <see cref="M:ICU4N.Text.FilteredNormalizer2.GetDecomposition(System.Int32)"/> method but returns the
            raw decomposition mapping as specified in UnicodeData.txt or
            (for custom data) in the mapping files processed by the gennorm2 tool.
            By contrast, <see cref="M:ICU4N.Text.FilteredNormalizer2.GetDecomposition(System.Int32)"/> returns the processed,
            recursively-decomposed version of this mapping.
            <para/>
            When used on a standard NFKC Normalizer2 instance,
            <see cref="M:ICU4N.Text.FilteredNormalizer2.GetRawDecomposition(System.Int32)"/> returns the Unicode Decomposition_Mapping (dm) property.
            <para/>
            When used on a standard NFC Normalizer2 instance,
            it returns the Decomposition_Mapping only if the Decomposition_Type (dt) is Canonical (Can);
            in this case, the result contains either one or two code points (=1..4 .NET chars).
            <para/>
            This function is independent of the mode of the Normalizer2.
            The default implementation returns null.
            </remarks>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s raw decomposition mapping, if any; otherwise null.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.ComposePair(System.Int32,System.Int32)">
            <summary>
            Performs pairwise composition of <paramref name="a"/> &amp; <paramref name="b"/> and returns the composite if there is one.
            </summary>
            <remarks>
            Returns a composite code point c only if c has a two-way mapping to a+b.
            In standard Unicode normalization, this means that
            c has a canonical decomposition to <paramref name="a"/>+<paramref name="b"/>
            and c does not have the Full_Composition_Exclusion property.
            <para/>
            This function is independent of the mode of the Normalizer2.
            The default implementation returns a negative value.
            </remarks>
            <param name="a">A (normalization starter) code point.</param>
            <param name="b">Another code point.</param>
            <returns>The non-negative composite code point if there is one; otherwise a negative value.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.GetCombiningClass(System.Int32)">
            <summary>
            Gets the combining class of <paramref name="codePoint"/>.
            The default implementation returns 0
            but all standard implementations return the Unicode Canonical_Combining_Class value.
            </summary>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s combining class.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.HasBoundaryBefore(System.Int32)">
            <summary>
            Tests if the <paramref name="character"/> always has a normalization boundary before it,
            regardless of context.
            If true, then the character does not normalization-interact with
            preceding characters.
            In other words, a string containing this character can be normalized
            by processing portions before this character and starting from this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> has a normalization boundary before it.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.HasBoundaryAfter(System.Int32)">
            <summary>
            Tests if the <paramref name="character"/> always has a normalization boundary after it,
            regardless of context.
            If true, then the character does not normalization-interact with
            following characters.
            In other words, a string containing this character can be normalized
            by processing portions up to this character and after this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            <para/>
            Note that this operation may be significantly slower than <see cref="M:ICU4N.Text.FilteredNormalizer2.HasBoundaryBefore(System.Int32)"/>.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> has a normalization boundary after it.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.IsInert(System.Int32)">
            <summary>
            Tests if the <paramref name="character"/> is normalization-inert.
            If true, then the character does not change, nor normalization-interact with
            preceding or following characters.
            In other words, a string containing this character can be normalized
            by processing portions before this character and after this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            <para/>
            Note that this operation may be significantly slower than <see cref="M:ICU4N.Text.FilteredNormalizer2.HasBoundaryBefore(System.Int32)"/>.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> is normalization-inert.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Normalize(System.String,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Normalize(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Normalize(System.Char[],System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Normalize(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Append(System.Text.StringBuilder,System.String)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Append(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Append(System.Text.StringBuilder,System.Char[])">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.Append(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.IsNormalized(System.String)">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.String)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.IsNormalized(System.Text.StringBuilder)">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.Text.StringBuilder)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.IsNormalized(System.Char[])">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.Char[])"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.IsNormalized(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(ICU4N.Support.Text.ICharSequence)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.String)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.String)"/> and
            <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.Text.StringBuilder)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.Text.StringBuilder)"/> and
            <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(System.Char[])">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.Char[])"/> and
            <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.QuickCheck(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(ICU4N.Support.Text.ICharSequence)"/> and
            <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.String)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.Text.StringBuilder)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(System.Char[])">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.FilteredNormalizer2.SpanQuickCheckYes(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.FilteredNormalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.IDNAError">
            <summary>
            IDNA error bit set values.
            When a domain name or label fails a processing step or does not meet the
            validity criteria, then one or more of these error bits are set.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.EmptyLabel">
            <summary>
            A non-final domain name label (or the whole domain name) is empty.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.LabelTooLong">
            <summary>
            A domain name label is longer than 63 bytes.
            (See STD13/RFC1034 3.1. Name space specifications and terminology.)
            This is only checked in ToASCII operations, and only if the output label is all-ASCII.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.DomainNameTooLong">
            <summary>
            A domain name is longer than 255 bytes in its storage form.
            (See STD13/RFC1034 3.1. Name space specifications and terminology.)
            This is only checked in ToASCII operations, and only if the output domain name is all-ASCII.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.LeadingHyphen">
            <summary>
            A label starts with a hyphen-minus ('-').
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.TrailingHyphen">
            <summary>
            A label ends with a hyphen-minus ('-').
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.Hyphen_3_4">
            <summary>
            A label contains hyphen-minus ('-') in the third and fourth positions.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.LeadingCombiningMark">
            <summary>
            A label starts with a combining mark.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.Disallowed">
            <summary>
            A label or domain name contains disallowed characters.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.Punycode">
            <summary>
            A label starts with "xn--" but does not contain valid Punycode.
            That is, an xn-- label failed Punycode decoding.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.LabelHasDot">
            <summary>
            A label contains a dot=full stop.
            This can occur in an input string for a single-label function.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.InvalidAceLabel">
            <summary>
            An ACE label does not contain a valid label string.
            The label was successfully ACE (Punycode) decoded but the resulting
            string had severe validation errors. For example,
            it might contain characters that are not allowed in ACE labels,
            or it might not be normalized.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.BiDi">
            <summary>
            A label does not meet the IDNA BiDi requirements (for right-to-left characters).
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.ContextJ">
            <summary>
            A label does not meet the IDNA CONTEXTJ requirements.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.ContextOPunctuation">
            <summary>
            A label does not meet the IDNA CONTEXTO requirements for punctuation characters.
            Some punctuation characters "Would otherwise have been DISALLOWED"
            but are allowed in certain contexts. (RFC 5892)
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Text.IDNAError.ContextODigits">
            <summary>
            A label does not meet the IDNA CONTEXTO requirements for digits.
            Arabic-Indic Digits (U+066x) must not be mixed with Extended Arabic-Indic Digits (U+06Fx).
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.IDNAInfo">
            <summary>
            Output container for IDNA processing errors.
            The <see cref="T:ICU4N.Text.IDNAInfo"/> class is not suitable for subclassing.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNAInfo.#ctor">
            <summary>
            Constructor.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="P:ICU4N.Text.IDNAInfo.HasErrors">
            <summary>
            Were there IDNA processing errors?
            Returns true if there were processing errors.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="P:ICU4N.Text.IDNAInfo.Errors">
            <summary>
            Returns a set indicating IDNA processing errors (modifiable, and not null).
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="P:ICU4N.Text.IDNAInfo.IsTransitionalDifferent">
            <summary>
            Returns true if transitional and nontransitional processing produce different results.
            This is the case when the input label or domain name contains
            one or more deviation characters outside a Punycode label (see UTS #46).
            <list type="bullet">
                <item><description>
                    With nontransitional processing, such characters are
                    copied to the destination string.
                </description></item>
                <item><description>
                    With transitional processing, such characters are
                    mapped (sharp s/sigma) or removed (joiner/nonjoiner).
                </description></item>
            </list>
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="T:ICU4N.Text.IDNA">
            <summary>
            Abstract base class for IDNA processing.
            See <a href="http://www.unicode.org/reports/tr46/">http://www.unicode.org/reports/tr46/</a>
            and <a href="http://www.ietf.org/rfc/rfc3490.txt">http://www.ietf.org/rfc/rfc3490.txt</a>
            </summary>
            <remarks>
            The IDNA class is not intended for public subclassing.
            The non-static methods implement UTS #46 and IDNA2008.
            IDNA2008 is implemented according to UTS #46, see <see cref="M:ICU4N.Text.IDNA.GetUTS46Instance(ICU4N.Impl.UTS46Options)"/>.
            <para/>
            IDNA2003 is obsolete. The static methods implement IDNA2003. They are all deprecated.
            <para/>
            IDNA2003 API Overview:
            <para/>
            The static IDNA API methods implement the IDNA protocol as defined in the
            <a href="http://www.ietf.org/rfc/rfc3490.txt">IDNA RFC</a>.
            The draft defines 2 operations: ToASCII and ToUnicode. Domain labels 
            containing non-ASCII code points are required to be processed by
            ToASCII operation before passing it to resolver libraries. Domain names
            that are obtained from resolver libraries are required to be processed by
            ToUnicode operation before displaying the domain name to the user.
            IDNA requires that implementations process input strings with 
            <a href="http://www.ietf.org/rfc/rfc3491.txt">Nameprep</a>, 
            which is a profile of <a href="http://www.ietf.org/rfc/rfc3454.txt">Stringprep</a> , 
            and then with <a href="http://www.ietf.org/rfc/rfc3492.txt">Punycode</a>. 
            Implementations of IDNA MUST fully implement Nameprep and Punycode; 
            neither Nameprep nor Punycode are optional.
            The input and output of ToASCII and ToUnicode operations are Unicode 
            and are designed to be chainable, i.e., applying ToASCII or ToUnicode operations
            multiple times to an input string will yield the same result as applying the operation
            once.
            <code>
            ToUnicode(ToUnicode(ToUnicode...(ToUnicode(string)))) == ToUnicode(string) 
            ToASCII(ToASCII(ToASCII...(ToASCII(string))) == ToASCII(string)
            </code>
            </remarks>
            <author>Ram Viswanadha, Markus Scherer</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.GetUTS46Instance(ICU4N.Impl.UTS46Options)">
            <summary>
            Returns an IDNA instance which implements UTS #46.
            Returns an unmodifiable instance, owned by the caller.
            Cache it for multiple operations, and delete it when done.
            The instance is thread-safe, that is, it can be used concurrently.
            </summary>
            <remarks>
            UTS #46 defines Unicode IDNA Compatibility Processing,
            updated to the latest version of Unicode and compatible with both
            IDNA2003 and IDNA2008.
            <para/>
            The worker functions use transitional processing, including deviation mappings,
            unless <see cref="F:ICU4N.Impl.UTS46Options.NontransitionalToASCII"/> or <see cref="F:ICU4N.Impl.UTS46Options.NontransitionalToUnicode"/>
            is used in which case the deviation characters are passed through without change.
            <para/>
            Disallowed characters are mapped to U+FFFD.
            <para/>
            Operations with the UTS #46 instance do not support the
            <see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/> option.
            <para/>
            By default, the UTS #46 implementation allows all ASCII characters (as valid or mapped).
            When the <see cref="F:ICU4N.Impl.UTS46Options.UseSTD3Rules"/> option is used, ASCII characters other than
            letters, digits, hyphen (LDH) and dot/full stop are disallowed and mapped to U+FFFD.
            </remarks>
            <param name="options">Bit set to modify the processing and error checking.</param>
            <returns>The UTS #46 IDNA instance, if successful.</returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.ResetInfo(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.HasCertainErrors(ICU4N.Text.IDNAInfo,System.Collections.Generic.ISet{ICU4N.Text.IDNAError})">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.HasCertainLabelErrors(ICU4N.Text.IDNAInfo,System.Collections.Generic.ISet{ICU4N.Text.IDNAError})">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.AddLabelError(ICU4N.Text.IDNAInfo,ICU4N.Text.IDNAError)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.PromoteAndResetLabelErrors(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.AddError(ICU4N.Text.IDNAInfo,ICU4N.Text.IDNAError)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.SetTransitionalDifferent(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.SetBiDi(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.IsBiDi(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.SetNotOkBiDi(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.IsOkBiDi(ICU4N.Text.IDNAInfo)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass constructors, typically implicit.)
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToASCII(System.String,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            ASCII names. A label is an individual part of a domain name. Labels are usually
            separated by dots; e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToASCII(System.Text.StringBuilder,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            ASCII names. A label is an individual part of a domain name. Labels are usually
            separated by dots; e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string as <see cref="T:System.Text.StringBuilder"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToASCII(ICU4N.Text.UCharacterIterator,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToASCII operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            ASCII names. A label is an individual part of a domain name. Labels are usually
            separated by dots; e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string as <see cref="T:ICU4N.Text.UCharacterIterator"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToASCII(ICU4N.Text.UCharacterIterator,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com". 
            It is important to note that this operation can fail. If it fails, then the input 
            domain name cannot be used as an Internationalized Domain Name and the application
            should have methods defined to deal with the failure.
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each,
            and then convert. This function does not offer that level of granularity. The options once  
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string as <see cref="T:ICU4N.Text.UCharacterIterator"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToASCII(System.Text.StringBuilder,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com". 
            It is important to note that this operation can fail. If it fails, then the input 
            domain name cannot be used as an Internationalized Domain Name and the application
            should have methods defined to deal with the failure.
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each,
            and then convert. This function does not offer that level of granularity. The options once  
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string as <see cref="T:System.Text.StringBuilder"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToASCII(System.String,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToASCII operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com". 
            It is important to note that this operation can fail. If it fails, then the input 
            domain name cannot be used as an Internationalized Domain Name and the application
            should have methods defined to deal with the failure.
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each,
            and then convert. This function does not offer that level of granularity. The options once  
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToUnicode(System.String,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToUnicode operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            Unicode names. A label is an individual part of a domain name. Labels are usually
            separated by dots; for e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToUnicode(System.Text.StringBuilder,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToUnicode operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            Unicode names. A label is an individual part of a domain name. Labels are usually
            separated by dots; for e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string as <see cref="T:System.Text.StringBuilder"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertToUnicode(ICU4N.Text.UCharacterIterator,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: This function implements the ToUnicode operation as defined in the IDNA RFC.
            This operation is done on <b>single labels</b> before sending it to something that expects
            Unicode names. A label is an individual part of a domain name. Labels are usually
            separated by dots; for e.g." "www.example.com" is composed of 3 labels 
            "www","example", and "com".
            </summary>
            <param name="src">The input string as <see cref="T:ICU4N.Text.UCharacterIterator"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToUnicode(ICU4N.Text.UCharacterIterator,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com".
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, 
            and then convert. This function does not offer that level of granularity. The options once
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string as <see cref="T:ICU4N.Text.UCharacterIterator"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToUnicode(System.Text.StringBuilder,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com".
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, 
            and then convert. This function does not offer that level of granularity. The options once
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string as <see cref="T:System.Text.StringBuilder"/> to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.ConvertIDNToUnicode(System.String,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Convenience function that implements the IDNToUnicode operation as defined in the IDNA RFC.
            This operation is done on complete domain names, e.g: "www.example.com".
            <para/>
            <b>Note:</b> IDNA RFC specifies that a conformant application should divide a domain name
            into separate labels, decide whether to apply allowUnassigned and useSTD3ASCIIRules on each, 
            and then convert. This function does not offer that level of granularity. The options once
            set will apply to all labels in the domain name.
            </summary>
            <param name="src">The input string to be processed.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns><see cref="T:System.Text.StringBuilder"/> the converted <see cref="T:System.String"/>.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.Compare(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Compare two IDN strings for equivalence.
            This function splits the domain names into labels and compares them.
            According to IDN RFC, whenever two labels are compared, they are 
            considered equal if and only if their ASCII forms (obtained by 
            applying ToASCII) match using an case-insensitive ASCII comparison.
            Two domain names are considered a match if and only if all labels 
            match regardless of whether label separators match.
            </summary>
            <param name="s1">First IDN string as <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="s2">Second IDN string as <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns>0 if the strings are equal, &gt; 0 if s1 &gt; s2 and &lt; 0 if s1 &lt; s2.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.Compare(System.String,System.String,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Compare two IDN strings for equivalence.
            This function splits the domain names into labels and compares them.
            According to IDN RFC, whenever two labels are compared, they are 
            considered equal if and only if their ASCII forms (obtained by 
            applying ToASCII) match using an case-insensitive ASCII comparison.
            Two domain names are considered a match if and only if all labels 
            match regardless of whether label separators match.
            </summary>
            <param name="s1">First IDN string.</param>
            <param name="s2">Second IDN string.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns>0 if the strings are equal, &gt; 0 if s1 &gt; s2 and &lt; 0 if s1 &lt; s2.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.Compare(ICU4N.Text.UCharacterIterator,ICU4N.Text.UCharacterIterator,ICU4N.Impl.IDNA2003Options)">
            <summary>
            IDNA2003: Compare two IDN strings for equivalence.
            This function splits the domain names into labels and compares them.
            According to IDN RFC, whenever two labels are compared, they are 
            considered equal if and only if their ASCII forms (obtained by 
            applying ToASCII) match using an case-insensitive ASCII comparison.
            Two domain names are considered a match if and only if all labels 
            match regardless of whether label separators match.
            </summary>
            <param name="s1">First IDN string as <see cref="T:ICU4N.Text.UCharacterIterator"/>.</param>
            <param name="s2">Second IDN string as <see cref="T:ICU4N.Text.UCharacterIterator"/>.</param>
            <param name="options">A bit set of options:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.Default"/></term>
                    <description>
                        Use default options, i.e., do not process unassigned code points
                        and do not use STD3 ASCII rules
                        If unassigned code points are found the operation fails with 
                        <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.AllowUnassigned"/></term>
                    <description>
                        Unassigned values can be converted to ASCII for query operations
                        If this option is set, the unassigned code points are in the input
                        are treated as normal Unicode code points.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Impl.IDNA2003Options.UseSTD3Rules"/></term>
                    <description>
                        Use STD3 ASCII rules for host name syntax restrictions
                        If this option is set and the input does not satisfy STD3 rules,
                        the operation will fail with <see cref="T:ICU4N.Text.StringPrepParseException"/>.
                    </description>
                </item>
            </list>
            </param>
            <returns>0 if the strings are equal, &gt; 0 if s1 &gt; s2 and &lt; 0 if s1 &lt; s2.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">When an error occurs for parsing a string.</exception>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToASCII(System.String,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The label might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToASCII(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The label might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToASCII(System.Char[],System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The label might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToASCII(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The label might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToUnicode(System.String,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The label might be modified according to the types of errors.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToUnicode(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The label might be modified according to the types of errors.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToUnicode(System.Char[],System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The label might be modified according to the types of errors.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.LabelToUnicode(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a single domain name label into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The label might be modified according to the types of errors.
            </summary>
            <param name="label">Input domain name label.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToASCII(System.String,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The domain name might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToASCII(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The domain name might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToASCII(System.Char[],System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The domain name might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToASCII(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its ASCII form for DNS lookup.
            If any processing step fails, then info.HasErrors will be true and
            the result might not be an ASCII string.
            The domain name might be modified according to the types of errors.
            Labels with severe errors will be left in (or turned into) their Unicode form.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToUnicode(System.String,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The domain name might be modified according to the types of errors.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToUnicode(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The domain name might be modified according to the types of errors.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToUnicode(System.Char[],System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The domain name might be modified according to the types of errors.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.IDNA.NameToUnicode(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.IDNAInfo)">
            <summary>
            Converts a whole domain name into its Unicode form for human-readable display.
            If any processing step fails, then info.HasErrors will be true.
            The domain name might be modified according to the types of errors.
            </summary>
            <param name="name">Input domain name.</param>
            <param name="dest">Destination string object.</param>
            <param name="info">Output container of IDNA processing details.</param>
            <returns><paramref name="dest"/></returns>
            <stable>ICU 4.6</stable>
        </member>
        <member name="T:ICU4N.Text.ILanguageBreakEngine">
            <summary>
            The <see cref="T:ICU4N.Text.ILanguageBreakEngine"/> interface is to be used to implement any
            language-specific logic for break iteration.
            </summary>
        </member>
        <member name="M:ICU4N.Text.ILanguageBreakEngine.Handles(System.Int32,System.Int32)">
            <param name="c">A Unicode codepoint value.</param>
            <param name="breakType">The kind of break iterator that is wanting to make use
            of this engine - character, word, line, sentence.</param>
            <returns>true if the engine can handle this character, false otherwise.</returns>
        </member>
        <member name="M:ICU4N.Text.ILanguageBreakEngine.FindBreaks(ICU4N.Support.Text.CharacterIterator,System.Int32,System.Int32,System.Int32,ICU4N.Text.DictionaryBreakEngine.DequeI)">
            <summary>
            Implements the actual breaking logic. Find any breaks within a run in the supplied text.
            </summary>
            <param name="text">The text to break over. The iterator is left at
            the end of the run of characters which the engine has handled.</param>
            <param name="startPos">The index of the beginning of the range.</param>
            <param name="endPos">The index of the possible end of our range. It is possible,
            however, that the range ends earlier.</param>
            <param name="breakType">The kind of break iterator that is wanting to make use
            of this engine - character, word, line, sentence.</param>
            <param name="foundBreaks">A data structure to receive the break positions.</param>
            <returns>The number of breaks found.</returns>
        </member>
        <member name="T:ICU4N.Text.LocaleDisplayNames">
            <summary>
            Returns display names of ULocales and components of ULocales. For
            more information on language, script, region, variant, key, and
            values, see <see cref="T:ICU4N.Util.ULocale"/>.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.LocaleDisplayNames.DialectHandling">
            <summary>
            Enumerator used in <see cref="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale,ICU4N.Text.LocaleDisplayNames.DialectHandling)"/>.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.DialectHandling.STANDARD_NAMES">
            <summary>
            Use standard names when generating a locale name,
            e.g. en_GB displays as 'English (United Kingdom)'.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.DialectHandling.DIALECT_NAMES">
            <summary>
            Use dialect names when generating a locale name,
            e.g. en_GB displays as 'British English'.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale)">
            <summary>
            Convenience overload of <see cref="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale,ICU4N.Text.LocaleDisplayNames.DialectHandling)"/> that specifies
            <see cref="F:ICU4N.Text.LocaleDisplayNames.DialectHandling.STANDARD_NAMES"/> dialect handling.
            </summary>
            <param name="locale">The display locale.</param>
            <returns>A <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Convenience overload of <see cref="M:ICU4N.Text.LocaleDisplayNames.GetInstance(System.Globalization.CultureInfo,ICU4N.Text.DisplayContext[])"/> that specifies
            <see cref="F:ICU4N.Text.DisplayContext.StandardNames"/>.
            </summary>
            <param name="locale">The display <see cref="T:System.Globalization.CultureInfo"/>.</param>
            <returns>A <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale,ICU4N.Text.LocaleDisplayNames.DialectHandling)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Text.LocaleDisplayNames"/> that returns names formatted for the provided <paramref name="locale"/>,
            using the provided <paramref name="dialectHandling"/>.
            </summary>
            <param name="locale">The display locale.</param>
            <param name="dialectHandling">How to select names for locales.</param>
            <returns>A <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale,ICU4N.Text.DisplayContext[])">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Text.LocaleDisplayNames"/> that returns names formatted for the provided <paramref name="locale"/>,
            using the provided <see cref="T:ICU4N.Text.DisplayContext"/> settings.
            </summary>
            <param name="locale">The display locale.</param>
            <param name="contexts">One or more context settings (e.g. for dialect handling, capitalization, etc.)</param>
            <returns>A <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetInstance(System.Globalization.CultureInfo,ICU4N.Text.DisplayContext[])">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Text.LocaleDisplayNames"/> that returns names formatted for the provided
            <see cref="T:System.Globalization.CultureInfo"/>, using the provided <see cref="T:ICU4N.Text.DisplayContext"/> settings.
            </summary>
            <param name="locale">The display <see cref="T:System.Globalization.CultureInfo"/>.</param>
            <param name="contexts">One or more context settings (e.g. for dialect handling, capitalization, etc.)</param>
            <returns>A <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetLocale">
            <summary>
            Returns the locale used to determine the display names. This is not necessarily the same
            locale passed to <see cref="M:ICU4N.Text.LocaleDisplayNames.GetInstance(ICU4N.Util.ULocale)"/>.
            </summary>
            <returns>The display locale.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetDialectHandling">
            <summary>
            Returns the dialect handling used in the display names.
            </summary>
            <returns>The dialect handling enumeration.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetContext(ICU4N.Text.DisplayContextType)">
            <summary>
            Returns the current value for a specified <see cref="T:ICU4N.Text.DisplayContextType"/>.
            </summary>
            <param name="type">The <see cref="T:ICU4N.Text.DisplayContextType"/> whose value to return.</param>
            <returns>The current DisplayContext setting for the specified type.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.LocaleDisplayName(ICU4N.Util.ULocale)">
            <summary>
            Returns the display name of the provided <paramref name="locale"/>.
            When no display names are available for all or portions
            of the original locale ID, those portions may be
            used directly (possibly in a more canonical form) as
            part of the  returned display name.
            </summary>
            <param name="locale">The locale whose display name to return.</param>
            <returns>The display name of the provided <paramref name="locale"/>.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.LocaleDisplayName(System.Globalization.CultureInfo)">
            <summary>
            Returns the display name of the provided <paramref name="locale"/>.
            When no display names are available for all or portions
            of the original locale ID, those portions may be
            used directly (possibly in a more canonical form) as
            part of the  returned display name.
            </summary>
            <param name="locale">The locale whose display name to return.</param>
            <returns>The display name of the provided <paramref name="locale"/>.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.LocaleDisplayName(System.String)">
            <summary>
            Returns the display name of the provided <paramref name="localeId"/>.
            When no display names are available for all or portions
            of the original locale ID, those portions may be
            used directly (possibly in a more canonical form) as
            part of the  returned display name.
            </summary>
            <param name="localeId">The id of the locale whose display name to return.</param>
            <returns>The display name of the provided locale.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.LanguageDisplayName(System.String)">
            <summary>
            Returns the display name of the provided language code.
            </summary>
            <param name="lang">The language code.</param>
            <returns>The display name of the provided language code.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.ScriptDisplayName(System.String)">
            <summary>
            Returns the display name of the provided script code.
            </summary>
            <param name="script">The script code.</param>
            <returns>The display name of the provided script code.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.ScriptDisplayNameInContext(System.String)">
            <summary>
            Returns the display name of the provided script code
            when used in the context of a full locale name.
            </summary>
            <param name="script">The script code.</param>
            <returns>The display name of the provided script code.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.ScriptDisplayName(System.Int32)">
            <summary>
            Returns the display name of the provided script code.  See
            <see cref="T:ICU4N.Globalization.UScript"/> for recognized script codes.
            </summary>
            <param name="scriptCode">The script code number.</param>
            <returns>The display name of the provided script code.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.RegionDisplayName(System.String)">
            <summary>
            Returns the display name of the provided region code.
            </summary>
            <param name="region">The region code.</param>
            <returns>The display name of the provided region code.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.VariantDisplayName(System.String)">
            <summary>
            Returns the display name of the provided variant.
            </summary>
            <param name="variant">The variant string.</param>
            <returns>The display name of the provided variant.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.KeyDisplayName(System.String)">
            <summary>
            Returns the display name of the provided locale key.
            </summary>
            <param name="key">The locale key name.</param>
            <returns>The display name of the provided locale key.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.KeyValueDisplayName(System.String,System.String)">
            <summary>
            Returns the display name of the provided value (used with the provided key).
            </summary>
            <param name="key">The locale key name.</param>
            <param name="value">The locale key's value.</param>
            <returns>The display name of the provided value.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetUiList(System.Collections.Generic.ISet{ICU4N.Util.ULocale},System.Boolean,System.Collections.Generic.IComparer{System.String})">
            <summary>
            Return a list of information used to construct a UI list of locale names.
            </summary>
            <param name="localeSet">A list of locales to present in a UI list. The casing uses the settings in the <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</param>
            <param name="inSelf">
            If true, compares the nameInSelf, otherwise the nameInDisplayLocale.
            Set depending on which field (displayLocale vs self) is to show up in the UI.
            If both are to show up in the UI, then it should be the one used for the primary sort order.
            </param>
            <param name="collator">How to collateshould normally be <c>Collator.GetInstance(GetDisplayLocale())</c>.</param>
            <returns>An ordered list of <see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/>s.</returns>
            <exception cref="T:ICU4N.Util.IllformedLocaleException">If any of the locales in localeSet are malformed.</exception>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetUiList(System.Collections.Generic.ISet{ICU4N.Util.ULocale},System.Boolean,System.Globalization.CompareInfo)">
            <summary>
            Return a list of information used to construct a UI list of locale names.
            </summary>
            <param name="localeSet">A list of locales to present in a UI list. The casing uses the settings in the <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</param>
            <param name="inSelf">
            If true, compares the nameInSelf, otherwise the nameInDisplayLocale.
            Set depending on which field (displayLocale vs self) is to show up in the UI.
            If both are to show up in the UI, then it should be the one used for the primary sort order.
            </param>
            <param name="collator">How to collateshould normally be <c>Collator.GetInstance(GetDisplayLocale())</c>.</param>
            <returns>An ordered list of <see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/>s.</returns>
            <exception cref="T:ICU4N.Util.IllformedLocaleException">If any of the locales in localeSet are malformed.</exception>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.GetUiListCompareWholeItems(System.Collections.Generic.ISet{ICU4N.Util.ULocale},System.Collections.Generic.IComparer{ICU4N.Text.LocaleDisplayNames.UiListItem})">
            <summary>
            Return a list of information used to construct a UI list of locale names, providing more access to control the sorting.
            Normally use <see cref="M:ICU4N.Text.LocaleDisplayNames.GetUiList(System.Collections.Generic.ISet{ICU4N.Util.ULocale},System.Boolean,System.Collections.Generic.IComparer{System.String})"/> instead.
            </summary>
            <param name="localeSet">A list of locales to present in a UI list. The casing uses the settings in the <see cref="T:ICU4N.Text.LocaleDisplayNames"/> instance.</param>
            <param name="comparer">How to sort the UiListItems in the result.</param>
            <returns>An ordered list of <see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/>s.</returns>
            <exception cref="T:ICU4N.Util.IllformedLocaleException">If any of the locales in localeSet are malformed.</exception>
            <stable>ICU 55</stable>
        </member>
        <member name="T:ICU4N.Text.LocaleDisplayNames.UiListItem">
            <summary>
            Struct-like class used to return information for constructing a UI list, each corresponding to a locale.
            </summary>
            <stable>ICU 55</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.UiListItem.minimized">
            <summary>
            Returns the minimized locale for an input locale, such as sr-Cyrl  sr
            </summary>
            <stable>ICU 55</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.UiListItem.modified">
            <summary>
            Returns the modified locale for an input locale, such as sr  sr-Cyrl, where there is also an sr-Latn in the list
            </summary>
            <stable>ICU 55</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.UiListItem.nameInDisplayLocale">
            <summary>
            Returns the name of the modified locale in the display locale, such as "Englisch (VS)" (for 'en-US', where the display locale is 'de').
            </summary>
            <stable>ICU 55</stable>
        </member>
        <member name="F:ICU4N.Text.LocaleDisplayNames.UiListItem.nameInSelf">
            <summary>
            Returns the name of the modified locale in itself, such as "English (US)" (for 'en-US').
            </summary>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.#ctor(ICU4N.Util.ULocale,ICU4N.Util.ULocale,System.String,System.String)">
            <summary>
            Constructor, normally only called internally.
            </summary>
            <param name="minimized">Locale for an input locale.</param>
            <param name="modified">Modified for an input locale.</param>
            <param name="nameInDisplayLocale">Name of the modified locale in the display locale.</param>
            <param name="nameInSelf">Name of the modified locale in itself.</param>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.GetHashCode">
            <summary>
            Gets the hash code for this instance.
            </summary>
            <returns>A hash code for the current object.</returns>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>A string that represents the current object.</returns>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.GetComparer(System.Collections.Generic.IComparer{System.String},System.Boolean)">
            <summary>
            Return a comparator that compares the locale names for the display locale or the in-self names,
            depending on an input parameter.
            </summary>
            <param name="comparer">The string <see cref="T:System.Collections.Generic.IComparer`1"/> to order the <see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/>s.</param>
            <param name="inSelf">If true, compares the nameInSelf, otherwise the nameInDisplayLocale.</param>
            <returns><see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/> comparer.</returns>
            <stable>ICU 55</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.UiListItem.GetComparer(System.Globalization.CompareInfo,System.Boolean)">
            <summary>
            Return a comparator that compares the locale names for the display locale or the in-self names,
            depending on an input parameter.
            </summary>
            <param name="comparer">The string <see cref="T:System.Collections.Generic.IComparer`1"/> to order the <see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/>s.</param>
            <param name="inSelf">If true, compares the nameInSelf, otherwise the nameInDisplayLocale.</param>
            <returns><see cref="T:ICU4N.Text.LocaleDisplayNames.UiListItem"/> comparer.</returns>
            <stable>ICU4N 60</stable>
        </member>
        <member name="M:ICU4N.Text.LocaleDisplayNames.#ctor">
            <summary>
            Sole constructor.  (For invocation by subclass constructors,
            typically implicit.)
            </summary>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.LocaleDisplayNames.LastResortLocaleDisplayNames">
            <summary>
            Minimum implementation of <see cref="T:ICU4N.Text.LocaleDisplayNames"/>
            </summary>
        </member>
        <member name="T:ICU4N.Text.MessageFormat">
            <icuenhanced><see cref="T:ICU4N.Text.MessageFormat"/></icuenhanced><icu>_usage_</icu>
            <summary>
            <see cref="T:ICU4N.Text.MessageFormat"/> prepares strings for display to users,
            with optional arguments (variables/placeholders).
            The arguments can occur in any order, which is necessary for translation
            into languages with different grammars.
            <para/>
            A <see cref="T:ICU4N.Text.MessageFormat"/> is constructed from a <em>pattern</em> string
            with arguments in {curly braces} which will be replaced by formatted values.
            </summary>
            <remarks>
            <see cref="T:ICU4N.Text.MessageFormat"/> differs from the other <see cref="T:ICU4N.Support.Text.Formatter"/>
            classes in that you create a <see cref="T:ICU4N.Text.MessageFormat"/> object with one
            of its constructors (not with a <c>GetInstance</c> style factory
            method). Factory methods aren't necessary because <see cref="T:ICU4N.Text.MessageFormat"/>
            itself doesn't implement locale-specific behavior. Any locale-specific
            behavior is defined by the pattern that you provide and the
            subformats used for inserted arguments.
            <para/>
            Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
            Some of the API methods work only with argument numbers and throw an exception
            if the pattern has named arguments (see <see cref="P:ICU4N.Text.MessageFormat.UsesNamedArguments"/>).
            <para/>
            An argument might not specify any format type. In this case,
            a numeric type value is formatted with a default (for the locale) <see cref="T:ICU4N.Text.NumberFormat"/>,
            a <see cref="T:System.DateTime"/> value is formatted with a default (for the locale) <see cref="T:ICU4N.Text.DateFormat"/>,
            and for any other value its <c>ToString()</c> value is used.
            <para/>
            An argument might specify a "simple" type for which the specified
            <see cref="T:ICU4N.Support.Text.Formatter"/> object is created, cached and used.
            <para/>
            An argument might have a "complex" type with nested MessageFormat sub-patterns.
            During formatting, one of these sub-messages is selected according to the argument value
            and recursively formatted.
            <para/>
            After construction, a custom <see cref="T:ICU4N.Support.Text.Formatter"/> object can be set for
            a top-level argument, overriding the default formatting and parsing behavior
            for that argument.
            However, custom formatting can be achieved more simply by writing
            a typeless argument in the pattern string
            and supplying it with a preformatted string value.
            <para/>
            When formatting, <see cref="T:ICU4N.Text.NumberFormat"/> takes a collection of argument values
            and writes an output string.
            The argument values may be passed as an array
            (when the pattern contains only numbered arguments)
            or as a <see cref="T:System.Collections.Generic.IDictionary`2"/> (which works for both named and numbered arguments).
            <para/>
            Each argument is matched with one of the input values by array index or dictionary key
            and formatted according to its pattern specification
            (or using a custom <see cref="T:ICU4N.Support.Text.Formatter"/> object if one was set).
            A numbered pattern argument is matched with a map key that contains that number
            as an ASCII-decimal-digit string (without leading zero).
            
            <h3><a name="patterns">Patterns and Their Interpretation</a></h3>
            
            <see cref="T:ICU4N.Text.MessageFormat"/> uses patterns of the following form:
            <code>
            message = messageText (argument messageText)*
            argument = noneArg | simpleArg | complexArg
            complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
            
            noneArg = '{' argNameOrNumber '}'
            simpleArg = '{' argNameOrNumber ',' argType [',' argStyle] '}'
            choiceArg = '{' argNameOrNumber ',' "choice" ',' choiceStyle '}'
            pluralArg = '{' argNameOrNumber ',' "plural" ',' pluralStyle '}'
            selectArg = '{' argNameOrNumber ',' "select" ',' selectStyle '}'
            selectordinalArg = '{' argNameOrNumber ',' "selectordinal" ',' pluralStyle '}'
            
            choiceStyle: see <see cref="T:ICU4N.Support.Text.ChoiceFormat"/>
            pluralStyle: see <see cref="T:ICU4N.Text.PluralFormat"/>
            selectStyle: see <see cref="T:ICU4N.Text.SelectFormat"/>
            
            argNameOrNumber = argName | argNumber
            argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
            argNumber = '0' | ('1'..'9' ('0'..'9')*)
            
            argType = "number" | "date" | "time" | "spellout" | "ordinal" | "duration"
            argStyle = "short" | "medium" | "long" | "full" | "integer" | "currency" | "percent" | argStyleText
            </code>
            
            <list type="bullet">
                <item>
                    <description>
                        messageText can contain quoted literal strings including syntax characters.
                        A quoted literal string begins with an ASCII apostrophe and a syntax character
                        (usually a {curly brace}) and continues until the next single apostrophe.
                        A double ASCII apostrohpe inside or outside of a quoted string represents
                        one literal apostrophe.
                    </description>
                </item>
                <item>
                    <description>
                        Quotable syntax characters are the {curly braces} in all messageText parts,
                        plus the '#' sign in a messageText immediately inside a pluralStyle,
                        and the '|' symbol in a messageText immediately inside a choiceStyle.
                    </description>
                </item>
                <item>
                    <description>
                        See also <see cref="P:ICU4N.Text.MessagePattern.ApostropheMode"/>
                    </description>
                </item>
                <item>
                    <description>
                        In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
                        and unquoted {curly braces} must occur in matched pairs.
                    </description>
                </item>
            </list>
            <para/>
            Recommendation: Use the real apostrophe (single quote) character \\u2019 for
            human-readable text, and use the ASCII apostrophe (\\u0027 ' )
            only in program syntax, like quoting in <see cref="T:ICU4N.Text.MessagePattern"/>.
            See the annotations for U+0027 Apostrophe in The Unicode Standard.
            <para/>
            The <c>choice</c> argument type is deprecated.
            Use <c>plural</c> arguments for proper plural selection,
            and <c>select</c> arguments for simple selection among a fixed set of choices.
            <para/>
            The <c>argType</c> and <c>argStyle</c> values are used to create
            a <see cref="T:ICU4N.Support.Text.Formatter"/> instance for the format element. The following
            table shows how the values map to <see cref="T:ICU4N.Support.Text.Formatter"/> instances. Combinations not
            shown in the table are illegal. Any <c>argStyleText</c> must
            be a valid pattern string for the <see cref="T:ICU4N.Support.Text.Formatter"/> subclass used.
            
            <list type="table">
                <listheader>
                    <term>argType</term>
                    <term>argStyle</term>
                    <term>resulting <see cref="T:ICU4N.Support.Text.Formatter"/> object</term>
                </listheader>
                <item>
                    <term><i>(none)</i></term>
                    <term><i>(none)</i></term>
                    <term><c>null</c></term>
                </item>
                <item>
                    <term><c>number</c></term>
                    <term><i>(none)</i></term>
                    <term><c>NumberFormat.GetInstance(CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>number</c></term>
                    <term><c>integer</c></term>
                    <term><c>NumberFormat.GetIntegerInstance(CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>number</c></term>
                    <term><c>currency</c></term>
                    <term><c>NumberFormat.GetCurrencyInstance(CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>number</c></term>
                    <term><c>percent</c></term>
                    <term><c>NumberFormat.GetPercentInstance(CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>number</c></term>
                    <term><i>argStyleText</i></term>
                    <term><c>new DecimalFormat(argStyleText, new DecimalFormatSymbols(CultureInfo.CurrentCulture))</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><i>(none)</i></term>
                    <term><c>DateFormat.GetDateInstance(DateFormat.Default, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><c>short</c></term>
                    <term><c>DateFormat.GetDateInstance(DateFormat.Short, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><c>medium</c></term>
                    <term><c>DateFormat.GetDateInstance(DateFormat.Default, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><c>long</c></term>
                    <term><c>DateFormat.GetDateInstance(DateFormat.Long, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><c>full</c></term>
                    <term><c>DateFormat.GetDateInstance(DateFormat.Full, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>date</c></term>
                    <term><i>argStyleText</i></term>
                    <term><c>new SimpleDateFormat(argStyleText, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><i>(none)</i></term>
                    <term><c>DateFormat.GetTimeInstance(DateFormat.Default, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><c>short</c></term>
                    <term><c>DateFormat.GetTimeInstance(DateFormat.Short, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><c>medium</c></term>
                    <term><c>DateFormat.GetTimeInstance(DateFormat.Default, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><c>long</c></term>
                    <term><c>DateFormat.GetTimeInstance(DateFormat.Long, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><c>full</c></term>
                    <term><c>DateFormat.GetTimeInstance(DateFormat.Full, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>time</c></term>
                    <term><i>argStyleText</i></term>
                    <term><c>new SimpleDateFormat(argStyleText, CultureInfo.CurrentCulture)</c></term>
                </item>
                <item>
                    <term><c>spellout</c></term>
                    <term><i>argStyleText (optional)</i></term>
                    <term><c>new RuleBasedNumberFormat(CultureInfo.CurrentCulture, RuleBasedNumberFormat.SpellOut)<br/>
                                .SetDefaultRuleset(argStyleText);</c></term>
                </item>
                <item>
                    <term><c>ordinal</c></term>
                    <term><i>argStyleText (optional)</i></term>
                    <term><c>new RuleBasedNumberFormat(CultureInfo.CurrentCulture, RuleBasedNumberFormat.Ordinal)<br/>
                                .SetDefaultRuleset(argStyleText);</c></term>
                </item>
                <item>
                    <term><c>duration</c></term>
                    <term><i>argStyleText (optional)</i></term>
                    <term><c>new RuleBasedNumberFormat(CultureInfo.CurrentCulture, RuleBasedNumberFormat.Duration)<br/>
                                .SetDefaultRuleset(argStyleText);</c></term>
                </item>
            </list>
            
            <h4><a name="diffsjdk">Differences from <c>java.text.MessageFormat</c></a></h4>
            
            <para/>
            The ICU MessageFormat supports both named and numbered arguments,
            while the JDK MessageFormat only supports numbered arguments.
            Named arguments make patterns more readable.
            <para/>
            ICU implements a more user-friendly apostrophe quoting syntax.
            In message text, an apostrophe only begins quoting literal text
            if it immediately precedes a syntax character (mostly {curly braces}).<br/>
            In the JDK MessageFormat, an apostrophe always begins quoting,
            which requires common text like "don't" and "aujourd'hui"
            to be written with doubled apostrophes like "don''t" and "aujourd''hui".
            For more details see <see cref="P:ICU4N.Text.MessagePattern.ApostropheMode"/>.
            <para/>
            ICU does not create a ChoiceFormat object for a choiceArg, pluralArg or selectArg
            but rather handles such arguments itself.
            The JDK MessageFormat does create and use a ChoiceFormat object
            (<c>new ChoiceFormat(argStyleText)</c>).
            The JDK does not support plural and select arguments at all.
            
            <h4>Usage Information</h4>
            
            <para/>
            Here are some examples of usage:
            <code>
            object[] arguments = {
                7,
                DateTime.Now,
                "a disturbance in the Force"
            };
            
            string result = MessageFormat.Format(
                "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
                arguments);
            
            // output: At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
            </code>
            Typically, the message format will come from resources, and the
            arguments will be dynamically set at runtime.
            
            <para/>Example 2:
            <code>
            object[] testArgs = { 3, "MyDisk" };
            
            MessageFormat format = new MessageFormat(
                "The disk \"{1}\" contains {0} file(s).");
                
            Console.WriteLine(format.Format(testArgs));
            
            // output, with different testArgs
            // output: The disk "MyDisk" contains 0 file(s).
            // output: The disk "MyDisk" contains 1 file(s).
            // output: The disk "MyDisk" contains 1,273 file(s).
            </code>
            
            <para/>For messages that include plural forms, you can use a plural argument:
            <code>
            MessageFormat msgFmt = new MessageFormat(
                "{num_files, plural, " +
                "=0{There are no files on disk \"{disk_name}\".}" +
                "=1{There is one file on disk \"{disk_name}\".}" +
                "other{There are # files on disk \"{disk_name}\".}}",
                CultureInfo.CurrentCulture);
            var args = new Dictionary&lt;string, object&gt;();
            args["num_files"] = 0;
            args["disk_name"] = "MyDisk";
            Console.WriteLine(msgFmt.Format(args));
            args["num_files"] = 3;
            Console.WriteLine(msgFmt.Format(args));
            
            // output:
            // There are no files on disk "MyDisk".
            // There are 3 files on "MyDisk".
            </code>
            See <see cref="T:ICU4N.Text.PluralFormat"/> and <see cref="T:ICU4N.Text.PluralRules"/> for details.
            
            <h4><a name="synchronization">Synchronization</a></h4>
            
            <para/>
            MessageFormats are not synchronized.
            It is recommended to create separate format instances for each thread.
            If multiple threads access a format concurrently, it must be synchronized
            externally.
            </remarks>
            <seealso cref="T:System.Globalization.CultureInfo"/>
            <seealso cref="T:ICU4N.Support.Text.Formatter"/>
            <seealso cref="T:ICU4N.Text.NumberFormat"/>
            <seealso cref="T:ICU4N.Text.DecimalFormat"/>
            <seealso cref="T:ICU4N.Support.Text.ChoiceFormat"/>
            <seealso cref="T:ICU4N.Text.PluralFormat"/>
            <seealso cref="T:ICU4N.Text.SelectFormat"/>
            <author>Mark Davis</author>
            <author>Markus Scherer</author>
            <stable>ICU 3.0</stable>
            
        </member>
        <member name="M:ICU4N.Text.MessageFormat.#ctor(System.String)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.MessageFormat"/> for the default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale and the
            specified pattern.
            Sets the locale and calls <see cref="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)"/> with <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern for this message format.</param>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <seealso cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.MessageFormat"/> for the specified locale and
            pattern.
            Sets the locale and calls <see cref="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)"/> with <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern for this message format.</param>
            <param name="locale">The <see cref="T:System.Globalization.CultureInfo"/> for this message format.</param>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.#ctor(System.String,ICU4N.Util.ULocale)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.MessageFormat"/> for the specified locale and
            pattern.
            Sets the locale and calls <see cref="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)"/> with <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern for this message format.</param>
            <param name="locale">The <see cref="T:ICU4N.Util.ULocale"/> for this message format.</param>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetLocale(System.Globalization.CultureInfo)">
            <summary>
            Sets the <see cref="T:System.Globalization.CultureInfo"/> to be used for creating argument <see cref="T:ICU4N.Support.Text.Formatter"/> objects.
            This affects subsequent calls to the <see cref="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)"/>
            method as well as to the <c>Format</c> and
            <see cref="M:ICU4N.Text.MessageFormat.FormatToCharacterIterator(System.Object)"/> methods.
            </summary>
            <param name="locale">The locale to be used when creating or comparing subformats.</param>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetLocale(ICU4N.Util.ULocale)">
            <summary>
            Sets the <see cref="T:ICU4N.Util.ULocale"/> to be used for creating argument <see cref="T:ICU4N.Support.Text.Formatter"/> objects.
            This affects subsequent calls to the <see cref="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)"/>
            method as well as to the <c>Format</c> and
            <see cref="M:ICU4N.Text.MessageFormat.FormatToCharacterIterator(System.Object)"/> methods.
            </summary>
            <param name="locale">The locale to be used when creating or comparing subformats.</param>
            <stable>ICU 3.2</stable>
        </member>
        <member name="P:ICU4N.Text.MessageFormat.Locale">
            <summary>
            Gets the <see cref="T:System.Globalization.CultureInfo"/> that's used when creating or comparing subformats.
            </summary>
            <stable>ICU 3.0</stable>
        </member>
        <member name="P:ICU4N.Text.MessageFormat.ULocale">
            <summary>
            <icu/> Gets the <see cref="T:ICU4N.Util.ULocale"/> that's used when creating argument <see cref="T:ICU4N.Support.Text.Formatter"/> objects.
            It is the <see cref="T:ICU4N.Util.ULocale"/> used when creating or comparing subformats.
            </summary>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String)">
            <summary>
            Sets the pattern used by this message format.
            Parses the pattern and caches <see cref="T:ICU4N.Support.Text.Formatter"/> objects for simple argument types.
            Patterns and their interpretation are specified in the
            </summary>
            <param name="pttrn">The pattern for this message format.</param>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ApplyPattern(System.String,ICU4N.Text.ApostropheMode)">
            <summary>
            <icu/> Sets the ApostropheMode and the pattern used by this message format.
            Parses the pattern and caches Format objects for simple argument types.
            Patterns and their interpretation are specified in the documentation of
            <see cref="T:ICU4N.Text.MessageFormat"/>.
            <para/>
            This method is best used only once on a given object to avoid confusion about the mode,
            and after constructing the object with an empty pattern string to minimize overhead.
            </summary>
            <param name="pattern">The pattern for this message format.</param>
            <param name="aposMode">The new <see cref="T:ICU4N.Text.ApostropheMode"/>.</param>
            <seealso cref="P:ICU4N.Text.MessagePattern.ApostropheMode"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessageFormat.ApostropheMode">
            <summary>
            <icu/> Gets this instance's <see cref="T:ICU4N.Text.ApostropheMode"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ToPattern">
            <summary>
            Returns the applied pattern string.
            </summary>
            <returns>The pattern string.</returns>
            <exception cref="T:System.InvalidOperationException">After custom <see cref="T:ICU4N.Support.Text.Formatter"/> objects have been set
            via <see cref="M:ICU4N.Text.MessageFormat.SetFormat(System.Int32,ICU4N.Support.Text.Formatter)"/> or similar APIs.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.NextTopLevelArgStart(System.Int32)">
            <summary>
            Returns the part index of the next <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> after 
            <paramref name="partIndex"/>, or -1 if there is none more.
            </summary>
            <param name="partIndex"><see cref="P:ICU4N.Text.MessagePatternPart.Index"/> of the previous 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> (initially 0).</param>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormatsByArgumentIndex(ICU4N.Support.Text.Formatter[])">
            <summary>
            Sets the <see cref="T:ICU4N.Support.Text.Formatter"/> objects to use for the values passed into
            <c>Format</c> methods or returned from <c>Parse</c>
            methods. The indices of elements in <paramref name="newFormats"/>
            correspond to the argument indices used in the previously set
            pattern string.
            The order of formats in <paramref name="newFormats"/> thus corresponds to
            the order of elements in the <c>arguments</c> array passed
            to the <c>Format</c> methods or the result array returned
            by the <c>Parse</c> methods.
            <para/>
            If an argument index is used for more than one format element
            in the pattern string, then the corresponding new format is used
            for all such format elements. If an argument index is not used
            for any format element in the pattern string, then the
            corresponding new format is ignored. If fewer formats are provided
            than needed, then only the formats for argument indices less
            than <c>newFormats.Length</c> are replaced.
            <para/>
            This method is only supported if the format does not use
            named arguments, otherwise an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="newFormats">The new formats to use.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormats"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If this formatter uses named arguments.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormatsByArgumentName(System.Collections.Generic.IDictionary{System.String,ICU4N.Support.Text.Formatter})">
            <summary>
            <icu/> Sets the <see cref="T:ICU4N.Support.Text.Formatter"/> objects to use for the values passed into
            <c>Format</c> methods or returned from <c>Parse</c>
            methods. The keys in <paramref name="newFormats"/> are the argument
            names in the previously set pattern string, and the values
            are the formats.
            <para/>
            Only argument names from the pattern string are considered.
            Extra keys in <paramref name="newFormats"/> that do not correspond
            to an argument name are ignored.  Similarly, if there is no
            format in <paramref name="newFormats"/> for an argument name, the formatter
            for that argument remains unchanged.
            <para/>
            This may be called on formats that do not use named arguments.
            In this case the map will be queried for key strings that
            represent argument indices, e.g. "0", "1", "2" etc.
            </summary>
            <param name="newFormats">A <see cref="T:System.Collections.Generic.IDictionary`2"/> from <see cref="T:System.String"/> to 
            <see cref="T:ICU4N.Support.Text.Formatter"/> providing new formats for named arguments.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormats"/> is null.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormats(ICU4N.Support.Text.Formatter[])">
            <summary>
            Sets the <see cref="T:ICU4N.Support.Text.Formatter"/> objects to use for the format elements in the
            previously set pattern string.
            The order of formats in <paramref name="newFormats"/> corresponds to
            the order of format elements in the pattern string.
            <para/>
            If more formats are provided than needed by the pattern string,
            the remaining ones are ignored. If fewer formats are provided
            than needed, then only the first <c>newFormats.Length</c>
            formats are replaced.
            <para/>
            Since the order of format elements in a pattern string often
            changes during localization, it is generally better to use the
            <see cref="M:ICU4N.Text.MessageFormat.SetFormatByArgumentIndex(System.Int32,ICU4N.Support.Text.Formatter)"/>
            method, which assumes an order of formats corresponding to the
            order of elements in the <c>arguments</c> array passed to
            the <c>Format</c> methods or the result array returned by
            the <c>Parse</c> methods.
            </summary>
            <param name="newFormats">The new formats to use.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormats"/> is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormatByArgumentIndex(System.Int32,ICU4N.Support.Text.Formatter)">
            <summary>
            Sets the Format object to use for the format elements within the
            previously set pattern string that use the given argument
            index.
            The <paramref name="argumentIndex"/> is part of the format element definition and
            represents an index into the <c>arguments</c> array passed
            to the <c>Format</c> methods or the result array returned
            by the <c>Parse</c> methods.
            <para/>
            If the argument index is used for more than one format element
            in the pattern string, then the new format is used for all such
            format elements. If the argument index is not used for any format
            element in the pattern string, then the new format is ignored.
            <para/>
            This method is only supported when exclusively numbers are used for
            argument names. Otherwise an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="argumentIndex">The argument index for which to use the new format.</param>
            <param name="newFormat">The new format to use.</param>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormat"/> is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormatByArgumentName(System.String,ICU4N.Support.Text.Formatter)">
            <summary>
            <icu/> Sets the <see cref="T:ICU4N.Support.Text.Formatter"/> object to use for the format elements within the
            previously set pattern string that use the given argument
            name.
            <para/>
            If the argument name is used for more than one format element
            in the pattern string, then the new format is used for all such
            format elements. If the argument name is not used for any format
            element in the pattern string, then the new format is ignored.
            <para/>
            This API may be used on formats that do not use named arguments.
            In this case <paramref name="argumentName"/> should be a string that names
            an argument index, e.g. "0", "1", "2"... etc.  If it does not name
            a valid index, the format will be ignored.  No error is thrown.
            </summary>
            <param name="argumentName">The name of the argument to change.</param>
            <param name="newFormat">The new format to use.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormat"/> is null.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetFormat(System.Int32,ICU4N.Support.Text.Formatter)">
            <summary>
            Sets the <see cref="T:ICU4N.Support.Text.Formatter"/> object to use for the format element with the given
            format element index within the previously set pattern string.
            The format element index is the zero-based number of the format
            element counting from the start of the pattern string.
            <para/>
            Since the order of format elements in a pattern string often
            changes during localization, it is generally better to use the
            <see cref="M:ICU4N.Text.MessageFormat.SetFormatByArgumentIndex(System.Int32,ICU4N.Support.Text.Formatter)"/>
            method, which accesses format elements based on the argument
            index they specify.
            </summary>
            <param name="formatElementIndex">The index of a format element within the pattern.</param>
            <param name="newFormat">The format to use for the specified format element.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="formatElementIndex"/> is equal to or
            larger than the number of format elements in the pattern string.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newFormat"/> is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetFormatsByArgumentIndex">
            <summary>
            Returns the <see cref="T:ICU4N.Support.Text.Formatter"/> objects used for the values passed into
            <c>Format</c> methods or returned from <c>Parse</c>
            methods. The indices of elements in the returned array
            correspond to the argument indices used in the previously set
            pattern string.
            The order of formats in the returned array thus corresponds to
            the order of elements in the <c>arguments</c> array passed
            to the <c>Format</c> methods or the result array returned
            by the <c>Parse</c> methods.
            <para/>
            If an argument index is used for more than one format element
            in the pattern string, then the format used for the last such
            format element is returned in the array. If an argument index
            is not used for any format element in the pattern string, then
            null is returned in the array.
            <para/>
            This method is only supported when exclusively numbers are used for
            argument names. Otherwise an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <returns>The formats used for the arguments within the pattern.</returns>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetFormats">
            <summary>
            Returns the <see cref="T:ICU4N.Support.Text.Formatter"/> objects used for the format elements in the
            previously set pattern string.
            The order of formats in the returned array corresponds to
            the order of format elements in the pattern string.
            <para/>
            Since the order of format elements in a pattern string often
            changes during localization, it's generally better to use the
            <see cref="M:ICU4N.Text.MessageFormat.GetFormatsByArgumentIndex"/>
            method, which assumes an order of formats corresponding to the
            order of elements in the <c>arguments</c> array passed to
            the <c>Format</c> methods or the result array returned by
            the <c>Parse</c> methods.
            <para/>
            This method is only supported when exclusively numbers are used for
            argument names. Otherwise an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <returns>The formats used for the format elements in the pattern.</returns>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetArgumentNames">
            <summary>
            <icu/> Returns the top-level argument names. For more details, see
            <see cref="M:ICU4N.Text.MessageFormat.SetFormatByArgumentName(System.String,ICU4N.Support.Text.Formatter)"/>.
            </summary>
            <returns>A <see cref="T:System.Collections.Generic.ICollection`1"/> of argument names.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetFormatByArgumentName(System.String)">
            <summary>
            <icu/> Returns the first top-level format associated with the given <paramref name="argumentName"/>.
            For more details, see <see cref="M:ICU4N.Text.MessageFormat.SetFormatByArgumentName(System.String,ICU4N.Support.Text.Formatter)"/>.
            </summary>
            <param name="argumentName">The name of the desired argument.</param>
            <returns>The <see cref="T:ICU4N.Support.Text.Formatter"/> associated with the name, or null if there isn't one.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.Object[],System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Formats an array of objects and appends the <see cref="T:ICU4N.Text.MessageFormat"/>'s
            pattern, with arguments replaced by the formatted objects, to the
            provided <see cref="T:System.Text.StringBuilder"/>.
            <para/>
            The text substituted for the individual format elements is derived from
            the current subformat of the format element and the
            <paramref name="arguments"/> element at the format element's argument index
            as indicated by the first matching line of the following table. An
            argument is <i>unavailable</i> if <paramref name="arguments"/> is
            <c>null</c> or has fewer than argumentIndex+1 elements.  When
            an argument is unavailable no substitution is performed.
            <list type="table">
                <listheader>
                    <term>argType or Format</term>
                    <term>value object</term>
                    <term>Formatted Text</term>
                </listheader>
                <item>
                    <term><i>any</i></term>
                    <term><i>unavailable</i></term>
                    <term><c>"{" + argNameOrNumber + "}"</c></term>
                </item>
                <item>
                    <term><i>any</i></term>
                    <term><c>null</c></term>
                    <term><c>"null"</c></term>
                </item>
                <item>
                    <term>custom Formatter <c>!= null</c></term>
                    <term><i>any</i></term>
                    <term><c>customFormat.Format(argument)</c></term>
                </item>
                <item>
                    <term>noneArg, or custom Formatter <c>== null</c></term>
                    <term>is numeric type (<see cref="T:System.Double"/>, <see cref="T:System.Int64"/>, etc)</term>
                    <term><c>NumberFormat.GetInstance(CultureInfo.CurrentCulture).Format(argument)</c></term>
                </item>
                <item>
                    <term>noneArg, or custom Formatter <c>== null</c></term>
                    <term><c>is DateTime</c></term>
                    <term><c>DateFormat.GetDateTimeInstance(DateFormat.Short, DateFormat.Short, 
                                CultureInfo.CurrentCulture).Format(argument)</c></term>
                </item>
                <item>
                    <term>noneArg, or custom Formatter <c>== null</c></term>
                    <term><c>is string</c></term>
                    <term><c>argument</c></term>
                </item>
                <item>
                    <term>noneArg, or custom Formatter <c>== null</c></term>
                    <term><i>any</i></term>
                    <term><c>argument.ToString()</c></term>
                </item>
                <item>
                    <term>complexArg</term>
                    <term><i>any</i></term>
                    <term>result of recursive formatting of a selected sub-message</term>
                </item>
            </list>
            <para/>
            If <paramref name="pos"/> is non-null, and refers to
            <see cref="F:ICU4N.Text.MessageFormatField.Argument"/>, the location of the first formatted
            string will be returned.
            <para/>
            This method is only supported when the format does not use named
            arguments, otherwise an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="arguments">An array of objects to be formatted and substituted.</param>
            <param name="result">Where text is appended.</param>
            <param name="pos">On input: an alignment field, if desired.
            On output: the offsets of the alignment field.</param>
            <exception cref="T:System.ArgumentException">If a value in the
            <paramref name="arguments"/> array is not of the type
            expected by the corresponding argument or custom <see cref="T:ICU4N.Support.Text.Formatter"/> object.</exception>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="pos"/> argument is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.Collections.Generic.IDictionary{System.String,System.Object},System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Formats a dictionary of objects and appends the <see cref="T:ICU4N.Text.MessageFormat"/>'s
            pattern, with <paramref name="arguments"/> replaced by the formatted objects, to the
            provided <see cref="T:System.Text.StringBuilder"/>.
            <para/>
            The text substituted for the individual format elements is derived from
            the current subformat of the format element and the
            <paramref name="arguments"/> value corresopnding to the format element's
            argument name.
            <para/>
            A numbered pattern argument is matched with a map key that contains that number
            as an ASCII-decimal-digit string (without leading zero).
            <para/>
            An argument is <i>unavailable</i> if <paramref name="arguments"/> is
            <c>null</c> or does not have a value corresponding to an argument
            name in the pattern.  When an argument is unavailable no substitution
            is performed.
            </summary>
            <param name="arguments">A <see cref="T:System.Collections.Generic.IDictionary`2"/> to be formatted and substituted.</param>
            <param name="result">Where text is appended.</param>
            <param name="pos">On input: an alignment field, if desired.
            On output: the offsets of the alignment field.</param>
            <exception cref="T:System.ArgumentException">If a value in the
            <paramref name="arguments"/> array is not of the type
            expected by the corresponding argument or custom <see cref="T:ICU4N.Support.Text.Formatter"/> object.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="pos"/> argument is null.</exception>
            <returns>The passed-in <see cref="T:System.Text.StringBuilder"/>.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.String,System.Object[])">
            <summary>
            Creates a <see cref="T:ICU4N.Text.MessageFormat"/> with the given <paramref name="pattern"/> and uses it
            to format the given <paramref name="arguments"/>. This is equivalent to
            <code>
            Format(arguments, new StringBuilder(), null).ToString()
            </code>
            </summary>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <exception cref="T:System.ArgumentException">If a value in the
            <paramref name="arguments"/> array is not of the type
            expected by the corresponding argument or custom <see cref="T:ICU4N.Support.Text.Formatter"/> object.</exception>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates a <see cref="T:ICU4N.Text.MessageFormat"/> with the given pattern and uses it to
            format the given arguments.  The pattern must identify arguments
            by name instead of by number.
            </summary>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
            <exception cref="T:System.ArgumentException">If a value in the
            <paramref name="arguments"/> array is not of the type
            expected by the corresponding argument or custom <see cref="T:ICU4N.Support.Text.Formatter"/> object.</exception>
            <seealso cref="M:ICU4N.Text.MessageFormat.Format(System.Collections.Generic.IDictionary{System.String,System.Object},System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)"/>
            <seealso cref="M:ICU4N.Text.MessageFormat.Format(System.String,System.Object[])"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessageFormat.UsesNamedArguments">
            <summary>
            <icu/> Returns true if this <see cref="T:ICU4N.Text.MessageFormat"/> uses named arguments,
            and false otherwise. See <see cref="T:ICU4N.Text.MessageFormat"/>.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.Object,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Formats a <see cref="T:System.Collections.Generic.IDictionary`2"/> or array of objects and appends the <see cref="T:ICU4N.Text.MessageFormat"/>'s
            pattern, with format elements replaced by the formatted objects, to the
            provided <see cref="T:System.Text.StringBuilder"/>.
            <para/>
            This is equivalent to either of <see cref="M:ICU4N.Text.MessageFormat.Format(System.Object[],System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)"/>
            or <see cref="M:ICU4N.Text.MessageFormat.Format(System.Collections.Generic.IDictionary{System.String,System.Object},System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)"/>.
            A <see cref="T:System.Collections.Generic.IDictionary`2"/> must be provided if this format uses named arguments, otherwise
            an <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
            <param name="arguments">A <see cref="T:System.Collections.Generic.IDictionary`2"/> or array of <see cref="T:System.Object"/>s to be formatted.</param>
            <param name="result">Where text is appended/</param>
            <param name="pos">On input: an alignment field, if desired
            On output: the offsets of the alignment field.</param>
            <exception cref="T:System.ArgumentException">If an argument in <paramref name="arguments"/> is not of the type
            expected by the format element(s) that use it.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="arguments"/> is
            an array of <see cref="T:System.Object"/> and this format uses named arguments.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="pos"/> argument is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.FormatToCharacterIterator(System.Object)">
            <summary>
            Formats an array of objects and inserts them into the
            <see cref="T:ICU4N.Text.MessageFormat"/>'s pattern, producing an
            <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.
            You can use the returned <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>
            to build the resulting <see cref="T:System.String"/>, as well as to determine information
            about the resulting <see cref="T:System.String"/>.
            <para/>
            The text of the returned <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> is
            the same that would be returned by
            <code>
            Format(arguments, new StringBuilder(), null).ToString()
            </code>
            In addition, the <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> contains at
            least attributes indicating where text was generated from an
            argument in the <paramref name="arguments"/> array. The keys of these attributes are of
            type <see cref="T:ICU4N.Text.MessageFormatField"/>, their values are
            <see cref="T:System.Int32"/> objects indicating the index in the <paramref name="arguments"/>
            array of the argument from which the text was generated.
            <para/>
            The attributes/value from the underlying <see cref="T:ICU4N.Support.Text.Formatter"/>
            instances that <see cref="T:ICU4N.Text.MessageFormat"/> uses will also be
            placed in the resulting <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/>.
            This allows you to not only find where an argument is placed in the
            resulting <see cref="T:System.String"/>, but also which fields it contains in turn.
            </summary>
            <param name="arguments">An array of objects to be formatted and substituted.</param>
            <returns><see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> describing the formatted value.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="arguments"/> is null.</exception>
            <exception cref="T:System.ArgumentException">if a value in the
            <paramref name="arguments"/> array is not of the type
            expected by the corresponding argument or custom <see cref="T:ICU4N.Support.Text.Formatter"/> object.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            Parses the string.
            </summary>
            <remarks>
            Caveats: The parse may fail in a number of circumstances.
            For example:
            <list type="bullet">
                <item>
                    <description>
                        If one of the arguments does not occur in the pattern.
                    </description>
                </item>
                <item>
                    <description>
                        If the format of an argument loses information, such as
                        with a choice format where a large number formats to "many".
                    </description>
                </item>
                <item>
                    <description>
                        Does not yet handle recursion (where
                        the substituted strings contain {n} references.)
                    </description>
                </item>
                <item>
                    <description>
                        Will not always find a match (or the correct match)
                        if some part of the parse is ambiguous.
                        For example, if the pattern "{1},{2}" is used with the
                        string arguments {"a,b", "c"}, it will format as "a,b,c".
                        When the result is parsed, it will return {"a", "b,c"}.
                    </description>
                </item>
                <item>
                    <description>
                        If a single argument is parsed more than once in the string,
                        then the later parse wins.
                    </description>
                </item>
            </list>
            When the parse fails, use <see cref="P:ICU4N.Support.Text.ParsePosition.ErrorIndex"/> to find out
            where in the string did the parsing failed. The returned error
            index is the starting offset of the sub-patterns that the string
            is comparing with. For example, if the parsing string "AAA {0} BBB"
            is comparing against the pattern "AAD {0} BBB", the error index is
            0. When an error occurs, the call to this method will return null.
            If the source is null, return an empty array.
            </remarks>
            <exception cref="T:System.ArgumentException">If this format uses named arguments</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="pos"/> argument is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ParseToMap(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            <icu/> Parses the string, returning the results in a <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            This is similar to the version that returns an array
            of <see cref="T:System.Object"/>.  This supports both named and numbered
            arguments-- if numbered, the keys in the map are the
            corresponding ASCII-decimal-digit strings (e.g. "0", "1", "2"...).
            </summary>
            <param name="source">The text to parse.</param>
            <param name="pos">The position at which to start parsing.  On return,
            contains the result of the parse.</param>
            <returns>A <see cref="T:System.Collections.Generic.IDictionary`2"/> containing key/value pairs for each parsed argument.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Parse(System.String)">
            <summary>
            Parses text from the beginning of the given string to produce an object
            array.
            The method may not use the entire text of the given string.
            <para/>
            See the <see cref="M:ICU4N.Text.MessageFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)"/> method for more information
            on message parsing.
            </summary>
            <param name="source">A <see cref="T:System.String"/> whose beginning should be parsed.</param>
            <returns>An <see cref="T:System.Object"/> array parsed from the string.</returns>
            <exception cref="T:System.FormatException">If the beginning of the specified string cannot be parsed.</exception>
            <exception cref="T:System.ArgumentException">If this format uses named arguments.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Parse(System.Int32,System.String,ICU4N.Support.Text.ParsePosition,System.Object[],System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Parses the string, filling either the <paramref name="argsMap"/> or the <paramref name="args"/>.
            This is a private method that all the public parsing methods call.
            This supports both named and numbered
            arguments-- if numbered, the keys in the map are the
            corresponding ASCII-decimal-digit strings (e.g. "0", "1", "2"...).
            </summary>
            <param name="msgStart">Index in the message pattern to start from.</param>
            <param name="source">The text to parse</param>
            <param name="pos">The position at which to start parsing.  On return,
            contains the result of the parse.</param>
            <param name="args">If not null, the parse results will be filled here (The pattern
            has to have numbered arguments in order for this to not be null).</param>
            <param name="argsMap">If not null, the parse results will be filled here.</param>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ParseToMap(System.String)">
            <summary>
            <icu/> Parses text from the beginning of the given string to produce a <see cref="T:System.Collections.Generic.IDictionary`2"/> from
            argument to values. The method may not use the entire text of the given string.
            <para/>
            See the <see cref="M:ICU4N.Text.MessageFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)"/> method for more information on
            message parsing.
            </summary>
            <param name="source">A <see cref="T:System.String"/> whose beginning should be parsed.</param>
            <returns>A <see cref="T:System.Collections.Generic.IDictionary`2"/> parsed from the string.</returns>
            <exception cref="T:System.FormatException">If the beginning of the specified string cannot be parsed.</exception>
            <seealso cref="M:ICU4N.Text.MessageFormat.ParseToMap(System.String,ICU4N.Support.Text.ParsePosition)"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            Parses text from a string to produce an object array or <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            <para/>
            The method attempts to parse text starting at the index given by
            <paramref name="pos"/>.
            If parsing succeeds, then the index of <paramref name="pos"/> is updated
            to the index after the last character used (parsing does not necessarily
            use all characters up to the end of the string), and the parsed
            object array is returned. The updated <paramref name="pos"/> can be used to
            indicate the starting point for the next call to this method.
            If an error occurs, then the index of <paramref name="pos"/> is not
            changed, the error index of <paramref name="pos"/> is set to the index of
            the character where the error occurred, and null is returned.
            <para/>
            See the <see cref="M:ICU4N.Text.MessageFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)"/> method for more information
            on message parsing.
            </summary>
            <param name="source">A <see cref="T:System.String"/>, part of which should be parsed.</param>
            <param name="pos">A <see cref="T:ICU4N.Support.Text.ParsePosition"/> object with index and error
            index information as described above.</param>
            <returns>
            An <see cref="T:System.Object"/> parsed from the string, either an
            array of <see cref="T:System.Object"/>, or a <see cref="T:System.Collections.Generic.IDictionary`2"/>,
            depending on whether named
            arguments are used.  This can be queried using <see cref="P:ICU4N.Text.MessageFormat.UsesNamedArguments"/>.
            In case of error, returns null.
            </returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="pos"/> is null.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Clone">
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Equals(System.Object)">
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetHashCode">
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Text.MessageFormat.ulocale">
            <summary>
            The locale to use for formatting numbers and dates.
            </summary>
        </member>
        <member name="F:ICU4N.Text.MessageFormat.msgPattern">
            <summary>
            The <see cref="T:ICU4N.Text.MessagePattern"/> which contains the parsed structure of the pattern string.
            </summary>
        </member>
        <member name="F:ICU4N.Text.MessageFormat.cachedFormatters">
            <summary>
            Cached formatters so we can just use them whenever needed instead of creating
            them from scratch every time.
            </summary>
        </member>
        <member name="F:ICU4N.Text.MessageFormat.customFormatArgStarts">
            <summary>
            Set of <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/>part indexes where custom, user-provided <see cref="T:ICU4N.Support.Text.Formatter"/> objects
            have been set via <see cref="M:ICU4N.Text.MessageFormat.SetFormat(System.Int32,ICU4N.Support.Text.Formatter)"/> or similar API.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.Int32,ICU4N.Text.MessageFormat.PluralSelectorContext,System.Object[],System.Collections.Generic.IDictionary{System.String,System.Object},ICU4N.Text.MessageFormat.AppendableWrapper,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Formats the arguments and writes the result into the
            <see cref="T:ICU4N.Text.MessageFormat.AppendableWrapper"/>, updates the field position.
            <para/>
            Exactly one of args and <paramref name="argsMap"/> must be null, the other non-null.
            </summary>
            <param name="msgStart">Index to msgPattern part to start formatting from.</param>
            <param name="pluralNumber">null except when formatting a plural argument sub-message
            where a '#' is replaced by the format string for this number.</param>
            <param name="args">The formattable objects array. Non-null iff numbered values are used.</param>
            <param name="argsMap">The key-value map of formattable objects. Non-null iff named values are used.</param>
            <param name="dest">Output parameter to receive the result.
            The result (string &amp; attributes) is appended to existing contents.</param>
            <param name="fp">Field position status.</param>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.GetLiteralStringUntilNextArgument(System.Int32)">
            <summary>
            Read as much literal string from the pattern string as possible. This stops
            as soon as it finds an argument, or it reaches the end of the string.
            </summary>
            <param name="from">Index in the pattern string to start from.</param>
            <returns>A substring from the pattern string representing the longest possible
            substring with no arguments.</returns>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.FindChoiceSubMessage(ICU4N.Text.MessagePattern,System.Int32,System.Double)">
            <summary>
            Finds the <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> sub-message for the given number.
            </summary>
            <param name="pattern">A <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <param name="partIndex">the index of the first <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> argument style part.</param>
            <param name="number">a number to be mapped to one of the <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> argument's intervals</param>
            <returns>the sub-message start part index.</returns>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.MatchStringUntilLimitPart(ICU4N.Text.MessagePattern,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Matches the <paramref name="pattern"/> string from the end of the <paramref name="partIndex"/> to
            the beginning of the <paramref name="limitPartIndex"/>,
            including all syntax except <see cref="F:ICU4N.Text.MessagePatternPartType.SkipSyntax"/>
            against the <paramref name="source"/> string starting at <paramref name="sourceOffset"/>.
            If they match, returns the length of the <paramref name="source"/> string match.
            Otherwise returns -1.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.FindOtherSubMessage(System.Int32)">
            <summary>
            Finds the "other" sub-message.
            </summary>
            <param name="partIndex">the index of the first <see cref="T:ICU4N.Text.PluralFormat"/> argument style part.</param>
            <returns>the "other" sub-message start part index.</returns>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.FindFirstPluralNumberArg(System.Int32,System.String)">
            <summary>
            Returns the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> index of the first occurrence of the plural number in a sub-message.
            Returns -1 if it is a <see cref="F:ICU4N.Text.MessagePatternPartType.ReplaceNumber"/>.
            Returns 0 if there is neither.
            </summary>
        </member>
        <member name="T:ICU4N.Text.MessageFormat.PluralSelectorContext">
            <summary>
            Mutable input/output values for the <see cref="T:ICU4N.Text.MessageFormat.PluralSelectorProvider"/>.
            Separate so that it is possible to make MessageFormat Freezable.
            </summary>
        </member>
        <member name="F:ICU4N.Text.MessageFormat.PluralSelectorContext.number">
            argument number - plural offset 
        </member>
        <member name="F:ICU4N.Text.MessageFormat.PluralSelectorContext.numberArgIndex">
            -1 if REPLACE_NUMBER, 0 arg not found, >0 ARG_START index 
        </member>
        <member name="F:ICU4N.Text.MessageFormat.PluralSelectorContext.numberString">
            formatted argument number - plural offset 
        </member>
        <member name="F:ICU4N.Text.MessageFormat.PluralSelectorContext.forReplaceNumber">
            true if number-offset was formatted with the stock number formatter 
        </member>
        <member name="T:ICU4N.Text.MessageFormat.PluralSelectorProvider">
            <summary>
            This provider helps defer instantiation of a <see cref="T:ICU4N.Text.PluralRules"/> object
            until we actually need to select a keyword.
            For example, if the number matches an explicit-value selector like "=1"
            we do not need any <see cref="T:ICU4N.Text.PluralRules"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.Format(System.Object[],System.Collections.Generic.IDictionary{System.String,System.Object},ICU4N.Text.MessageFormat.AppendableWrapper,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Internal routine used by format.
            </summary>
            <exception cref="T:System.ArgumentException">if an argument in the
            <paramref name="arguments"/> map is not of the type
            expected by the format element(s) that use it.</exception>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.WriteObject(System.IO.Stream)">
            Custom serialization, new in ICU 4.8.
            We do not want to use default serialization because we only have a small
            amount of persistent state which is better expressed explicitly
            rather than via writing field objects.
            @param out The output stream.
            @serialData Writes the locale as a BCP 47 language tag string,
            the MessagePattern.ApostropheMode as an object,
            and the pattern string (null if none was applied).
            Followed by an int with the number of (int formatIndex, Object formatter) pairs,
            and that many such pairs, corresponding to previous setFormat() calls for custom formats.
            Followed by an int with the number of (int, Object) pairs,
            and that many such pairs, for future (post-ICU 4.8) extension of the serialization format.
        </member>
        <member name="M:ICU4N.Text.MessageFormat.ReadObject(System.IO.Stream)">
            <summary>
            Custom deserialization, new in ICU 4.8. See comments on writeObject().
            </summary>
            <exception cref="T:System.InvalidOperationException">if the objects read from the stream is invalid.</exception>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetArgStartFormat(System.Int32,ICU4N.Support.Text.Formatter)">
            <summary>
            Sets a formatter for a <see cref="T:ICU4N.Text.MessagePattern"/> <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> part index.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.SetCustomArgStartFormat(System.Int32,ICU4N.Support.Text.Formatter)">
            <summary>
            Sets a custom formatter for a <see cref="T:ICU4N.Text.MessagePattern"/> <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> part index.
            "Custom" formatters are provided by the user via <see cref="M:ICU4N.Text.MessageFormat.SetFormat(System.Int32,ICU4N.Support.Text.Formatter)"/> or similar APIs.
            </summary>
            <param name="argStart"></param>
            <param name="formatter"></param>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.AutoQuoteApostrophe(System.String)">
            <summary>
            <icu/> Converts an 'apostrophe-friendly' pattern into a standard
            pattern.
            <em>This is obsolete for ICU 4.8 and higher MessageFormat pattern strings.</em>
            </summary>
            <remarks>
            See the class description for more about apostrophes and quoting,
            and differences between ICU and java.text.MessageFormat.
            <para/>
            java.text.MessageFormat and ICU 4.6 and earlier <see cref="T:ICU4N.Text.MessageFormat"/>
            treat all ASCII apostrophes as
            quotes, which is problematic in some languages, e.g.
            French, where apostrophe is commonly used.  This utility
            assumes that only an unpaired apostrophe immediately before
            a brace is a true quote.  Other unpaired apostrophes are paired,
            and the resulting standard pattern string is returned.
            <para/>
            <b>Note</b>: It is not guaranteed that the returned pattern
            is indeed a valid pattern.  The only effect is to convert
            between patterns having different quoting semantics.
            <para/>
            <b>Note</b>: This method only works on top-level messageText,
            not messageText nested inside a complexArg.
            </remarks>
            <param name="pattern">the 'apostrophe-friendly' pattern to convert</param>
            <returns>the standard equivalent of the original pattern</returns>
            <stable>ICU 3.4</stable>
        </member>
        <member name="T:ICU4N.Text.MessageFormat.AppendableWrapper">
            <summary>
            Convenience wrapper for Appendable, tracks the result string length.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessageFormat.AttributeAndPosition.#ctor(System.Object,System.Int32,System.Int32)">
            <summary>
            Defaults the field to <see cref="F:ICU4N.Text.MessageFormatField.Argument"/>.
            </summary>
        </member>
        <member name="T:ICU4N.Text.MessageFormatField">
            <summary>
            Defines constants that are used as attribute keys in the
            <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> returned
            from <see cref="M:ICU4N.Text.MessageFormat.FormatToCharacterIterator(System.Object)"/>.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormatField.#ctor(System.String)">
            <summary>
            Create a <see cref="T:ICU4N.Text.MessageFormatField"/> with the specified name.
            </summary>
            <param name="name">The name of the attribute</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessageFormatField.ReadResolve">
            <summary>
            Resolves instances being deserialized to the predefined constants.
            </summary>
            <returns>resolved <see cref="T:ICU4N.Text.MessageFormatField"/> constant</returns>
            <exception cref="T:System.InvalidOperationException">if the constant could not be resolved.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessageFormatField.Argument">
            <summary>
            Constant identifying a portion of a message that was generated
            from an argument passed into <see cref="M:ICU4N.Text.MessageFormat.FormatToCharacterIterator(System.Object)"/>.
            The value associated with the key will be an <see cref="T:System.Int32"/>
            indicating the index in the <c>arguments</c> array of the
            argument from which the text was generated.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Text.ApostropheMode">
            <summary>
            Mode for when an apostrophe starts quoted literal text for <see cref="T:ICU4N.Text.MessageFormat"/> output.
            The default is DOUBLE_OPTIONAL unless overridden via <see cref="T:ICU4N.ICUConfig"/>.
            </summary>
            <remarks>
            A pair of adjacent apostrophes always results in a single apostrophe in the output,
            even when the pair is between two single, text-quoting apostrophes.
            <para/>
            The following table shows examples of desired <see cref="M:ICU4N.Text.MessageFormat.Format(System.String,System.Object[])"/> output
            with the pattern strings that yield that output.
            <list type="table">
                <listheader>
                    <term>Desired output</term>
                    <term><see cref="F:ICU4N.Text.ApostropheMode.DoubleOptional"/></term>
                    <term><see cref="F:ICU4N.Text.ApostropheMode.DoubleRequired"/></term>
                </listheader>
                <item>
                    <term>I see {many}</term>
                    <term>I see '{many}'</term>
                    <term>(same)</term>
                </item>
                <item>
                    <term>I said {'Wow!'}</term>
                    <term>I said '{''Wow!''}'</term>
                    <term>(same)</term>
                </item>
                <item>
                    <term>I don't know</term>
                    <term>I don't know OR<br/> I don''t know</term>
                    <term>I don''t know</term>
                </item>
            </list>
            </remarks>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ApostropheMode.DoubleOptional">
            <summary>
            A literal apostrophe is represented by
            either a single or a double apostrophe pattern character.
            Within a <see cref="T:ICU4N.Text.MessageFormat"/> pattern, a single apostrophe only starts quoted literal text
            if it immediately precedes a curly brace {},
            or a pipe symbol | if inside a choice format,
            or a pound symbol # if inside a plural format.
            <para/>
            This is the default behavior starting with ICU 4.8.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ApostropheMode.DoubleRequired">
            <summary>
            A literal apostrophe must be represented by
            a double apostrophe pattern character.
            A single apostrophe always starts quoted literal text.
            <para/>
            This is the behavior of ICU 4.6 and earlier, and of the JDK's java.text.MessageFormat.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.MessagePatternArgType">
            <summary>
            Argument type constants.
            Returned by <see cref="P:ICU4N.Text.MessagePatternPart.ArgType"/> for 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> and <see cref="F:ICU4N.Text.MessagePatternPartType.ArgLimit"/> parts.
            <para/>
            Messages nested inside an argument are each delimited by <see cref="F:ICU4N.Text.MessagePatternPartType.MsgStart"/> and <see cref="F:ICU4N.Text.MessagePatternPartType.MsgLimit"/>,
            with a nesting level one greater than the surrounding message.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.None">
            <summary>
            The argument has no specified type.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.Simple">
            <summary>
            The argument has a "simple" type which is provided by the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgType"/> part.
            An <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStyle"/> part might follow that.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.Choice">
            <summary>
            The argument is a <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> with one or more
            ((<see cref="F:ICU4N.Text.MessagePatternPartType.ArgInt"/> | <see cref="F:ICU4N.Text.MessagePatternPartType.ArgDouble"/>), 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/>, message) tuples.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.Plural">
            <summary>
            The argument is a cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> with an optional <see cref="F:ICU4N.Text.MessagePatternPartType.ArgInt"/> 
            or <see cref="F:ICU4N.Text.MessagePatternPartType.ArgDouble"/> offset (e.g., offset:1)
            and one or more (<see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/> [explicit-value] message) tuples.
            If the selector has an explicit value (e.g., =2), then that value is provided by the 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgInt"/>  or <see cref="F:ICU4N.Text.MessagePatternPartType.ArgDouble"/> part preceding the message.
            Otherwise the message immediately follows the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.Select">
            <summary>
            The argument is a <see cref="T:ICU4N.Text.SelectFormat"/> with one or more (<see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/>, message) pairs.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternArgType.SelectOrdinal">
            <summary>
            The argument is an ordinal-number <see cref="T:ICU4N.Text.PluralFormat"/>
            with the same style parts sequence and semantics as <see cref="F:ICU4N.Text.MessagePatternArgType.Plural"/>
            </summary>
            <stable>ICU 50</stable>
        </member>
        <member name="T:ICU4N.Text.MessagePatternPartType">
            <summary>
            Part type constants.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.MsgStart">
            <summary>
            Start of a message pattern (main or nested).
            The length is 0 for the top-level message
            and for a choice argument sub-message, otherwise 1 for the '{'.
            The value indicates the nesting level, starting with 0 for the main message.
            <para/>
            There is always a later <see cref="F:ICU4N.Text.MessagePatternPartType.MsgLimit"/> part.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.MsgLimit">
            <summary>
            End of a message pattern (main or nested).
            The length is 0 for the top-level message and
            the last sub-message of a choice argument,
            otherwise 1 for the '}' or (in a choice argument style) the '|'.
            The value indicates the nesting level, starting with 0 for the main message.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.SkipSyntax">
            <summary>
            Indicates a substring of the pattern string which is to be skipped when formatting.
            For example, an apostrophe that begins or ends quoted text
            would be indicated with such a part.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.InsertChar">
            <summary>
            Indicates that a syntax character needs to be inserted for auto-quoting.
            The length is 0.
            The value is the character code of the insertion character. (U+0027=APOSTROPHE)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ReplaceNumber">
            <summary>
            Indicates a syntactic (non-escaped) # symbol in a plural variant.
            When formatting, replace this part's substring with the
            (value-offset) for the plural argument value.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgStart">
            <summary>
            Start of an argument.
            The length is 1 for the '{'.
            The value is the ordinal value of the <see cref="T:ICU4N.Text.MessagePatternArgType"/>.
            Use <see cref="P:ICU4N.Text.MessagePatternPart.ArgType"/>.
            <para/>
            This part is followed by either an <see cref="F:ICU4N.Text.MessagePatternPartType.ArgNumber"/> or <see cref="F:ICU4N.Text.MessagePatternPartType.ArgName"/>,
            followed by optional argument sub-parts (see <see cref="T:ICU4N.Text.MessagePatternArgType"/>)
            and finally an <see cref="F:ICU4N.Text.MessagePatternPartType.ArgLimit"/> part.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgLimit">
            <summary>
            End of an argument.
            The length is 1 for the '}'.
            The value is the ordinal value of the <see cref="T:ICU4N.Text.MessagePatternArgType"/>. 
            Use <see cref="P:ICU4N.Text.MessagePatternPart.ArgType"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgNumber">
            <summary>
            The argument number, provided by the value.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgName">
            <summary>
            The argument name.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgType">
            <summary>
            The argument type.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgStyle">
            <summary>
            The argument style text.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgSelector">
            <summary>
            A selector substring in a "complex" argument style.
            The value is undefined and currently always 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgInt">
            <summary>
            An integer value, for example the offset or an explicit selector value
            in a <see cref="T:ICU4N.Text.PluralFormat"/> style.
            The part value is the integer value.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePatternPartType.ArgDouble">
            <summary>
            A numeric value, for example the offset or an explicit selector value
            in a <see cref="T:ICU4N.Text.PluralFormat"/> style.
            The part value is an index into an internal array of numeric values;
            use <see cref="M:ICU4N.Text.MessagePattern.GetNumericValue(ICU4N.Text.MessagePatternPart)"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.MessagePatternEnumExtensions">
            <summary>
            Extension methods for <see cref="T:ICU4N.Text.MessagePatternArgType"/> and <see cref="T:ICU4N.Text.MessagePatternPartType"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessagePatternEnumExtensions.HasPluralStyle(ICU4N.Text.MessagePatternArgType)">
            <summary>
            
            </summary>
            <param name="argType"></param>
            <returns>true if the argument type has a plural style part sequence and semantics,
            for example <see cref="F:ICU4N.Text.MessagePatternArgType.Plural"/> and <see cref="F:ICU4N.Text.MessagePatternArgType.SelectOrdinal"/>.
            </returns>
        </member>
        <member name="M:ICU4N.Text.MessagePatternEnumExtensions.HasNumericValue(ICU4N.Text.MessagePatternPartType)">
            <summary>
            Indicates whether this part has a numeric value.
            If so, then that numeric value can be retrieved via <see cref="M:ICU4N.Text.MessagePattern.GetNumericValue(ICU4N.Text.MessagePatternPart)"/>
            </summary>
            <param name="partType"></param>
            <returns>true if this part has a numeric value.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.MessagePatternPart">
            <summary>
            A message pattern "part", representing a pattern parsing event.
            There is a part for the start and end of a message or argument,
            for quoting and escaping of and with ASCII apostrophes,
            and for syntax elements of "complex" arguments.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.Type">
            <summary>
            Returns the type of this <see cref="T:ICU4N.Text.MessagePatternPart"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.Index">
            <summary>
            Gets the pattern string index associated with this <see cref="T:ICU4N.Text.MessagePatternPart"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.Length">
            <summary>
            Gets the length of the pattern substring associated with this <see cref="T:ICU4N.Text.MessagePatternPart"/>.
            This is 0 for some parts.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.Limit">
            <summary>
            Gets the pattern string limit (exclusive-end) index associated with this <see cref="T:ICU4N.Text.MessagePatternPart"/>.
            Convenience method for <see cref="P:ICU4N.Text.MessagePatternPart.Index"/> + <see cref="P:ICU4N.Text.MessagePatternPart.Length"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.Value">
            <summary>
            Gets a value associated with this part.
            See the documentation of each part type for details.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePatternPart.ArgType">
            <summary>
            Gets the argument type if this part is of type <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> or 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgLimit"/>, otherwise <see cref="F:ICU4N.Text.MessagePatternArgType.None"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePatternPart.ToString">
            <returns>a string representation of this part.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePatternPart.Equals(System.Object)">
            <param name="other">another object to compare with.</param>
            <returns>true if this object is equivalent to the other one.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePatternPart.GetHashCode">
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePatternPart.Clone">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="T:ICU4N.Text.MessagePattern">
            <summary>
            Parses and represents ICU <see cref="T:ICU4N.Text.MessageFormat"/> patterns.
            Also handles patterns for <see cref="T:ICU4N.Support.Text.ChoiceFormat"/>, <see cref="T:ICU4N.Text.PluralFormat"/> and <see cref="T:ICU4N.Text.SelectFormat"/>.
            Used in the implementations of those classes as well as in tools
            for message validation, translation and format conversion.
            </summary>
            <remarks>
            The parser handles all syntax relevant for identifying message arguments.
            This includes "complex" arguments whose style strings contain
            nested MessageFormat pattern substrings.
            For "simple" arguments (with no nested <see cref="T:ICU4N.Text.MessageFormat"/> pattern substrings),
            the argument style is not parsed any further.
            <para/>
            The parser handles named and numbered message arguments and allows both in one message.
            <para/>
            Once a pattern has been parsed successfully, iterate through the parsed data
            with <see cref="M:ICU4N.Text.MessagePattern.CountParts"/>, <see cref="M:ICU4N.Text.MessagePattern.GetPart(System.Int32)"/> and related methods.
            <para/>
            The data logically represents a parse tree, but is stored and accessed
            as a list of "parts" for fast and simple parsing and to minimize object allocations.
            Arguments and nested messages are best handled via recursion.
            For every _START "part", <see cref="M:ICU4N.Text.MessagePattern.GetLimitPartIndex(System.Int32)"/> efficiently returns
            the index of the corresponding _LIMIT "part".
            <para/>
            List of "parts":
            <code>
            message = MSG_START (SKIP_SYNTAX | INSERT_CHAR | REPLACE_NUMBER | argument)* MSG_LIMIT
            argument = noneArg | simpleArg | complexArg
            complexArg = choiceArg | pluralArg | selectArg
            
            noneArg = ARG_START.NONE (ARG_NAME | ARG_NUMBER) ARG_LIMIT.NONE
            simpleArg = ARG_START.SIMPLE (ARG_NAME | ARG_NUMBER) ARG_TYPE [ARG_STYLE] ARG_LIMIT.SIMPLE
            choiceArg = ARG_START.CHOICE (ARG_NAME | ARG_NUMBER) choiceStyle ARG_LIMIT.CHOICE
            pluralArg = ARG_START.PLURAL (ARG_NAME | ARG_NUMBER) pluralStyle ARG_LIMIT.PLURAL
            selectArg = ARG_START.SELECT (ARG_NAME | ARG_NUMBER) selectStyle ARG_LIMIT.SELECT
            
            choiceStyle = ((ARG_INT | ARG_DOUBLE) ARG_SELECTOR message)+
            pluralStyle = [ARG_INT | ARG_DOUBLE] (ARG_SELECTOR [ARG_INT | ARG_DOUBLE] message)+
            selectStyle = (ARG_SELECTOR message)+
            </code>
            <list type="bullet">
                <item>
                    <description>
                        Literal output text is not represented directly by "parts" but accessed
                        between parts of a message, from one part's <see cref="P:ICU4N.Text.MessagePatternPart.Limit"/> 
                        to the next part's <see cref="P:ICU4N.Text.MessagePatternPart.Index"/>.
                    </description>
                </item>
                <item>
                    <description>
                        <c>ARG_START.CHOICE</c> stands for an <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> <see cref="T:ICU4N.Text.MessagePatternPart"/> 
                        with <see cref="F:ICU4N.Text.MessagePatternArgType.Choice"/>.
                    </description>
                </item>
                <item>
                    <description>
                        In the choiceStyle, the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/> has the '&lt;', the '#' or
                        the less-than-or-equal-to sign (U+2264).
                    </description>
                </item>
                <item>
                    <description>
                        In the pluralStyle, the first, optional numeric Part has the "offset:" value.
                        The optional numeric <see cref="T:ICU4N.Text.MessagePatternPart"/> between each 
                        (<see cref="F:ICU4N.Text.MessagePatternPartType.ArgSelector"/>, message) pair
                        is the value of an explicit-number selector like "=2",
                        otherwise the selector is a non-numeric identifier.
                    </description>
                </item>
                <item>
                    <description>
                        The <see cref="F:ICU4N.Text.MessagePatternPartType.ReplaceNumber"/> <see cref="T:ICU4N.Text.MessagePatternPart"/> can occur only 
                        in an immediate sub-message of the pluralStyle.
                    </description>
                </item>
            </list>
            <para/>
            This class is not intended for public subclassing.
            </remarks>
            <stable>ICU 4.8</stable>
            <author>Markus Scherer</author>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.#ctor">
            <summary>
            Constructs an empty <see cref="T:ICU4N.Text.MessagePattern"/> with default <see cref="T:ICU4N.Text.ApostropheMode"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.#ctor(ICU4N.Text.ApostropheMode)">
            <summary>
            Constructs an empty <see cref="T:ICU4N.Text.MessagePattern"/>.
            </summary>
            <param name="mode">Explicit <see cref="T:ICU4N.Text.ApostropheMode"/>.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.#ctor(System.String)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.MessagePattern"/> with default <see cref="T:ICU4N.Text.ApostropheMode"/> and
            parses the <see cref="T:ICU4N.Text.MessageFormat"/> pattern string.
            </summary>
            <param name="pattern">a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string</param>
            <exception cref="T:System.ArgumentException">for syntax errors in the pattern string</exception>
            <exception cref="T:System.IndexOutOfRangeException">if certain limits are exceeded
            (e.g., argument number too high, argument name too long, etc.)</exception>
            <exception cref="T:System.FormatException">if a number could not be parsed</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Parse(System.String)">
            <summary>
            Parses a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string.
            </summary>
            <param name="pattern">a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">for syntax errors in the pattern string</exception>
            <exception cref="T:System.IndexOutOfRangeException">if certain limits are exceeded
            (e.g., argument number too high, argument name too long, etc.)</exception>
            <exception cref="T:System.FormatException">if a number could not be parsed</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ParseChoiceStyle(System.String)">
            <summary>
            Parses a <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> pattern string.
            </summary>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">for syntax errors in the pattern string</exception>
            <exception cref="T:System.IndexOutOfRangeException">if certain limits are exceeded
            (e.g., argument number too high, argument name too long, etc.)</exception>
            <exception cref="T:System.FormatException">if a number could not be parsed</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ParsePluralStyle(System.String)">
            <summary>
            Parses a <see cref="T:ICU4N.Text.PluralFormat"/> pattern string.
            </summary>
            <param name="pattern">A <see cref="T:ICU4N.Text.PluralFormat"/> pattern string</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">for syntax errors in the pattern string</exception>
            <exception cref="T:System.IndexOutOfRangeException">if certain limits are exceeded
            (e.g., argument number too high, argument name too long, etc.)</exception>
            <exception cref="T:System.FormatException">if a number could not be parsed</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ParseSelectStyle(System.String)">
            <summary>
            Parses a <see cref="T:ICU4N.Text.SelectFormat"/> pattern string.
            </summary>
            <param name="pattern">A <see cref="T:ICU4N.Text.SelectFormat"/> pattern string</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">for syntax errors in the pattern string</exception>
            <exception cref="T:System.IndexOutOfRangeException">if certain limits are exceeded
            (e.g., argument number too high, argument name too long, etc.)</exception>
            <exception cref="T:System.FormatException">if a number could not be parsed</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Clear">
            <summary>
            Clears this <see cref="T:ICU4N.Text.MessagePattern"/>.
            <see cref="M:ICU4N.Text.MessagePattern.CountParts"/> will return 0.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ClearPatternAndSetApostropheMode(ICU4N.Text.ApostropheMode)">
            <summary>
            Clears this <see cref="T:ICU4N.Text.MessagePattern"/> and sets the <see cref="T:ICU4N.Text.ApostropheMode"/>.
            <see cref="M:ICU4N.Text.MessagePattern.CountParts"/> will return 0.
            </summary>
            <param name="mode">The new <see cref="T:ICU4N.Text.ApostropheMode"/></param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Equals(System.Object)">
            <param name="other">another object to compare with.</param>
            <returns>true if this object is equivalent to the other one.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetHashCode">
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.ApostropheMode">
            <summary>
            Gets this instance's <see cref="T:ICU4N.Text.ApostropheMode"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.JdkAposMode">
            <summary>
            Gets true if <see cref="P:ICU4N.Text.MessagePattern.ApostropheMode"/> == <see cref="F:ICU4N.Text.ApostropheMode.DoubleRequired"/>
            </summary>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.PatternString">
            <summary>
            Gets the parsed pattern string (null if none was parsed).
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.HasNamedArguments">
            <summary>
            Does the parsed pattern have named arguments like {first_name}?
            Returns true if the parsed pattern has at least one named argument.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.HasNumberedArguments">
            <summary>
            Does the parsed pattern have numbered arguments like {2}?
            Returns true if the parsed pattern has at least one numbered argument.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ToString">
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ValidateArgumentName(System.String)">
            <summary>
            Validates and parses an argument name or argument number string.
            An argument name must be a "pattern identifier", that is, it must contain
            no Unicode <see cref="F:ICU4N.Globalization.UProperty.Pattern_Syntax"/> or 
            <see cref="F:ICU4N.Globalization.UProperty.Pattern_White_Space"/> characters.
            If it only contains ASCII digits, then it must be a small integer with no leading zero.
            </summary>
            <param name="name">Input string.</param>
            <returns>&gt;=0 if the name is a valid number,
            <see cref="F:ICU4N.Text.MessagePattern.ArgNameNotNumber"/> (-1) if it is a "pattern identifier" but not all ASCII digits,
            <see cref="F:ICU4N.Text.MessagePattern.ArgNameNotValid"/> (-2) if it is neither.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePattern.ArgNameNotNumber">
            <summary>
            Return value from <see cref="M:ICU4N.Text.MessagePattern.ValidateArgumentName(System.String)"/> for when
            the string is a valid "pattern identifier" but not a number.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePattern.ArgNameNotValid">
            <summary>
            Return value from <see cref="M:ICU4N.Text.MessagePattern.ValidateArgumentName(System.String)"/> for when
            the string is invalid.
            It might not be a valid "pattern identifier",
            or it have only ASCII digits but there is a leading zero or the number is too large.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.AutoQuoteApostropheDeep">
            <summary>
            Returns a version of the parsed pattern string where each ASCII apostrophe
            is doubled (escaped) if it is not already, and if it is not interpreted as quoting syntax.
            <para/>
            For example, this turns "I don't '{know}' {gender,select,female{h''er}other{h'im}}."
            into "I don''t '{know}' {gender,select,female{h''er}other{h''im}}."
            </summary>
            <returns>The deep-auto-quoted version of the parsed pattern string.</returns>
            <seealso cref="M:ICU4N.Text.MessageFormat.AutoQuoteApostrophe(System.String)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.CountParts">
            <summary>
            Returns the number of "parts" created by parsing the pattern string.
            Returns 0 if no pattern has been parsed or <see cref="M:ICU4N.Text.MessagePattern.Clear"/> was called.
            </summary>
            <returns>the number of pattern parts.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetPart(System.Int32)">
            <summary>
            Gets the i-th pattern "part".
            </summary>
            <param name="i">The index of the <see cref="T:ICU4N.Text.MessagePatternPart"/> data. (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1)</param>
            <returns>the i-th pattern "part".</returns>
            <exception cref="T:System.IndexOutOfRangeException">if partIndex is outside the (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1) range</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetPartType(System.Int32)">
            <summary>
            Returns the <see cref="T:ICU4N.Text.MessagePatternPartType"/> of the i-th pattern "part".
            Convenience method for <c>GetPart(i).Type</c>.
            </summary>
            <param name="i">The index of the Part data. (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1)</param>
            <returns>The <see cref="T:ICU4N.Text.MessagePatternPartType"/> of the i-th <see cref="T:ICU4N.Text.MessagePatternPart"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if partIndex is outside the (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1) range</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetPatternIndex(System.Int32)">
            <summary>
            Returns the pattern index of the specified pattern "part".
            Convenience method for <c>GetPart(partIndex).Index</c>.
            </summary>
            <param name="partIndex">The index of the Part data. (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1)</param>
            <returns>The pattern index of this <see cref="T:ICU4N.Text.MessagePatternPart"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if partIndex is outside the (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1) range</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetSubstring(ICU4N.Text.MessagePatternPart)">
            <summary>
            Returns the substring of the pattern string indicated by the <paramref name="part"/>.
            Convenience method for <c>PatternString.Substring(part.Index, part.Limit - part.Index)</c>.
            </summary>
            <param name="part">A part of this <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <returns>The substring associated with <paramref name="part"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.PartSubstringMatches(ICU4N.Text.MessagePatternPart,System.String)">
            <summary>
            Compares the <paramref name="part"/>'s substring with the input string <paramref name="s"/>.
            </summary>
            <param name="part">A part of this <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <param name="s">A string.</param>
            <returns>true if <c>GetSubstring(part).Equals(s)</c>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetNumericValue(ICU4N.Text.MessagePatternPart)">
            <summary>
            Returns the numeric value associated with an <see cref="F:ICU4N.Text.MessagePatternPartType.ArgInt"/> 
            or <see cref="F:ICU4N.Text.MessagePatternPartType.ArgDouble"/>.
            </summary>
            <param name="part">A part of this <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <returns>The part's numeric value, or <see cref="F:ICU4N.Text.MessagePattern.NoNumericValue"/> if this is not a numeric part.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.MessagePattern.NoNumericValue">
            <summary>
            Special value that is returned by <see cref="M:ICU4N.Text.MessagePattern.GetNumericValue(ICU4N.Text.MessagePatternPart)"/> when no
            numeric value is defined for a part.
            </summary>
            <seealso cref="M:ICU4N.Text.MessagePattern.GetNumericValue(ICU4N.Text.MessagePatternPart)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetPluralOffset(System.Int32)">
            <summary>
            Returns the "offset:" value of a <see cref="T:ICU4N.Text.PluralFormat"/> argument, or 0 if none is specified.
            </summary>
            <param name="pluralStart">the index of the first <see cref="T:ICU4N.Text.PluralFormat"/> argument style part. (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1)</param>
            <returns>the "offset:" value.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if start is outside the (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1) range.</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.GetLimitPartIndex(System.Int32)">
            <summary>
            Returns the index of the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgLimit"/>|<see cref="F:ICU4N.Text.MessagePatternPartType.MsgLimit"/> 
            part corresponding to the <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/>|<see cref="F:ICU4N.Text.MessagePatternPartType.MsgStart"/> 
            at <paramref name="start"/>.
            </summary>
            <param name="start">The index of some <see cref="T:ICU4N.Text.MessagePatternPart"/> data (0..countParts()-1);
            this <see cref="T:ICU4N.Text.MessagePatternPart"/> should be of <see cref="P:ICU4N.Text.MessagePatternPart.Type"/> 
            <see cref="F:ICU4N.Text.MessagePatternPartType.ArgStart"/> or <see cref="F:ICU4N.Text.MessagePatternPartType.MsgStart"/>.</param>
            <returns>The first i&gt;start where GetPart(i).Type==<see cref="F:ICU4N.Text.MessagePatternPartType.ArgLimit"/>|<see cref="F:ICU4N.Text.MessagePatternPartType.MsgLimit"/> at the same nesting level,
            or start itself if getPartType(msgStart)!=ARG|MSG_START.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if start is outside the (0..<see cref="M:ICU4N.Text.MessagePattern.CountParts"/>-1) range.</exception>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Clone">
            <summary>
            Creates and returns a copy of this object.
            </summary>
            <returns>A copy of this object (or itself if frozen).</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.CloneAsThawed">
            <summary>
            Creates and returns an unfrozen copy of this object.
            </summary>
            <returns>A copy of this object.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Freeze">
            <summary>
            Freezes this object, making it immutable and thread-safe.
            </summary>
            <returns>this</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.MessagePattern.IsFrozen">
            <summary>
            Gets whether this object is frozen (immutable) or not.
            Returns true if this object is frozen.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ParseArgNumber(System.String,System.Int32,System.Int32)">
            <summary>
            Validates and parses an argument name or argument number string.
            This internal method assumes that the input substring is a "pattern identifier".
            </summary>
            <param name="s"></param>
            <param name="start"></param>
            <param name="limit"></param>
            <returns>&gt;=0 if the name is a valid number,
            <see cref="F:ICU4N.Text.MessagePattern.ArgNameNotNumber"/> (-1) if it is a "pattern identifier" but not all ASCII digits,
            <see cref="F:ICU4N.Text.MessagePattern.ArgNameNotValid"/> (-2) if it is neither.</returns>
            <seealso cref="M:ICU4N.Text.MessagePattern.ValidateArgumentName(System.String)"/>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.ParseDouble(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Parses a number from the specified message substring.
            </summary>
            <param name="start">start index into the message string</param>
            <param name="limit">limit index into the message string, must be start&lt;limit</param>
            <param name="allowInfinity">allowInfinity true if U+221E is allowed (for <see cref="T:ICU4N.Support.Text.ChoiceFormat"/>)</param>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.AppendReducedApostrophes(System.String,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Appends the s[start, limit[ substring to sb, but with only half of the apostrophes
            according to JDK pattern behavior.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.SkipDouble(System.Int32)">
            <summary>
            Skips a sequence of characters that could occur in a double value.
            Does not fully parse or validate the value.
            </summary>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.inMessageFormatPattern(System.Int32)">
            <returns>true if we are inside a <see cref="T:ICU4N.Text.MessageFormat"/> (sub-)pattern,
            as opposed to inside a top-level choice/plural/select pattern.</returns>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.InTopLevelChoiceMessage(System.Int32,ICU4N.Text.MessagePatternArgType)">
            <returns>true if we are in a MessageFormat sub-pattern
            of a top-level <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> pattern.</returns>
        </member>
        <member name="M:ICU4N.Text.MessagePattern.Prefix(System.String,System.Int32)">
            <summary>
            Returns a prefix of s.Substring(start). Used for Exception messages.
            </summary>
            <param name="s"></param>
            <param name="start">start index in <paramref name="s"/></param>
            <returns> s.Substring(start) or a prefix of that</returns>
        </member>
        <member name="T:ICU4N.Text.MessagePatternUtil">
            <summary>
            Utilities for working with a <see cref="T:ICU4N.Text.MessagePattern"/>.
            Intended for use in tools when convenience is more important than
            minimizing runtime and object creations.
            <para/>
            This class only has static methods.
            Each of the nested classes is immutable and thread-safe.
            <para/>
            This class and its nested classes are not intended for public subclassing.
            </summary>
            <stable>ICU 49</stable>
            <author>Markus Scherer</author>
        </member>
        <member name="M:ICU4N.Text.MessagePatternUtil.BuildMessageNode(System.String)">
            <summary>
            Factory method, builds and returns a <see cref="T:ICU4N.Text.MessageNode"/> from a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string.
            </summary>
            <param name="patternString">a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string</param>
            <returns>A <see cref="T:ICU4N.Text.MessageNode"/> or a <see cref="T:ICU4N.Text.ComplexArgStyleNode"/></returns>
            <exception cref="T:System.ArgumentException">if the <see cref="T:ICU4N.Text.MessagePattern"/> is empty
            or does not represent a <see cref="T:ICU4N.Text.MessageFormat"/> pattern</exception>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.MessagePatternUtil.BuildMessageNode(ICU4N.Text.MessagePattern)">
            <summary>
            Factory method, builds and returns a <see cref="T:ICU4N.Text.MessageNode"/> from a <see cref="T:ICU4N.Text.MessagePattern"/>.
            </summary>
            <param name="pattern">A parsed <see cref="T:ICU4N.Text.MessageFormat"/> pattern string</param>
            <returns>A <see cref="T:ICU4N.Text.MessageNode"/> or a <see cref="T:ICU4N.Text.ComplexArgStyleNode"/></returns>
            <exception cref="T:System.ArgumentException">if the <see cref="T:ICU4N.Text.MessagePattern"/> is empty
            or does not represent a <see cref="T:ICU4N.Text.MessageFormat"/> pattern</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="pattern"/> is null.</exception>
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.MessagePatternNode">
            <summary>
            Common base class for all elements in a tree of nodes
            returned by <see cref="M:ICU4N.Text.MessagePatternUtil.BuildMessageNode(ICU4N.Text.MessagePattern)"/>.
            This class and all subclasses are immutable and thread-safe.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.MessageNode">
            <summary>
            A Node representing a parsed <see cref="T:ICU4N.Text.MessageFormat"/> pattern string.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.MessageNode.GetContents">
            <returns>The list of MessageContentsNode nodes that this message contains.</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.MessageNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.MessageContentsNode">
            <summary>
            A piece of <see cref="T:ICU4N.Text.MessageNode"/> contents.
            Use <see cref="P:ICU4N.Text.MessageContentsNode.Type"/> to determine the type and the actual <see cref="T:ICU4N.Text.MessagePatternNode"/> subclass.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.MessageContentsNode.NodeType">
            <summary>
            The type of a piece of <see cref="T:ICU4N.Text.MessageNode"/> contents.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Text.MessageContentsNode.NodeType.Text">
            <summary>
            This is a <see cref="T:ICU4N.Text.TextNode"/> containing literal text (downcast and call <see cref="F:ICU4N.Text.MessageContentsNode.NodeType.Text"/>).
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Text.MessageContentsNode.NodeType.Arg">
            <summary>
            This is an <see cref="T:ICU4N.Text.ArgNode"/> representing a message argument
            (downcast and use specific methods).
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Text.MessageContentsNode.NodeType.ReplaceNumber">
            <summary>
            This <see cref="T:ICU4N.Text.MessagePatternNode"/> represents a place in a plural argument's variant where
            the formatted (plural-offset) value is to be put.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.MessageContentsNode.Type">
            <summary>
            Returns the type of this piece of <see cref="T:ICU4N.Text.MessageNode"/> contents.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.MessageContentsNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.TextNode">
            <summary>
            Literal text, a piece of MessageNode contents.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.TextNode.Text">
            <summary>
            Gets or sets the literal text at this point in the message
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.TextNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.ArgNode">
            <summary>
            A piece of <see cref="T:ICU4N.Text.MessageNode"/> contents representing a message argument and its details.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.ArgType">
            <summary>
            Gets or Sets the argument type.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.Name">
            <summary>
            Gets or sets the argument name string (the decimal-digit string if the argument has a number)
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.Number">
            <summary>
            Gets or sets the argument number, or -1 if none (for a named argument).
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.TypeName">
            <summary>
            Gets or sets the argument type string, or null if none was specified.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.SimpleStyle">
            <summary>
            Gets or sets the simple-argument style string,
            or null if no style is specified and for other argument types.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ArgNode.ComplexStyle">
            <summary>
            Gets or sets the complex-argument-style object,
            or null if the argument type is <see cref="F:ICU4N.Text.MessagePatternArgType.None"/> 
            or <see cref="F:ICU4N.Text.MessagePatternArgType.Simple"/>
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.ArgNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.ComplexArgStyleNode">
            <summary>
            A <see cref="T:ICU4N.Text.MessagePatternNode"/> representing details of the argument style of a complex argument.
            (Which is a choice/plural/select argument which selects among nested messages.)
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ComplexArgStyleNode.ArgType">
            <summary>
            Gets or sets the argument type (same as <see cref="P:ICU4N.Text.ComplexArgStyleNode.ArgType"/>getArgType() on the parent <see cref="T:ICU4N.Text.ArgNode"/>)
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ComplexArgStyleNode.HasExplicitOffset">
            <summary>
            Gets or sets true if this is a plural style with an explicit offset
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ComplexArgStyleNode.Offset">
            <summary>
            Gets or sets the plural offset, or 0 if this is not a plural style or
            the offset is explicitly or implicitly 0
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.ComplexArgStyleNode.Variants">
            <summary>
            Gets or sets the list of variants: the nested messages with their selection criteria
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.ComplexArgStyleNode.GetVariantsByType(System.Collections.Generic.IList{ICU4N.Text.VariantNode},System.Collections.Generic.IList{ICU4N.Text.VariantNode})">
            <summary>
            Separates the variants by type.
            Intended for use with plural and select argument styles,
            not useful for choice argument styles.
            <para/>
            Both parameters are used only for output, and are first cleared.
            </summary>
            <param name="numericVariants">Variants with numeric-value selectors (if any) are added here.
            Can be null for a select argument style.</param>
            <param name="keywordVariants">Variants with keyword selectors, except "other", are added here.
            For a plural argument, if this list is empty after the call, then
            all variants except "other" have explicit values
            and PluralRules need not be called.</param>
            <returns>the "other" variant (the first one if there are several),
            null if none (choice style)</returns>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.ComplexArgStyleNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.VariantNode">
            <summary>
            A <see cref="T:ICU4N.Text.MessagePatternNode"/> representing a nested message (nested inside an argument)
            with its selection criterium.
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.VariantNode.Selector">
            <summary>
            Gets the selector string.
            For example: A plural/select keyword ("few"), a plural explicit value ("=1"),
            a choice comparison operator ("#").
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.VariantNode.IsSelectorNumeric">
            <summary>
            Gets true for choice variants and for plural explicit values
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.VariantNode.SelectorValue">
            <summary>
            Gets the selector's numeric value, or NO_NUMERIC_VALUE if !isSelectorNumeric()
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="P:ICU4N.Text.VariantNode.Message">
            <summary>
            Gets the nested message
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="M:ICU4N.Text.VariantNode.ToString">
            <stable>ICU 49</stable>
        </member>
        <member name="T:ICU4N.Text.QuickCheckResult">
            <summary>
            Result values for <see cref="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode)"/> and
            <see cref="M:ICU4N.Text.Normalizer2.QuickCheck(System.String)"/>.
            For details see Unicode Technical Report 15.
            </summary>
        </member>
        <member name="F:ICU4N.Text.QuickCheckResult.No">
            <summary>
            Indicates that string is not in the normalized format.
            </summary>
        </member>
        <member name="F:ICU4N.Text.QuickCheckResult.Yes">
            <summary>
            Indicates that string is in the normalized format.
            </summary>
        </member>
        <member name="F:ICU4N.Text.QuickCheckResult.Maybe">
            <summary>
            Indicates it cannot be determined if string is in the normalized
            format without further thorough checks.
            </summary>
        </member>
        <member name="T:ICU4N.Text.NormalizerUnicodeVersion">
            <summary>
            <see cref="T:ICU4N.Text.Normalizer"/> Unicode version options.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerUnicodeVersion.Default">
            <summary>
            Optionto select the default Unicode normalization
            (except NormalizationCorrections).
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2">
            <summary>
            Option to select Unicode 3.2 normalization
            (except NormalizationCorrections).
            </summary>
        </member>
        <member name="T:ICU4N.Text.NormalizerComparison">
            <summary>
            Options for <see cref="T:ICU4N.Text.Normalizer"/> text comparison
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerComparison.Default">
            <summary>
            Option bit for compare:
            Use when no other option is required. This has no effect if it is ORed with other options.
            </summary>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="F:ICU4N.Text.NormalizerComparison.InputIsFCD">
            <summary>
            Option bit for compare:
            Both input strings are assumed to fulfill FCD conditions.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizerComparison.IgnoreCase">
            <summary>
            Option bit for compare:
            Perform case-insensitive comparison.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizerComparison.CodePointOrder">
            <summary>
            Option bit for compare:
            Compare strings in code point order instead of code unit order.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.NormalizerMode">
            <summary>
            Normalization mode constants.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.None">
            <summary>
            No decomposition/composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.NFD">
            <summary>
            Canonical decomposition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.NFKD">
            <summary>
            Compatibility decomposition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.NFC">
            <summary>
            Canonical decomposition followed by canonical composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.Default">
            <summary>
            Default normalization.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.NFKC">
            <summary>
            Compatibility decomposition followed by canonical composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NormalizerMode.FCD">
            <summary>
            "Fast C or D" form.
            </summary>
        </member>
        <member name="T:ICU4N.Text.Normalizer">
            <summary>
            Old Unicode normalization API.
            <para/>
            This API has been replaced by the <see cref="T:ICU4N.Text.Normalizer2"/> class and is only available
            for backward compatibility. This class simply delegates to the Normalizer2 class.
            There are two exceptions: The new API does not provide a replacement for
            <see cref="T:ICU4N.Text.QuickCheckResult"/> and <see cref="M:ICU4N.Text.Normalizer.Compare(System.String,System.String)"/>.
            </summary>
            <remarks>
            <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> transforms Unicode text into an equivalent composed or
            decomposed form, allowing for easier sorting and searching of text.
            <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> supports the standard normalization forms described in
            <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
            Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms</a>.
            <para/>
            Characters with accents or other adornments can be encoded in
            several different ways in Unicode.  For example, take the character A-acute.
            In Unicode, this can be encoded as a single character (the
            "composed" form):
            <code>
                 00C1    LATIN CAPITAL LETTER A WITH ACUTE
            </code>
            or as two separate characters (the "decomposed" form):
            <code>
                 0041    LATIN CAPITAL LETTER A
                 0301    COMBINING ACUTE ACCENT
            </code>
            <para/>
            To a user of your program, however, both of these sequences should be
            treated as the same "user-level" character "A with acute accent".  When you
            are searching or comparing text, you must ensure that these two sequences are
            treated equivalently.  In addition, you must handle characters with more than
            one accent.  Sometimes the order of a character's combining accents is
            significant, while in other cases accent sequences in different orders are
            really equivalent.
            <para/>
            Similarly, the string "ffi" can be encoded as three separate letters:
            <code>
                 0066    LATIN SMALL LETTER F
                 0066    LATIN SMALL LETTER F
                 0069    LATIN SMALL LETTER I
            </code>
            or as the single character
            <code>
                 FB03    LATIN SMALL LIGATURE FFI
            </code>
            <para/>
            The ffi ligature is not a distinct semantic character, and strictly speaking
            it shouldn't be in Unicode at all, but it was included for compatibility
            with existing character sets that already provided it.  The Unicode standard
            identifies such characters by giving them "compatibility" decompositions
            into the corresponding semantic characters.  When sorting and searching, you
            will often want to use these mappings.
            <para/>
            <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> helps solve these problems by transforming text into
            the canonical composed and decomposed forms as shown in the first example
            above. In addition, you can have it perform compatibility decompositions so
            that you can treat compatibility characters the same as their equivalents.
            Finally, <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> rearranges accents into the proper canonical
            order, so that you do not have to worry about accent rearrangement on your
            own.
            <para/>
            Form FCD, "Fast C or D", is also designed for collation.
            It allows to work on strings that are not necessarily normalized
            with an algorithm (like in collation) that works under "canonical closure",
            i.e., it treats precomposed characters and their decomposed equivalents the
            same.
            <para/>
            It is not a normalization form because it does not provide for uniqueness of
            representation. Multiple strings may be canonically equivalent (their NFDs
            are identical) and may all conform to FCD without being identical themselves.
            The form is defined such that the "raw decomposition", the recursive
            canonical decomposition of each character, results in a string that is
            canonically ordered. This means that precomposed characters are allowed for
            as long as their decompositions do not need canonical reordering.
            <para/>
            Its advantage for a process like collation is that all NFD and most NFC texts
            - and many unnormalized texts - already conform to FCD and do not need to be
            normalized (NFD) for such a process. The FCD quick check will return YES for
            most strings in practice.
            <para/>
            Normalize(FCD) may be implemented with NFD.
            <para/>
            For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications):
            <a href="http://www.unicode.org/notes/tn5/#FCD">http://www.unicode.org/notes/tn5/#FCD</a>
            <para/>
            ICU collation performs either NFD or FCD normalization automatically if
            normalization is turned on for the collator object. Beyond collation and
            string search, normalized strings may be useful for string equivalence
            comparisons, transliteration/transcription, unique representations, etc.
            <para/>
            The W3C generally recommends to exchange texts in NFC.
            Note also that most legacy character encodings use only precomposed forms and
            often do not encode any combining marks by themselves. For conversion to such
            character encodings the Unicode text needs to be normalized to NFC.
            For more usage examples, see the Unicode Standard Annex.
            <para/>
            Note: The <see cref="T:ICU4N.Text.Normalizer"/> class also provides API for iterative normalization.
            While the <see cref="M:ICU4N.Text.Normalizer.SetIndex(System.Int32)"/> and <see cref="P:ICU4N.Text.Normalizer.Index"/> refer to indices in the
            underlying Unicode input text, the <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> methods
            iterate through characters in the normalized output.
            This means that there is not necessarily a one-to-one correspondence
            between characters returned by <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> and the indices
            passed to and returned from <see cref="M:ICU4N.Text.Normalizer.SetIndex(System.Int32)"/> and <see cref="P:ICU4N.Text.Normalizer.Index"/>.
            It is for this reason that <see cref="T:ICU4N.Text.Normalizer"/> does not implement the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> interface.
            </remarks>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFDModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFKDModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFCModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFKCModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.FCDModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.Unicode32.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFD32ModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFKD32ModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFC32ModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.NFKC32ModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="P:ICU4N.Text.Normalizer.FCD32ModeImpl.Instance">
            <summary>
            public singleton instance
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.Unicode3_2">
            <summary>
            Options bit set value to select Unicode 3.2 normalization
            (except NormalizationCorrections).
            At most one Unicode version can be selected at a time.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.Done">
            <summary>
            Constant indicating that the end of the iteration has been reached.
            This is guaranteed to have the same value as <see cref="F:ICU4N.Text.UCharacterIterator.Done"/>.
            </summary>
        </member>
        <member name="T:ICU4N.Text.Normalizer.Mode">
            <summary>
            Constants for normalization modes.
            <para/>
            The <see cref="T:ICU4N.Text.Normalizer.Mode"/> class is not intended for public subclassing.
            Only the <see cref="T:ICU4N.Text.Normalizer.Mode"/> constants provided by the Normalizer class should be used,
            and any fields or methods should not be called or overridden by users.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Mode.#ctor(ICU4N.Text.NormalizerMode)">
            <summary>
            Sole constructor.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Mode.GetNormalizer2(System.Int32)">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NONE">
            <summary>
            No decomposition/composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NFD">
            <summary>
            Canonical decomposition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NFKD">
            <summary>
            Compatibility decomposition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NFC">
            <summary>
            Canonical decomposition followed by canonical composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.DEFAULT">
            <summary>
            Default normalization.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NFKC">
            <summary>
            Compatibility decomposition followed by canonical composition.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.FCD">
            <summary>
            "Fast C or D" form.
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NO_OP">
            <summary>
            Null operation for use with the <see cref="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> constructors.
            and the static <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> method.  This value tells
            the <see cref="T:ICU4N.Text.Normalizer"/> to do nothing but return unprocessed characters
            from the underlying string or <see cref="T:ICU4N.Support.Text.CharacterIterator"/>.  If you have code which
            requires raw text at some times and normalized text at others, you can
            use <c>NO_OP</c> for the cases where you want raw text, rather
            than having a separate code path that bypasses <see cref="T:ICU4N.Text.Normalizer"/>
            altogether.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.None"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPOSE">
            <summary>
            Canonical decomposition followed by canonical composition.  Used 
            with the <see cref="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> constructors.
            and the static <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> method
            to determine the operation to be performed.
            <para/>
            If all optional features (<i>e.g.</i> <see cref="F:ICU4N.Text.Normalizer.IGNORE_HANGUL"/>) are turned
            off, this operation produces output that is in
            <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Canonical
            Form</a> <b>C</b>.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.NFC"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPOSE_COMPAT">
            <summary>
            Compatibility decomposition followed by canonical composition.
            Used 
            with the <see cref="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> constructors.
            and the static <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> method
            to determine the operation to be performed.
            <para/>
            If all optional features (<i>e.g.</i> <see cref="F:ICU4N.Text.Normalizer.IGNORE_HANGUL"/>) are turned
            off, this operation produces output that is in
            <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Canonical
            Form</a> <b>KC</b>.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.NFKC"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.DECOMP">
            <summary>
            Canonical decomposition.  This value is passed to the
            <see cref="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> constructors.
            and the static <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> method
            to determine the operation to be performed.
            <para/>
            If all optional features (<i>e.g.</i> <see cref="F:ICU4N.Text.Normalizer.IGNORE_HANGUL"/>) are turned
            off, this operation produces output that is in
            <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Canonical
            Form</a> <b>D</b>.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
            <seealso cref="F:ICU4N.Text.Normalizer.NFD"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.DECOMP_COMPAT">
            <summary>
            Compatibility decomposition.  This value is passed to the
            <see cref="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> constructors.
            and the static <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/> method
            to determine the operation to be performed.
            <para/>
            If all optional features (<i>e.g.</i> <see cref="F:ICU4N.Text.Normalizer.IGNORE_HANGUL"/>) are turned
            off, this operation produces output that is in
            <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Canonical
            Form</a> <b>KD</b>.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.NFKD"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.IGNORE_HANGUL">
            <summary>
            Option to disable Hangul/Jamo composition and decomposition.
            This option applies to Korean text,
            which can be represented either in the Jamo alphabet or in Hangul
            characters, which are really just two or three Jamo combined
            into one visual glyph.  Since Jamo takes up more storage space than
            Hangul, applications that process only Hangul text may wish to turn
            this option on when decomposing text.
            <para/>
            The Unicode standard treates Hangul to Jamo conversion as a
            canonical decomposition, so this option must be turned <b>off</b> if you
            wish to transform strings into one of the standard
            <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
            Unicode Normalization Forms</a>.
            </summary>
            <see cref="M:ICU4N.Text.Normalizer.SetOption(System.Int32,System.Boolean)"/>
        </member>
        <member name="F:ICU4N.Text.Normalizer.NO">
            <summary>
            Indicates that string is not in the normalized format
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.YES">
            <summary>
            Indicates that string is in the normalized format
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.MAYBE">
            <summary>
            Indicates it cannot be determined if string is in the normalized
            format without further thorough checks.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.FOLD_CASE_DEFAULT">
            <summary>
            Option bit for compare:
            Case sensitively compare the strings
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.INPUT_IS_FCD">
            <summary>
            Option bit for compare:
            Both input strings are assumed to fulfill FCD conditions.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPARE_IGNORE_CASE">
            <summary>
            Option bit for compare:
            Perform case-insensitive comparison.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPARE_CODE_POINT_ORDER">
            <summary>
            Option bit for compare:
            Compare strings in code point order instead of code unit order.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.FOLD_CASE_EXCLUDE_SPECIAL_I">
            <summary>
            Option value for case folding:
            Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
            and dotless i appropriately for Turkic languages (tr, az).
            </summary>
            <seealso cref="F:ICU4N.UChar.FoldCaseExcludeSpecialI"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPARE_NORM_OPTIONS_SHIFT">
            <summary>
            Lowest-order bit number of <see cref="M:ICU4N.Text.Normalizer.Compare(System.String,System.String)"/> options bits corresponding to
            normalization options bits.
            <para/>
            The options parameter for <see cref="M:ICU4N.Text.Normalizer.Compare(System.String,System.String)"/> uses most bits for
            itself and for various comparison and folding flags.
            The most significant bits, however, are shifted down and passed on
            to the normalization implementation.
            (That is, from compare(..., options, ...),
            options&gt;&gt;COMPARE_NORM_OPTIONS_SHIFT will be passed on to the
            internal normalization functions.)
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.Compare(System.String,System.String)"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of a given string.
            </summary>
            <param name="str">The string to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of a given string.
            <para/>
            The <paramref name="unicodeVersion"/> parameter specifies which optional
            <see cref="T:ICU4N.Text.Normalizer"/> features are to be enabled for this object.
            </summary>
            <param name="str">The string to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.NormalizerMode)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of the given text.
            </summary>
            <param name="iter">The input text to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of the given text.
            </summary>
            <param name="iter">The input text to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(ICU4N.Text.UCharacterIterator,ICU4N.Text.NormalizerMode)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of the given text.
            </summary>
            <param name="iter">The input text to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.#ctor(ICU4N.Text.UCharacterIterator,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.Normalizer"/> object for iterating over the
            normalized form of the given text.
            </summary>
            <param name="iter">The input text to be normalized.  The normalization
            will start at the beginning of the string.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Clone">
            <summary>
            Clones this <see cref="T:ICU4N.Text.Normalizer"/> object.  All properties of this
            object are duplicated in the new object, including the cloning of any
            <see cref="T:ICU4N.Support.Text.CharacterIterator"/> that was passed in to the constructor
            or to <see cref="M:ICU4N.Text.Normalizer.SetText(ICU4N.Support.Text.CharacterIterator)"/>.
            However, the text storage underlying
            the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> is not duplicated unless the
            <see cref="M:ICU4N.Support.Text.CharacterIterator.Clone"/> method does so.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compose(System.String,System.Boolean)">
            <summary>
            Compose a string.
            The string will be composed to according to the specified mode.
            </summary>
            <param name="str">The string to compose.</param>
            <param name="compat">If true the string will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> rules and if false will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> rules.</param>
            <returns>The composed string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compose(System.String,System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compose a string.
            The string will be composed to according to the specified mode.
            </summary>
            <param name="str">The string to compose.</param>
            <param name="compat">If true the string will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> rules and if false will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The composed string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compose(System.Char[],System.Char[],System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compose a string.
            The string will be composed to according to the specified mode.
            </summary>
            <param name="source">The char array to compose.</param>
            <param name="target">A char buffer to receive the normalized text.</param>
            <param name="compat">If true the char array will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> rules and if false will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            result, the output was truncated.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If target.Length is less than the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compose(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compose a string.
            The string will be composed to according to the specified mode.
            </summary>
            <param name="src">The char array to compose.</param>
            <param name="srcStart">Start index of the source.</param>
            <param name="srcLimit">Limit index of the source.</param>
            <param name="dest">The char buffer to fill in.</param>
            <param name="destStart">Start index of the destination buffer.</param>
            <param name="destLimit">End index of the destination buffer.</param>
            <param name="compat">If true the char array will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> rules and if false will be composed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            result, the output was truncated.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If target.Length is less than the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Decompose(System.String,System.Boolean)">
            <summary>
            Decompose a string.
            The string will be decomposed to according to the specified mode.
            </summary>
            <param name="str">The string to decompose.</param>
            <param name="compat">If true the string will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>
            rules and if false will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>
            rules.
            </param>
            <returns>The decomposed string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Decompose(System.String,System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Decompose a string.
            The string will be decomposed to according to the specified mode.
            </summary>
            <param name="str">The string to decompose.</param>
            <param name="compat">If true the string will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>
            rules and if false will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>
            rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The decomposed string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Decompose(System.Char[],System.Char[],System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Decompose a string.
            The string will be decomposed to according to the specified mode.
            </summary>
            <param name="source">The char array to decompose.</param>
            <param name="target">A char buffer to receive the normalized text.</param>
            <param name="compat">If true the char array will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>
            rules and if false will be decomposed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFD"/> rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            result,the output was truncated.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the target capacity is less than
            the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Decompose(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Decompose a string.
            The string will be decomposed to according to the specified mode.
            </summary>
            <param name="src">The char array to compose.</param>
            <param name="srcStart">Start index of the source.</param>
            <param name="srcLimit">Limit index of the source.</param>
            <param name="dest">The char buffer to fill in.</param>
            <param name="destStart">Start index of the destination buffer.</param>
            <param name="destLimit">End index of the destination buffer.</param>
            <param name="compat">If true the char array will be decomposed according to <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>
            rules and if false will be decomposed according to
            <see cref="F:ICU4N.Text.NormalizerMode.NFD"/> rules.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            result,the output was truncated.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the target capacity is less than
            the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Normalizes a <see cref="T:System.String"/> using the given normalization operation.
            </summary>
            <param name="str">The input string to be normalized.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The normalized string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode)">
            <summary>
            Normalize a string.
            The string will be normalized according to the specified normalization
            mode and options.
            </summary>
            <param name="src">The string to normalize.</param>
            <param name="mode">The normalization mode; one of <see cref="F:ICU4N.Text.NormalizerMode.None"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>, <see cref="F:ICU4N.Text.NormalizerMode.Default"/>.
            </param>
            <returns>The normalized string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Char[],ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Normalize a string.
            The string will be normalized according to the specified normalization
            mode and options.
            </summary>
            <param name="source">The char array to normalize.</param>
            <param name="target">A char buffer to receive the normalized text.</param>
            <param name="mode">The normalization mode; one of <see cref="F:ICU4N.Text.NormalizerMode.None"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>, <see cref="F:ICU4N.Text.NormalizerMode.Default"/>.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            than the required length.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the target capacity is less than
            the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Normalize a string.
            The string will be normalized according to the specified normalization
            mode and options.
            </summary>
            <param name="src">The char array to compose.</param>
            <param name="srcStart">Start index of the source.</param>
            <param name="srcLimit">Limit index of the source.</param>
            <param name="dest">The char buffer to fill in.</param>
            <param name="destStart">Start index of the destination buffer.</param>
            <param name="destLimit">End index of the destination buffer.</param>
            <param name="mode">The normalization mode; one of <see cref="F:ICU4N.Text.NormalizerMode.None"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>, <see cref="F:ICU4N.Text.NormalizerMode.Default"/>.
            </param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The total buffer size needed;if greater than length of
            less than the required length.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the target capacity is less than
            the required length.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Normalize a codepoint according to the given mode.
            </summary>
            <param name="char32">The input string to be normalized.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>The normalized string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Normalize(System.Int32,ICU4N.Text.NormalizerMode)">
            <summary>
            Convenience method to normalize a codepoint according to the given mode.
            </summary>
            <param name="char32">The input string to be normalized.</param>
            <param name="mode">The normalization mode.</param>
            <returns>The normalized string.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode)">
            <summary>
            Convenience method.
            </summary>
            <param name="source">String for determining if it is in a normalized format.</param>
            <param name="mode">Normalization format (<see cref="F:ICU4N.Text.NormalizerMode.NFC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFD"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>).</param>
            <returns>Return code to specify if the text is normalized or not
            (<see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>)</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Performing quick check on a string, to quickly determine if the string is
            in a particular normalization format.
            Three types of result can be returned <see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or
            <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>. Result <see cref="F:ICU4N.Text.QuickCheckResult.Yes"/> indicates that the argument
            string is in the desired normalized format, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> determines that
            argument string is not in the desired normalized format. A
            <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/> result indicates that a more thorough check is required,
            the user may have to put the string in its normalized form and compare
            the results.
            </summary>
            <param name="source">String for determining if it is in a normalized format.</param>
            <param name="mode">Normalization format (<see cref="F:ICU4N.Text.NormalizerMode.NFC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFD"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>).</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Return code to specify if the text is normalized or not
            (<see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>)</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.QuickCheck(System.Char[],ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Convenience method.
            </summary>
            <param name="source">Array of characters for determining if it is in a
            normalized format.</param>
            <param name="mode">Normalization format (<see cref="F:ICU4N.Text.NormalizerMode.NFC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFD"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>).</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Return code to specify if the text is normalized or not
            (<see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>)</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.QuickCheck(System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Performing quick check on a string, to quickly determine if the string is
            in a particular normalization format.
            Three types of result can be returned <see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or
            <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>. Result <see cref="F:ICU4N.Text.QuickCheckResult.Yes"/> indicates that the argument
            string is in the desired normalized format, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> determines that
            argument string is not in the desired normalized format. A
            <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/> result indicates that a more thorough check is required,
            the user may have to put the string in its normalized form and compare
            the results.
            </summary>
            <param name="source">String for determining if it is in a normalized format.</param>
            <param name="start">The start index of the source.</param>
            <param name="limit">The limit index of the source it is equal to the length.</param>
            <param name="mode">Normalization format (<see cref="F:ICU4N.Text.NormalizerMode.NFC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFD"/>,
            <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/>,<see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>).</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Return code to specify if the text is normalized or not
            (<see cref="F:ICU4N.Text.QuickCheckResult.Yes"/>, <see cref="F:ICU4N.Text.QuickCheckResult.No"/> or <see cref="F:ICU4N.Text.QuickCheckResult.Maybe"/>)</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.IsNormalized(System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Test if a string is in a given normalization form.
            This is semantically equivalent to <c>source.Equals(Normalize(source, mode))</c>.
            Unlike <see cref="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode)"/>, this function returns a definitive result,
            never a "maybe".
            For <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>, and <see cref="F:ICU4N.Text.NormalizerMode.FCD"/>, both functions work exactly the same.
            For <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> and <see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> where quickCheck may return "maybe", this function will
            perform further tests to arrive at a true/false result.
            </summary>
            <param name="src">The input array of characters to be checked to see if
            it is normalized.</param>
            <param name="start">The strart index in the source.</param>
            <param name="limit">The limit index in the source.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Boolean value indicating whether the source string is in the
            "<paramref name="mode"/>" normalization form.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.IsNormalized(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Test if a string is in a given normalization form.
            This is semantically equivalent to source.Equals(Normalize(source, mode)).
            Unlike <see cref="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode)"/>, this function returns a definitive result,
            never a "maybe".
            For <see cref="F:ICU4N.Text.NormalizerMode.NFD"/>, <see cref="F:ICU4N.Text.NormalizerMode.NFKD"/>, and <see cref="F:ICU4N.Text.NormalizerMode.FCD"/>, both functions work exactly the same.
            For <see cref="F:ICU4N.Text.NormalizerMode.NFC"/> and<see cref="F:ICU4N.Text.NormalizerMode.NFKC"/> where <see cref="M:ICU4N.Text.Normalizer.QuickCheck(System.String,ICU4N.Text.NormalizerMode)"/> may return "maybe", this function will
            perform further tests to arrive at a true/false result.
            </summary>
            <param name="str">The input string to be checked to see if it is normalized.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Boolean value indicating whether the source string is in the
            "<paramref name="mode"/>" normalization form.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.IsNormalized(System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.IsNormalized(System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Convenience Method.
            </summary>
            <param name="char32">The input code point to be checked to see if it is normalized.</param>
            <param name="mode">The normalization mode.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>Boolean value indicating whether the source string is in the
            "<paramref name="mode"/>" normalization form.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.IsNormalized(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
            <code>strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))</code>
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source character array.</param>
            <param name="s1Start">start index of source</param>
            <param name="s1Limit">limit of the source</param>
            <param name="s2">Second source character array.</param>
            <param name="s2Start">start index of the source</param>
            <param name="s2Limit">limit of the source</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerComparison)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
            <code>strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))</code>
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source character array.</param>
            <param name="s1Start">start index of source</param>
            <param name="s1Limit">limit of the source</param>
            <param name="s2">Second source character array.</param>
            <param name="s2Start">start index of the source</param>
            <param name="s2Limit">limit of the source</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.Normalizer.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
            <code>strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))</code>
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source character array.</param>
            <param name="s1Start">start index of source</param>
            <param name="s1Limit">limit of the source</param>
            <param name="s2">Second source character array.</param>
            <param name="s2Start">start index of the source</param>
            <param name="s2Limit">limit of the source</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
            <code>strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))</code>
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source character array.</param>
            <param name="s1Start">start index of source</param>
            <param name="s1Limit">limit of the source</param>
            <param name="s2">Second source character array.</param>
            <param name="s2Start">start index of the source</param>
            <param name="s2Limit">limit of the source</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.String,System.String)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
              strcmp[CodePointOrder](FoldCase(NFD(s1)), FoldCase(NFD(s2)))
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.String,System.String,ICU4N.Text.NormalizerComparison)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
              strcmp[CodePointOrder](FoldCase(NFD(s1)), FoldCase(NFD(s2)))
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.String,System.String,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
              strcmp[CodePointOrder](FoldCase(NFD(s1)), FoldCase(NFD(s2)))
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.String,System.String,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            </summary>
            <remarks>
            Canonical equivalence between two strings is defined as their normalized
            forms (<see cref="F:ICU4N.Text.NormalizerMode.NFD"/> or <see cref="F:ICU4N.Text.NormalizerMode.NFC"/>) being identical.
            This function compares strings incrementally instead of normalizing
            (and optionally case-folding) both strings entirely,
            improving performance significantly.
            <para/>
            Bulk normalization is only necessary if the strings do not fulfill the
            <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> conditions. Only in this case, and only if the strings are relatively
            long, is memory allocated temporarily.
            For <see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings and short non-<see cref="F:ICU4N.Text.NormalizerMode.FCD"/> strings there is no memory allocation.
            <para/>
            Semantically, this is equivalent to
              strcmp[CodePointOrder](FoldCase(NFD(s1)), FoldCase(NFD(s2)))
            where code point order and foldCase are all optional.
            </remarks>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Char[])">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            Convenience method.
            </summary>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Char[],ICU4N.Text.NormalizerComparison)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            Convenience method.
            </summary>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Char[],ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            Convenience method.
            </summary>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Char[],System.Char[],ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Compare two strings for canonical equivalence.
            Further options include case-insensitive comparison and
            code point order (as opposed to code unit order).
            Convenience method.
            </summary>
            <param name="s1">First source string.</param>
            <param name="s2">Second source string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.InputIsFCD"/></term><description>
                    Set if the caller knows that both <paramref name="s1"/> and <paramref name="s2"/> fulfill the FCD
                    conditions. If not set, the function will quickCheck for FCD
                    and normalize if necessary.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.CodePointOrder"/></term><description>
                    Set to choose code point order instead of code unit order.
                </description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerComparison.IgnoreCase"/></term><description>
                    Set to compare strings case-insensitively using case folding,
                    instead of case-sensitively.
                    If set, then the following case folding options are used.
                </description></item>
            </list>
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <returns>&lt;0 or 0 or &gt;0 as usual for string comparisons.</returns>
            <seealso cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
            <seealso cref="F:ICU4N.Text.NormalizerMode.FCD"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.Int32)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="char32b">The second code point.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.Int32,ICU4N.Text.NormalizerComparison)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="char32b">The second code point.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.Int32,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="char32b">The second code point.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.Int32,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="char32b">The second code point.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.String)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="str2">The second string.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.String,ICU4N.Text.NormalizerComparison)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="str2">The second string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.String,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="str2">The second string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <draft>ICU4N 60.1</draft>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Compare(System.Int32,System.String,ICU4N.Text.NormalizerComparison,ICU4N.Globalization.FoldCase,ICU4N.Text.NormalizerUnicodeVersion)">
            <summary>
            Convenience method that can have faster implementation
            by not allocating buffers.
            </summary>
            <param name="char32a">The first code point to be checked against the.</param>
            <param name="str2">The second string.</param>
            <param name="comparison"><see cref="T:ICU4N.Text.NormalizerComparison"/> flags to control the text comparison.
            </param>
            <param name="foldCase"><see cref="T:ICU4N.Globalization.FoldCase"/> option, such as 
            <see cref="F:ICU4N.Globalization.FoldCase.ExcludeSpecialI"/> or <see cref="F:ICU4N.Globalization.FoldCase.Default"/>.</param>
            <param name="unicodeVersion">The Unicode version to use.
            Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
            If you want the default behavior corresponding to one of the
            standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
            </param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
             <summary>
             Concatenate normalized strings, making sure that the result is normalized
             as well.
             </summary>
             <remarks>
             If both the left and the right strings are in
             the normalization form according to "mode",
             then the result will be
            
             <code>
                 dest=Normalize(left+right, mode)
             </code>
            
             With the input strings already being normalized,
             this function will use <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/>
             to find the adjacent end pieces of the input strings.
             Only the concatenation of these end pieces will be normalized and
             then concatenated with the remaining parts of the input strings.
             <para/>
             It is allowed to have dest==left to avoid copying the entire left string.
             </remarks>
             <param name="left">Left source array, may be same as dest.</param>
             <param name="leftStart">Start in the left array.</param>
             <param name="leftLimit">Limit in the left array (==length).</param>
             <param name="right">Right source array.</param>
             <param name="rightStart">Start in the right array.</param>
             <param name="rightLimit">Limit in the right array (==length).</param>
             <param name="dest">The output buffer; can be null if destStart==destLimit==0
             for pure preflighting.</param>
             <param name="destStart">Start in the destination array.</param>
             <param name="destLimit">Limit in the destination array (==length).</param>
             <param name="mode">The normalization mode.</param>
             <param name="unicodeVersion">The Unicode version to use.
             Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
             If you want the default behavior corresponding to one of the
             standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
             </param>
             <returns>Length of output (number of chars) when successful or <see cref="T:System.IndexOutOfRangeException"/>.</returns>
             <exception cref="T:System.IndexOutOfRangeException">If target capacity is less than the required length.</exception>
             <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
             <see cref="M:ICU4N.Text.Normalizer.Next"/>
             <see cref="M:ICU4N.Text.Normalizer.Previous"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Char[],ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
             <summary>
             Concatenate normalized strings, making sure that the result is normalized
             as well.
             </summary>
             <remarks>
             If both the left and the right strings are in
             the normalization form according to "mode",
             then the result will be
            
             <code>
                 dest=Normalize(left+right, mode)
             </code>
             
             <para/>
             For details see <see cref="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>.
             </remarks>
             <param name="left">Left source string.</param>
             <param name="right">Right source string.</param>
             <param name="mode">The normalization mode.</param>
             <param name="unicodeVersion">The Unicode version to use.
             Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
             If you want the default behavior corresponding to one of the
             standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
             </param>
             <returns>Result.</returns>
             <exception cref="T:System.IndexOutOfRangeException">If target capacity is less than the required length.</exception>
             <see cref="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
             <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
             <see cref="M:ICU4N.Text.Normalizer.Next"/>
             <see cref="M:ICU4N.Text.Normalizer.Previous"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Concatenate(System.String,System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)">
             <summary>
             Concatenate normalized strings, making sure that the result is normalized
             as well.
             </summary>
             <remarks>
             If both the left and the right strings are in
             the normalization form according to "mode",
             then the result will be
            
             <code>
                 dest=Normalize(left+right, mode)
             </code>
            
             With the input strings already being normalized,
             this function will use <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/>
             to find the adjacent end pieces of the input strings.
             Only the concatenation of these end pieces will be normalized and
             then concatenated with the remaining parts of the input strings.
             </remarks>
             <param name="left">Left source string.</param>
             <param name="right">Right source string.</param>
             <param name="mode">The normalization mode.</param>
             <param name="unicodeVersion">The Unicode version to use.
             Currently the only available option is <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/>.
             If you want the default behavior corresponding to one of the
             standard Unicode Normalization Forms, use <see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Default"/> for this argument.
             </param>
             <returns>Result.</returns>
             <exception cref="T:System.IndexOutOfRangeException">If target capacity is less than the required length.</exception>
             <see cref="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
             <see cref="M:ICU4N.Text.Normalizer.Normalize(System.String,ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
             <see cref="M:ICU4N.Text.Normalizer.Next"/>
             <see cref="M:ICU4N.Text.Normalizer.Previous"/>
             <see cref="M:ICU4N.Text.Normalizer.Concatenate(System.Char[],System.Char[],ICU4N.Text.NormalizerMode,ICU4N.Text.NormalizerUnicodeVersion)"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetFC_NFKC_Closure(System.Int32,System.Char[])">
            <summary>
            Gets the FC_NFKC closure value.
            </summary>
            <param name="c">The code point whose closure value is to be retrieved.</param>
            <param name="dest">The char array to receive the closure value.</param>
            <returns>The length of the closure value; 0 if there is none.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetFC_NFKC_Closure(System.Int32)">
            <summary>
            Gets the FC_NFKC closure value.
            </summary>
            <param name="c">The code point whose closure value is to be retrieved.</param>
            <returns>String representation of the closure value; "" if there is none.</returns>
        </member>
        <member name="P:ICU4N.Text.Normalizer.Current">
            <summary>
            Gets the current character in the normalized text.
            Returns the codepoint as an int.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Next">
            <summary>
            Return the next character in the normalized text and advance
            the iteration position by one.  If the end
            of the text has already been reached, <see cref="F:ICU4N.Text.Normalizer.Done"/> is returned.
            </summary>
            <returns>The codepoint as an int.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Previous">
            <summary>
            Return the previous character in the normalized text and decrement
            the iteration position by one.  If the beginning
            of the text has already been reached, <see cref="F:ICU4N.Text.Normalizer.Done"/> is returned.
            </summary>
            <returns>The codepoint as an int.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Reset">
            <summary>
            Reset the index to the beginning of the text.
            This is equivalent to <c>SetIndexOnly(startIndex)</c>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetIndexOnly(System.Int32)">
            <summary>
            Set the iteration position in the input text that is being normalized,
            without any immediate normalization.
            After <see cref="M:ICU4N.Text.Normalizer.SetIndexOnly(System.Int32)"/>, <see cref="P:ICU4N.Text.Normalizer.Index"/> will return the same index that is
            specified here.
            </summary>
            <param name="index">The desired index in the input text.</param>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetIndex(System.Int32)">
            <summary>
            Set the iteration position in the input text that is being normalized
            and return the first normalized character at that position.
            <para/>
            <b>Note:</b> This method sets the position in the <em>input</em> text,
            while <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> iterate through characters
            in the normalized <em>output</em>.  This means that there is not
            necessarily a one-to-one correspondence between characters returned
            by see <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> and the indices passed to and
            returned from <see cref="M:ICU4N.Text.Normalizer.SetIndex(System.Int32)"/> and <see cref="P:ICU4N.Text.Normalizer.Index"/>.
            </summary>
            <param name="index">The desired index in the input text.</param>
            <returns>The first normalized character that is the result of iterating
            forward starting at the given index.</returns>
            <exception cref="T:System.ArgumentException">if the given index is less than
            <see cref="M:ICU4N.Text.Normalizer.GetBeginIndex"/> or greater than <see cref="M:ICU4N.Text.Normalizer.GetEndIndex"/>.</exception>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetBeginIndex">
            <summary>
            Retrieve the index of the start of the input text. This is the begin
            index of the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> or the start (i.e. 0) of the
            <see cref="T:System.String"/> over which this <see cref="T:ICU4N.Text.Normalizer"/> is iterating.
            </summary>
            <returns>The codepoint as an int.</returns>
            <seealso cref="P:ICU4N.Text.Normalizer.StartIndex"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetEndIndex">
            <summary>
            Retrieve the index of the end of the input text.  This is the end index
            of the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> or the length of the <see cref="T:System.String"/>
            over which this <see cref="T:ICU4N.Text.Normalizer"/> is iterating.
            </summary>
            <returns>The codepoint as an int.</returns>
            <seealso cref="P:ICU4N.Text.Normalizer.EndIndex"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.First">
            <summary>
            Return the first character in the normalized text.  This resets
            the <see cref="T:ICU4N.Text.Normalizer"/>'s position to the beginning of the text.
            </summary>
            <returns>The codepoint as an int.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.Last">
            <summary>
            Return the last character in the normalized text.  This resets
            the <see cref="T:ICU4N.Text.Normalizer"/>'s position to be just before the
            the input text corresponding to that normalized character.
            </summary>
            <returns>The codepoint as an int.</returns>
        </member>
        <member name="P:ICU4N.Text.Normalizer.Index">
            <summary>
            Retrieve the current iteration position in the input text that is
            being normalized.  This method is useful in applications such as
            searching, where you need to be able to determine the position in
            the input text that corresponds to a given normalized output character.
            <para/>
            <b>Note:</b> This method sets the position in the <em>input</em>, while
            <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> iterate through characters in the
            <em>output</em>.  This means that there is not necessarily a one-to-one
            correspondence between characters returned by <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/>
            and the indices passed to and returned from <see cref="M:ICU4N.Text.Normalizer.SetIndex(System.Int32)"/> and <see cref="P:ICU4N.Text.Normalizer.Index"/>.
            </summary>
            <returns>The current iteration position.</returns>
        </member>
        <member name="P:ICU4N.Text.Normalizer.StartIndex">
            <summary>
            Retrieve the index of the start of the input text. This is the begin
            index of the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> or the start (i.e. 0) of the
            <see cref="T:System.String"/> over which this <see cref="T:ICU4N.Text.Normalizer"/> is iterating.
            </summary>
            <returns>The current iteration position.</returns>
        </member>
        <member name="P:ICU4N.Text.Normalizer.EndIndex">
            <summary>
            Retrieve the index of the end of the input text.  This is the end index
            of the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> or the length of the <see cref="T:System.String"/>
            over which this <see cref="T:ICU4N.Text.Normalizer"/> is iterating.
            </summary>
            <returns>The current iteration position.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)">
            <summary>
            Set the normalization mode for this object.
            <para/>
            <b>Note:</b>If the normalization mode is changed while iterating
            over a string, calls to <see cref="M:ICU4N.Text.Normalizer.Next"/> and <see cref="M:ICU4N.Text.Normalizer.Previous"/> may
            return previously buffers characters in the old normalization mode
            until the iteration is able to re-sync at the next base character.
            It is safest to call <see cref="M:ICU4N.Text.Normalizer.SetText(System.String)"/>, <see cref="M:ICU4N.Text.Normalizer.First"/>,
            <see cref="M:ICU4N.Text.Normalizer.Last"/>, etc. after calling <see cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>.
            </summary>
            <param name="newMode">The new mode for this <see cref="T:ICU4N.Text.Normalizer"/>.
            The supported modes are:
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.NormalizerMode.NFC"/></term><description>Unicode canonical decompositiion followed by canonical composition.</description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerMode.NFKC"/></term><description>Unicode compatibility decompositiion follwed by canonical composition.</description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerMode.NFD"/></term><description>Unicode canonical decomposition.</description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerMode.NFKD"/></term><description>Unicode compatibility decomposition.</description></item>
                <item><term><see cref="F:ICU4N.Text.NormalizerMode.None"/></term><description>Do nothing but return characters from the underlying input text.</description></item>
            </list>
            </param>
            <see cref="M:ICU4N.Text.Normalizer.GetMode"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetMode">
            <summary>
            Return the basic operation performed by this <see cref="T:ICU4N.Text.Normalizer"/>.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetMode(ICU4N.Text.NormalizerMode)"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetOption(System.Int32,System.Boolean)">
            <summary>
            Set options that affect this <tt>Normalizer</tt>'s operation.
            Options do not change the basic composition or decomposition operation
            that is being performed , but they control whether
            certain optional portions of the operation are done.
            Currently the only available option is:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Text.NormalizerUnicodeVersion.Unicode3_2"/></term>
                    <description>Use Normalization conforming to Unicode version 3.2.</description>
                </item>
            </list>
            </summary>
            <param name="option">The option whose value is to be set.</param>
            <param name="value">the new setting for the option.  Use <c>true</c> to
            turn the option on and <c>false</c> to turn it off.</param>
            <seealso cref="M:ICU4N.Text.Normalizer.GetOption(System.Int32)"/>
            <seealso cref="P:ICU4N.Text.Normalizer.UnicodeVersion"/>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetOption(System.Int32)">
            <summary>
            Determine whether an option is turned on or off.
            </summary>
            <seealso cref="M:ICU4N.Text.Normalizer.SetOption(System.Int32,System.Boolean)"/>
            <seealso cref="P:ICU4N.Text.Normalizer.UnicodeVersion"/>
        </member>
        <member name="P:ICU4N.Text.Normalizer.UnicodeVersion">
            <summary>
            Gets or sets whether to use Normalization conforming to Unicode version 3.2
            or default behavior corresponding to one of the standard Unicode Normalization Forms
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetText(System.Char[])">
            <summary>
            Gets the underlying text storage.
            </summary>
            <param name="fillIn">the char buffer to fill the UTF-16 units.
            The length of the buffer should be equal to the length of the
            underlying text storage.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the index passed for the array is invalid.</exception>
            <seealso cref="P:ICU4N.Text.Normalizer.Length"/>
        </member>
        <member name="P:ICU4N.Text.Normalizer.Length">
            <summary>
            Gets the length of underlying text storage.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.GetText">
            <summary>
            Returns the text under iteration as a string.
            </summary>
            <returns>A copy of the text under iteration.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetText(System.Text.StringBuilder)">
            <summary>
            Set the input text over which this <see cref="T:ICU4N.Text.Normalizer"/> will iterate.
            The iteration position is set to the beginning of the input text.
            </summary>
            <param name="newText">The new string to be normalized.</param>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetText(System.Char[])">
            <summary>
            Set the input text over which this <see cref="T:ICU4N.Text.Normalizer"/> will iterate.
            The iteration position is set to the beginning of the input text.
            </summary>
            <param name="newText">The new string to be normalized.</param>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetText(System.String)">
            <summary>
            Set the input text over which this <see cref="T:ICU4N.Text.Normalizer"/> will iterate.
            The iteration position is set to the beginning of the input text.
            </summary>
            <param name="newText">The new string to be normalized.</param>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetText(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Set the input text over which this <see cref="T:ICU4N.Text.Normalizer"/> will iterate.
            The iteration position is set to the beginning of the input text.
            </summary>
            <param name="newText">The new string to be normalized.</param>
        </member>
        <member name="M:ICU4N.Text.Normalizer.SetText(ICU4N.Text.UCharacterIterator)">
            <summary>
            Set the input text over which this <see cref="T:ICU4N.Text.Normalizer"/> will iterate.
            The iteration position is set to the beginning of the string.
            </summary>
            <param name="newText">The new string to be normalized.</param>
        </member>
        <member name="F:ICU4N.Text.Normalizer.COMPARE_EQUIV">
            <summary>
            Internal option for unorm_cmpEquivFold() for decomposing.
            If not set, just do strcasecmp().
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer.CmpEquivFold(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            internal function; package visibility for use by <see cref="T:ICU4N.Text.UTF16.StringComparer"/>
            </summary>
        </member>
        <member name="T:ICU4N.Text.Normalizer.CharsAppendable">
            <summary>
            An <see cref="T:ICU4N.Support.Text.IAppendable"/> that writes into a char array with a capacity that may be
            less than array.Length.
            (By contrast, <see cref="T:ICU4N.Support.IO.CharBuffer"/> will write beyond destLimit all the way up to array.Length.)
            <para/>
            An overflow is only reported at the end, for the old Normalizer API functions that write
            to char arrays.
            </summary>
        </member>
        <member name="T:ICU4N.Text.Normalizer2Mode">
            <summary>
            Constants for normalization modes.
            For details about standard Unicode normalization forms
            and about the algorithms which are also used with custom mapping tables
            see http://www.unicode.org/unicode/reports/tr15/
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer2Mode.Compose">
            <summary>
            Decomposition followed by composition.
            Same as standard NFC when using an "nfc" instance.
            Same as standard NFKC when using an "nfkc" instance.
            For details about standard Unicode normalization forms
            see http://www.unicode.org/unicode/reports/tr15/
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer2Mode.Decompose">
            <summary>
            Map, and reorder canonically.
            Same as standard NFD when using an "nfc" instance.
            Same as standard NFKD when using an "nfkc" instance.
            For details about standard Unicode normalization forms
            see http://www.unicode.org/unicode/reports/tr15/
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer2Mode.FCD">
            <summary>
            "Fast C or D" form.
            If a string is in this form, then further decomposition <i>without reordering</i>
            would yield the same form as <see cref="F:ICU4N.Text.Normalizer2Mode.Decompose"/>.
            Text in "Fast C or D" form can be processed efficiently with data tables
            that are "canonically closed", that is, that provide equivalent data for
            equivalent text, without having to be fully normalized.
            <para/>
            Not a standard Unicode normalization form.
            <para/>
            Not a unique form: Different FCD strings can be canonically equivalent.
            <para/>
            For details see http://www.unicode.org/notes/tn5/#FCD
            </summary>
        </member>
        <member name="F:ICU4N.Text.Normalizer2Mode.ComposeContiguous">
            <summary>
            Compose only contiguously.
            Also known as "FCC" or "Fast C Contiguous".
            The result will often but not always be in NFC.
            The result will conform to FCD which is useful for processing.
            <para/>
            Not a standard Unicode normalization form.
            <para/>
            For details see http://www.unicode.org/notes/tn5/#FCC
            </summary>
        </member>
        <member name="T:ICU4N.Text.Normalizer2">
            <summary>
            Unicode normalization functionality for standard Unicode normalization or
            for using custom mapping tables.
            All instances of this class are unmodifiable/immutable.
            The Normalizer2 class is not intended for public subclassing.
            </summary>
            <remarks>
            The primary functions are to produce a normalized string and to detect whether
            a string is already normalized.
            <para/>
            The most commonly used normalization forms are those defined in
            http://www.unicode.org/unicode/reports/tr15/
            However, this API supports additional normalization forms for specialized purposes.
            For example, NFKC_Casefold is provided via GetInstance("nfkc_cf", COMPOSE)
            and can be used in implementations of UTS #46.
            <para/>
            Not only are the standard compose and decompose modes supplied,
            but additional modes are provided as documented in the Mode enum.
            <para/>
            Some of the functions in this class identify normalization boundaries.
            At a normalization boundary, the portions of the string
            before it and starting from it do not interact and can be handled independently.
            <para/>
            The <see cref="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.String)"/> stops at a normalization boundary.
            When the goal is a normalized string, then the text before the boundary
            can be copied, and the remainder can be processed with <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)"/>.
            <para/>
            The <see cref="M:ICU4N.Text.Normalizer2.HasBoundaryBefore(System.Int32)"/>, <see cref="M:ICU4N.Text.Normalizer2.HasBoundaryAfter(System.Int32)"/> and <see cref="M:ICU4N.Text.Normalizer2.IsInert(System.Int32)"/> functions test whether
            a character is guaranteed to be at a normalization boundary,
            regardless of context.
            This is used for moving from one normalization boundary to the next
            or preceding boundary, and for performing iterative normalization.
            <para/>
            Iterative normalization is useful when only a small portion of a
            longer string needs to be processed.
            For example, in ICU, iterative normalization is used by the NormalizationTransliterator
            (to avoid replacing already-normalized text) and ucol_nextSortKeyPart()
            (to process only the substring for which sort key bytes are computed).
            <para/>
            The set of normalization boundaries returned by these functions may not be
            complete: There may be more boundaries that could be returned.
            Different functions may return different boundaries.
            </remarks>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.#ctor">
            <summary>
            Sole constructor.  (For invocation by subclass constructors,
            typically implicit.)
            <para/>
            This API is ICU internal only.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetNFCInstance">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance for Unicode NFC normalization.
            Same as GetInstance(null, "nfc", UNormalization2Mode.UNORM2_COMPOSE).
            Returns an unmodifiable singleton instance.
            </summary>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetNFDInstance">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance for Unicode NFD normalization.
            Same as GetInstance(null, "nfc", UNormalization2Mode.UNORM2_DECOMPOSE).
            Returns an unmodifiable singleton instance.
            </summary>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetNFKCInstance">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance for Unicode NFKC normalization.
            Same as GetInstance(null, "nfkc", UNormalization2Mode.UNORM2_COMPOSE).
            Returns an unmodifiable singleton instance.
            </summary>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetNFKDInstance">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance for Unicode NFKD normalization.
            Same as GetInstance(null, "nfkc", UNormalization2Mode.UNORM2_DECOMPOSE).
            Returns an unmodifiable singleton instance.
            </summary>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetNFKCCasefoldInstance">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance for Unicode NFKC_Casefold normalization.
            Same as GetInstance(null, "nfkc_cf", UNormalization2Mode.UNORM2_COMPOSE).
            Returns an unmodifiable singleton instance.
            </summary>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetInstance(System.IO.Stream,System.String,ICU4N.Text.Normalizer2Mode)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.Normalizer2"/> instance which uses the specified data file
            (an ICU data file if data=null, or else custom binary data)
            and which composes or decomposes text according to the specified mode.
            Returns an unmodifiable singleton instance.
            <list type="bullet">
            	<item><description>Use data=null for data files that are part of ICU's own data.</description></item>
            	<item><description>Use name="nfc" and COMPOSE/DECOMPOSE for Unicode standard NFC/NFD.</description></item>
            	<item><description>Use name="nfkc" and COMPOSE/DECOMPOSE for Unicode standard NFKC/NFKD.</description></item>
            	<item><description>Use name="nfkc_cf" and COMPOSE for Unicode standard NFKC_CF=NFKC_Casefold.</description></item>
            </list>
            <para/>
            If data!=null, then the binary data is read once and cached using the provided
            name as the key.
            If you know or expect the data to be cached already, you can use data!=null
            for non-ICU data as well.
            </summary>
            <param name="data">The binary, big-endian normalization (.nrm file) data, or null for ICU data.</param>
            <param name="name">"nfc" or "nfkc" or "nfkc_cf" or name of custom data file.</param>
            <param name="mode">Normalization mode (compose or decompose etc.)</param>
            <returns>The requested <see cref="T:ICU4N.Text.Normalizer2"/>, if successful.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.String)">
            <summary>
            Returns the normalized form of the source string.
            </summary>
            <param name="src">Source string.</param>
            <returns>Normalized src.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.Text.StringBuilder)">
            <summary>
            Returns the normalized form of the source <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="src">Source <see cref="T:System.Text.StringBuilder"/>.</param>
            <returns>Normalized src.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.Char[])">
            <summary>
            Returns the normalized form of the source <see cref="T:char[]"/>.
            </summary>
            <param name="src">Source <see cref="T:char[]"/>.</param>
            <returns>Normalized src.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the normalized form of the source <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            </summary>
            <param name="src">Source <see cref="T:ICU4N.Support.Text.ICharSequence"/>.</param>
            <returns>Normalized src.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.String,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source <see cref="T:System.Text.StringBuilder"/> to the destination string
            (replacing its contents) and returns the destination string.
            The source and destination strings must be different objects.
            </summary>
            <param name="src">Source <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(System.Char[],System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source <see cref="T:char[]"/> to the destination string
            (replacing its contents) and returns the destination string.
            The source and destination strings must be different objects.
            </summary>
            <param name="src">Source <see cref="T:char[]"/>.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Normalize(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.IAppendable)">
            <summary>
            Writes the normalized form of the source string to the destination string
            (replacing its contents) and returns the destination string.
            </summary>
            <param name="src">Source string.</param>
            <param name="dest">Destination string; its contents is replaced with normalized <paramref name="src"/>.</param>
            <returns><paramref name="dest"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Appends the normalized form of the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if the first string was normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, will be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Append(System.Text.StringBuilder,System.String)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Append(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Append(System.Text.StringBuilder,System.Char[])">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.Append(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Appends the second string to the first string
            (merging them at the boundary) and returns the first string.
            The result is normalized if both the strings were normalized.
            The first and second strings must be different objects.
            </summary>
            <param name="first">First string, should be normalized.</param>
            <param name="second">Second string, should be normalized.</param>
            <returns><paramref name="first"/></returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetDecomposition(System.Int32)">
            <summary>
            Gets the decomposition mapping of <paramref name="codePoint"/>.
            Roughly equivalent to normalizing the <see cref="T:System.String"/> form of <paramref name="codePoint"/>
            on a DECOMPOSE <see cref="T:ICU4N.Text.Normalizer2"/> instance, but much faster, and except that this function
            returns null if c does not have a decomposition mapping in this instance's data.
            This function is independent of the mode of the Normalizer2.
            </summary>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s decomposition mapping, if any; otherwise null.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetRawDecomposition(System.Int32)">
            <summary>
            Gets the raw decomposition mapping of <paramref name="codePoint"/>.
            </summary>
            <remarks>
            This is similar to the <see cref="M:ICU4N.Text.Normalizer2.GetDecomposition(System.Int32)"/> method but returns the
            raw decomposition mapping as specified in UnicodeData.txt or
            (for custom data) in the mapping files processed by the gennorm2 tool.
            By contrast, <see cref="M:ICU4N.Text.Normalizer2.GetDecomposition(System.Int32)"/> returns the processed,
            recursively-decomposed version of this mapping.
            <para/>
            When used on a standard NFKC <see cref="T:ICU4N.Text.Normalizer2"/> instance,
            <see cref="M:ICU4N.Text.Normalizer2.GetRawDecomposition(System.Int32)"/> returns the Unicode Decomposition_Mapping (dm) property.
            <para/>
            When used on a standard NFC <see cref="T:ICU4N.Text.Normalizer2"/> instance,
            it returns the Decomposition_Mapping only if the Decomposition_Type (dt) is Canonical (Can);
            in this case, the result contains either one or two code points (=1..4 .NET chars).
            <para/>
            This function is independent of the mode of the <see cref="T:ICU4N.Text.Normalizer2"/>.
            The default implementation returns null.
            </remarks>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s raw decomposition mapping, if any; otherwise null.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.ComposePair(System.Int32,System.Int32)">
            <summary>
            Performs pairwise composition of a &amp; b and returns the composite if there is one.
            </summary>
            <remarks>
            Returns a composite code point c only if c has a two-way mapping to a+b.
            In standard Unicode normalization, this means that
            c has a canonical decomposition to a+b
            and c does not have the Full_Composition_Exclusion property.
            <para/>
            This function is independent of the mode of the Normalizer2.
            The default implementation returns a negative value.
            </remarks>
            <param name="a">A (normalization starter) code point.</param>
            <param name="b">Another code point.</param>
            <returns>The non-negative composite code point if there is one; otherwise a negative value.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.GetCombiningClass(System.Int32)">
            <summary>
            Gets the combining class of <paramref name="codePoint"/>.
            The default implementation returns 0
            but all standard implementations return the Unicode Canonical_Combining_Class value.
            </summary>
            <param name="codePoint">Code point.</param>
            <returns><paramref name="codePoint"/>'s combining class.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.IsNormalized(System.String)">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.Normalizer2.QuickCheck(System.String)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.IsNormalized(System.Text.StringBuilder)">
            <summary>
            Tests if the <see cref="T:System.Text.StringBuilder"/> is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.Normalizer2.QuickCheck(System.Text.StringBuilder)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.IsNormalized(System.Char[])">
            <summary>
            Tests if the <see cref="T:char[]"/> is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.Normalizer2.QuickCheck(System.Char[])"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.IsNormalized(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Tests if the string is normalized.
            Internally, in cases where the <see cref="M:ICU4N.Text.Normalizer2.QuickCheck(ICU4N.Support.Text.ICharSequence)"/> method would return "maybe"
            (which is only possible for the two COMPOSE modes) this method
            resolves to "yes" or "no" to provide a definitive result,
            at the cost of doing more work in those cases.
            </summary>
            <param name="s">Input string.</param>
            <returns>true if s is normalized.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.QuickCheck(System.String)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.String)"/> and
            <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.QuickCheck(System.Text.StringBuilder)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.Text.StringBuilder)"/> and
            <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.QuickCheck(System.Char[])">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.Char[])"/> and
            <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.QuickCheck(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Tests if the string is normalized.
            For the two COMPOSE modes, the result could be "maybe" in cases that
            would take a little more work to resolve definitively.
            Use <see cref="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(ICU4N.Support.Text.ICharSequence)"/> and
            <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)"/> for a faster
            combination of quick check + normalization, to avoid
            re-checking the "yes" prefix.
            </summary>
            <param name="s">Input string.</param>
            <returns>The quick check result.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.String)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.String)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.Text.StringBuilder)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Text.StringBuilder)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(System.Char[])">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,System.Char[])"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.SpanQuickCheckYes(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the end of the normalized substring of the input string.
            In other words, with <c>end=SpanQuickCheckYes(s);</c>
            the substring <c>s.SubString(0, end)</c>
            will pass the quick check with a "yes" result.
            </summary>
            <remarks>
            The returned end index is usually one or more characters before the
            "no" or "maybe" character: The end index is at a normalization boundary.
            (See the class documentation for more about normalization boundaries.)
            <para/>
            When the goal is a normalized string and most input strings are expected
            to be normalized already, then call this method,
            and if it returns a prefix shorter than the input string,
            copy that prefix and use <see cref="M:ICU4N.Text.Normalizer2.NormalizeSecondAndAppend(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)"/> for the remainder.
            </remarks>
            <param name="s">Input string.</param>
            <returns>"yes" span end index.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.HasBoundaryBefore(System.Int32)">
            <summary>
            Tests if the character always has a normalization boundary before it,
            regardless of context.
            If true, then the character does not normalization-interact with
            preceding characters.
            In other words, a string containing this character can be normalized
            by processing portions before this character and starting from this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> has a normalization boundary before it.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.HasBoundaryAfter(System.Int32)">
            <summary>
            Tests if the character always has a normalization boundary after it,
            regardless of context.
            If true, then the character does not normalization-interact with
            following characters.
            In other words, a string containing this character can be normalized
            by processing portions up to this character and after this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            <para/>
            Note that this operation may be significantly slower than <see cref="M:ICU4N.Text.Normalizer2.HasBoundaryBefore(System.Int32)"/>.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> has a normalization boundary after it.</returns>
        </member>
        <member name="M:ICU4N.Text.Normalizer2.IsInert(System.Int32)">
            <summary>
            Tests if the character is normalization-inert.
            If true, then the character does not change, nor normalization-interact with
            preceding or following characters.
            In other words, a string containing this character can be normalized
            by processing portions before this character and after this
            character independently.
            This is used for iterative normalization. See the class documentation for details.
            <para/>
            Note that this operation may be significantly slower than <see cref="M:ICU4N.Text.Normalizer2.HasBoundaryBefore(System.Int32)"/>.
            </summary>
            <param name="character">Character to test.</param>
            <returns>true if <paramref name="character"/> is normalization-inert.</returns>
        </member>
        <member name="T:ICU4N.Text.NumberFormatStyle">
            <summary>
            Constants to be used to specify <see cref="T:ICU4N.Text.NumberFormat"/> style.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.NumberStyle">
            <summary>
            <icu/> Constant to specify normal number style of format.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.CurrencyStyle">
            <summary>
            <icu/> Constant to specify general currency style of format. Defaults to
            <see cref="F:ICU4N.Text.NumberFormatStyle.StandardCurrencyStyle"/>, using currency symbol, for example "$3.00", with
            non-accounting style for negative values (e.g. minus sign).
            The specific style may be specified using the -cf- locale key.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.PercentStyle">
            <summary>
            <icu/> Constant to specify a style of format to display percent.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.ScientificStyle">
            <summary>
            <icu/> Constant to specify a style of format to display scientific number.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.IntegerStyle">
            <summary>
            <icu/> Constant to specify a integer number style format.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.ISOCurrencyStyle">
            <summary>
            <icu/> Constant to specify currency style of format which uses currency
            ISO code to represent currency, for example: "USD3.00".
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.PluralCurrencyStyle">
            <summary>
            <icu/> Constant to specify currency style of format which uses currency
            long name with plural format to represent currency, for example,
            "3.00 US Dollars".
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.AccountingCurrencyStyle">
            <summary>
            <icu/> Constant to specify currency style of format which uses currency symbol
            to represent currency for accounting, for example: "($3.00), instead of
            "-$3.00" (<see cref="F:ICU4N.Text.NumberFormatStyle.CurrencyStyle"/>).
            Overrides any style specified using -cf- key in locale.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.CashCurrencyStyle">
            <summary>
            <icu/> Constant to specify currency cash style of format which uses currency
            ISO code to represent currency, for example: "NT$3" instead of "NT$3.23".
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatStyle.StandardCurrencyStyle">
            <summary>
            <icu/>Constant to specify currency style of format which uses currency symbol
            to represent currency, for example "$3.00", using non-accounting style for
            negative values (e.g. minus sign).
            Overrides any style specified using -cf- key in locale.
            </summary>
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormat.IntegerField">
            Field constant used to construct a FieldPosition object. Signifies that
            the position of the integer part of a formatted number should be returned.
            @see java.text.FieldPosition
            @stable ICU 2.0
        </member>
        <member name="F:ICU4N.Text.NumberFormat.FractionField">
            Field constant used to construct a FieldPosition object. Signifies that
            the position of the fraction part of a formatted number should be returned.
            @see java.text.FieldPosition
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Object,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            Formats a number and appends the resulting text to the given string buffer.
            {@icunote} recognizes <code>BigInteger</code>
            and <code>BigDecimal</code> objects.
            @see java.text.Format#format(Object, StringBuffer, FieldPosition)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)">
            Parses text from a string to produce a number.
            @param source the String to parse
            @param parsePosition the position at which to start the parse
            @return the parsed number, or null
            @see java.text.NumberFormat#parseObject(String, ParsePosition)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Double)">
            Specialization of format.
            @see java.text.Format#format(Object)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Int64)">
            Specialization of format.
            @see java.text.Format#format(Object)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Numerics.BigInteger)">
            {@icu} Convenience method to format a BigInteger.
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Double,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            Specialization of format.
            @see java.text.Format#format(Object, StringBuffer, FieldPosition)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Int64,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            Specialization of format.
            @see java.text.Format#format(Object, StringBuffer, FieldPosition)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Format(System.Numerics.BigInteger,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            {@icu} Formats a BigInteger. Specialization of format.
            @see java.text.Format#format(Object, StringBuffer, FieldPosition)
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            Returns a <see cref="T:System.Int64"/> if possible (e.g., within the range [<see cref="F:System.Int64.MinValue"/>,
            <see cref="F:System.Int64.MaxValue"/>] and with no decimals); otherwise, returns another type,
            such as a <see cref="T:ICU4N.Text.BigDecimal"/>, <see cref="T:System.Numerics.BigInteger"/>, or <see cref="T:System.Double"/>. The return type is not
            guaranteed other than for the <see cref="T:System.Int64"/> case.
            <para/>
            If <see cref="P:ICU4N.Text.NumberFormat.ParseIntegerOnly"/> is set, will stop at a decimal
            point (or equivalent; e.g., for rational numbers "1 2/3", will stop
            after the 1).
            <para/>
            Does not throw an exception; if no object can be parsed, index is
            unchanged!
            <para/>
            For more detail on parsing, see the "Parsing" header in the class
            documentation of <see cref="T:ICU4N.Text.DecimalFormat"/>.
            </summary>
            <seealso cref="P:ICU4N.Text.NumberFormat.ParseIntegerOnly"/>
            <seealso cref="P:ICU4N.Text.DecimalFormat.ParseBigDecimal"/>
            <seealso cref="M:ICU4N.Support.Text.Formatter.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Parse(System.String)">
             Parses text from the beginning of the given string to produce a number.
             The method might not use the entire text of the given string.
            
             @param text A String whose beginning should be parsed.
             @return A Number parsed from the string.
             @throws ParseException if the beginning of the specified string
             cannot be parsed.
             @see #format
             @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.ParseIntegerOnly">
             Returns true if this format will parse numbers as integers only.
             For example in the English locale, with ParseIntegerOnly true, the
             string "1234." would be parsed as the integer value 1234 and parsing
             would stop at the "." character.  The decimal separator accepted
             by the parse operation is locale-dependent and determined by the
             subclass.
            
             @return true if this will parse integers only
             @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.ParseStrict">
            {@icu} Returns whether strict parsing is in effect.
            @return true if strict parsing is in effect
            @see #setParseStrict
            @stable ICU 3.6
        </member>
        <member name="M:ICU4N.Text.NumberFormat.SetContext(ICU4N.Text.DisplayContext)">
             {@icu} Set a particular DisplayContext value in the formatter,
             such as CAPITALIZATION_FOR_STANDALONE.
            
             @param context The DisplayContext value to set.
             @stable ICU 53
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetContext(ICU4N.Text.DisplayContextType)">
             {@icu} Get the formatter's DisplayContext value for the specified DisplayContext.Type,
             such as CAPITALIZATION.
            
             @param type the DisplayContext.Type whose value to return
             @return the current DisplayContext setting for the specified type
             @stable ICU 53
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance">
            Returns the default number format for the current default <code>FORMAT</code> locale.
            The default format is one of the styles provided by the other
            factory methods: getNumberInstance, getIntegerInstance,
            getCurrencyInstance or getPercentInstance.
            Exactly which one is locale-dependent.
            @see Category#FORMAT
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo)">
            Returns the default number format for the specified locale.
            The default format is one of the styles provided by the other
            factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
            Exactly which one is locale-dependent.
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance(ICU4N.Util.ULocale)">
            {@icu} Returns the default number format for the specified locale.
            The default format is one of the styles provided by the other
            factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
            Exactly which one is locale-dependent.
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance(ICU4N.Text.NumberFormatStyle)">
            {@icu} Returns a specific style number format for default <code>FORMAT</code> locale.
            @param style  number format style
            @see Category#FORMAT
            @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo,ICU4N.Text.NumberFormatStyle)">
            {@icu} Returns a specific style number format for a specific locale.
            @param inLocale  the specific locale.
            @param style     number format style
            @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetNumberInstance">
            Returns a general-purpose number format for the current default <code>FORMAT</code> locale.
            @see Category#FORMAT
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetNumberInstance(System.Globalization.CultureInfo)">
            Returns a general-purpose number format for the specified locale.
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetNumberInstance(ICU4N.Util.ULocale)">
            {@icu} Returns a general-purpose number format for the specified locale.
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetIntegerInstance">
             Returns an integer number format for the current default <code>FORMAT</code> locale. The
             returned number format is configured to round floating point numbers
             to the nearest integer using IEEE half-even rounding (see {@link
             com.ibm.icu.math.BigDecimal#ROUND_HALF_EVEN ROUND_HALF_EVEN}) for formatting,
             and to parse only the integer part of an input string (see {@link
             #isParseIntegerOnly isParseIntegerOnly}).
            
             @return a number format for integer values
             @see Category#FORMAT
             @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetIntegerInstance(System.Globalization.CultureInfo)">
             Returns an integer number format for the specified locale. The
             returned number format is configured to round floating point numbers
             to the nearest integer using IEEE half-even rounding (see {@link
             com.ibm.icu.math.BigDecimal#ROUND_HALF_EVEN ROUND_HALF_EVEN}) for formatting,
             and to parse only the integer part of an input string (see {@link
             #isParseIntegerOnly isParseIntegerOnly}).
            
             @param inLocale the locale for which a number format is needed
             @return a number format for integer values
             @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetIntegerInstance(ICU4N.Util.ULocale)">
             {@icu} Returns an integer number format for the specified locale. The
             returned number format is configured to round floating point numbers
             to the nearest integer using IEEE half-even rounding (see {@link
             com.ibm.icu.math.BigDecimal#ROUND_HALF_EVEN ROUND_HALF_EVEN}) for formatting,
             and to parse only the integer part of an input string (see {@link
             #isParseIntegerOnly isParseIntegerOnly}).
            
             @param inLocale the locale for which a number format is needed
             @return a number format for integer values
             @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetCurrencyInstance">
            Returns a currency format for the current default <code>FORMAT</code> locale.
            @return a number format for currency
            @see Category#FORMAT
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetCurrencyInstance(System.Globalization.CultureInfo)">
            Returns a currency format for the specified locale.
            @return a number format for currency
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetCurrencyInstance(ICU4N.Util.ULocale)">
            {@icu} Returns a currency format for the specified locale.
            @return a number format for currency
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPercentInstance">
            Returns a percentage format for the current default <code>FORMAT</code> locale.
            @return a number format for percents
            @see Category#FORMAT
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPercentInstance(System.Globalization.CultureInfo)">
            Returns a percentage format for the specified locale.
            @return a number format for percents
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPercentInstance(ICU4N.Util.ULocale)">
            {@icu} Returns a percentage format for the specified locale.
            @return a number format for percents
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetScientificInstance">
            {@icu} Returns a scientific format for the current default <code>FORMAT</code> locale.
            @return a scientific number format
            @see Category#FORMAT
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetScientificInstance(System.Globalization.CultureInfo)">
            {@icu} Returns a scientific format for the specified locale.
            @return a scientific number format
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetScientificInstance(ICU4N.Util.ULocale)">
            {@icu} Returns a scientific format for the specified locale.
            @return a scientific number format
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetAvailableLocales">
            Returns the list of Locales for which NumberFormats are available.
            @return the available locales
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetAvailableULocales">
            {@icu} Returns the list of Locales for which NumberFormats are available.
            @return the available locales
            @draft ICU 3.2 (retain)
            @provisional This API might change or be removed in a future release.
        </member>
        <member name="M:ICU4N.Text.NumberFormat.RegisterFactory(ICU4N.Text.NumberFormatFactory)">
            <summary>
            <icu/> Registers a new <see cref="T:ICU4N.Text.NumberFormatFactory"/>. The factory is adopted by
            the service and must not be modified.  The returned object is a
            key that can be used to unregister this factory.
            <para/>
            Because ICU may choose to cache NumberFormat objects internally, this must
            be called at application startup, prior to any calls to
            <see cref="M:ICU4N.Text.NumberFormat.GetInstance"/> to avoid undefined behavior.
            </summary>
            <param name="factory">The factory to register.</param>
            <returns>A key with which to unregister the factory.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Unregister(System.Object)">
            {@icu} Unregisters the factory or instance associated with this key (obtained from
            registerInstance or registerFactory).
            @param registryKey a key obtained from registerFactory
            @return true if the object was successfully unregistered
            @stable ICU 2.6
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetHashCode">
             {@inheritDoc}
            
             @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Equals(System.Object)">
            Overrides equals.
            Two NumberFormats are equal if they are of the same class
            and the settings (groupingUsed, parseIntegerOnly, maximumIntegerDigits, etc.
            are equal.
            @param obj the object to compare against
            @return true if the object is equal to this.
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.Clone">
            Overrides clone.
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.IsGroupingUsed">
            Returns true if grouping is used in this format. For example, in the
            en_US locale, with grouping on, the number 1234567 will be formatted
            as "1,234,567". The grouping separator as well as the size of each group
            is locale-dependent and is determined by subclasses of NumberFormat.
            Grouping affects both parsing and formatting.
            @return true if grouping is used
            @see #setGroupingUsed
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.MaximumIntegerDigits">
             Returns the maximum number of digits allowed in the integer portion of a
             number.  The default value is 40, which subclasses can override.
            
             When formatting, if the number of digits exceeds this value, the highest-
             significance digits are truncated until the limit is reached, in accordance
             with UTS#35.
            
             This setting has no effect on parsing.
            
             @return the maximum number of integer digits
             @see #setMaximumIntegerDigits
             @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.MinimumIntegerDigits">
            Returns the minimum number of digits allowed in the integer portion of a
            number.  The default value is 1, which subclasses can override.
            When formatting, if this value is not reached, numbers are padded on the
            left with the locale-specific '0' character to ensure at least this
            number of integer digits.  When parsing, this has no effect.
            @return the minimum number of integer digits
            @see #setMinimumIntegerDigits
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.MaximumFractionDigits">
            Returns the maximum number of digits allowed in the fraction
            portion of a number.  The default value is 3, which subclasses
            can override.  When formatting, the exact behavior when this
            value is exceeded is subclass-specific.  When parsing, this has
            no effect.
            @return the maximum number of fraction digits
            @see #setMaximumFractionDigits
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.NumberFormat.MinimumFractionDigits">
            Returns the minimum number of digits allowed in the fraction portion of a
            number.  The default value is 0, which subclasses can override.
            When formatting, if this value is not reached, numbers are padded on
            the right with the locale-specific '0' character to ensure at least
            this number of fraction digits.  When parsing, this has no effect.
            @return the minimum number of fraction digits
            @see #setMinimumFractionDigits
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetInstance(ICU4N.Util.ULocale,ICU4N.Text.NumberFormatStyle)">
            Returns a specific style number format for a specific locale.
            @param desiredLocale  the specific locale.
            @param choice         number format style
            @throws IllegalArgumentException  if choice is not one of
                                              NUMBERSTYLE, CURRENCYSTYLE,
                                              PERCENTSTYLE, SCIENTIFICSTYLE,
                                              INTEGERSTYLE, ISOCURRENCYSTYLE,
                                              PLURALCURRENCYSTYLE, ACCOUNTINGCURRENCYSTYLE.
                                              CASHCURRENCYSTYLE, STANDARDCURRENCYSTYLE.
            @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPattern(System.Globalization.CultureInfo,ICU4N.Text.NumberFormatStyle)">
            Returns the pattern for the provided locale and choice.
            @param forLocale the locale of the data.
            @param choice the pattern format.
            @return the pattern
            @deprecated ICU 3.4 subclassers should override getPattern(ULocale, int) instead of this method.
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPattern(ICU4N.Util.ULocale,ICU4N.Text.NumberFormatStyle)">
            Returns the pattern for the provided locale and choice.
            @param forLocale the locale of the data.
            @param choice the pattern format.
            @return the pattern
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPatternForStyle(ICU4N.Util.ULocale,ICU4N.Text.NumberFormatStyle)">
            Returns the pattern for the provided locale and choice.
            @param forLocale the locale of the data.
            @param choice the pattern format.
            @return the pattern
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Text.NumberFormat.GetPatternForStyleAndNumberingSystem(ICU4N.Util.ULocale,System.String,ICU4N.Text.NumberFormatStyle)">
            Returns the pattern for the provided locale, numbering system, and choice.
            @param forLocale the locale of the data.
            @param nsName The name of the numbering system, like "latn".
            @param choice the pattern format.
            @return the pattern
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Text.NumberFormat.ReadObject(System.IO.Stream)">
             First, read in the default serializable data.
            
             Then, if <code>serialVersionOnStream</code> is less than 1, indicating that
             the stream was written by JDK 1.1,
             set the <code>int</code> fields such as <code>maximumIntegerDigits</code>
             to be equal to the <code>byte</code> fields such as <code>maxIntegerDigits</code>,
             since the <code>int</code> fields were not present in JDK 1.1.
             Finally, set serialVersionOnStream back to the maximum allowed value so that
             default serialization will work properly if this object is streamed out again.
        </member>
        <member name="M:ICU4N.Text.NumberFormat.WriteObject(System.IO.Stream)">
            Write out the default serializable data, after first setting
            the <code>byte</code> fields such as <code>maxIntegerDigits</code> to be
            equal to the <code>int</code> fields such as <code>maximumIntegerDigits</code>
            (or to <code>Byte.MAX_VALUE</code>, whichever is smaller), for compatibility
            with the JDK 1.1 version of the stream format.
        </member>
        <member name="F:ICU4N.Text.NumberFormat.groupingUsed">
             True if the the grouping (i.e. thousands) separator is used when
             formatting and parsing numbers.
            
             @serial
             @see #isGroupingUsed
        </member>
        <member name="F:ICU4N.Text.NumberFormat.parseIntegerOnly">
             True if this format will parse numbers as integers only.
            
             @serial
             @see #isParseIntegerOnly
        </member>
        <member name="F:ICU4N.Text.NumberFormat.maximumIntegerDigits">
             The maximum number of digits allowed in the integer portion of a
             number.  <code>maximumIntegerDigits</code> must be greater than or equal to
             <code>minimumIntegerDigits</code>.
            
             @serial
             @see #getMaximumIntegerDigits
        </member>
        <member name="F:ICU4N.Text.NumberFormat.minimumIntegerDigits">
             The minimum number of digits allowed in the integer portion of a
             number.  <code>minimumIntegerDigits</code> must be less than or equal to
             <code>maximumIntegerDigits</code>.
            
             @serial
             @see #getMinimumIntegerDigits
        </member>
        <member name="F:ICU4N.Text.NumberFormat.maximumFractionDigits">
             The maximum number of digits allowed in the fractional portion of a
             number.  <code>maximumFractionDigits</code> must be greater than or equal to
             <code>minimumFractionDigits</code>.
            
             @serial
             @see #getMaximumFractionDigits
        </member>
        <member name="F:ICU4N.Text.NumberFormat.minimumFractionDigits">
             The minimum number of digits allowed in the fractional portion of a
             number.  <code>minimumFractionDigits</code> must be less than or equal to
             <code>maximumFractionDigits</code>.
            
             @serial
             @see #getMinimumFractionDigits
        </member>
        <member name="M:ICU4N.Text.NumberFormat.#ctor">
            <summary>
            Empty constructor.  Public for API compatibility with historic versions of
            java.text.NumberFormat which had public constructor even though this is
            an abstract class.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormat.capitalizationSetting">
            <summary>
            Capitalization context setting, new in ICU 53
            </summary>
            <serial/>
        </member>
        <member name="T:ICU4N.Text.NumberFormatField">
            <summary>
            The instances of this inner class are used as attribute keys and values
            in <see cref="T:ICU4N.Support.Text.AttributedCharacterIterator"/> that
            <c>NumberFormat.FormatToCharacterIterator()</c> method returns.
            <para/>
            There is no public constructor to this class, the only instances are the
            constants defined here.
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Sign">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Integer">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Fraction">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Exponent">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.ExponentSign">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.ExponentSymbol">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.DecimalSeparator">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.GroupingSeparator">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Percent">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.PerMille">
            <stable>ICU 3.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatField.Currency">
            <stable>ICU 3.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatField.#ctor(System.String)">
            <summary>
            Constructs a new instance of <see cref="T:ICU4N.Text.NumberFormatField"/> with the given
            <paramref name="fieldName"/>.
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatField.ReadResolve">
            serizalization method resolve instances to the constant
            NumberFormat.Field values
            @stable ICU 3.6
        </member>
        <member name="T:ICU4N.Text.NumberFormatFactory">
            <summary>
            A <see cref="T:ICU4N.Text.NumberFormatFactory"/> is used to register new number formats.  The factory
            should be able to create any of the predefined formats for each locale it
            supports.  When registered, the locales it supports extend or override the
            locales already supported by ICU.
            <para/>
            <b>Note:</b> as of ICU4J 3.2, the default API for <see cref="T:ICU4N.Text.NumberFormatFactory"/> uses
            <see cref="T:ICU4N.Util.ULocale"/> instead of <see cref="T:System.Globalization.CultureInfo"/>.  Instead of overriding <see cref="M:ICU4N.Text.NumberFormatFactory.CreateFormat(System.Globalization.CultureInfo,System.Int32)"/>,
            new implementations should override <see cref="M:ICU4N.Text.NumberFormatFactory.CreateFormat(ICU4N.Util.ULocale,System.Int32)"/>.  Note that
            one of these two methods <b>MUST</b> be overridden or else an infinite
            loop will occur.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatFactory.FormatNumber">
            <summary>
            Value passed to format requesting a default number format.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatFactory.FormatCurrency">
            <summary>
            Value passed to format requesting a currency format.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatFactory.FormatPercent">
            <summary>
            Value passed to format requesting a percent format.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatFactory.FormatScientific">
            <summary>
            Value passed to format requesting a scientific format.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.NumberFormatFactory.FormatInteger">
            <summary>
            Value passed to format requesting an integer format.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Text.NumberFormatFactory.Visible">
            <summary>
            Returns true if this factory is visible.  Default is true.
            If not visible, the locales supported by this factory will not
            be listed by getAvailableLocales.  This value must not change.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatFactory.GetSupportedLocaleNames">
            <summary>
            Returns an immutable collection of the locale names directly
            supported by this factory.
            </summary>
            <returns>the supported locale names.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatFactory.CreateFormat(ICU4N.Util.ULocale,System.Int32)">
            <summary>
            Returns a number format of the appropriate type.  If the locale
            is not supported, return null.  If the locale is supported, but
            the type is not provided by this service, return null.  Otherwise
            return an appropriate instance of <see cref="T:ICU4N.Text.NumberFormat"/>.
            <b>Note:</b> as of ICU4J 3.2, implementations should override
            this method instead of <see cref="M:ICU4N.Text.NumberFormatFactory.CreateFormat(System.Globalization.CultureInfo,System.Int32)"/>.
            </summary>
            <param name="loc">the locale for which to create the format</param>
            <param name="formatType">the type of format</param>
            <returns>The <see cref="T:ICU4N.Text.NumberFormat"/>, or null.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatFactory.CreateFormat(System.Globalization.CultureInfo,System.Int32)">
            <summary>
            Returns a number format of the appropriate type.  If the locale
            is not supported, return null.  If the locale is supported, but
            the type is not provided by this service, return null.  Otherwise
            return an appropriate instance of <see cref="T:ICU4N.Text.NumberFormat"/>.
            <b>Note:</b> as of ICU4J 3.2, <see cref="M:ICU4N.Text.NumberFormatFactory.CreateFormat(ICU4N.Util.ULocale,System.Int32)"/> should be
            overridden instead of this method.  This method is no longer
            abstract and delegates to that method.
            </summary>
            <param name="loc">the locale for which to create the format</param>
            <param name="formatType">the type of format</param>
            <returns>the NumberFormat, or null.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberFormatFactory.#ctor">
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.SimpleNumberFormatFactory">
            <summary>
            A <see cref="T:ICU4N.Text.NumberFormatFactory"/> that supports a single locale.  It can be visible or invisible.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleNumberFormatFactory.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.SimpleNumberFormatFactory"/> with the given locale.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleNumberFormatFactory.#ctor(System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.SimpleNumberFormatFactory"/> with the given locale and the
            visibility.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleNumberFormatFactory.#ctor(ICU4N.Util.ULocale)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.SimpleNumberFormatFactory"/> with the given locale.
            </summary>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleNumberFormatFactory.#ctor(ICU4N.Util.ULocale,System.Boolean)">
            <summary>
            Constructs a <see cref="T:ICU4N.Text.SimpleNumberFormatFactory"/> with the given locale and the
            visibility.
            </summary>
            <stable>ICU 3.2</stable>
        </member>
        <member name="P:ICU4N.Text.SimpleNumberFormatFactory.Visible">
            <summary>
            Returns true if this factory is visible.  Default is true.
            If not visible, the locales supported by this factory will not
            be listed by getAvailableLocales.  This value must not change.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleNumberFormatFactory.GetSupportedLocaleNames">
            <summary>
            Returns an immutable collection of the locale names directly
            supported by this factory.
            </summary>
            <returns>the supported locale names.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.NumberingSystem">
            <summary>
            <see cref="T:ICU4N.Text.NumberingSystem"/> is the base class for all number
            systems. This class provides the interface for setting different numbering
            system types, whether it be a simple alternate digit system such as
            Thai digits or Devanagari digits, or an algorithmic numbering system such
            as Hebrew numbering or Chinese numbering.
            </summary>
            <author>John Emmons</author>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberingSystem.Latin">
            <summary>
            For convenience, an instance representing the <em>latn</em> numbering system, which
            corresponds to digits in the ASCII range '0' through '9'.
            </summary>
            <draft>ICU 60</draft>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.#ctor">
            <summary>
            Default constructor.  Returns a numbering system that uses the Western decimal
            digits 0 through 9.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstance(System.Int32,System.Boolean,System.String)">
            <summary>
            Factory method for creating a numbering system.
            </summary>
            <param name="radix_in">The radix for this numbering system.  ICU currently
            supports only numbering systems whose radix is 10.</param>
            <param name="isAlgorithmic_in">Specifies whether the numbering system is algorithmic
            (true) or numeric (false).</param>
            <param name="desc_in">String used to describe the characteristics of the numbering
            system.  For numeric systems, this string contains the digits used by the
            numbering system, in order, starting from zero.  For algorithmic numbering
            systems, the string contains the name of the RBNF ruleset in the locale's
            NumberingSystemRules section that will be used to format numbers using
            this numbering system.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstance(System.String,System.Int32,System.Boolean,System.String)">
            <summary>
            Factory method for creating a numbering system.
            </summary>
            <param name="name_in">The string representing the name of the numbering system.</param>
            <param name="radix_in">The radix for this numbering system.  ICU currently
            supports only numbering systems whose radix is 10.</param>
            <param name="isAlgorithmic_in">Specifies whether the numbering system is algorithmic
            (true) or numeric (false).</param>
            <param name="desc_in">String used to describe the characteristics of the numbering
            system.  For numeric systems, this string contains the digits used by the
            numbering system, in order, starting from zero.  For algorithmic numbering
            systems, the string contains the name of the RBNF ruleset in the locale's
            NumberingSystemRules section that will be used to format numbers using
            this numbering system.</param>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns the default numbering system for the specified locale.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstance(ICU4N.Util.ULocale)">
            <summary>
            Returns the default numbering system for the specified <see cref="T:ICU4N.Util.ULocale"/>.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstance">
            <summary>
            Returns the default numbering system for the default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
            </summary>
            <seealso cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetInstanceByName(System.String)">
            <summary>
            Returns a numbering system from one of the predefined numbering systems
            known to ICU.  Numbering system names are based on the numbering systems
            defined in CLDR.  To get a list of available numbering systems, use the
            <see cref="M:ICU4N.Text.NumberingSystem.GetAvailableNames"/> method.
            </summary>
            <param name="name">The name of the desired numbering system.  Numbering system
            names often correspond with the name of the script they are associated
            with.  For example, "thai" for Thai digits, "hebr" for Hebrew numerals.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.GetAvailableNames">
            <summary>
            Returns a string array containing a list of the names of numbering systems
            currently known to ICU.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.NumberingSystem.IsValidDigitString(System.String)">
            <summary>
            Convenience method to determine if a given digit string is valid for use as a
            descriptor of a numeric ( non-algorithmic ) numbering system.  In order for
            a digit string to be valid, it must contain exactly ten Unicode code points.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="P:ICU4N.Text.NumberingSystem.Radix">
            <summary>
            Returns the radix of the current numbering system.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="P:ICU4N.Text.NumberingSystem.Description">
            <summary>
            Returns the description string of the current numbering system.
            The description string describes the characteristics of the numbering
            system.  For numeric systems, this string contains the digits used by the
            numbering system, in order, starting from zero.  For algorithmic numbering
            systems, the string contains the name of the RBNF ruleset in the locale's
            NumberingSystemRules section that will be used to format numbers using
            this numbering system.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="P:ICU4N.Text.NumberingSystem.Name">
            <summary>
            Returns the string representing the name of the numbering system.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="P:ICU4N.Text.NumberingSystem.IsAlgorithmic">
            <summary>
            Returns the numbering system's algorithmic status.  If true,
            the numbering system is algorithmic and uses an RBNF formatter to
            format numerals.  If false, the numbering system is numeric and
            uses a fixed set of digits.
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.NumberingSystem.cachedLocaleData">
            <summary>
            Cache to hold the NumberingSystems by Locale.
            </summary>
        </member>
        <member name="F:ICU4N.Text.NumberingSystem.cachedStringData">
            <summary>
            Cache to hold the NumberingSystems by name.
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralFormat">
            <summary>
            <see cref="T:ICU4N.Text.PluralFormat"/> supports the creation of internationalized
            messages with plural inflection. It is based on <i>plural
            selection</i>, i.e. the caller specifies messages for each
            plural case that can appear in the user's language and the
            <see cref="T:ICU4N.Text.PluralFormat"/> selects the appropriate message based on
            the number.
            </summary>
            <remarks>
            <h3>The Problem of Plural Forms in Internationalized Messages</h3>
            <para/>
            Different languages have different ways to inflect
            plurals. Creating internationalized messages that include plural
            forms is only feasible when the framework is able to handle plural
            forms of <i>all</i> languages correctly. <see cref="T:ICU4N.Support.Text.ChoiceFormat"/>
            doesn't handle this well, because it attaches a number interval to
            each message and selects the message whose interval contains a
            given number. This can only handle a finite number of
            intervals. But in some languages, like Polish, one plural case
            applies to infinitely many intervals (e.g., the paucal case applies to
            numbers ending with 2, 3, or 4 except those ending with 12, 13, or
            14). Thus <see cref="T:ICU4N.Support.Text.ChoiceFormat"/> is not adequate.
            <para/>
            <see cref="T:ICU4N.Text.PluralFormat"/> deals with this by breaking the problem
            into two parts:
            <list type="bullet">
                <item>
                    <description>
                        It uses <code>PluralRules</code> that can define more complex
                        conditions for a plural case than just a single interval. These plural
                        rules define both what plural cases exist in a language, and to
                        which numbers these cases apply.
                    </description>
                </item>
                <item>
                    <description>
                        It provides predefined plural rules for many languages. Thus, the programmer
                        need not worry about the plural cases of a language and
                        does not have to define the plural cases; they can simply
                        use the predefined keywords. The whole plural formatting of messages can
                        be done using localized patterns from resource bundles. For predefined plural
                        rules, see the CLDR <i>Language Plural Rules</i> page at
                        <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>
                    </description>
                </item>
            </list>
            <h4>Usage of <see cref="T:ICU4N.Text.PluralFormat"/></h4>
            <para/>
            Note: Typically, plural formatting is done via <see cref="T:ICU4N.Text.MessageFormat"/>
            with a <c>plural</c> argument type,
            rather than using a stand-alone <see cref="T:ICU4N.Text.PluralFormat"/>.
            <para/>
            This discussion assumes that you use <see cref="T:ICU4N.Text.PluralFormat"/> with
            a predefined set of plural rules. You can create one using one of
            the constructors that takes a <see cref="T:ICU4N.Util.ULocale"/> object. To
            specify the message pattern, you can either pass it to the
            constructor or set it explicitly using the
            <see cref="M:ICU4N.Text.PluralFormat.ApplyPattern(System.String)"/> method. The <see cref="M:ICU4N.Text.PluralFormat.Format(System.Double)"/>
            method takes a number and selects the message of the
            matching plural case. This message will be returned.
            <h5>Patterns and Their Interpretation</h5>
            <para/>
            The pattern text defines the message output for each plural case of the
            specified locale. Syntax:
            <code>
            pluralStyle = [offsetValue] (selector '{' message '}')+
            offsetValue = "offset:" number
            selector = explicitValue | keyword
            explicitValue = '=' number  // adjacent, no white space in between
            keyword = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
            message: see <see cref="T:ICU4N.Text.MessageFormat"/>
            </code>
            <see cref="F:ICU4N.Globalization.UProperty.Pattern_White_Space"/> between syntax elements is ignored, except
            between the {curly braces} and their sub-message,
            and between the '=' and the number of an explicitValue.
            <para/>
            There are 6 predefined case keywords in CLDR/ICU - 'zero', 'one', 'two', 'few', 'many' and
            'other'. You always have to define a message text for the default plural case
            "<c>other</c>" which is contained in every rule set.
            If you do not specify a message text for a particular plural case, the
            message text of the plural case "<c>other</c>" gets assigned to this
            plural case.
            <para/>
            When formatting, the input number is first matched against the explicitValue clauses.
            If there is no exact-number match, then a keyword is selected by calling
            the <see cref="T:ICU4N.Text.PluralRules"/> with the input number <em>minus the offset</em>.
            (The offset defaults to 0 if it is omitted from the pattern string.)
            If there is no clause with that keyword, then the "other" clauses is returned.
            <para/>
            An unquoted pound sign (<c>#</c>) in the selected sub-message
            itself (i.e., outside of arguments nested in the sub-message)
            is replaced by the input number minus the offset.
            The number-minus-offset value is formatted using a
            <see cref="T:ICU4N.Text.NumberFormat"/> for the <see cref="T:ICU4N.Text.PluralFormat"/>'s locale. If you
            need special number formatting, you have to use a <see cref="T:ICU4N.Text.MessageFormat"/>
            and explicitly specify a <see cref="T:ICU4N.Text.NumberFormat"/> argument.
            <strong>Note:</strong> That argument is formatting without subtracting the offset!
            If you need a custom format and have a non-zero offset, then you need to pass the
            number-minus-offset value as a separate parameter.
            <para/>
            For a usage example, see the <see cref="T:ICU4N.Text.MessageFormat"/> class documentation.
            
            <h4>Defining Custom Plural Rules</h4>
            <para/>
            If you need to use <see cref="T:ICU4N.Text.PluralFormat"/> with custom rules, you can
            create a <see cref="T:ICU4N.Text.PluralRules"/> object and pass it to
            <see cref="T:ICU4N.Text.PluralFormat"/>'s constructor. If you also specify a locale in this
            constructor, this locale will be used to format the number in the message
            texts.
            <para/>
            For more information about <see cref="T:ICU4N.Text.PluralRules"/>, see <see cref="T:ICU4N.Text.PluralRules"/>.
            </remarks>
            <author>tschumann (Tim Schumann)</author>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.ulocale">
            <summary>
            The locale used for standard number formatting and getting the predefined
            plural rules (if they were not defined explicitely).
            </summary>
            <serial/>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.pluralRules">
            <summary>
            The plural rules used for plural selection.
            </summary>
            <serial/>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.pattern">
            <summary>
            The applied pattern string.
            </summary>
            <serial/>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.msgPattern">
            <summary>
            The <see cref="T:ICU4N.Text.MessagePattern"/> which contains the parsed structure of the pattern string.
            </summary>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.parsedValues">
            <summary>
            Obsolete with use of <see cref="T:ICU4N.Text.MessagePattern"/> since ICU 4.8. Used to be:
            The format messages for each plural case. It is a mapping:
            <see cref="T:System.String"/>(plural case keyword) --&gt; <see cref="T:System.String"/>
            (message for this plural case).
            </summary>
            <serial/>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.numberFormat">
            <summary>
            This <see cref="T:ICU4N.Text.NumberFormat"/> is used for the standard formatting of
            the number inserted into the message.
            </summary>
            <serial/>
        </member>
        <member name="F:ICU4N.Text.PluralFormat.offset">
            <summary>
            The offset to subtract before invoking plural rules.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for the default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale.
            This locale will be used to get the set of plural rules and for standard
            number formatting.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given locale.
            </summary>
            <param name="ulocale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given
            <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="locale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Text.PluralRules)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given set of rules.
            The standard number formatting will be done using the default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale.
            </summary>
            <param name="rules">defines the behavior of the <see cref="T:ICU4N.Text.PluralFormat"/>
            object.</param>
            <seealso cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralRules)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given set of rules.
            The standard number formatting will be done using the given locale.
            </summary>
            <param name="ulocale">the default number formatting will be done using this
            locale.</param>
            <param name="rules">defines the behavior of the <see cref="T:ICU4N.Text.PluralFormat"/>
            object.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(System.Globalization.CultureInfo,ICU4N.Text.PluralRules)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given set of rules.
            The standard number formatting will be done using the given locale.
            </summary>
            <param name="locale">the default number formatting will be done using this
            locale.</param>
            <param name="rules">defines the behavior of the <see cref="T:ICU4N.Text.PluralFormat"/>
            object.</param>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralType)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.PluralFormat"/> for the plural type.
            The standard number formatting will be done using the given locale.
            </summary>
            <param name="ulocale">the default number formatting will be done using this
            locale.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <stable>ICU 50</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(System.Globalization.CultureInfo,ICU4N.Text.PluralType)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.PluralFormat"/> for the plural type.
            The standard number formatting will be done using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="locale">the default number formatting will be done using this
            locale.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(System.String)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given pattern string.
            The default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale will be used to get the set of plural rules and for
            standard number formatting.
            </summary>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <seealso cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,System.String)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given pattern string and
            locale.
            The locale will be used to get the set of plural rules and for
            standard number formatting.
            </summary>
            <param name="ulocale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Text.PluralRules,System.String)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given set of rules and a
            pattern.
            The standard number formatting will be done using the default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale.
            </summary>
            <param name="rules">defines the behavior of the <see cref="T:ICU4N.Text.PluralFormat"/>
            object.</param>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralRules,System.String)">
            <summary>
            Creates a new cardinal-number <see cref="T:ICU4N.Text.PluralFormat"/> for a given set of rules, a
            pattern and a locale.
            </summary>
            <param name="ulocale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <param name="rules">defines the behavior of the <see cref="T:ICU4N.Text.PluralFormat"/>
            object.</param>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralType,System.String)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.PluralFormat"/> for a plural type, a
            pattern and a locale.
            </summary>
            <param name="ulocale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <stable>ICU 50</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralType,System.String,ICU4N.Text.NumberFormat)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.PluralFormat"/> for a plural type, a
            pattern and a locale.
            </summary>
            <param name="ulocale">the <see cref="T:ICU4N.Text.PluralFormat"/> will be configured with
            rules for this locale. This locale will also be used for standard
            number formatting.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <param name="pattern">the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.</param>
            <param name="numberFormat">The number formatter to use.</param>
            <exception cref="T:System.ArgumentException">If the pattern is invalid.</exception>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.ApplyPattern(System.String)">
            <summary>
            Sets the pattern used by this plural format.
            The method parses the pattern and creates a map of format strings
            for the plural rules.
            Patterns and their interpretation are specified in the class description.
            </summary>
            <param name="pattern">the pattern for this plural format.</param>
            <exception cref="T:System.ArgumentException">if the pattern is invalid.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.ToPattern">
            <summary>
            Returns the pattern for this <see cref="T:ICU4N.Text.PluralFormat"/>.
            </summary>
            <returns>the pattern string</returns>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.FindSubMessage(ICU4N.Text.MessagePattern,System.Int32,ICU4N.Text.PluralFormat.IPluralSelector,System.Object,System.Double)">
            <summary>
            Finds the <see cref="T:ICU4N.Text.PluralFormat"/> sub-message for the given number, or the "other" sub-message.
            </summary>
            <param name="pattern">A <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <param name="partIndex">the index of the first <see cref="T:ICU4N.Text.PluralFormat"/> argument style part.</param>
            <param name="selector">the <see cref="T:ICU4N.Text.PluralFormat.IPluralSelector"/> for mapping the number (minus offset) to a keyword.</param>
            <param name="context">worker object for the selector.</param>
            <param name="number">a number to be matched to one of the <see cref="T:ICU4N.Text.PluralFormat"/> argument's explicit values,
            or mapped via the <see cref="T:ICU4N.Text.PluralFormat.IPluralSelector"/>.</param>
            <returns>the sub-message start part index.</returns>
        </member>
        <member name="T:ICU4N.Text.PluralFormat.IPluralSelector">
            <summary>
            Interface for selecting <see cref="T:ICU4N.Text.PluralFormat"/> keywords for numbers.
            The <see cref="T:ICU4N.Text.PluralRules"/> class was intended to implement this interface,
            but there is no public API that uses a <see cref="T:ICU4N.Text.PluralFormat.IPluralSelector"/>,
            only <see cref="T:ICU4N.Text.MessageFormat"/> and <see cref="T:ICU4N.Text.PluralFormat"/> have <see cref="T:ICU4N.Text.PluralFormat.IPluralSelector"/> implementations.
            Therefore, <see cref="T:ICU4N.Text.PluralRules"/> is not marked to implement this non-public interface,
            to avoid confusing users.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.IPluralSelector.Select(System.Object,System.Double)">
            <summary>
            Given a number, returns the appropriate <see cref="T:ICU4N.Text.PluralFormat"/> keyword.
            </summary>
            <param name="context">worker object for the selector.</param>
            <param name="number">The number to be plural-formatted.</param>
            <returns>The selected <see cref="T:ICU4N.Text.PluralFormat"/> keyword.</returns>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.Format(System.Double)">
            <summary>
            Formats a plural message for a given number.
            </summary>
            <param name="number">a number for which the plural message should be formatted.
            If no pattern has been applied to this
            <see cref="T:ICU4N.Text.PluralFormat"/> object yet, the formatted number will
            be returned.
            </param>
            <returns>the string containing the formatted plural message.</returns>
            <stable>ICU 4.0</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.Format(System.Object,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Formats a plural message for a given number and appends the formatted
            message to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="number">a number for which
            the plural message should be formatted. If no pattern has been
            applied to this <see cref="T:ICU4N.Text.PluralFormat"/> object yet, the
            formatted number will be returned.
            Note: If this object is not a number type (<see cref="T:System.Int64"/>, <see cref="T:System.Double"/>, etc),
            the <paramref name="toAppendTo"/> will not be modified.</param>
            <param name="toAppendTo">the formatted message will be appended to this <see cref="T:System.Text.StringBuilder"/></param>
            <param name="pos">will be ignored by this method.</param>
            <returns>the <see cref="T:System.Text.StringBuilder"/> passed in as <paramref name="toAppendTo"/>, with formatted text
            appended.</returns>
            <exception cref="T:System.ArgumentException">if number cannot be converted to a <see cref="T:System.Double"/>.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.Parse(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            This method is not yet supported by <see cref="T:ICU4N.Text.PluralFormat"/>.
            </summary>
            <param name="text">the string to be parsed.</param>
            <param name="parsePosition">defines the position where parsing is to begin,
            and upon return, the position where parsing left off.  If the position
            has not changed upon return, then parsing failed.</param>
            <returns>nothing because this method is not yet implemented.</returns>
            <exception cref="T:System.InvalidOperationException">will always be thrown by this method.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)">
            <summary>
            This method is not yet supported by <see cref="T:ICU4N.Text.PluralFormat"/>.
            </summary>
            <param name="source">the string to be parsed.</param>
            <param name="pos">defines the position where parsing is to begin,
            and upon return, the position where parsing left off.  If the position
            has not changed upon return, then parsing failed.</param>
            <returns>nothing because this method is not yet implemented.</returns>
            <exception cref="T:System.InvalidOperationException">will always be thrown by this method.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.SetLocale(ICU4N.Util.ULocale)">
            <summary>
            Sets the locale used by this <see cref="T:ICU4N.Text.PluralFormat"/> object.
            Note: Calling this method resets this <see cref="T:ICU4N.Text.PluralFormat"/> object,
            i.e., a pattern that was applied previously will be removed,
            and the NumberFormat is set to the default number format for
            the locale.  The resulting format behaves the same as one
            constructed from <see cref="M:ICU4N.Text.PluralFormat.#ctor(ICU4N.Util.ULocale,ICU4N.Text.PluralType)"/>
            with <see cref="F:ICU4N.Text.PluralType.Cardinal"/>.
            </summary>
            <param name="ulocale">The <see cref="T:ICU4N.Util.ULocale"/> used to configure the
            formatter. If <paramref name="ulocale"/> is <c>null</c>, the
            default <see cref="F:ICU4N.Util.ULocale.Category.FORMAT"/> locale will be used.
            </param>
            <seealso cref="F:ICU4N.Util.ULocale.Category.FORMAT"/>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.SetNumberFormat(ICU4N.Text.NumberFormat)">
            <summary>
            Sets the number format used by this formatter.  You only need to
            call this if you want a different number format than the default
            formatter for the locale.
            </summary>
            <param name="format">the number format to use.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.Equals(System.Object)">
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.Equals(ICU4N.Text.PluralFormat)">
            <summary>
            Returns true if this equals the provided <see cref="T:ICU4N.Text.PluralFormat"/>.
            </summary>
            <param name="rhs">the PluralFormat to compare against</param>
            <returns>true if this equals <paramref name="rhs"/></returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.GetHashCode">
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralFormat.ToString">
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Text.PluralRanges">
            <summary>
            Utility class for returning the plural category for a range of numbers, such as 15, so that appropriate messages can
            be chosen. The rules for determining this value vary widely across locales.
            </summary>
            <author>markdavis</author>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.#ctor">
            <summary>
            Constructor
            </summary>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRanges.Matrix">
            <summary>
            Internal class for mapping from two StandardPluralCategories values to another.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Matrix.Set(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method for setting.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Matrix.SetIfNew(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method for setting; throws exception if already set.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Matrix.Get(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method for getting.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Matrix.EndSame(ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method to see if &lt;*,end&gt; values are all the same.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Matrix.StartSame(ICU4N.Impl.StandardPlural,System.Collections.Generic.IList{ICU4N.Impl.StandardPlural},System.Boolean@)">
            <summary>
            Internal method to see if &lt;start,*&gt; values are all the same.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Add(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method for building. If the start or end are null, it means everything of that type.
            </summary>
            <param name="rangeStart">plural category for the start of the range</param>
            <param name="rangeEnd">plural category for the end of the range</param>
            <param name="result">the resulting plural category</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Get(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Returns the appropriate plural category for a range from <paramref name="start"/> to <paramref name="end"/>. If there is no available data, then
            'end' is returned as an implicit value. (Such an implicit value can be tested for with <see cref="M:ICU4N.Text.PluralRanges.IsExplicit(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)"/>.)
            </summary>
            <param name="start">plural category for the start of the range</param>
            <param name="end">plural category for the end of the range</param>
            <returns>the resulting plural category, or 'end' if there is no data.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.IsExplicit(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)">
            <summary>
            Returns whether the appropriate plural category for a range from <paramref name="start"/> to <paramref name="end"/>
            is explicitly in the data (vs given an implicit value). See also <see cref="M:ICU4N.Text.PluralRanges.Get(ICU4N.Impl.StandardPlural,ICU4N.Impl.StandardPlural)"/>.
            </summary>
            <param name="start">plural category for the start of the range</param>
            <param name="end">plural category for the end of the range</param>
            <returns>Whether the value for (start,end) is explicit or not.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.IsExplicitlySet(ICU4N.Impl.StandardPlural)">
            <summary>
            Internal method to determines whether the StandardPluralCategories was explicitly used in any add statement.
            </summary>
            <param name="count">plural category to test</param>
            <returns>true if set</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Equals(System.Object)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.GetHashCode">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.CompareTo(ICU4N.Text.PluralRanges)">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRanges.IsFrozen">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.Freeze">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.CloneAsThawed">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRanges.ToString">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules">
            <summary>
            Defines rules for mapping non-negative numeric values onto a small set of keywords.
            </summary>
            <remarks>
            Rules are constructed from a text description, consisting of a series of keywords and conditions. The <see cref="M:ICU4N.Text.PluralRules.Select(System.Double)"/>
            method examines each condition in order and returns the keyword for the first condition that matches the number. If
            none match, <see cref="F:ICU4N.Text.PluralRules.KeywordOther"/> is returned.
            <para/>
            A <see cref="T:ICU4N.Text.PluralRules"/> object is immutable. It contains caches for sample values, but those are synchronized.
            <para/>
            <see cref="T:ICU4N.Text.PluralRules"/> is Serializable (except in .NET Standard 1.x) so that it can be used in formatters, which are serializable.
            <para/>
            For more information, details, and tips for writing rules, see the <a
            href="http://www.unicode.org/draft/reports/tr35/tr35.html#Language_Plural_Rules">LDML spec, C.11 Language Plural
            Rules</a>
            <para/>
            Examples:
            <para/>
            <code>
            &quot;one: n is 1; few: n in 2..4&quot;
            </code>
            This defines two rules, for 'one' and 'few'. The condition for 'one' is "n is 1" which means that the number must be
            equal to 1 for this condition to pass. The condition for 'few' is "n in 2..4" which means that the number must be
            between 2 and 4 inclusive - and be an integer - for this condition to pass. All other numbers are assigned the
            keyword "other" by the default rule.
            <para/>
            <code>
            &quot;zero: n is 0; one: n is 1; zero: n mod 100 in 1..19&quot;
            </code>
            This illustrates that the same keyword can be defined multiple times. Each rule is examined in order, and the first
            keyword whose condition passes is the one returned. Also notes that a modulus is applied to n in the last rule. Thus
            its condition holds for 119, 219, 319...
            <para/>
            <code>
            &quot;one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14&quot;
            </code>
            This illustrates conjunction and negation. The condition for 'few' has two parts, both of which must be met:
            "n mod 10 in 2..4" and "n mod 100 not in 12..14". The first part applies a modulus to n before the test as in the
            previous example. The second part applies a different modulus and also uses negation, thus it matches all numbers
            _not_ in 12, 13, 14, 112, 113, 114, 212, 213, 214...
            <para/>
            Syntax:
            <para/>
            <code>
            rules         = rule (';' rule)*
            rule          = keyword ':' condition
            keyword       = &lt;identifier&gt;
            condition     = and_condition ('or' and_condition)*
            and_condition = relation ('and' relation)*
            relation      = not? expr not? rel not? range_list
            expr          = ('n' | 'i' | 'f' | 'v' | 't') (mod value)?
            not           = 'not' | '!'
            rel           = 'in' | 'is' | '=' | '' | 'within'
            mod           = 'mod' | '%'
            range_list    = (range | value) (',' range_list)*
            value         = digit+
            digit         = 0|1|2|3|4|5|6|7|8|9
            range         = value'..'value
            </code>
            <para/>
            Each <b>not</b> term inverts the meaning; however, there should not be more than one of them.
            <para/>
            The i, f, t, and v values are defined as follows:
            <list type="bullet">
                <item><description>i to be the integer digits.</description></item>
                <item><description>f to be the visible decimal digits, as an integer.</description></item>
                <item><description>t to be the visible decimal digitswithout trailing zerosas an integer.</description></item>
                <item><description>v to be the number of visible fraction digits.</description></item>
                <item><description>j is defined to only match integers. That is j is 3 fails if v != 0 (eg for 3.1 or 3.0).</description></item>
            </list>
            <para/>
            Examples are in the following table:
            <list type="table">
                <listheader>
                    <term>n</term>
                    <term>i</term>
                    <term>f</term>
                    <term>v</term>
                </listheader>
                <item>
                    <term>1.0</term>
                    <term>1</term>
                    <term>0</term>
                    <term>1</term>
                </item>
                <item>
                    <term>1.00</term>
                    <term>1</term>
                    <term>0</term>
                    <term>2</term>
                </item>
                <item>
                    <term>1.3</term>
                    <term>1</term>
                    <term>3</term>
                    <term>1</term>
                </item>
                <item>
                    <term>1.03</term>
                    <term>1</term>
                    <term>3</term>
                    <term>2</term>
                </item>
                <item>
                    <term>1.23</term>
                    <term>1</term>
                    <term>23</term>
                    <term>2</term>
                </item>
            </list>
            <para/>
            An "identifier" is a sequence of characters that do not have the Unicode 
            <see cref="F:ICU4N.Globalization.UProperty.Pattern_Syntax"/> or <see cref="F:ICU4N.Globalization.UProperty.Pattern_White_Space"/>
            properties.
            <para/>
            The difference between 'in' and 'within' is that 'in' only includes integers in the specified range, while 'within'
            includes all values. Using 'within' with a range_list consisting entirely of values is the same as using 'in' (it's
            not an error).
            </remarks>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.CategorySeparator">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordRuleSeparator">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.Factory">
            <summary>
            Provides a factory for returning plural rules
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.#ctor">
            <summary>
            Sole constructor
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.ForLocale(ICU4N.Util.ULocale,ICU4N.Text.PluralType)">
            <summary>
            Provides access to the predefined <see cref="T:ICU4N.Text.PluralRules"/> for a given locale and the plural type.
            <para/>
            ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>. For these predefined
            rules, see CLDR page at 
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>.
            </summary>
            <param name="locale">The locale for which a <see cref="T:ICU4N.Text.PluralRules"/> object is returned.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <returns>The predefined <see cref="T:ICU4N.Text.PluralRules"/> object for this locale. If there's no predefined rules for
            this locale, the rules for the closest parent in the locale hierarchy that has one will be returned.
            The final fallback always returns the default rules.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.ForLocale(ICU4N.Util.ULocale)">
            <summary>
            Utility for getting <see cref="F:ICU4N.Text.PluralType.Cardinal"/> rules.
            </summary>
            <param name="locale">the locale</param>
            <returns>plural rules.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.GetAvailableULocales">
            <summary>
            Returns the locales for which there is plurals data.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.GetFunctionalEquivalent(ICU4N.Util.ULocale,System.Boolean[])">
            <summary>
            Returns the 'functionally equivalent' locale with respect to plural rules. Calling PluralRules.forLocale with
            the functionally equivalent locale, and with the provided locale, returns rules that behave the same. 
            All locales with the same functionally equivalent locale have plural rules that behave the same. This is not
            exaustive; there may be other locales whose plural rules behave the same that do not have the same equivalent
            locale.
            </summary>
            <param name="locale">The locale to check.</param>
            <param name="isAvailable">if not null and of length &gt; 0, this will hold 'true' at index 0 if locale is directly defined
            (without fallback) as having plural rules</param>
            <returns>the functionally-equivalent locale</returns>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.Factory.DefaultFactory">
            <summary>
            Returns the default factory.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Factory.HasOverride(ICU4N.Util.ULocale)">
            <summary>
            Returns whether or not there are overrides.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordZero">
            <summary>
            Common name for the 'zero' plural form.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordOne">
            <summary>
            Common name for the 'singular' plural form.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordTwo">
            <summary>
            Common name for the 'dual' plural form.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordFew">
            <summary>
            Common name for the 'paucal' or other special plural form.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordMany">
            <summary>
            Common name for the arabic (11 to 99) plural form.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.KeywordOther">
            <summary>
            Common name for the default plural form.  This name is returned
            for values to which no other form in the rule applies.  It
            can additionally be assigned rules of its own.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.NoUniqueValue">
            <summary>
            Value returned by <see cref="M:ICU4N.Text.PluralRules.GetUniqueKeywordValue(System.String)"/>
            when there is no unique value to return.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.NO_CONSTRAINT">
            <summary>
            The default constraint that is always satisfied.
            </summary>
        </member>
        <member name="F:ICU4N.Text.PluralRules.DEFAULT_RULE">
            <summary>
            
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ParseDescription(System.String)">
            <summary>
            Parses a plural rules <paramref name="description"/> and returns a <see cref="T:ICU4N.Text.PluralRules"/>.
            </summary>
            <param name="description">The rule description.</param>
            <exception cref="T:System.FormatException">If the <paramref name="description"/> cannot be parsed.
            The exception index is typically not set, it will be -1.</exception>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.CreateRules(System.String)">
            <summary>
            Creates a <see cref="T:ICU4N.Text.PluralRules"/> from a <paramref name="description"/> if it is parsable,
            otherwise returns null.
            </summary>
            <param name="description">The rule description.</param>
            <returns>The <see cref="T:ICU4N.Text.PluralRules"/>.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Default">
            <summary>
            The default rules that accept any number and return
            <see cref="F:ICU4N.Text.PluralRules.KeywordOther"/>.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Text.PluralRules.Operand">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.n">
            <summary>
            The double value of the entire number.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.i">
            <summary>
            The integer value, with the fraction digits truncated off.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.f">
            <summary>
            All visible fraction digits as an integer, including trailing zeros.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.t">
            <summary>
            Visible fraction digits as an integer, not including trailing zeros.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.v">
            <summary>
            Number of visible fraction digits.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.w">
            <summary>
            Number of visible fraction digits, not including trailing zeros.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.Operand.j">
            <summary>
            THIS OPERAND IS DEPRECATED AND HAS BEEN REMOVED FROM THE SPEC.
            <para/>
            Returns the integer value, but will fail if the number has fraction digits.
            That is, using "j" instead of "i" is like implicitly adding "v is 0".
            <para/>
            For example, "j is 3" is equivalent to "i is 3 and v is 0": it matches
            "3" but not "3.1" or "3.0".
            </summary>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.IFixedDecimal">
            <summary>
            An interface to FixedDecimal, allowing for other implementations.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IFixedDecimal.GetPluralOperand(ICU4N.Text.PluralRules.Operand)">
            <summary>
            Returns the value corresponding to the specified operand (n, i, f, t, v, or w).
            If the operand is 'n', returns a double; otherwise, returns an integer.
            </summary>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.IFixedDecimal.IsNaN">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.IFixedDecimal.IsInfinity">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.FixedDecimal">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.Source">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.VisibleDecimalDigitCount">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.VisibleDecimalDigitCountWithoutTrailingZeros">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.DecimalDigits">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.DecimalDigitsWithoutTrailingZeros">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.IntegerValue">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.IsNegative">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.BaseFactor">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.#ctor(System.Double,System.Int32,System.Int64)">
            <param name="n">is the original number</param>
            <param name="v">number of digits to the right of the decimal place. e.g 1.00 = 2 25. = 0</param>
            <param name="f">Corresponds to f in the plural rules grammar.
            The digits to the right of the decimal place as an integer. e.g 1.10 = 10</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.#ctor(System.Double,System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.#ctor(System.Double)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.#ctor(System.Int64)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.Decimals(System.Double)">
            <summary>
            Return a guess as to the number of decimals that would be displayed. This is only a guess; callers should
            always supply the decimals explicitly if possible. Currently, it is up to 6 decimals (without trailing zeros).
            Returns 0 for infinities and nans.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.#ctor(System.String)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.GetPluralOperand(ICU4N.Text.PluralRules.Operand)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.GetOperand(System.String)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.CompareTo(ICU4N.Text.PluralRules.FixedDecimal)">
            <summary>
            We're not going to care about NaN.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.Equals(System.Object)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.GetHashCode">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.ToString">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.HasIntegerValue">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.Int32Value">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.Int64Value">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.SingleValue">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.DoubleValue">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimal.GetShiftedValue">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.IsNaN">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimal.IsInfinity">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.FixedDecimalRange">
            <summary>
            A range of NumberInfo that includes all values with the same visibleFractionDigitCount.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.FixedDecimalRange.start">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.FixedDecimalRange.end">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalRange.#ctor(ICU4N.Text.PluralRules.FixedDecimal,ICU4N.Text.PluralRules.FixedDecimal)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalRange.ToString">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.FixedDecimalSamples">
            <summary>
            A list of NumberInfo that includes all values with the same visibleFractionDigitCount.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.FixedDecimalSamples.sampleType">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.FixedDecimalSamples.samples">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRules.FixedDecimalSamples.bounded">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalSamples.#ctor(ICU4N.Text.PluralRulesSampleType,System.Collections.Generic.ICollection{ICU4N.Text.PluralRules.FixedDecimalRange},System.Boolean)">
            <summary>
            The samples must be immutable.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalSamples.Parse(System.String)">
            <summary>
            Parse a list of the form described in CLDR. The source must be trimmed.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalSamples.AddSamples(System.Collections.Generic.ISet{System.Double})">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalSamples.ToString">
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.FixedDecimalSamples.Samples">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.FixedDecimalSamples.GetStartEndSamples(System.Collections.Generic.ICollection{ICU4N.Text.PluralRules.FixedDecimal})">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRules.IConstraint">
            <summary>
            A constraint on a number.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IConstraint.IsFulfilled(ICU4N.Text.PluralRules.IFixedDecimal)">
            <summary>
            Returns true if the number fulfills the constraint.
            </summary>
            <param name="n">the number to test, &gt;= 0.</param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IConstraint.IsLimited(ICU4N.Text.PluralRulesSampleType)">
            <summary>
            Returns false if an unlimited number of values fulfills the
            constraint.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Unexpected(System.String,System.String)">
            <summary>
            Returns a parse exception wrapping the token and context strings.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.NextToken(System.String[],System.Int32,System.String)">
            <summary>
            Returns the token at x if available, else throws a <see cref="T:System.FormatException"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ParseRule(System.String)">
            <summary>
            Syntax:
            rule : keyword ':' condition
            keyword: &lt;identifier&gt;
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ParseRuleChain(System.String)">
            <summary>
            Syntax:
            rules : rule
                    rule ';' rules
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralRules.RangeConstraint">
            <summary>
             An implementation of <see cref="T:ICU4N.Text.PluralRules.IConstraint"/> representing a modulus,
             a range of values, and include/exclude. Provides lots of
             convenience factory methods.
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralRules.BinaryConstraint">
            <summary>
            Convenience base class for and/or constraints.
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralRules.AndConstraint">
            <summary>
            A constraint representing the logical and of two constraints.
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralRules.OrConstraint">
            <summary>
            A constraint representing the logical or of two constraints.
            </summary>
        </member>
        <member name="T:ICU4N.Text.PluralRules.Rule">
            <summary>
            Implementation of <see cref="T:ICU4N.Text.PluralRules.Rule"/> that uses a constraint.
            Provides 'and' and 'or' to combine constraints.  Immutable.
            </summary>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Rule.GetHashCode">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ForLocale(ICU4N.Util.ULocale)">
            <summary>
            Provides access to the predefined cardinal-number <see cref="T:ICU4N.Text.PluralRules"/> for a given
            <paramref name="locale"/>.
            Same as <c>ForLocale(ULocale, PluralType.Cardinal)</c>.
            <para/>
            ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
            For these predefined rules, see CLDR page at
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>.
            </summary>
            <param name="locale">The locale for which a <see cref="T:ICU4N.Text.PluralRules"/> object is
            returned.</param>
            <returns>
            The predefined <see cref="T:ICU4N.Text.PluralRules"/> object for this <paramref name="locale"/>.
            If there's no predefined rules for this <paramref name="locale"/>, the rules
            for the closest parent in the <paramref name="locale"/> hierarchy that has one will
            be returned.  The final fallback always returns the default
            rules.
            </returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ForLocale(System.Globalization.CultureInfo)">
            <summary>
            Provides access to the predefined cardinal-number <see cref="T:ICU4N.Text.PluralRules"/> for a given
            <see cref="T:System.Globalization.CultureInfo"/>.
            Same as <c>ForLocale(CultureInfo, PluralType.Cardinal)"/></c>
            <para/>
            ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
            For these predefined rules, see CLDR page at
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>.
            </summary>
            <param name="locale">The locale for which a <see cref="T:ICU4N.Text.PluralRules"/> object is
            returned.</param>
            <returns>
            The predefined <see cref="T:ICU4N.Text.PluralRules"/> object for this <paramref name="locale"/>.
            If there's no predefined rules for this <paramref name="locale"/>, the rules
            for the closest parent in the <paramref name="locale"/> hierarchy that has one will
            be returned.  The final fallback always returns the default
            rules.
            </returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ForLocale(ICU4N.Util.ULocale,ICU4N.Text.PluralType)">
            <summary>
            Provides access to the predefined <see cref="T:ICU4N.Text.PluralRules"/> for a given
            <paramref name="locale"/> and the plural <paramref name="type"/>.
            <para/>
            ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
            For these predefined rules, see CLDR page at
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>.
            </summary>
            <param name="locale">The locale for which a <see cref="T:ICU4N.Text.PluralRules"/> object is
            returned.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <returns>
            The predefined <see cref="T:ICU4N.Text.PluralRules"/> object for this <paramref name="locale"/>.
            If there's no predefined rules for this <paramref name="locale"/>, the rules
            for the closest parent in the <paramref name="locale"/> hierarchy that has one will
            be returned.  The final fallback always returns the default
            rules.
            </returns>
            <stable>ICU 50</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ForLocale(System.Globalization.CultureInfo,ICU4N.Text.PluralType)">
            <summary>
            Provides access to the predefined <see cref="T:ICU4N.Text.PluralRules"/> for a given
            <see cref="T:System.Globalization.CultureInfo"/> and the plural <paramref name="type"/>.
            <para/>
            ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>.
            For these predefined rules, see CLDR page at
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html">http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html</a>.
            </summary>
            <param name="locale">The locale for which a <see cref="T:ICU4N.Text.PluralRules"/> object is
            returned.</param>
            <param name="type">The plural type (e.g., cardinal or ordinal).</param>
            <returns>
            The predefined <see cref="T:ICU4N.Text.PluralRules"/> object for this <paramref name="locale"/>.
            If there's no predefined rules for this <paramref name="locale"/>, the rules
            for the closest parent in the <paramref name="locale"/> hierarchy that has one will
            be returned.  The final fallback always returns the default
            rules.
            </returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IsValidKeyword(System.String)">
            <summary>
            Checks whether a <paramref name="token"/> is a valid keyword.
            </summary>
            <param name="token">The token to be checked.</param>
            <returns>true if the token is a valid keyword.</returns>
        </member>
        <member name="M:ICU4N.Text.PluralRules.#ctor(ICU4N.Text.PluralRules.RuleList)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.PluralRules"/> object. Immutable.
            </summary>
            <param name="rules"></param>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetHashCode">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Select(System.Double)">
            <summary>
            Given a <paramref name="number"/>, returns the keyword of the first rule that applies to
            the <paramref name="number"/>.
            </summary>
            <param name="number">The number for which the rule has to be determined.</param>
            <returns>The keyword of the selected rule.</returns>
            <stable>ICU 4.0</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Select(System.Double,System.Int32,System.Int64)">
            <summary>
            Given a <paramref name="number"/>, returns the keyword of the first rule that applies to
            the <paramref name="number"/>.
            </summary>
            <param name="number">The number for which the rule has to be determined.</param>
            <param name="countVisibleFractionDigits"></param>
            <param name="fractionaldigits"></param>
            <returns>The keyword of the selected rule.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Select(ICU4N.Text.PluralRules.IFixedDecimal)">
            <summary>
            Given a <paramref name="number"/> information, returns the keyword of the first rule that applies to
            the <paramref name="number"/>.
            </summary>
            <param name="number">The number information for which the rule has to be determined.</param>
            <returns>The keyword of the selected rule.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Matches(ICU4N.Text.PluralRules.FixedDecimal,System.String)">
            <summary>
            Given a number information, and <paramref name="keyword"/>, return whether the keyword would match the number.
            </summary>
            <param name="sample">The number information for which the rule has to be determined.</param>
            <param name="keyword">The keyword to filter on.</param>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.PluralRules.Keywords">
            <summary>
            Gets a set of all rule keywords used in this <see cref="T:ICU4N.Text.PluralRules"/>
            object.  The rule "other" is always present by default.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetUniqueKeywordValue(System.String)">
            <summary>
            Returns the unique value that this <paramref name="keyword"/> matches, or <see cref="F:ICU4N.Text.PluralRules.NoUniqueValue"/>
            if the <paramref name="keyword"/> matches multiple values or is not defined for this <see cref="T:ICU4N.Text.PluralRules"/>.
            </summary>
            <param name="keyword">The keyword to check for a unique value.</param>
            <returns>The unique value for the keyword, or <see cref="F:ICU4N.Text.PluralRules.NoUniqueValue"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetAllKeywordValues(System.String)">
            <summary>
            Returns all the values that trigger this keyword, or null if the number of such
            values is unlimited.
            </summary>
            <param name="keyword">The keyword.</param>
            <returns>The values that trigger this keyword, or null.  The returned collection
            is immutable. It will be empty if the keyword is not defined.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetAllKeywordValues(System.String,ICU4N.Text.PluralRulesSampleType)">
            <summary>
            Returns all the values that trigger this <paramref name="keyword"/>, or null if the number of such
            values is unlimited.
            </summary>
            <param name="keyword">The keyword.</param>
            <param name="type">the type of samples requested,
            <see cref="F:ICU4N.Text.PluralRulesSampleType.Integer"/> or <see cref="F:ICU4N.Text.PluralRulesSampleType.Decimal"/>.</param>
            <returns>The values that trigger this <paramref name="keyword"/>, or null.  The returned collection
            is immutable. It will be empty if the <paramref name="keyword"/> is not defined.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetSamples(System.String)">
            <summary>
            Returns a list of integer values for which <see cref="M:ICU4N.Text.PluralRules.Select(System.Double)"/> would return that <paramref name="keyword"/>,
            or null if the keyword is not defined.
            </summary>
            <remarks>
            The returned collection is unmodifiable.
            The returned list is not complete, and there might be additional values that
            would return the <paramref name="keyword"/>.
            </remarks>
            <param name="keyword">The keyword to test.</param>
            <returns>A list of values matching the <paramref name="keyword"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetSamples(System.String,ICU4N.Text.PluralRulesSampleType)">
            <summary>
            Returns a list of values for which <see cref="M:ICU4N.Text.PluralRules.Select(System.Double)"/> would return that <paramref name="keyword"/>,
            or null if the keyword is not defined or no samples are available.
            </summary>
            <remarks>
            The returned collection is unmodifiable.
            The returned list is not complete, and there might be additional values that
            would return the <paramref name="keyword"/>. The keyword might be defined, and yet have an empty set of samples,
            IF there are samples for the other <paramref name="sampleType"/>.
            </remarks>
            <param name="keyword">The keyword to test.</param>
            <param name="sampleType">The type of samples requested, 
            <see cref="F:ICU4N.Text.PluralRulesSampleType.Integer"/> or <see cref="F:ICU4N.Text.PluralRulesSampleType.Decimal"/>.</param>
            <returns>A list of values matching the <paramref name="keyword"/>.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.AddSample(System.String,System.Object,System.Int32,System.Collections.Generic.ICollection{System.Double})">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetDecimalSamples(System.String,ICU4N.Text.PluralRulesSampleType)">
            <summary>
            Returns a list of values for which <see cref="M:ICU4N.Text.PluralRules.Select(System.Double)"/> would return that <paramref name="keyword"/>,
            or null if the keyword is not defined or no samples are available.
            </summary>
            <remarks>
            The returned collection is unmodifiable.
            The returned list is not complete, and there might be additional values that
            would return the <paramref name="keyword"/>.
            </remarks>
            <param name="keyword">The keyword to test.</param>
            <param name="sampleType">The type of samples requested, 
            <see cref="F:ICU4N.Text.PluralRulesSampleType.Integer"/> or <see cref="F:ICU4N.Text.PluralRulesSampleType.Decimal"/>.</param>
            <returns>A list of values matching the <paramref name="keyword"/>.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetAvailableULocales">
            <summary>
            Returns the set of locales for which <see cref="T:ICU4N.Text.PluralRules"/> are known.
            </summary>
            <returns>The set of locales for which PluralRules are known, as an array.</returns>
            <draft>ICU 4.2 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetFunctionalEquivalent(ICU4N.Util.ULocale,System.Boolean[])">
            <summary>
            Returns the 'functionally equivalent' locale with respect to
            plural rules.  Calling <see cref="M:ICU4N.Text.PluralRules.ForLocale(System.Globalization.CultureInfo)"/> with the functionally equivalent
            locale, and with the provided locale, returns rules that behave the same.
            </summary>
            <remarks>
            All locales with the same functionally equivalent locale have
            plural rules that behave the same.  This is not exaustive;
            there may be other locales whose plural rules behave the same
            that do not have the same equivalent locale.
            </remarks>
            <param name="locale">The locale to check.</param>
            <param name="isAvailable">If not null and of length &gt; 0, this will hold 'true' at
            index 0 if locale is directly defined (without fallback) as having plural rules.</param>
            <returns>The functionally-equivalent locale.</returns>
            <draft>ICU 4.2 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ToString">
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Equals(System.Object)">
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.Equals(ICU4N.Text.PluralRules)">
            <summary>
            Returns true if rhs is equal to this.
            </summary>
            <param name="rhs">The <see cref="T:ICU4N.Text.PluralRules"/> to compare to.</param>
            <returns>true if this and rhs are equal.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetKeywordStatus(System.String,System.Int32,System.Collections.Generic.ICollection{System.Double},System.Nullable{System.Double}@)">
            <summary>
            Find the status for the <paramref name="keyword"/>, given a certain set of explicit values.
            </summary>
            <param name="keyword">The particular keyword (call <see cref="P:ICU4N.Text.PluralRules.Keywords"/> to get the valid ones).</param>
            <param name="offset">The offset used, or 0.0d if not. Internally, the offset is subtracted from each explicit value before
            checking against the <paramref name="keyword"/> values.</param>
            <param name="explicits">A set of doubles that are used explicitly (eg [=0], "[=1]"). May be empty or null.</param>
            <param name="uniqueValue">If non null, set to the unique value.</param>
            <returns>The <see cref="T:ICU4N.Text.PluralRulesKeywordStatus"/>.</returns>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetKeywordStatus(System.String,System.Int32,System.Collections.Generic.ICollection{System.Double},System.Nullable{System.Double}@,ICU4N.Text.PluralRulesSampleType)">
            <summary>
            Find the status for the <paramref name="keyword"/>, given a certain set of explicit values.
            </summary>
            <param name="keyword">The particular keyword (call <see cref="P:ICU4N.Text.PluralRules.Keywords"/> to get the valid ones)</param>
            <param name="offset">The offset used, or 0.0d if not. Internally, the offset is subtracted from each explicit value before
            checking against the keyword values.</param>
            <param name="explicits">A set of doubles that are used explicitly (eg [=0], "[=1]"). May be empty or null.</param>
            <param name="uniqueValue">Request <see cref="T:ICU4N.Text.PluralRulesKeywordStatus"/> relative to 
            <see cref="F:ICU4N.Text.PluralRulesSampleType.Integer"/> or <see cref="F:ICU4N.Text.PluralRulesSampleType.Decimal"/> values.</param>
            <param name="sampleType">If non null, set to the unique value.</param>
            <returns>The <see cref="T:ICU4N.Text.PluralRulesKeywordStatus"/>.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.GetRules(System.String)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.CompareTo(ICU4N.Text.PluralRules)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IsLimited(System.String)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.IsLimited(System.String,ICU4N.Text.PluralRulesSampleType)">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.PluralRules.ComputeLimited(System.String,ICU4N.Text.PluralRulesSampleType)">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralType">
            <summary>
            Type of plurals and <see cref="T:ICU4N.Text.PluralRules"/>.
            </summary>
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.Text.PluralType.Cardinal">
            <summary>
            Plural rules for cardinal numbers: 1 file vs. 2 files.
            </summary>
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.Text.PluralType.Ordinal">
            <summary>
            Plural rules for ordinal numbers: 1st file, 2nd file, 3rd file, 4th file, etc.
            </summary>
            <stable>ICU 50</stable>
        </member>
        <member name="T:ICU4N.Text.PluralRulesSampleType">
            <summary>
            Selection parameter for either integer-only or decimal-only.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRulesSampleType.Integer">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.PluralRulesSampleType.Decimal">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.PluralRulesKeywordStatus">
            <summary>
            Status of the keyword for the rules, given a set of explicit values.
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.PluralRulesKeywordStatus.Invalid">
            <summary>
            The keyword is not valid for the rules.
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.PluralRulesKeywordStatus.Suppressed">
            <summary>
            The keyword is valid, but unused (it is covered by the explicit values, OR has no values for the given <see cref="T:ICU4N.Text.PluralRulesSampleType"/>).
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.PluralRulesKeywordStatus.Unique">
            <summary>
            The keyword is valid, used, and has a single possible value (before considering explicit values).
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.PluralRulesKeywordStatus.Bounded">
            <summary>
            The keyword is valid, used, not unique, and has a finite set of values.
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="F:ICU4N.Text.PluralRulesKeywordStatus.Unbounded">
            <summary>
            The keyword is valid but not bounded; there indefinitely many matching values.
            </summary>
            <draft>ICU 50</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="T:ICU4N.Text.PluralRulesSerialProxy">
            <author>markdavis</author>
        </member>
        <member name="F:ICU4N.Text.Quantifier.MAX">
            <summary>
            Maximum count a quantifier can have.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Quantifier.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Implement <see cref="T:ICU4N.Text.IUnicodeMatcher"/> API.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Quantifier.ToPattern(System.Boolean)">
            <summary>
            Implement <see cref="T:ICU4N.Text.IUnicodeMatcher"/> API.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Quantifier.MatchesIndexValue(System.Int32)">
            <summary>
            Implement <see cref="T:ICU4N.Text.IUnicodeMatcher"/> API.
            </summary>
        </member>
        <member name="M:ICU4N.Text.Quantifier.AddMatchSetTo(ICU4N.Text.UnicodeSet)">
            <summary>
            Implementation of <see cref="T:ICU4N.Text.IUnicodeMatcher"/> API.  Union the set of all
            characters that may be matched by this object into the given
            set.
            </summary>
            <param name="toUnionTo">The set into which to union the source characters.</param>
        </member>
        <member name="T:ICU4N.Text.RBBIDataWrapper">
            <summary>
            Internal class used for Rule Based Break Iterators
            <para/>
            This class provides access to the compiled break rule data, as
            it is stored in a .brk file.
            </summary>
        </member>
        <member name="T:ICU4N.Text.RBBIDataWrapper.RBBIDataHeader">
            Data Header.  A struct-like class with the fields from the RBBI data file header.
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.GetRowIndex(System.Int32)">
            <summary>
            RBBI State Table Indexing Function.  Given a <paramref name="state"/> number, return the
            array index of the start of the state table row for that state.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.Get(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Get an <see cref="T:ICU4N.Text.RBBIDataWrapper"/> from an InputStream onto a pre-compiled set
            of RBBI rules.
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.GetStateTableNumStates(System.Int16[])">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.GetStateTableFlags(System.Int16[])">
            CLOVER:ON
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.Dump(System.IO.TextWriter)">
            <summary>Debug function to display the break iterator data.</summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.Int32ToString(System.Int32,System.Int32)">
            <summary>Fixed width int-to-string conversion.</summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.Int32ToHexString(System.Int32,System.Int32)">
            <summary>Fixed width int-to-string conversion.</summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.DumpTable(System.IO.TextWriter,System.Int16[])">
            <summary>Dump a state table.  (A full set of RBBI rules has 4 state tables.)</summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.DumpRow(System.IO.TextWriter,System.Int16[],System.Int32)">
            <summary>
            Dump (for debug) a single row of an RBBI state table
            </summary>
        </member>
        <member name="M:ICU4N.Text.RBBIDataWrapper.DumpCharCategories(System.IO.TextWriter)">
            CLOVER:ON
            CLOVER:OFF
        </member>
        <member name="T:ICU4N.Text.RBBINode">
            <summary>
            This class represents a node in the parse tree created by the RBBI Rule compiler.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RBBINode.PrintNode(ICU4N.Text.RBBINode)">
            CLOVER:OFF
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_ERROR_START">
            <summary>Start of codes indicating Break Iterator failures</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_INTERNAL_ERROR">
            <summary>An internal error (bug) was detected.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_HEX_DIGITS_EXPECTED">
            <summary>Hex digits expected as part of a escaped char in a rule.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_SEMICOLON_EXPECTED">
            <summary>Missing ';' at the end of a RBBI rule.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_RULE_SYNTAX">
            <summary>Syntax error in RBBI rule.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_UNCLOSED_SET">
            <summary>UnicodeSet witing an RBBI rule missing a closing ']'.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_ASSIGN_ERROR">
            <summary>Syntax error in RBBI rule assignment statement.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_VARIABLE_REDFINITION">
            <summary>RBBI rule $Variable redefined.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_MISMATCHED_PAREN">
            <summary>Mis-matched parentheses in an RBBI rule.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_NEW_LINE_IN_QUOTED_STRING">
            <summary>Missing closing quote in an RBBI rule.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_UNDEFINED_VARIABLE">
            <summary>Use of an undefined $Variable in an RBBI rule. </summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_INIT_ERROR">
            <summary>Initialization failure.  Probable missing ICU Data.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_RULE_EMPTY_SET">
            <summary>Rule contains an empty Unicode Set.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_UNRECOGNIZED_OPTION">
            <summary>!!option in RBBI rules not recognized.</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_MALFORMED_RULE_TAG">
            <summary>The {nnn} tag on a rule is mal formed</summary>
        </member>
        <member name="F:ICU4N.Text.RBBIRuleBuilder.U_BRK_ERROR_LIMIT">
            <summary>This must always be the last value to indicate the limit for Break Iterator failures</summary>
        </member>
        <member name="T:ICU4N.Text.RBBIRuleParseTable">
            <summary>
            Generated .NET File.  Do not edit by hand.
            This file contains the state table for the ICU Rule Based Break Iterator
            rule parser.
            It is generated from the "RBBIRuleParseTable.tt" file using the 
            rule parser state definitions file "rbbirpt.txt".
            </summary>
        </member>
        <member name="T:ICU4N.Text.RBBIRuleScanner">
            <summary>
            This class is part of the Rule Based Break Iterator rule compiler.
            It scans the rules and builds the parse tree.
            There is no public API here.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RBBIRuleScanner.PrintNodeStack(System.String)">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RBBIRuleScanner.PushNewNode(System.Int32)">
            CLOVER:ON
        </member>
        <member name="M:ICU4N.Text.RBBISetBuilder.PrintRanges">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RBBISetBuilder.PrintRangeGroups">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RBBISetBuilder.PrintSets">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RBBISymbolTable.RbbiSymtablePrint">
            CLOVER:OFF
        </member>
        <member name="T:ICU4N.Text.IReplaceable">
            <summary>
            <see cref="T:ICU4N.Text.IReplaceable"/> is an interface representing a
            string of characters that supports the replacement of a range of
            itself with a new string of characters.  It is used by APIs that
            change a piece of text while retaining metadata.  Metadata is data
            other than the Unicode characters returned by <see cref="M:ICU4N.Text.IReplaceable.Char32At(System.Int32)"/>.  One
            example of metadata is style attributes; another is an edit
            history, marking each character with an author and revision number.
            </summary>
            <remarks>
            An implicit aspect of the <see cref="T:ICU4N.Text.IReplaceable"/> API is that
            during a replace operation, new characters take on the metadata of
            the old characters.  For example, if the string "the <b>bold</b>
            font" has range (4, 8) replaced with "strong", then it becomes "the
            <b>strong</b> font".
            <para/>
            <see cref="T:ICU4N.Text.IReplaceable"/> specifies ranges using a start
            offset and a limit offset.  The range of characters thus specified
            includes the characters at offset start..limit-1.  That is, the
            start offset is inclusive, and the limit offset is exclusive.
            <para/>
            <see cref="T:ICU4N.Text.IReplaceable"/> also includes API to access characters
            in the string: <see cref="P:ICU4N.Text.IReplaceable.Length"/>, <see cref="P:ICU4N.Text.IReplaceable.Item(System.Int32)"/>,
            and <see cref="M:ICU4N.Text.IReplaceable.Char32At(System.Int32)"/>.
            <para/>
            For an implementation to support metadata, typical behavior of
            <see cref="M:ICU4N.Text.IReplaceable.Replace(System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)"/> is the following:
            <list type="bullet">
                <item><description>
                    Set the metadata of the new text to the metadata of the first
                    character replaced
                </description></item>
                <item><description>
                    If no characters are replaced, use the metadata of the
                    previous character
                </description></item>
                <item><description>
                    If there is no previous character (i.e. start == 0), use the
                    following character
                </description></item>
                <item><description>
                    If there is no following character (i.e. the replaceable was
                    empty), use default metadata
                </description></item>
                <item><description>
                    If the code point U+FFFF is seen, it should be interpreted as
                    a special marker having no metadata
                </description></item>
            </list>
            If this is not the behavior, the implementation should document any differences.
            </remarks>
            <author>Alan Liu</author>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.IReplaceable.Length">
            <summary>
            Gets the number of 16-bit code units in the text.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.IReplaceable.Item(System.Int32)">
            <summary>
            Gets the 16-bit code unit at the given offset into the text.
            </summary>
            <remarks>
            NOTE: This is equivalent to charAt(index) in ICU4J.
            </remarks>
            <param name="index">An integer between 0 and <see cref="P:ICU4N.Text.IReplaceable.Length"/>-1 inclusive.</param>
            <returns>16-bit code unit of text at given offset.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IReplaceable.Char32At(System.Int32)">
            <summary>
            Returns the 32-bit code point at the given 16-bit offset into
            the text.  This assumes the text is stored as 16-bit code units
            with surrogate pairs intermixed.  If the offset of a leading or
            trailing code unit of a surrogate pair is given, return the
            code point of the surrogate pair.
            <para/>
            Most implementations can return
            <c>UTF16.CharAt(this, offset)</c>.
            </summary>
            <param name="index">An integer between 0 and <see cref="P:ICU4N.Text.IReplaceable.Length"/>-1 inclusive.</param>
            <returns>32-bit code point of text at given offset.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IReplaceable.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies characters from this object into the destination
            character array.  The first character to be copied is at index
            <paramref name="sourceIndex"/>; the last character to be copied is at
            index <paramref name="count"/>-<paramref name="sourceIndex"/>.
            The characters are copied into the subarray of <paramref name="destination"/>
            starting at index <paramref name="destinationIndex"/> and ending at index
            <paramref name="destinationIndex"/>+<paramref name="count"/>.
            </summary>
            <remarks>
            NOTE: This is roughly equivalent to GetChars(int srcStart, int srcLimit, char dst[], int dstStart)
            in ICU4J with one important difference - the final parameter is the total
            count of characters to be copied (srcLimit - srcStart). This is to 
            make the function compatible with the <see cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)"/> implementation in .NET.
            </remarks>
            <param name="sourceIndex">The index of the first character in this instance to copy.</param>
            <param name="destination">An array of Unicode characters to which characters in this instance are copied.</param>
            <param name="destinationIndex">The index in <paramref name="destination"/> at which the copy operation begins.</param>
            <param name="count">The number of characters in this instance to copy to <paramref name="destination"/>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IReplaceable.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Replaces a substring of this object with the given text.
            <para/>
            Implementations must ensure that if the text between start and
            limit is equal to the replacement text, that replace has no
            effect. That is, any metadata
            should be unaffected. In addition, implementers are encouraged to
            check for initial and trailing identical characters, and make a
            smaller replacement if possible. This will preserve as much
            metadata as possible.
            </summary>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.IReplaceable.Length"/></c>.</param>
            <param name="text">The text to replace characters <c><paramref name="start"/></c> to <c><paramref name="limit"/> - 1</c>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IReplaceable.Replace(System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Replaces a substring of this object with the given text.
            <para/>
            Implementations must ensure that if the text between start and
            limit is equal to the replacement text, that replace has no
            effect. That is, any metadata
            should be unaffected. In addition, implementers are encouraged to
            check for initial and trailing identical characters, and make a
            smaller replacement if possible. This will preserve as much
            metadata as possible.
            </summary>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.IReplaceable.Length"/></c>.</param>
            <param name="chars">The text to replace characters <paramref name="start"/> to <c><paramref name="limit"/> - 1</c></param>
            <param name="charsStart">The beginning index into <paramref name="chars"/>, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="charsLen">The number of characters of <paramref name="chars"/>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IReplaceable.Copy(System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies a substring of this object, retaining metadata.
            This method is used to duplicate or reorder substrings.
            The destination index must not overlap the source range.
            </summary>
            <remarks>
            If <see cref="P:ICU4N.Text.IReplaceable.HasMetaData"/> returns false, implementations
            may use the naive implementation:
            
            <code>
            char[] text = new char[limit - start];
            CopyTo(start, text, 0, limit - start);
            Replace(dest, dest, text, 0, limit - start);
            </code>
            </remarks>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.IReplaceable.Length"/></c>.</param>
            <param name="dest">The destination index.  The characters from
            <c><paramref name="start"/>..<paramref name="limit"/>-1</c> will be copied to <paramref name="dest"/>.
            Implementations of this method may assume that <c><paramref name="dest"/> &lt;= <paramref name="start"/> ||
            <paramref name="dest"/> &gt;= <paramref name="limit"/></c>.
            </param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.IReplaceable.HasMetaData">
            <summary>
            Returns true if this object contains metadata.  If a
            <see cref="T:ICU4N.Text.IReplaceable"/> object has metadata, calls to the <see cref="T:ICU4N.Text.IReplaceable"/> API
            must be made so as to preserve metadata.  If it does not, calls
            to the <see cref="T:ICU4N.Text.IReplaceable"/> API may be optimized to improve performance.
            </summary>
            <stable>ICU 2.2</stable>
        </member>
        <member name="T:ICU4N.Text.ReplaceableContextIterator">
            <summary>
            Implementation of <see cref="T:ICU4N.Impl.UCaseProps.IContextIterator"/>, iterates over a <see cref="T:ICU4N.Text.IReplaceable"/>.
            See casetrn.cpp/utrans_rep_caseContextIterator().
            </summary>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.SetText(ICU4N.Text.IReplaceable)">
            <summary>
            Set the text for iteration.
            </summary>
            <param name="rep"><see cref="T:ICU4N.Text.IReplaceable"/> to iterate over.</param>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.SetIndex(System.Int32)">
            <summary>
            Set the index where <see cref="M:ICU4N.Text.ReplaceableContextIterator.NextCaseMapCP"/> is to start iterating.
            </summary>
            <param name="index">Iteration start index for <see cref="M:ICU4N.Text.ReplaceableContextIterator.NextCaseMapCP"/>.</param>
        </member>
        <member name="P:ICU4N.Text.ReplaceableContextIterator.CaseMapCPStart">
            <summary>
            Get the index of where the code point currently being case-mapped starts.
            </summary>
            <returns>The start index of the current code point.</returns>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.SetLimit(System.Int32)">
            <summary>
            Set the iteration limit for <see cref="M:ICU4N.Text.ReplaceableContextIterator.NextCaseMapCP"/> to an index within the string.
            If the limit parameter is negative or past the string, then the
            string length is restored as the iteration limit.
            </summary>
            <param name="lim">The iteration limit.</param>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.SetContextLimits(System.Int32,System.Int32)">
            <summary>
            Set the start and limit indexes for context iteration with <see cref="M:ICU4N.Text.ReplaceableContextIterator.Next"/>.
            </summary>
            <param name="contextStart">Start of context for <see cref="M:ICU4N.Text.ReplaceableContextIterator.Next"/>.</param>
            <param name="contextLimit">Limit of context for <see cref="M:ICU4N.Text.ReplaceableContextIterator.Next"/>.</param>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.NextCaseMapCP">
            <summary>
            Iterate forward through the string to fetch the next code point
            to be case-mapped, and set the context indexes for it.
            </summary>
            <returns>The next code point to be case-mapped, or &lt;0 when the iteration is done.</returns>
        </member>
        <member name="M:ICU4N.Text.ReplaceableContextIterator.Replace(System.String)">
            <summary>
            Replace the current code point by its case mapping,
            and update the indexes.
            </summary>
            <param name="text">Replacement text.</param>
            <returns>The delta for the change of the text length.</returns>
        </member>
        <member name="P:ICU4N.Text.ReplaceableContextIterator.DidReachLimit">
            <summary>
            Did forward context iteration with <see cref="M:ICU4N.Text.ReplaceableContextIterator.Next"/> reach the iteration limit?
            </summary>
        </member>
        <member name="T:ICU4N.Text.ReplaceableString">
            <summary>
            <see cref="T:ICU4N.Text.ReplaceableString"/> is an adapter class that implements the
            <see cref="T:ICU4N.Text.IReplaceable"/> API around an ordinary <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <remarks>
            <em>Note:</em> This class does not support attributes and is not
            intended for general use.  Most clients will need to implement
            <see cref="T:ICU4N.Text.IReplaceable"/> in their text representation class.
            </remarks>
            <see cref="T:ICU4N.Text.IReplaceable"/>
            <author>Alan Liu</author>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.#ctor(System.String)">
            <summary>
            Construct a new object with the given initial contents.
            </summary>
            <param name="str">Initial contents.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.#ctor(System.Text.StringBuilder)">
            <summary>
            Construct a new object using <paramref name="buf"/> for internal
            storage.  The contents of <paramref name="buf"/> at the time of
            construction are used as the initial contents.  <em>Note!
            Modifications to <paramref name="buf"/> will modify this object, and
            vice versa.</em>
            </summary>
            <param name="buf">Object to be used as internal storage.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.#ctor">
            <summary>
            Construct a new empty object.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.ToString">
            <summary>
            Return the contents of this object as a <see cref="T:System.String"/>.
            </summary>
            <returns>String contents of this object.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.Substring(System.Int32,System.Int32)">
            <summary>
            Return a substring of the given string.
            </summary>
            <remarks>
            Using .NET semantics - that is, the second parameter
            is count rather than end.
            </remarks>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.ReplaceableString.Length">
            <summary>
            Return the number of characters contained in this object.
            <see cref="T:ICU4N.Text.IReplaceable"/> API.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.ReplaceableString.Item(System.Int32)">
            <summary>
            Gets the character at the given position in this object.
            <see cref="T:ICU4N.Text.IReplaceable"/> API.
            </summary>
            <param name="index">Offset into the contents, from 0 to <c><see cref="P:ICU4N.Text.ReplaceableString.Length"/> - 1</c></param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.Char32At(System.Int32)">
            <summary>
            Return the 32-bit code point at the given 16-bit offset into
            the text.  This assumes the text is stored as 16-bit code units
            with surrogate pairs intermixed.  If the offset of a leading or
            trailing code unit of a surrogate pair is given, return the
            code point of the surrogate pair.
            </summary>
            <param name="offset">An integer between 0 and <see cref="P:ICU4N.Text.ReplaceableString.Length"/>-1 inclusive.</param>
            <returns>32-bit code point of text at given offset.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies characters from this object into the destination
            character array.  The first character to be copied is at index
            The first character to be copied is at index
            <paramref name="sourceIndex"/>; the last character to be copied is at
            index <paramref name="count"/>-<paramref name="sourceIndex"/>.
            The characters are copied into the subarray of <paramref name="destination"/>
            starting at index <paramref name="destinationIndex"/> and ending at index
            <paramref name="destinationIndex"/>+<paramref name="count"/>.
            </summary>
            <remarks>
            NOTE: This is roughly equivalent to GetChars(int srcStart, int srcLimit, char dst[], int dstStart)
            in ICU4J with one important difference - the final parameter is the total
            count of characters to be copied (srcLimit - srcStart). This is to 
            make the function compatible with the <see cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)"/> implementation in .NET.
            </remarks>
            <param name="sourceIndex">The index of the first character in this instance to copy.</param>
            <param name="destination">An array of Unicode characters to which characters in this instance are copied.</param>
            <param name="destinationIndex">The index in <paramref name="destination"/> at which the copy operation begins.</param>
            <param name="count">The number of characters in this instance to copy to <paramref name="destination"/>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Replace zero or more characters with new characters.
            <see cref="T:ICU4N.Text.IReplaceable"/> API.
            </summary>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.ReplaceableString.Length"/></c>.</param>
            <param name="text">The text to replace characters <c><paramref name="start"/></c> to <c><paramref name="limit"/> - 1</c>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.Replace(System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Replace a substring of this object with the given text.
            </summary>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.ReplaceableString.Length"/></c>.</param>
            <param name="chars">The text to replace characters <paramref name="start"/> to <c><paramref name="limit"/> - 1</c></param>
            <param name="charsStart">The beginning index into <paramref name="chars"/>, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="charsLen">The number of characters of <paramref name="chars"/>.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.ReplaceableString.Copy(System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy a substring of this object, retaining attribute (out-of-band)
            information.  This method is used to duplicate or reorder substrings.
            The destination index must not overlap the source range.
            </summary>
            <param name="start">The beginning index, inclusive; <c>0 &lt;= <paramref name="start"/> &lt;= <paramref name="limit"/></c>.</param>
            <param name="limit">The ending index, exclusive; <c><paramref name="start"/> &lt;= <paramref name="limit"/> &lt;= <see cref="P:ICU4N.Text.ReplaceableString.Length"/></c>.</param>
            <param name="dest">The destination index.  The characters from
            <c><paramref name="start"/>..<paramref name="limit"/>-1</c> will be copied to <paramref name="dest"/>.
            Implementations of this method may assume that <c><paramref name="dest"/> &lt;= <paramref name="start"/> ||
            <paramref name="dest"/> &gt;= <paramref name="limit"/></c>.
            </param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.ReplaceableString.HasMetaData">
            <summary>
            Implements <see cref="T:ICU4N.Text.IReplaceable"/>
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="T:ICU4N.Text.RuleBasedBreakIterator">
            <summary>
            Rule Based Break Iterator
            <para/>
            This is a port of the C++ class RuleBasedBreakIterator from ICU4C.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.GetInstanceFromCompiledRules(System.IO.Stream)">
            <summary>
            Create a break iterator from a precompiled set of break rules.
            <para/>
            Creating a break iterator from the binary rules is much faster than
            creating one from source rules.
            <para/>
            The binary rules are generated by the <see cref="M:ICU4N.Text.RuleBasedBreakIterator.CompileRules(System.String,System.IO.Stream)"/> function.
            Binary break iterator rules are not guaranteed to be compatible between
            different versions of ICU.
            </summary>
            <param name="input">An input stream supplying the compiled binary rules.</param>
            <exception cref="T:System.IO.IOException">If there is an error while reading the rules from the <see cref="T:System.IO.Stream"/>.</exception>
            <seealso cref="M:ICU4N.Text.RuleBasedBreakIterator.CompileRules(System.String,System.IO.Stream)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.GetInstanceFromCompiledRules(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Create a break iterator from a precompiled set of break rules.
            <para/>
            Creating a break iterator from the binary rules is much faster than
            creating one from source rules.
            <para/>
            The binary rules are generated by the <see cref="M:ICU4N.Text.RuleBasedBreakIterator.CompileRules(System.String,System.IO.Stream)"/> function.
            Binary break iterator rules are not guaranteed to be compatible between
            different versions of ICU.
            </summary>
            <param name="bytes">A buffer supplying the compiled binary rules.</param>
            <exception cref="T:System.IO.IOException">If there is an error while reading the rules from the buffer.</exception>
            <seealso cref="M:ICU4N.Text.RuleBasedBreakIterator.CompileRules(System.String,System.IO.Stream)"/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.#ctor(System.String)">
            <summary>
            Construct a <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/> from a set of rules supplied as a string.
            </summary>
            <param name="rules">The break rules to be used.</param>
            <stable>ICU 2.2</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Clone">
            <summary>
            Clones this iterator.
            </summary>
            <returns>A newly-constructed <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/> with the same
            behavior as this one.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Equals(System.Object)">
            <summary>
            Returns true if both <see cref="T:ICU4N.Text.BreakIterator"/>s are of the same class, have the same
            rules, and iterate over the same text.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.ToString">
            <summary>
            Returns the description (rules) used to create this iterator.
            (In ICU4C, the same function is RuleBasedBreakIterator::getRules())
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.GetHashCode">
            <summary>
            Compute a hashcode for this <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <returns>A hash code.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fText">
            <summary>
            The character iterator through which this <see cref="T:ICU4N.Text.BreakIterator"/> accesses the text.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fRData">
            <summary>
            The rule data for this <see cref="T:ICU4N.Text.BreakIterator"/> instance. Package private.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fPosition">
            <summary>
            The iteration state - current position, rule status for the current position,
                                  and whether the iterator ran off the end, yielding <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
                                  Current position is pinned to be 0 &lt; position &lt;= text.Length.
                                  Current position is always set to a boundary.
            <para/>
            The current  position of the iterator. Pinned, 0 &lt; fPosition &lt;= text.Length.
            Never has the value <see cref="F:ICU4N.Text.BreakIterator.Done"/> (-1).
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fRuleStatusIndex">
            <summary>
            Index of the Rule {tag} values for the most recent match.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fDone">
            <summary>
            True when iteration has run off the end, and iterator functions should return UBRK_DONE.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fBreakCache">
            <summary>
            Cache of previously determined boundary positions.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fDictionaryCharCount">
            <summary>
            Counter for the number of characters encountered with the "dictionary"
            flag set.  Normal RBBI iterators don't use it, although the code
            for updating it is live.  Dictionary Based break iterators (a subclass
            of us) access this field directly.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.RBBI_DEBUG_ARG">
            <summary>
            ICU debug argument name for RBBI
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.TRACE">
            <summary>
            Debugging flag.  Trace operation of state machine when true.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fBreakType">
            <summary>
            What kind of break iterator this is.
            Defaulting <see cref="P:ICU4N.Text.RuleBasedBreakIterator.BreakType"/> to word gives reasonable dictionary behavior for
            Break Iterators that are built from rules.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.gUnhandledBreakEngine">
            <summary>
            The "default" break engine - just skips over ranges of dictionary words,
            producing no breaks. Should only be used if characters need to be handled
            by a dictionary but we have no dictionary implementation for them.
            <para/>
            Only one instance; shared by all break iterators.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.gAllBreakEngines">
            <summary>
            List of all known break engines, common for all break iterators.
            Lazily updated as break engines are needed, because instantiation of
            break engines is expensive.
            <para/>
            Because <see cref="F:ICU4N.Text.RuleBasedBreakIterator.gAllBreakEngines"/> can be referenced concurrently from different
            <see cref="T:ICU4N.Text.BreakIterator"/> instances, all access is synchronized.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fBreakEngines">
            <summary>
            List of all known break engines. Similar to <see cref="F:ICU4N.Text.RuleBasedBreakIterator.gAllBreakEngines"/>, but local to a
            break iterator, allowing it to be used without synchronization.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Dump(System.IO.TextWriter)">
            <summary>
            Dump the contents of the state table and character classes for this break iterator.
            For debugging only.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.CompileRules(System.String,System.IO.Stream)">
            <summary>
            Compile a set of source break rules into the binary state tables used
            by the break iterator engine.  Creating a break iterator from precompiled
            rules is much faster than creating one from source rules.
            <para/>
            Binary break rules are not guaranteed to be compatible between different
            versions of ICU.
            </summary>
            <param name="rules">The source form of the break rules.</param>
            <param name="ruleBinary">An output stream to receive the compiled rules.</param>
            <exception cref="T:System.IO.IOException">If there is an error writing the output.</exception>
            <seealso cref="M:ICU4N.Text.RuleBasedBreakIterator.GetInstanceFromCompiledRules(System.IO.Stream)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.First">
            <summary>
            Sets the current iteration position to the beginning of the text.
            (i.e., the <see cref="T:ICU4N.Support.Text.CharacterIterator"/>'s starting offset).
            </summary>
            <returns>The offset of the beginning of the text.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Last">
            <summary>
            Sets the current iteration position to the end of the text.
            (i.e., the <see cref="T:ICU4N.Support.Text.CharacterIterator"/>'s ending offset).
            </summary>
            <returns>The text's past-the-end offset.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Next(System.Int32)">
            <summary>
            Advances the iterator either forward or backward the specified number of steps.
            Negative values move backward, and positive values move forward.  This is
            equivalent to repeatedly calling <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Next"/> or <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Previous"/>.
            </summary>
            <param name="n">The number of steps to move.  The sign indicates the direction
            (negative is backwards, and positive is forwards).</param>
            <returns>The character offset of the boundary position n boundaries away from
            the current one.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Next">
            <summary>
            Advances the iterator to the next boundary position.
            </summary>
            <returns>The position of the first boundary after this one.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Previous">
            <summary>
            Moves the iterator backwards, to the boundary preceding the current one.
            </summary>
            <returns>The position of the boundary position immediately preceding the starting position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Following(System.Int32)">
            <summary>
            Sets the iterator to refer to the first boundary position following
            the specified position.
            </summary>
            <param name="startPos">The position from which to begin searching for a break position.</param>
            <returns>The position of the first break after the current position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.Preceding(System.Int32)">
            <summary>
            Sets the iterator to refer to the last boundary position before the
            specified position.
            </summary>
            <param name="offset">The position to begin searching for a break from.</param>
            <returns>The position of the last boundary before the starting position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.CheckOffset(System.Int32,ICU4N.Support.Text.CharacterIterator)">
            <exception cref="T:System.ArgumentException">Unless begin &lt;= offset &lt; end.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.IsBoundary(System.Int32)">
            <summary>
            Returns true if the specified position is a boundary position.  As a side
            effect, leaves the iterator pointing to the first boundary position at
            or after "<paramref name="offset"/>".
            </summary>
            <param name="offset">The offset to check.</param>
            <returns>True if "<paramref name="offset"/>" is a boundary position.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedBreakIterator.Current">
            <summary>
            Returns the current iteration position.  Note that <see cref="F:ICU4N.Text.BreakIterator.Done"/> is never
            returned from this function; if iteration has run to the end of a
            string, <see cref="P:ICU4N.Text.RuleBasedBreakIterator.Current"/> will return the length of the string while
            <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Next"/> will return <see cref="F:ICU4N.Text.BreakIterator.Done"/>.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedBreakIterator.RuleStatus">
            <summary>
            Gets the status tag from the break rule that determined the most recently
            returned break position.
            </summary>
            <remarks>
            The values appear in the rule source
            within brackets, {123}, for example.  For rules that do not specify a
            status, a default value of 0 is returned.  If more than one rule applies,
            the numerically largest of the possible status values is returned.
            <para/>
            Of the standard types of ICU break iterators, only the word and line break
            iterator provides status values.  The values are defined in
            class <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/>, and allow distinguishing between words
            that contain alphabetic letters, "words" that appear to be numbers,
            punctuation and spaces, words containing ideographic characters, and
            more.  Call <see cref="P:ICU4N.Text.RuleBasedBreakIterator.RuleStatus"/> after obtaining a boundary
            position from <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Next"/>, <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Previous"/>, or
            any other break iterator functions that returns a boundary position.
            </remarks>
            <stable>ICU 60</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.GetRuleStatusVec(System.Int32[])">
            <summary>
            Get the status (tag) values from the break rule(s) that determined the most
            recently returned break position.  
            </summary>
            <remarks>
            The values appear in the rule source
            within brackets, {123}, for example.  The default status value for rules
            that do not explicitly provide one is zero.
            <para/>
            The status values used by the standard ICU break rules are defined
            as public constants in class <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/>.
            <para/>
            If the size  of the output array is insufficient to hold the data,
            the output will be truncated to the available length.  No exception
            will be thrown.
            </remarks>
            <param name="fillInArray">An array to be filled in with the status values.</param>
            <returns>
            The number of rule status values from rules that determined
            the most recent boundary returned by the break iterator.
            In the event that the array is too small, the return value
            is the total number of status values that were available,
            not the reduced number that were actually returned.
            </returns>
            <stable>ICU 60</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedBreakIterator.Text">
            <summary>
            Gets a <see cref="T:ICU4N.Support.Text.CharacterIterator"/> over the text being analyzed.  This version
            of this property returns the actual <see cref="T:ICU4N.Support.Text.CharacterIterator"/> we're using internally.
            Changing the state of this iterator can have undefined consequences.  If
            you need to change it, clone it first.
            </summary>
            <returns>An iterator over the text being analyzed.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.SetText(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Set the iterator to analyze a new piece of text.  This function resets
            the current iteration position to the beginning of the text.
            </summary>
            <param name="newText">An iterator over the text to analyze.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedBreakIterator.BreakType">
            <summary>
            Internal.
            </summary>
        </member>
        <member name="F:ICU4N.Text.RuleBasedBreakIterator.fDebugEnv">
            <summary>
            Control debug, trace and dump options.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.HandleNext">
            <summary>
            The State Machine Engine for moving forward is here.
            This function is the heart of the RBBI run time engine.
            </summary>
            <remarks>
            <code>
            Input
               fPosition, the position in the text to begin from.
            Output
               fPosition:           the boundary following the starting position.
               fDictionaryCharCount the number of dictionary characters encountered.
                                    If > 0, the segment will be further subdivided
               fRuleStatusIndex     Info from the state table indicating which rules caused the boundary.
            </code>
            <para/>
            A note on supplementary characters and the position of underlying
            <see cref="T:ICU4N.Support.Text.CharacterIterator"/>:   Normally, a character iterator is positioned at
            the char most recently returned by <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Next"/>.  Within this function, when
            a supplementary char is being processed, the char iterator is left
            sitting on the trail surrogate, in the middle of the code point.
            This is different from everywhere else, where an iterator always
            points at the lead surrogate of a supplementary.
            </remarks>
            <returns>The new iterator position.</returns>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.HandlePrevious(System.Int32)">
            <summary>
            Iterate backwards from an arbitrary position in the input text using the Safe Reverse rules.
            This locates a "Safe Position" from which the forward break rules
            will operate correctly. A Safe Position is not necessarily a boundary itself.
            </summary>
            <remarks>
            The logic of this function is very similar to <see cref="M:ICU4N.Text.RuleBasedBreakIterator.HandleNext"/>.
            </remarks>
            <param name="fromPosition">The position in the input text to begin the iteration.</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.CISetIndex32(ICU4N.Support.Text.CharacterIterator,System.Int32)">
            <summary>
            Set the index of a <see cref="T:ICU4N.Support.Text.CharacterIterator"/>.
            Pin the index to the valid range range of <see cref="P:ICU4N.Support.Text.CharacterIterator.BeginIndex"/> &lt;= index &lt;= <see cref="P:ICU4N.Support.Text.CharacterIterator.EndIndex"/>.
            If the index points to a trail surrogate of a supplementary character, adjust it
            to the start (lead surrogate) index.
            </summary>
            <param name="ci">A <see cref="T:ICU4N.Support.Text.CharacterIterator"/> to set.</param>
            <param name="index">The index to set.</param>
            <returns>The resulting index, possibly pinned or adjusted.</returns>
        </member>
        <member name="T:ICU4N.Text.RuleBasedBreakIterator.DictionaryCache">
            <summary>
            <see cref="T:ICU4N.Text.RuleBasedBreakIterator.DictionaryCache"/> stores the boundaries obtained from a run of dictionary characters.
                            Dictionary boundaries are moved first to this cache, then from here
                            to the main <see cref="T:ICU4N.Text.RuleBasedBreakIterator.BreakCache"/>, where they may inter-leave with non-dictionary
                            boundaries. The public <see cref="T:ICU4N.Text.BreakIterator"/> API always fetches directly
                            from the main <see cref="T:ICU4N.Text.RuleBasedBreakIterator.BreakCache"/>, not from here.
            <para/>                 
                            In common situations, the number of boundaries in a single dictionary run
                            should be quite small, it will be terminated by punctuation, spaces,
                            or any other non-dictionary characters. The main BreakCache may end
                            up with boundaries from multiple dictionary based runs.
            <para/>                
                            The boundaries are stored in a simple <see cref="T:System.Collections.Generic.List`1"/> (vector), with the
                            assumption that they will be accessed sequentially.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.DictionaryCache.PopulateDictionary(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Populate the cache with the dictionary based boundaries within a region of text.
            </summary>
            <param name="startPos">The start position of a range of text.</param>
            <param name="endPos">The end position of a range of text.</param>
            <param name="firstRuleStatus">The rule status index that applies to the break at <paramref name="startPos"/>.</param>
            <param name="otherRuleStatus">The rule status index that applies to boundaries other than <paramref name="startPos"/>.</param>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.DictionaryCache.#ctor(ICU4N.Text.RuleBasedBreakIterator,ICU4N.Text.RuleBasedBreakIterator.DictionaryCache)">
            <summary>
            Copy constructor. Used by <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Clone"/>.
            </summary>
            <param name="outerInstance">The <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/> that owns this instance.</param>
            <param name="src">The source object to be copied.</param>
        </member>
        <member name="T:ICU4N.Text.RuleBasedBreakIterator.BreakCache">
            <summary>
            Class BreakCache.
            </summary>
            <remarks>
            Cache of break boundary positions and rule status values.
            Break iterator API functions, <see cref="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.Next"/>, <see cref="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.Previous"/>, etc., will use cached results
            when possible, and otherwise cache new results as they are obtained.
            <para/>
            Uniformly caches both dictionary and rule based (non-dictionary) boundaries.
            <para/>
            The cache is implemented as a single circular buffer.
            </remarks>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.Current">
            <summary>
            Update the state of the public <see cref="T:ICU4N.Text.BreakIterator"/> (fBI) to reflect the
            current state of the break iterator cache (this).
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.PopulateNear(System.Int32)">
            <summary>
            Add boundaries to the cache near the specified position.
            </summary>
            <remarks>
            The given <paramref name="position"/> need not be a boundary itself.
            The input <paramref name="position"/> must be within the range of the text, and
            on a code point boundary.
            If the requested <paramref name="position"/> is a break boundary, leave the iteration
            position on it.
            If the requested <paramref name="position"/> is not a boundary, leave the iteration
            position on the preceding boundary and include both the the
            preceding and following boundaries in the cache.
            Additional boundaries, either preceding or following, may be added
            to the cache as a side effect.
            </remarks>
            <returns>false if the operation failed.</returns>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.PopulateFollowing">
            <summary>
            Add boundary(s) to the cache following the current last boundary.
            Return false if at the end of the text, and no more boundaries can be added.
            Leave iteration position at the first newly added boundary, or unchanged if no boundary was added.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.PopulatePreceding">
            <summary>
            Add one or more boundaries to the cache preceding the first currently cached boundary.
            Leave the iteration position on the first added boundary.
            Return false if no boundaries could be added (if at the start of the text.)
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.AddFollowing(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Add the boundary following the current position.
            The current position can be left as it was, or changed to the newly added boundary,
            as specified by the update parameter.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.AddPreceding(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Add the boundary preceding the current position.
            The current position can be left as it was, or changed to the newly added boundary,
            as specified by the update parameter.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.Seek(System.Int32)">
            <summary>
            Set the cache position to the specified position, or, if the position
            falls between to cached boundaries, to the preceding boundary.
            Fails if the requested position is outside of the range of boundaries currently held by the cache.
            The <paramref name="pos"/> must be on a code point boundary.
            </summary>
            <returns>true if successful, false if the specified position is after
            the last cached boundary or before the first.</returns>
        </member>
        <member name="M:ICU4N.Text.RuleBasedBreakIterator.BreakCache.#ctor(ICU4N.Text.RuleBasedBreakIterator,ICU4N.Text.RuleBasedBreakIterator.BreakCache)">
            <summary>
            Copy constructor, used from <see cref="M:ICU4N.Text.RuleBasedBreakIterator.Clone"/>.
            </summary>
            <param name="outerInstance">The <see cref="T:ICU4N.Text.RuleBasedBreakIterator"/> that owns this instance.</param>
            <param name="src"></param>
        </member>
        <member name="T:ICU4N.Text.SelectFormat">
            <summary>
            <see cref="T:ICU4N.Text.SelectFormat"/> supports the creation of internationalized
            messages by selecting phrases based on keywords. The pattern specifies
            how to map keywords to phrases and provides a default phrase. The
            object provided to the format method is a string that's matched
            against the keywords. If there is a match, the corresponding phrase
            is selected; otherwise, the default phrase is used.
            </summary>
            <remarks>
            <h3>Using <see cref="T:ICU4N.Text.SelectFormat"/> for Gender Agreement</h3>
            <para/>
            Note: Typically, select formatting is done via <see cref="T:ICU4N.Text.MessageFormat"/>
            with a <c>select</c> argument type,
            rather than using a stand-alone <see cref="T:ICU4N.Text.SelectFormat"/>.
            <para/>
            The main use case for the select format is gender based inflection.
            When names or nouns are inserted into sentences, their gender can affect pronouns,
            verb forms, articles, and adjectives. Special care needs to be
            taken for the case where the gender cannot be determined.
            The impact varies between languages:
            <list type="bullet">
                <item>
                    <description>
                        English has three genders, and unknown gender is handled as a special
                        case. Names use the gender of the named person (if known), nouns referring
                        to people use natural gender, and inanimate objects are usually neutral.
                        The gender only affects pronouns: "he", "she", "it", "they".
                    </description>
                </item>
                <item>
                    <description>
                        German differs from English in that the gender of nouns is rather
                        arbitrary, even for nouns referring to people ("M&#xE4;dchen", girl, is  neutral).
                        The gender affects pronouns ("er", "sie", "es"), articles ("der", "die",
                        "das"), and adjective forms ("guter Mann", "gute Frau", "gutes  M&#xE4;dchen").
                    </description>
                </item>
                <item>
                    <description>
                        French has only two genders; as in German the gender of nouns
                        is rather arbitrary - for sun and moon, the genders
                        are the opposite of those in German. The gender affects
                        pronouns ("il", "elle"), articles ("le", "la"),
                        adjective forms ("bon", "bonne"), and sometimes
                        verb forms ("all&#xE9;", "all&#xE9;e").
                    </description>
                </item>
                <item>
                    <description>
                        Polish distinguishes five genders (or noun classes),
                        human masculine, animate non-human masculine, inanimate masculine,
                        feminine, and neuter.
                    </description>
                </item>
            </list>
            <para/>
            Some other languages have noun classes that are not related to gender,
            but similar in grammatical use.
            Some African languages have around 20 noun classes.
            <para/>
            <b>Note:</b>For the gender of a <i>person</i> in a given sentence,
            we usually need to distinguish only between female, male and other/unknown.
            <para/>
            To enable localizers to create sentence patterns that take their
            language's gender dependencies into consideration, software has to provide
            information about the gender associated with a noun or name to
            <see cref="T:ICU4N.Text.MessageFormat"/>.
            Two main cases can be distinguished:
            <list type="bullet">
                <item>
                    <description>
                        For people, natural gender information should be maintained for each person.
                        Keywords like "male", "female", "mixed" (for groups of people)
                        and "unknown" could be used.
                    </description>
                </item>
                <item>
                    <description>
                        For nouns, grammatical gender information should be maintained for
                        each noun and per language, e.g., in resource bundles.
                        The keywords "masculine", "feminine", and "neuter" are commonly used,
                        but some languages may require other keywords.
                    </description>
                </item>
            </list>
            <para/>
            The resulting keyword is provided to <see cref="T:ICU4N.Text.MessageFormat"/> as a
            parameter separate from the name or noun it's associated with. For example,
            to generate a message such as "Jean went to Paris", three separate arguments
            would be provided: The name of the person as argument 0, the gender of
            the person as argument 1, and the name of the city as argument 2.
            The sentence pattern for English, where the gender of the person has
            no impact on this simple sentence, would not refer to argument 1 at all:
            <code>{0} went to {2}.</code>
            <para/>
            <b>Note:</b> The entire sentence should be included (and partially repeated)
            inside each phrase. Otherwise translators would have to be trained on how to
            move bits of the sentence in and out of the select argument of a message
            (The examples below do not follow this recommendation!)
            <para/>
            The sentence pattern for French, where the gender of the person affects
            the form of the participle, uses a select format based on argument 1:
            <code>{0} est {1, select, female {all&#xE9;e} other {all&#xE9;}} &#xE0; {2}.</code>
            <para/>
            Patterns can be nested, so that it's possible to handle interactions of
            number and gender where necessary. For example, if the above sentence should
            allow for the names of several people to be inserted, the following sentence
            pattern can be used (with argument 0 the list of people's names,
            argument 1 the number of people, argument 2 their combined gender, and
            argument 3 the city name):
            <code>
            {0} {1, plural, 
            one {est {2, select, female {all&#xE9;e} other {all&#xE9;}}}
            other {sont {2, select, female {all&#xE9;es} other {all&#xE9;s}}}
            }&#xE0; {3}.
            </code>
            <h4>Patterns and Their Interpretation</h4>
            <para/>
            The <see cref="T:ICU4N.Text.SelectFormat"/> pattern string defines the phrase output
            for each user-defined keyword.
            The pattern is a sequence of (keyword, message) pairs.
            A keyword is a "pattern identifier": <c>[^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+</c>
            <para/>
            Each message is a <see cref="T:ICU4N.Text.MessageFormat"/> pattern string enclosed in {curly braces}.
            <para/>
            You always have to define a phrase for the default keyword
            <c>other</c>; this phrase is returned when the keyword
            provided to
            the <c>format</c> method matches no other keyword.
            If a pattern does not provide a phrase for <c>other</c>, the method
            it's provided to returns the error <c>U_DEFAULT_KEYWORD_MISSING</c>.
            <para/>
            Pattern_White_Space between keywords and messages is ignored.
            Pattern_White_Space within a message is preserved and output.
            <code>
            // Example:
            MessageFormat msgFmt = new MessageFormat("{0} est " +
                "{1, select, female {all&#xE9;e} other {all&#xE9;}} &#xE0; Paris.",
                new ULocale("fr"));
            object args[] = {"Kirti","female"};
            Console.WriteLine(msgFmt.Format(args));
            </code>
            <para/>
            Produces the output:
            <code>Kirti est all&#xE9;e &#xE0; Paris.</code>
            </remarks>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.SelectFormat.pattern">
            <summary>
            The applied pattern string.
            </summary>
        </member>
        <member name="F:ICU4N.Text.SelectFormat.msgPattern">
            <summary>
            The <see cref="T:ICU4N.Text.MessagePattern"/> which contains the parsed structure of the pattern string.
            </summary>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:ICU4N.Text.SelectFormat"/> for a given pattern string.
            </summary>
            <param name="pattern">The pattern for this <see cref="T:ICU4N.Text.SelectFormat"/>.</param>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.Reset">
            <summary>
            Resets the <see cref="T:ICU4N.Text.SelectFormat"/> object.
            </summary>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.ApplyPattern(System.String)">
            <summary>
            Sets the pattern used by this select format.
            Patterns and their interpretation are specified in the class description.
            </summary>
            <param name="pattern">The pattern for this select format.</param>
            <exception cref="T:System.ArgumentException">When the <paramref name="pattern"/> is not a valid select format pattern.</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.ToPattern">
            <summary>
            Returns the pattern for this <see cref="T:ICU4N.Text.SelectFormat"/>.
            </summary>
            <returns>The pattern string</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.FindSubMessage(ICU4N.Text.MessagePattern,System.Int32,System.String)">
            <summary>
            Finds the <see cref="T:ICU4N.Text.SelectFormat"/> sub-message for the given <paramref name="keyword"/>, or the "other" sub-message.
            </summary>
            <param name="pattern">A <see cref="T:ICU4N.Text.MessagePattern"/>.</param>
            <param name="partIndex">The index of the first <see cref="T:ICU4N.Text.SelectFormat"/> argument style part.</param>
            <param name="keyword">A keyword to be matched to one of the <see cref="T:ICU4N.Text.SelectFormat"/> argument's keywords.</param>
            <returns>The sub-message start part index.</returns>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.Format(System.String)">
            <summary>
            Selects the phrase for the given <paramref name="keyword"/>.
            </summary>
            <param name="keyword">A phrase selection keyword.</param>
            <returns>The string containing the formatted select message.</returns>
            <exception cref="T:System.ArgumentException">When the given keyword is not a "pattern identifier".</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.Format(System.Object,System.Text.StringBuilder,ICU4N.Support.Text.FieldPosition)">
            <summary>
            Selects the phrase for the given <paramref name="keyword"/>.
            and appends the formatted message to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="keyword">a phrase selection keyword.</param>
            <param name="toAppendTo">the selected phrase will be appended to this
            <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="pos">will be ignored by this method.</param>
            <returns>the string buffer passed in as <paramref name="toAppendTo"/>, with formatted text appended.</returns>
            <exception cref="T:System.ArgumentException">when the given keyword is not a <see cref="T:System.String"/> or not a "pattern identifier".</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.ParseObject(System.String,ICU4N.Support.Text.ParsePosition)">
            
            <summary>
            This method is not supported by <see cref="T:ICU4N.Text.SelectFormat"/>.
            </summary>
            <param name="source">the string to be parsed.</param>
            <param name="pos">defines the position where parsing is to begin,
            and upon return, the position where parsing left off.  If the position
            has not changed upon return, then parsing failed.</param>
            <returns>nothing because this method is not supported.</returns>
            <exception cref="T:System.NotSupportedException">thrown always.</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.Equals(System.Object)">
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.GetHashCode">
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.SelectFormat.ToString">
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.SimpleFormatter">
            <summary>
            Formats simple patterns like "{1} was born in {0}".
            </summary>
            <remarks>
            Minimal subset of <see cref="T:ICU4N.Text.MessageFormat"/>; fast, simple, minimal dependencies.
            Supports only numbered arguments with no type nor style parameters,
            and formats only string values.
            Quoting via ASCII apostrophe compatible with ICU <see cref="T:ICU4N.Text.MessageFormat"/> default behavior.
            <para/>
            Factory methods throw exceptions for syntax errors
            and for too few or too many arguments/placeholders.
            <para/>
            <see cref="T:ICU4N.Text.SimpleFormatter"/> objects are immutable and can be safely cached like strings.
            <para/>
            Example:
            <code>
            SimpleFormatter fmt = SimpleFormatter.Compile("{1} '{born}' in {0}");
            
            // Output: "paul {born} in england"
            Console.WriteLine(fmt.Format("england", "paul"));
            </code>
            </remarks>
            <seealso cref="T:ICU4N.Text.MessageFormat"/>
            <seealso cref="T:ICU4N.Text.ApostropheMode"/>
            <stable>ICU 57</stable>
        </member>
        <member name="F:ICU4N.Text.SimpleFormatter.compiledPattern">
            <summary>
            Binary representation of the compiled pattern.
            </summary>
            <seealso cref="T:ICU4N.Impl.SimpleFormatterImpl"/>
        </member>
        <member name="P:ICU4N.Text.SimpleFormatter.ArgumentLimit">
            <summary>
            The max argument number + 1.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndAppend(System.Text.StringBuilder,System.Int32[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <returns><paramref name="appendTo"/></returns>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndReplace(System.Text.StringBuilder,System.Int32[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <returns><paramref name="result"/></returns>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.ToString">
            <summary>
            Returns a string similar to the original pattern, only for debugging.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.GetTextWithNoArguments">
            <summary>
            Returns the pattern text with none of the arguments.
            Like formatting with all-empty string values.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Compile(System.String)">
            <summary>
            Creates a formatter from the pattern string.
            </summary>
            <param name="pattern">The pattern string.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Compile(System.Text.StringBuilder)">
            <summary>
            Creates a formatter from the pattern string.
            </summary>
            <param name="pattern">The pattern string.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Compile(System.Char[])">
            <summary>
            Creates a formatter from the pattern string.
            </summary>
            <param name="pattern">The pattern string.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Compile(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Creates a formatter from the pattern string.
            </summary>
            <param name="pattern">The pattern string.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.CompileMinMaxArguments(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a formatter from the pattern string.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.CompileMinMaxArguments(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Creates a formatter from the pattern string.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.CompileMinMaxArguments(System.Char[],System.Int32,System.Int32)">
            <summary>
            Creates a formatter from the pattern string.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.CompileMinMaxArguments(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Creates a formatter from the pattern string.
            The number of arguments checked against the given limits is the
            highest argument number plus one, not the number of occurrences of arguments.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="min">The pattern must have at least this many arguments.</param>
            <param name="max">The pattern must have at most this many arguments.</param>
            <returns>The new <see cref="T:ICU4N.Text.SimpleFormatter"/> object.</returns>
            <exception cref="T:System.ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Format(System.String[])">
            <summary>
            Formats the given values.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Format(System.Text.StringBuilder[])">
            <summary>
            Formats the given values.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Format(System.Char[][])">
            <summary>
            Formats the given values.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.Format(ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values.
            </summary>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndAppend(System.Text.StringBuilder,System.Int32[],System.String[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as appendTo.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            Can be null if <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>==0.
            </param>
            <returns><paramref name="appendTo"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndAppend(System.Text.StringBuilder,System.Int32[],System.Text.StringBuilder[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as appendTo.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            Can be null if <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>==0.
            </param>
            <returns><paramref name="appendTo"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndAppend(System.Text.StringBuilder,System.Int32[],System.Char[][])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as appendTo.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            Can be null if <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>==0.
            </param>
            <returns><paramref name="appendTo"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndAppend(System.Text.StringBuilder,System.Int32[],ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values, appending to the <paramref name="appendTo"/> builder.
            </summary>
            <param name="appendTo">Gets the formatted pattern and values appended.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value must not be the same object as appendTo.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            Can be null if <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>==0.
            </param>
            <returns><paramref name="appendTo"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndReplace(System.Text.StringBuilder,System.Int32[],System.String[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            </param>
            <returns><paramref name="result"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndReplace(System.Text.StringBuilder,System.Int32[],System.Text.StringBuilder[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            </param>
            <returns><paramref name="result"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndReplace(System.Text.StringBuilder,System.Int32[],System.Char[][])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            </param>
            <returns><paramref name="result"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="M:ICU4N.Text.SimpleFormatter.FormatAndReplace(System.Text.StringBuilder,System.Int32[],ICU4N.Support.Text.ICharSequence[])">
            <summary>
            Formats the given values, replacing the contents of the result builder.
            May optimize by actually appending to the result if it is the same object
            as the value corresponding to the initial argument in the pattern.
            </summary>
            <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
            <param name="offsets">
            offsets[i] receives the offset of where
            values[i] replaced pattern argument {i}.
            Can be null, or can be shorter or longer than values.
            If there is no {i} in the pattern, then offsets[i] is set to -1.
            </param>
            <param name="values">
            The argument values.
            An argument value may be the same object as result.
            values.Length must be at least <see cref="P:ICU4N.Text.SimpleFormatter.ArgumentLimit"/>.
            </param>
            <returns><paramref name="result"/></returns>
            <stable>ICU 57</stable>
        </member>
        <member name="T:ICU4N.Text.StringPrepOptions">
            <summary>
            Options for <see cref="T:ICU4N.Text.StringPrep"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Text.StringPrepOptions.Default">
            <summary>
            Option to prohibit processing of unassigned code points in the input.
            </summary>
            <see cref="M:ICU4N.Text.StringPrep.Prepare(System.String,ICU4N.Text.StringPrepOptions)"/>
            <see cref="M:ICU4N.Text.StringPrep.Prepare(ICU4N.Text.UCharacterIterator,ICU4N.Text.StringPrepOptions)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepOptions.AllowUnassigned">
            <summary>
            Option to allow processing of unassigned code points in the input.
            </summary>
            <see cref="M:ICU4N.Text.StringPrep.Prepare(System.String,ICU4N.Text.StringPrepOptions)"/>
            <see cref="M:ICU4N.Text.StringPrep.Prepare(ICU4N.Text.UCharacterIterator,ICU4N.Text.StringPrepOptions)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.StringPrepProfile">
            <summary>
            Profiles for <see cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3491NamePrep">
            <summary>
            Profile type: RFC3491 Nameprep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3530Nfs4CsPrep">
            <summary>
            Profile type: RFC3530 nfs4_cs_prep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3530Nfs4CsPrepCaseInsensitive">
            <summary>
            Profile type: RFC3530 nfs4_cs_prep with case insensitive option
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3530Nfs4CisPrep">
            <summary>
            Profile type: RFC3530 nfs4_cis_prep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3530Nfs4MixedPrepPrefix">
            <summary>
            Profile type: RFC3530 nfs4_mixed_prep for prefix
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3530Nfs4MixedPrepSuffix">
            <summary>
            Profile type: RFC3530 nfs4_mixed_prep for suffix
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3722iSCSI">
            <summary>
            Profile type: RFC3722 iSCSI
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3920NodePrep">
            <summary>
            Profile type: RFC3920 XMPP Nodeprep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc3920ResourcePrep">
            <summary>
            Profile type: RFC3920 XMPP Resourceprep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc4011MIB">
            <summary>
            Profile type: RFC4011 Policy MIB Stringprep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc4013SaslPrep">
            <summary>
            Profile type: RFC4013 SASLprep
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc4505Trace">
            <summary>
            Profile type: RFC4505 trace
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc4518Ldap">
            <summary>
            Profile type: RFC4518 LDAP
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepProfile.Rfc4518LdapCaseInsensitive">
            <summary>
            Profile type: RFC4518 LDAP for case ignore, numeric and stored prefix
            matching rules
            </summary>
            <seealso cref="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="T:ICU4N.Text.StringPrep">
            <summary>
            <see cref="T:ICU4N.Text.StringPrep"/> API implements the StingPrep framework as described by 
            <a href="http://www.ietf.org/rfc/rfc3454.txt">RFC 3454</a>.
            </summary>
            <remarks>
            <see cref="T:ICU4N.Text.StringPrep"/> prepares Unicode strings for use in network protocols.
            Profiles of <see cref="T:ICU4N.Text.StringPrep"/> are set of rules and data according to which the
            Unicode Strings are prepared. Each profiles contains tables which describe
            how a code point should be treated. The tables are broadly classied into
            <list type="table">
                <item><term>Unassigned Table</term><description>
                    Contains code points that are unassigned in the 
                    Unicode Version supported by <see cref="T:ICU4N.Text.StringPrep"/>. Currently 
                    RFC 3454 supports Unicode 3.2.
                </description></item>
                <item><term>Prohibited Table</term><description>
                    Contains code points that are prohibted from
                    the output of the <see cref="T:ICU4N.Text.StringPrep"/> processing function.
                </description></item>
                <item><term>Mapping Table</term><description>
                    Contains code ponts that are deleted from the output or case mapped.
                </description></item>
            </list>
            <para/>
            The procedure for preparing Unicode strings:
            <list type="table">
                <item>Map<term></term><description>
                    For each character in the input, check if it has a mapping
                    and, if so, replace it with its mapping.
                </description></item>
                <item>Normalize<term></term><description>
                    Possibly normalize the result of step 1 using Unicode
                    normalization.
                </description></item>
                <item>Prohibit<term></term><description>
                    Check for any characters that are not allowed in the
                    output.  If any are found, return an error.
                </description></item>
                <item>Check bidi<term></term><description>
                    Possibly check for right-to-left characters, and if
                    any are found, make sure that the whole string satisfies the
                    requirements for bidirectional strings.  If the string does not
                    satisfy the requirements for bidirectional strings, return an
                    error.
                </description></item>
            </list>
            </remarks>
            <author>Ram Viswanadha</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrep.#ctor(System.IO.Stream)">
            <summary>
            Creates an <see cref="T:ICU4N.Text.StringPrep"/> object after reading the input stream.
            The object does not hold a reference to the input steam, so the stream can be
            closed after the method returns.
            </summary>
            <param name="inputStream">The stream for reading the <see cref="T:ICU4N.Text.StringPrep"/> profile binarySun.</param>
            <exception cref="T:System.IO.IOException">An exception occurs when I/O of the inputstream is invalid.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrep.GetInstance(ICU4N.Text.StringPrepProfile)">
            <summary>
            Gets a <see cref="T:ICU4N.Text.StringPrep"/> instance for the specified profile.
            </summary>
            <param name="profile">The profile passed to find the <see cref="T:ICU4N.Text.StringPrep"/> instance.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrep.Prepare(ICU4N.Text.UCharacterIterator,ICU4N.Text.StringPrepOptions)">
            <summary>
            Prepare the input buffer for use in applications with the given profile. This operation maps, normalizes(NFKC),
            checks for prohibited and BiDi characters in the order defined by RFC 3454
            depending on the options specified in the profile.
            </summary>
            <param name="src">A <see cref="T:ICU4N.Text.UCharacterIterator"/> object containing the source string.</param>
            <param name="options">A bit set of options:
            <list type="bullet">
                <item><term><see cref="F:ICU4N.Text.StringPrepOptions.Default"/></term><description>Prohibit processing of unassigned code points in the input.</description></item>
                <item><term><see cref="F:ICU4N.Text.StringPrepOptions.AllowUnassigned"/></term><description>Treat the unassigned code points are in the input as normal Unicode code points.</description></item>
            </list>
            </param>
            <returns>A <see cref="T:System.Text.StringBuilder"/> containing the output.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">An exception occurs when parsing a string is invalid.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrep.Prepare(System.String,ICU4N.Text.StringPrepOptions)">
            <summary>
            Prepare the input String for use in applications with the given profile. This operation maps, normalizes(NFKC),
            checks for prohibited and BiDi characters in the order defined by RFC 3454
            depending on the options specified in the profile.
            </summary>
            <param name="src">A string.</param>
            <param name="options">A bit set of options:
            <list type="bullet">
                <item><term><see cref="F:ICU4N.Text.StringPrepOptions.Default"/></term><description>Prohibit processing of unassigned code points in the input.</description></item>
                <item><term><see cref="F:ICU4N.Text.StringPrepOptions.AllowUnassigned"/></term><description>Treat the unassigned code points are in the input as normal Unicode code points.</description></item>
            </list>
            </param>
            <returns>A string containing the output.</returns>
            <exception cref="T:ICU4N.Text.StringPrepParseException">An exception occurs when parsing a string is invalid.</exception>
            <stable>ICU 4.2</stable>
        </member>
        <member name="T:ICU4N.Text.StringPrepErrorType">
            <summary>
            Error types for <see cref="T:ICU4N.Text.StringPrepParseException"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.InvalidCharFound">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.IllegalCharFound">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.ProhibitedError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.UnassignedError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.CheckBiDiError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.STD3ASCIIRulesError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.AcePrefixError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.VerificationError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.LabelTooLongError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.BufferOverflowError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.ZeroLengthLabel">
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepErrorType.DomainNameTooLongError">
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.StringPrepParseException">
            <summary>
            Exception that signals an error has occurred while parsing the
            input to <see cref="T:ICU4N.Text.StringPrep"/> or <see cref="T:ICU4N.Text.IDNA"/>.
            </summary>
            <author>Ram Viswanadha</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.#ctor(System.String,ICU4N.Text.StringPrepErrorType)">
            <summary>
            Construct a ParseException object with the given message
            and error code
            </summary>
            <param name="message">A string describing the type of error that occurred.</param>
            <param name="error">The error that has occurred.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.#ctor(System.String,ICU4N.Text.StringPrepErrorType,System.String,System.Int32)">
            <summary>
            Construct a ParseException object with the given message and
            error code.
            </summary>
            <param name="message">A string describing the type of error that occurred.</param>
            <param name="error">The error that has occurred.</param>
            <param name="rules">The input rules string.</param>
            <param name="pos">The position of error in the rules string.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.#ctor(System.String,ICU4N.Text.StringPrepErrorType,System.String,System.Int32,System.Int32)">
            <summary>
            Construct  a ParseException object with the given message and error code.
            </summary>
            <param name="message">A string describing the type of error that occurred.</param>
            <param name="error">The error that has occurred.</param>
            <param name="rules">The input rules string.</param>
            <param name="pos">The position of error in the rules string.</param>
            <param name="lineNumber">
            The line number at which the error has occurred.
            If the parse engine is not using this field, it should set it to zero.  Otherwise
            it should be a positive integer. The default value of this field
            is -1. It will be set to 0 if the code populating this struct is not
            using line numbers.
            </param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.Equals(System.Object)">
            <summary>
            Compare this ParseException to another and evaluate if they are equal.
            The comparison works only on the type of error and does not compare
            the rules strings, if any, for equality.
            </summary>
            <param name="other">The exception that this object should be compared to.</param>
            <returns>true if the objects are equal, false if unequal.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.GetHashCode">
            <summary>
            Mock implementation of <see cref="M:ICU4N.Text.StringPrepParseException.GetHashCode"/>. This implementation always returns a constant
            value. When .NET assertion is enabled, this method triggers an assertion failure.
            </summary>
            <returns>This API is ICU internal only.</returns>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.StringPrepParseException.ToString">
            <summary>
            Returns the position of error in the rules string.
            </summary>
            <returns>String.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.StringPrepParseException.line">
            <summary>
            The line on which the error occurred.  If the parse engine
            is not using this field, it should set it to zero.  Otherwise
            it should be a positive integer. The default value of this field
            is -1. It will be set to 0 if the code populating this struct is not
            using line numbers.
            </summary>
        </member>
        <member name="F:ICU4N.Text.StringPrepParseException.preContext">
            <summary>
            Textual context before the error.  Null-terminated.
            May be the empty string if not implemented by parser.
            </summary>
        </member>
        <member name="F:ICU4N.Text.StringPrepParseException.postContext">
            <summary>
            Textual context after the error.  Null-terminated.
            May be the empty string if not implemented by parser.
            </summary>
        </member>
        <member name="P:ICU4N.Text.StringPrepParseException.Error">
            <summary>
            Returns the error code of this exception.
            This method is only used for testing to verify the error.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="P:ICU4N.Text.StringPrepParseException.Line">
            <summary>
            Gets the line on which the error occurred.
            </summary>
        </member>
        <member name="T:ICU4N.Text.IStringTransform">
            <summary>
            Provide a base class for Transforms that focuses just on the transformation of the text. APIs that take Transliterator, but only 
            depend on the text transformation should use this interface in the API instead.
            </summary>
            <stable>ICU 3.8</stable>
            <author>markdavis</author>
        </member>
        <member name="T:ICU4N.Text.ISymbolTable">
            <summary>
            An interface that defines both lookup protocol and parsing of
            symbolic names.
            </summary>
            <remarks>
            This interface is used by <see cref="T:ICU4N.Text.UnicodeSet"/> to resolve $Variable style
            references that appear in set patterns.  RBBI and Transliteration
            both independently implement this interface.
            <para/>
            A symbol table maintains two kinds of mappings.  The first is
            between symbolic names and their values.  For example, if the
            variable with the name "start" is set to the value "alpha"
            (perhaps, though not necessarily, through an expression such as
            "$start=alpha"), then the call lookup("start") will return the
            char[] array ['a', 'l', 'p', 'h', 'a'].
            <para/>
            The second kind of mapping is between character values and
            <see cref="T:ICU4N.Text.IUnicodeMatcher"/> objects.  This is used by RuleBasedTransliterator,
            which uses characters in the private use area to represent objects
            such as <see cref="T:ICU4N.Text.UnicodeSet"/>s.  If U+E015 is mapped to the <see cref="T:ICU4N.Text.UnicodeSet"/> [a-z],
            then lookupMatcher(0xE015) will return the <see cref="T:ICU4N.Text.UnicodeSet"/> [a-z].
            <para/>
            Finally, a symbol table defines parsing behavior for symbolic
            names.  All symbolic names start with the <see cref="F:ICU4N.Text.SymbolTable.SYMBOL_REF"/> character.
            When a parser encounters this character, it calls <see cref="M:ICU4N.Text.ISymbolTable.ParseReference(System.String,ICU4N.Support.Text.ParsePosition,System.Int32)"/>
            with the position immediately following the <see cref="F:ICU4N.Text.SymbolTable.SYMBOL_REF"/>.  The symbol
            table parses the name, if there is one, and returns it.
            </remarks>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.ISymbolTable.Lookup(System.String)">
            <summary>
            Lookup the characters associated with this string and return it.
            Return <c>null</c> if no such name exists.  The resultant
            array may have length zero.
            </summary>
            <param name="s">The symbolic name to lookup.</param>
            <returns>A char array containing the name's value, or null if
            there is no mapping for s.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.ISymbolTable.LookupMatcher(System.Int32)">
            <summary>
            Lookup the <see cref="T:ICU4N.Text.IUnicodeMatcher"/> associated with the given character, and
            return it.  Return <c>null</c> if not found.
            </summary>
            <param name="ch">A 32-bit code point from 0 to 0x10FFFF inclusive.</param>
            <returns>The <see cref="T:ICU4N.Text.IUnicodeMatcher"/> object represented by the given
            character, or null if there is no mapping for ch.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.ISymbolTable.ParseReference(System.String,ICU4N.Support.Text.ParsePosition,System.Int32)">
            <summary>
            Parse a symbol reference name from the given string, starting
            at the given position.  If no valid symbol reference name is
            found, return null and leave <paramref name="pos"/> unchanged.  That is, if the
            character at <paramref name="pos"/> cannot start a name, or if <paramref name="pos"/> is at or after
            text.Length, then return null.  This indicates an isolated
            <see cref="F:ICU4N.Text.SymbolTable.SYMBOL_REF"/> character.
            </summary>
            <param name="text">The text to parse for the name.</param>
            <param name="pos">Position on entry, the index of the first character to parse.
            This is the character following the <see cref="F:ICU4N.Text.SymbolTable.SYMBOL_REF"/> character.  On
            exit, the index after the last parsed character.  If the parse
            failed, pos is unchanged on exit.
            </param>
            <param name="limit">The index after the last character to be parsed.</param>
            <returns>The parsed name, or null if there is no valid symbolic name at the given position.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.SymbolTable">
            <summary>
            <see cref="T:ICU4N.Text.ISymbolTable"/> constants.
            </summary>
        </member>
        <member name="F:ICU4N.Text.SymbolTable.SYMBOL_REF">
            <summary>
            The character preceding a symbol reference name.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.ITransform`2">
            <summary>
            Provide an interface for Transforms that focuses just on the transformation of the text.
            APIs that take Transliterator or <see cref="T:ICU4N.Text.IStringTransform"/>, but only depend on the transformation should use this interface in the API instead.
            </summary>
            <typeparam name="TSource">Source <see cref="T:System.Type"/> of transformation.</typeparam>
            <typeparam name="TDestination">Destination <see cref="T:System.Type"/> of transformation.</typeparam>
            <author>markdavis</author>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Text.ITransform`2.Transform(`0)">
            <summary>
            Transform the input in some way, to be determined by the subclass.
            </summary>
            <param name="source">Source to be transformed (eg lowercased).</param>
            <returns>Result.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.UCharacterIterator">
            <summary>
            Abstract class that defines an API for iteration on text objects.This is an interface for forward and backward
            iteration and random access into a text object. Forward iteration is done with post-increment and backward iteration
            is done with pre-decrement semantics, while the <see cref="T:ICU4N.Support.Text.CharacterIterator"/> interface methods provided
            forward iteration with "pre-increment" and backward iteration with pre-decrement semantics. This API is more
            efficient for forward iteration over code points. The other major difference is that this API can do both code unit
            and code point iteration, <see cref="T:ICU4N.Support.Text.CharacterIterator"/> can only iterate over code units and is limited to
            BMP (0 - 0xFFFF)
            </summary>
            <author>Ram</author>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.UCharacterIterator.Done">
            <summary>
            Indicator that we have reached the ends of the UTF16 text.
            </summary>
            <draft>ICU4N 60</draft>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.#ctor">
            <summary>
            Protected default constructor for the subclasses.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(ICU4N.Text.IReplaceable)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a <see cref="T:ICU4N.Text.IReplaceable"/> object.
            </summary>
            <param name="source">A valid source as a <see cref="T:ICU4N.Text.IReplaceable"/> object.</param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(System.String)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a source string.
            </summary>
            <param name="source">A string.</param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(System.Char[])">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a source character array.
            </summary>
            <param name="source">An array of UTF-16 code units.</param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a source character array.
            </summary>
            <param name="source">An array of UTF-16 code units.</param>
            <param name="start"></param>
            <param name="limit"></param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(System.Text.StringBuilder)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a source <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="source">A string buffer of UTF-16 code units.</param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetInstance(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Returns a <see cref="T:ICU4N.Text.UCharacterIterator"/> object given a <see cref="T:ICU4N.Support.Text.CharacterIterator"/>.
            </summary>
            <param name="source">A valid <see cref="T:ICU4N.Support.Text.CharacterIterator"/> object.</param>
            <returns><see cref="T:ICU4N.Text.UCharacterIterator"/> object.</returns>
            <exception cref="T:System.ArgumentException">If the argument is null.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetCharacterIterator">
            <summary>
            Returns a <see cref="T:ICU4N.Support.Text.CharacterIterator"/> object for the underlying text of this iterator. The returned
            iterator is independent of this iterator.
            </summary>
            <returns><see cref="T:ICU4N.Support.Text.CharacterIterator"/> object.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UCharacterIterator.Current">
            <summary>
            Returns the code unit at the current index. If index is out of range, returns <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/>. Index is not changed.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UCharacterIterator.CurrentCodePoint">
            <summary>
            Returns the codepoint at the current index. If the current index is invalid, <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is returned. If the current
            index points to a lead surrogate, and there is a following trail surrogate, then the code point is returned.
            Otherwise, the code unit at index is returned. Index is not changed.
            </summary>
            <returns>Current codepoint.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UCharacterIterator.Length">
            <summary>
            Returns the length of the text.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UCharacterIterator.Index">
            <summary>
            Gets or Sets the current index in text.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">Is thrown if an invalid index is supplied.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.Next">
            <summary>
            Returns the UTF16 code unit at index, and increments to the next code unit (post-increment semantics). If index
            is out of range, <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is returned, and the iterator is reset to the limit of the text.
            </summary>
            <returns>The next UTF16 code unit, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the index is at the limit of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.NextCodePoint">
            <summary>
            Returns the code point at index, and increments to the next code point (post-increment semantics). If index does
            not point to a valid surrogate pair, the behavior is the same as <see cref="M:ICU4N.Text.UCharacterIterator.Next"/>. Otherwise the iterator is
            incremented past the surrogate pair, and the code point represented by the pair is returned.
            </summary>
            <returns>The next codepoint in text, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the index is at the limit of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.Previous">
            <summary>
            Decrement to the position of the previous code unit in the text, and return it (pre-decrement semantics). If the
            resulting index is less than 0, the index is reset to 0 and <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is returned.
            </summary>
            <returns>The previous code unit in the text, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the new index is before the start of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.PreviousCodePoint">
            <summary>
            Retreat to the start of the previous code point in the text, and return it (pre-decrement semantics). If the
            index is not preceeded by a valid surrogate pair, the behavior is the same as <see cref="M:ICU4N.Text.UCharacterIterator.Previous"/>. Otherwise
            the iterator is decremented to the start of the surrogate pair, and the code point represented by the pair is
            returned.
            </summary>
            <returns>The previous code point in the text, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the new index is before the start of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.SetToLimit">
            <summary>
            Sets the current index to the limit.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.SetToStart">
            <summary>
            Sets the current index to the start.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetText(System.Char[],System.Int32)">
            <summary>
            Fills the buffer with the underlying text storage of the iterator. If the buffer capacity is not enough a
            exception is thrown. The capacity of the fill in buffer should at least be equal to length of text in the
            iterator obtained by getting <see cref="P:ICU4N.Text.UCharacterIterator.Length"/>.
            </summary>
            <remarks>
            <b>Usage:</b>
            <code>
            UChacterIterator iter = new UCharacterIterator.GetInstance(text);
            char[] buf = new char[iter.Length];
            iter.GetText(buf);
            </code>
            OR
            <code>
            char[] buf= new char[1];
            int len = 0;
            while (true)
            {
                try
                {
                    len = iter.GetText(buf);
                    break;
                }
                catch (IndexOutOfRangeException)
                {
                    buf = new char[iter.Length];
                }
            }
            </code>
            </remarks>
            <param name="fillIn">An array of chars to fill with the underlying UTF-16 code units.</param>
            <param name="offset">The position within the array to start putting the data.</param>
            <returns>The number of code units added to fillIn, as a convenience.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Exception if there is not enough room after offset in the array, or if offset &lt; 0.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetText(System.Char[])">
            <summary>
            Convenience override for <see cref="M:ICU4N.Text.UCharacterIterator.GetText(System.Char[],System.Int32)"/> that provides an offset of 0.
            </summary>
            <param name="fillIn">An array of chars to fill with the underlying UTF-16 code units.</param>
            <returns>The number of code units added to fillIn, as a convenience.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If there is not enough room in the array.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.GetText">
            <summary>
            Convenience method for returning the underlying text storage as as string.
            </summary>
            <returns>The underlying text storage in the iterator as a string.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.MoveIndex(System.Int32)">
            <summary>
            Moves the current position by the number of code units specified, either forward or backward depending on the
            sign of delta (positive or negative respectively). If the resulting index would be less than zero, the index is
            set to zero, and if the resulting index would be greater than limit, the index is set to limit.
            </summary>
            <param name="delta">The number of code units to move the current index.</param>
            <returns>The new index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if an invalid index is supplied.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.MoveCodePointIndex(System.Int32)">
            <summary>
            Moves the current position by the number of code points specified, either forward or backward depending on the
            sign of delta (positive or negative respectively). If the current index is at a trail surrogate then the first
            adjustment is by code unit, and the remaining adjustments are by code points. If the resulting index would be
            less than zero, the index is set to zero, and if the resulting index would be greater than limit, the index is
            set to limit.
            </summary>
            <param name="delta">The number of code units to move the current index.</param>
            <returns>The new index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if an invalid index is supplied.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UCharacterIterator.Clone">
            <summary>
            Creates a copy of this iterator, independent from other iterators. If it is not possible to clone the iterator,
            returns null.
            </summary>
            <returns>Copy of this iterator.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="T:ICU4N.Text.UFormat">
            <summary>
            An abstract class that extends <see cref="T:ICU4N.Support.Text.Formatter"/> to provide
            additional ICU protocol, specifically, the <see cref="M:ICU4N.Text.UFormat.GetLocale(ICU4N.Util.ULocale.Type)"/>
            API.  All ICU format classes are subclasses of this class.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <author>weiv</author>
            <author>Alan Liu</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.UFormat.#ctor">
            <summary>
            Default constructor.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.UFormat.GetLocale(ICU4N.Util.ULocale.Type)">
            <summary>
            Return the locale that was used to create this object, or null.
            </summary>
            <remarks>
            This may may differ from the locale requested at the time of
            this object's creation.  For example, if an object is created
            for locale <tt>en_US_CALIFORNIA</tt>, the actual data may be
            drawn from <tt>en</tt> (the <i>actual</i> locale), and
            <tt>en_US</tt> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This method will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation.  The <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            </remarks>
            <param name="type">
            type of information requested, either <see cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            or <see cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>.
            </param>
            <returns>
            the information specified by <i>type</i>, or null if
            this object was not constructed from locale data.
            </returns>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.UFormat.SetLocale(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            <summary>
            Set information about the locales that were used to create this
            object.  If the object was not constructed from locale data,
            both arguments should be set to null.  Otherwise, neither
            should be null.  The actual locale must be at the same level or
            less specific than the valid locale.  This method is intended
            for use by factories or other entities that create objects of
            this class.
            </summary>
            <param name="valid">the most specific locale containing any resource
            data, or null</param>
            <param name="actual">the locale containing data used to construct this
            object, or null</param>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
        </member>
        <member name="F:ICU4N.Text.UFormat.validLocale">
            <summary>
            The most specific locale containing any resource data, or null.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
        </member>
        <member name="F:ICU4N.Text.UFormat.actualLocale">
            <summary>
            The locale containing data used to construct this object, or
            null.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
        </member>
        <member name="T:ICU4N.Text.IUForwardCharacterIterator">
            <summary>
            Interface that defines an API for forward-only iteration
            on text objects.
            </summary>
            <remarks>
            This is a minimal interface for iteration without random access
            or backwards iteration. It is especially useful for wrapping
            streams with converters into an object for collation or
            normalization.
            <para/>
            Characters can be accessed in two ways: as code units or as
            code points.
            Unicode code points are 21-bit integers and are the scalar values
            of Unicode characters. ICU uses the type <see cref="T:System.Int32"/> for them.
            Unicode code units are the storage units of a given
            Unicode/UCS Transformation Format (a character encoding scheme).
            With UTF-16, all code points can be represented with either one
            or two code units ("surrogates").
            String storage is typically based on code units, while properties
            of characters are typically determined using code point values.
            Some processes may be designed to work with sequences of code units,
            or it may be known that all characters that are important to an
            algorithm can be represented with single code units.
            Other processes will need to use the code point access functions.
            <para/>
            <see cref="T:ICU4N.Text.IUForwardCharacterIterator"/> provides <see cref="M:ICU4N.Text.IUForwardCharacterIterator.Next"/> to access
            a code unit and advance an internal position into the text object,
            similar to a <c>return text[position++]</c>.
            It provides <see cref="M:ICU4N.Text.IUForwardCharacterIterator.NextCodePoint"/> to access a code point and advance an internal
            position.
            <para/>
            <see cref="M:ICU4N.Text.IUForwardCharacterIterator.NextCodePoint"/> assumes that the current position is that of
            the beginning of a code point, i.e., of its first code unit.
            After <see cref="M:ICU4N.Text.IUForwardCharacterIterator.NextCodePoint"/>, this will be true again.
            In general, access to code units and code points in the same
            iteration loop should not be mixed. In UTF-16, if the current position
            is on a second code unit (Low Surrogate), then only that code unit
            is returned even by <see cref="M:ICU4N.Text.IUForwardCharacterIterator.NextCodePoint"/>.
            <para/>
            Usage:
            <code>
            public void Function1(IUForwardCharacterIterator it)
            {
                int c;
                while ((c = it.Next()) != UForwardCharacterIterator.Done)
                {
                    // use c
                }
            }
            </code>
            </remarks>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.IUForwardCharacterIterator.Next">
            <summary>
            Returns the UTF16 code unit at index, and increments to the next
            code unit (post-increment semantics).  If index is out of
            range, <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> is returned, and the iterator is reset to the limit
            of the text.
            </summary>
            <returns>The next UTF16 code unit, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the index is at the limit of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.IUForwardCharacterIterator.NextCodePoint">
            <summary>
            Returns the code point at index, and increments to the next code
            point (post-increment semantics).  If index does not point to a
            valid surrogate pair, the behavior is the same as
            <see cref="M:ICU4N.Text.IUForwardCharacterIterator.Next"/>.  Otherwise the iterator is incremented past
            the surrogate pair, and the code point represented by the pair
            is returned.
            </summary>
            <returns>The next codepoint in text, or <see cref="F:ICU4N.Text.UForwardCharacterIterator.Done"/> if the index is at
            the limit of the text.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="T:ICU4N.Text.UForwardCharacterIterator">
            <summary>
            <see cref="T:ICU4N.Text.IUForwardCharacterIterator"/> constants.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UForwardCharacterIterator.Done">
            <summary>
            Indicator that we have reached the ends of the UTF16 text.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UnhandledBreakEngine.HandleChar(System.Int32,System.Int32)">
            <summary>
            Update the set of unhandled characters for the specified breakType to include
            all that have the same script as <paramref name="c"/>.
            May be called concurrently with <see cref="M:ICU4N.Text.UnhandledBreakEngine.Handles(System.Int32,System.Int32)"/> or <see cref="M:ICU4N.Text.UnhandledBreakEngine.FindBreaks(ICU4N.Support.Text.CharacterIterator,System.Int32,System.Int32,System.Int32,ICU4N.Text.DictionaryBreakEngine.DequeI)"/>.
            Must not be called concurrently with itself.
            </summary>
        </member>
        <member name="T:ICU4N.Text.UnicodeFilter">
            <summary>
            <see cref="T:ICU4N.Text.UnicodeFilter"/> defines a protocol for selecting a
            subset of the full range (U+0000 to U+FFFF) of Unicode characters.
            Currently, filters are used in conjunction with classes like
            Transliterator to only process selected characters through a
            transformation.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeFilter.Contains(System.Int32)">
            <summary>
            Returns <c>true</c> for characters that are in the selected
            subset.  In other words, if a character is <b>to be
            filtered</b>, then <see cref="M:ICU4N.Text.UnicodeFilter.Contains(System.Int32)"/> returns
            <b><c>false</c></b>.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeFilter.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Default implementation of <see cref="M:ICU4N.Text.IUnicodeMatcher.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)"/> for Unicode
            filters.  Matches a single 16-bit code unit at offset.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeFilter.#ctor">
            <summary>
            (This should not be here; it is declared to make CheckTags
            happy.  .NET inserts a synthetic constructor and CheckTags
            can't tell that it's synthetic.)
            </summary>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.IUnicodeMatcher">
            <summary>
            <see cref="T:ICU4N.Text.IUnicodeMatcher"/> defines a protocol for objects that can
            match a range of characters in a <see cref="T:ICU4N.Text.IReplaceable"/> string.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IUnicodeMatcher.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Return a <see cref="T:ICU4N.Text.MatchDegree"/> value indicating the degree of match for
            the given text at the given offset.  Zero, one, or more
            characters may be matched.
            </summary>
            <remarks>
            Matching in the forward direction is indicated by <paramref name="limit"/> &gt;
            <paramref name="offset"/>.  Characters from <paramref name="offset"/> forwards to <paramref name="limit"/>-1 will be
            considered for matching.
            <para/>
            Matching in the reverse direction is indicated by <paramref name="limit"/> &lt;
            <paramref name="offset"/>.  Characters from <paramref name="offset"/> backwards to <paramref name="limit"/>+1 will be
            considered for matching.
            <para/>
            If <paramref name="limit"/> == <paramref name="offset"/> then the only match possible is a zero
            character match (which subclasses may implement if desired).
            <para/>
            If <see cref="F:ICU4N.Text.MatchDegree.Match"/> is returned, then as a side effect, advance the
            <paramref name="offset"/> parameter to the limit of the matched substring.  In the
            forward direction, this will be the index of the last matched
            character plus one.  In the reverse direction, this will be the
            index of the last matched character minus one.
            </remarks>
            <param name="text">The text to be matched.</param>
            <param name="offset">Offset on input, the index into text at which to begin
            matching.  On output, the limit of the matched text.  The
            number of matched characters is the output value of <paramref name="offset"/>
            minus the input value.  Offset should always point to the
            HIGH SURROGATE (leading code unit) of a pair of surrogates,
            both on entry and upon return.
            </param>
            <param name="limit">The limit index of text to be matched.  Greater
            than <paramref name="offset"/> for a forward direction match, less than <paramref name="offset"/> for
            a backward direction match.  The last character to be
            considered for matching will be <c>text[limit-1]</c> in the
            forward direction or <c>text[limit+1]</c> in the backward
            direction.
            </param>
            <param name="incremental">If TRUE, then assume further characters may
            be inserted at <paramref name="limit"/> and check for partial matching.  Otherwise
            assume the text as given is complete.
            </param>
            <returns>a match degree value indicating a full match, a partial
            match, or a mismatch.  If incremental is FALSE then
            <see cref="F:ICU4N.Text.MatchDegree.PartialMatch"/> should never be returned.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IUnicodeMatcher.ToPattern(System.Boolean)">
            <summary>
            Returns a string representation of this matcher.  If the result of
            calling this function is passed to the appropriate parser, it
            will produce another matcher that is equal to this one.
            </summary>
            <param name="escapeUnprintable">if TRUE then convert unprintable
            character to their hex escape representations, \\uxxxx or
            \\Uxxxxxxxx.  Unprintable characters are those other than
            U+000A, U+0020..U+007E.
            </param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IUnicodeMatcher.MatchesIndexValue(System.Int32)">
            <summary>
            Returns TRUE if this matcher will match a character c, where c
            &amp; 0xFF == v, at offset, in the forward direction (with limit &gt;
            offset).  This is used by <c>RuleBasedTransliterator</c> for
            indexing.
            </summary>
            <remarks>
            Note:  This API uses an <see cref="T:System.Int32"/> even though the value will be
            restricted to 8 bits in order to avoid complications with
            signedness (bytes convert to ints in the range -128..127).
            </remarks>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.IUnicodeMatcher.AddMatchSetTo(ICU4N.Text.UnicodeSet)">
            <summary>
            Union the set of all characters that may be matched by this object
            into the given set.
            </summary>
            <param name="toUnionTo">The set into which to union the source characters.</param>
            <stable>ICU 2.2</stable>
        </member>
        <member name="T:ICU4N.Text.UnicodeMatcher">
            <summary>
            Constants for <see cref="T:ICU4N.Text.IUnicodeMatcher"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UnicodeMatcher.ETHER">
            <summary>
            The character at index i, where i &lt; contextStart || i &gt;= contextLimit,
            is <see cref="F:ICU4N.Text.UnicodeMatcher.ETHER"/>.  This allows explicit matching by rules and <see cref="T:ICU4N.Text.UnicodeSet"/>s
            of text outside the context.  In traditional terms, this allows anchoring
            at the start and/or end.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="T:ICU4N.Text.MatchDegree">
            <summary>
            Constants returned by <see cref="M:ICU4N.Text.IUnicodeMatcher.Matches(ICU4N.Text.IReplaceable,System.Int32[],System.Int32,System.Boolean)"/>
            indicating the degree of match.
            </summary>
            <remarks>
            Ported from icu4c/source/common/unicode/unimatch.h
            </remarks>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.MatchDegree.Mismatch">
            <summary>
            Indicates a mismatch between the text and the <see cref="T:ICU4N.Text.IUnicodeMatcher"/>.  
            The text contains a character which does not match, or the text does not contain
            all desired characters for a non-incremental match.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.MatchDegree.PartialMatch">
            <summary>
            Indicates a partial match between the text and the <see cref="T:ICU4N.Text.IUnicodeMatcher"/>.  This value is
            only returned for incremental match operations.  All characters
            of the text match, but more characters are required for a
            complete match.  Alternatively, for variable-length matchers,
            all characters of the text match, and if more characters were
            supplied at limit, they might also match.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.MatchDegree.Match">
            <summary>
            Indicates a complete match between the text and the <see cref="T:ICU4N.Text.IUnicodeMatcher"/>.  For an
            incremental variable-length match, this value is returned if
            the given text matches, and it is known that additional
            characters would not alter the extent of the match.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="T:ICU4N.Text.IUnicodeReplacer">
            <summary>
            <see cref="T:ICU4N.Text.IUnicodeReplacer"/> defines a protocol for objects that
            replace a range of characters in a <see cref="T:ICU4N.Text.IReplaceable"/> string with output
            text.  The replacement is done via the <see cref="T:ICU4N.Text.IReplaceable"/> API so as to
            preserve out-of-band data.
            </summary>
            <author>Alan Liu</author>
        </member>
        <member name="M:ICU4N.Text.IUnicodeReplacer.Replace(ICU4N.Text.IReplaceable,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Replace characters in '<paramref name="text"/>' from '<paramref name="start"/>' to '<paramref name="limit"/>' with the
            output text of this object.  Update the '<paramref name="cursor"/>' parameter to
            give the cursor position and return the length of the
            replacement text.
            </summary>
            <param name="text">The text to be matched.</param>
            <param name="start">Inclusive start index of <paramref name="text"/> to be replaced.</param>
            <param name="limit">Exclusive end index of <paramref name="text"/> to be replaced;
            must be greater than or equal to start.</param>
            <param name="cursor">Output parameter for the cursor position.
            Not all replacer objects will update this, but in a complete
            tree of replacer objects, representing the entire output side
            of a transliteration rule, at least one must update it.
            </param>
            <returns>The number of 16-bit code units in the text replacing
            the characters at offsets start..(limit-1) in text.</returns>
        </member>
        <member name="M:ICU4N.Text.IUnicodeReplacer.ToReplacerPattern(System.Boolean)">
            <summary>
            Returns a string representation of this replacer.  If the
            result of calling this function is passed to the appropriate
            parser, typically TransliteratorParser, it will produce another
            replacer that is equal to this one.
            </summary>
            <param name="escapeUnprintable">If TRUE then convert unprintable
            character to their hex escape representations, \\uxxxx or
            \\Uxxxxxxxx.  Unprintable characters are defined by
            <see cref="M:ICU4N.Impl.Utility.IsUnprintable(System.Int32)"/></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.IUnicodeReplacer.AddReplacementSetTo(ICU4N.Text.UnicodeSet)">
            <summary>
            Union the set of all characters that may output by this object
            into the given set.
            </summary>
            <param name="toUnionTo">The set into which to union the output characters.</param>
        </member>
        <member name="T:ICU4N.Text.PatternOptions">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, 
            and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Text.PatternOptions.IgnoreSpace">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PatternOptions.Case">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            <para/>
            Enable case insensitive matching.  E.g., "[ab]" with this flag
            will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
            match all except 'a', 'A', 'b', and 'B'. This performs a full
            closure over case mappings, e.g. U+017F for s.
            <para/>
            The resulting set is a superset of the input for the code points but
            not for the strings.
            It performs a case mapping closure of the code points and adds
            full case folding strings for the code points, and reduces strings of
            the original set to their full case folding equivalents.
            </summary>
            <remarks>
            This is designed for case-insensitive matches, for example
            in regular expressions. The full code point case closure allows checking of
            an input character directly against the closure set.
            Strings are matched by comparing the case-folded form from the closure
            set with an incremental case folding of the string in question.
            <para/>
            The closure set will also contain single code points if the original
            set contained case-equivalent strings (like U+00DF for "ss" or "Ss" etc.).
            This is not necessary (that is, redundant) for the above matching method
            but results in the same closure sets regardless of whether the original
            set contained the code point or a string.
            </remarks>
            <stable>ICU 3.8</stable>
        </member>
        <member name="F:ICU4N.Text.PatternOptions.CaseInsensitive">
            <summary>
            Alias for <see cref="F:ICU4N.Text.UnicodeSet.Case"/>, for ease of porting from C++ where ICU4C
            also has both USET_CASE and USET_CASE_INSENSITIVE (see uset.h).
            </summary>
            <seealso cref="F:ICU4N.Text.PatternOptions.Case"/>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Text.PatternOptions.AddCaseMappings">
            <summary>
            Bitmask for <see cref="M:ICU4N.Text.UnicodeSet.#ctor(System.String,ICU4N.Text.PatternOptions)"/> constructor, 
            <see cref="M:ICU4N.Text.UnicodeSet.ApplyPattern(System.String,ICU4N.Text.PatternOptions)"/>, and <see cref="M:ICU4N.Text.UnicodeSet.CloseOver(ICU4N.Text.PatternOptions)"/>.
            indicating letter case.  This may be ORed together with other
            selectors.
            <para/>
            Enable case insensitive matching.  E.g., "[ab]" with this flag
            will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
            match all except 'a', 'A', 'b', and 'B'. This adds the lower-,
            title-, and uppercase mappings as well as the case folding
            of each existing element in the set.
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="T:ICU4N.Text.ComparisonStyle">
            <summary>
            Comparison style enums used by <see cref="M:ICU4N.Text.UnicodeSet.CompareTo(ICU4N.Text.UnicodeSet,ICU4N.Text.ComparisonStyle)"/>.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.ComparisonStyle.ShorterFirst">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.ComparisonStyle.Lexicographic">
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.ComparisonStyle.LongerFirst">
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.SpanCondition">
            <summary>
            Argument values for whether <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> and similar functions continue while the current character is contained vs.
            not contained in the set.
            </summary>
            <remarks>
            The functionality is straightforward for sets with only single code points, without strings (which is the common
            case):
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Text.SpanCondition.Contained"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/> work the same.</description></item>
                <item><description><see cref="F:ICU4N.Text.SpanCondition.Contained"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/> are inverses of <see cref="F:ICU4N.Text.SpanCondition.NotContained"/>.</description></item>
                <item><description><see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> and <see cref="M:ICU4N.Text.UnicodeSet.SpanBack(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> partition any string the
                    same way when alternating between Span(<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>) and Span(either "contained" condition).</description></item>
                <item><description>Using a complemented (inverted) set and the opposite span conditions yields the same results.</description></item>
            </list>
            When a set contains multi-code point strings, then these statements may not be true, depending on the strings in
            the set (for example, whether they overlap with each other) and the string that is processed. For a set with
            strings:
            <list type="bullet">
                <item><description>
                    The complement of the set contains the opposite set of code points, but the same set of strings.
                    Therefore, complementing both the set and the span conditions may yield different results.
                </description></item>
                <item><description>
                    When starting spans at different positions in a string (span(s, ...) vs. span(s+1, ...)) the 
                    ends of the spans may be different because a set string may start before the later position.
                </description></item>
                <item><description>
                    Span(<see cref="F:ICU4N.Text.SpanCondition.Simple"/>) may be shorter than Span(<see cref="F:ICU4N.Text.SpanCondition.Contained"/>) because it will 
                    not recursively try all possible paths. For example, with a set which
                    contains the three strings "xy", "xya" and "ax", Span("xyax", <see cref="F:ICU4N.Text.SpanCondition.Contained"/>) will return 4 but span("xyax",
                    <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) will return 3. Span(<see cref="F:ICU4N.Text.SpanCondition.Simple"/>) will never be longer than Span(<see cref="F:ICU4N.Text.SpanCondition.Contained"/>).
                </description></item>
                <item><description>
                    With either "contained" condition, Span() and SpanBack() may partition a string in different ways. For example,
                    with a set which contains the two strings "ab" and "ba", and when processing the string "aba", Span() will yield
                    contained/not-contained boundaries of { 0, 2, 3 } while SpanBack() will yield boundaries of { 0, 1, 3 }.
                </description></item>
            </list>
            Note: If it is important to get the same boundaries whether iterating forward or backward through a string, then
            either only Span() should be used and the boundaries cached for backward operation, or an ICU <see cref="T:ICU4N.Text.BreakIterator"/> could
            be used.
            <para/>
            Note: Unpaired surrogates are treated like surrogate code points. Similarly, set strings match only on code point
            boundaries, never in the middle of a surrogate pair.
            </remarks>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.SpanCondition.NotContained">
            <summary>
            Continues a <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> while there is no set element at the current position.
            Increments by one code point at a time.
            Stops before the first set element (character or string).
            (For code points only, this is like while Contains(current)==false).
            </summary>
            <remarks>
            When <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> returns, the substring between where it started and the position it returned consists only of
            characters that are not in the set, and none of its strings overlap with the span.
            </remarks>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.SpanCondition.Contained">
            <summary>
            Spans the longest substring that is a concatenation of set elements (characters or strings).
            (For characters only, this is like while Contains(current)==true).
            </summary>
            <remarks>
            When <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> returns, the substring between where it started and the position it returned consists only of set
            elements (characters or strings) that are in the set.
            <para/>
            If a set contains strings, then the span will be the longest substring for which there
            exists at least one non-overlapping concatenation of set elements (characters or strings).
            This is equivalent to a POSIX regular expression for <c>(OR of each set element)*</c>.
            (.NET/ICU/Perl regex stops at the first match of an OR.)
            </remarks>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.SpanCondition.Simple">
            <summary>
            Continues a <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> while there is a set element at the current position.
            Increments by the longest matching element at each position.
            (For characters only, this is like while Contains(current)==true).
            </summary>
            <remarks>
            When <see cref="M:ICU4N.Text.UnicodeSet.Span(System.String,System.Int32,ICU4N.Text.SpanCondition)"/> returns, the substring between where it started and the position it returned consists only of set
            elements (characters or strings) that are in the set.
            <para/>
            If a set only contains single characters, then this is the same as <see cref="F:ICU4N.Text.SpanCondition.Contained"/>.
            <para/>
            If a set contains strings, then the span will be the longest substring with a match at each position with the
            longest single set element (character or string).
            <para/>
            Use this span condition together with other longest-match algorithms, such as ICU converters
            (ucnv_getUnicodeSet()).
            </remarks>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.SpanCondition.ConditionCount">
            <summary>
            One more than the last span condition.
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.UnicodeSetIterator">
            <summary>
            <see cref="T:ICU4N.Text.UnicodeSetIterator"/> iterates over the contents of a <see cref="T:ICU4N.Text.UnicodeSet"/>.  It
            iterates over either code points or code point ranges.  After all
            code points or ranges have been returned, it returns the
            multicharacter strings of the <see cref="T:ICU4N.Text.UnicodeSet"/>, if any.
            </summary>
            <remarks>
            To iterate over code points and multicharacter strings,
            use a loop like this:
            <code>
            for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.Next();)
            {
                ProcessString(it.GetString());
            }
            </code>
            <para/>
            To iterate over code point ranges, use a loop like this:
            <code>
            for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.NextRange();)
            {
                if (it.Codepoint != UnicodeSetIterator.IS_STRING)
                {
                    ProcessCodepointRange(it.Codepoint, it.CodepointEnd);
                }
                else
                {
                    ProcessString(it.GetString());
                }
            }
            </code>
            <para/>
            <b>Warning: </b>For speed, <see cref="T:ICU4N.Text.UnicodeSet"/> iteration does not check for concurrent modification. 
            Do not alter the <see cref="T:ICU4N.Text.UnicodeSet"/> while iterating.
            </remarks>
            <author>M. Davis</author>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.UnicodeSetIterator.IsString">
            <summary>
            Value of <see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> if the iterator points to a string.
            If <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, then examine
            <c>string</c> for the current iteration result.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSetIterator.Codepoint">
            <summary>
            Current code point, or the special value <tt>IS_STRING</tt>, if
            the iterator points to a string.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSetIterator.CodepointEnd">
            <summary>
            When iterating over ranges using <see cref="M:ICU4N.Text.UnicodeSetIterator.NextRange"/>,
            <see cref="P:ICU4N.Text.UnicodeSetIterator.CodepointEnd"/> contains the inclusive end of the
            iteration range, if <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> != <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>. If
            iterating over code points using <see cref="M:ICU4N.Text.UnicodeSetIterator.Next"/>, or if
            <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, then the value of
            <see cref="P:ICU4N.Text.UnicodeSetIterator.CodepointEnd"/> is undefined.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSetIterator.String">
            <summary>
            If <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, then <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> points
            to the current string. If <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> != <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, the
            value of <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> is undefined.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.#ctor(ICU4N.Text.UnicodeSet)">
            <summary>
            Create an iterator over the given set.
            </summary>
            <param name="set">Set to iterate over.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.#ctor">
            <summary>
            Create an iterator over nothing.  <see cref="M:ICU4N.Text.UnicodeSetIterator.Next"/> and
            <see cref="M:ICU4N.Text.UnicodeSetIterator.NextRange"/> return false. This is a convenience
            constructor allowing the target to be set later.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.Next">
            <summary>
            Returns the next element in the set, either a single code point
            or a string.  If there are no more elements in the set, return
            false.  If <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, the value is a
            string in the <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> field.  Otherwise the value is a
            single code point in the <see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> field.
            </summary>
            <remarks>
            The order of iteration is all code points in sorted order,
            followed by all strings sorted order.  <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> is
            undefined unless <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>.  Do not mix
            calls to <see cref="M:ICU4N.Text.UnicodeSetIterator.Next"/> and <see cref="M:ICU4N.Text.UnicodeSetIterator.NextRange"/> without
            calling <see cref="M:ICU4N.Text.UnicodeSetIterator.Reset"/> between them.  The results of doing so
            are undefined.
            <para/>
            <b>Warning: </b>For speed, <see cref="T:ICU4N.Text.UnicodeSet"/> iteration does not check for concurrent modification. 
            Do not alter the <see cref="T:ICU4N.Text.UnicodeSet"/> while iterating.
            </remarks>
            <returns>true if there was another element in the set and this
            object contains the element.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.NextRange">
            <summary>
            Returns the next element in the set, either a code point range
            or a string.  If there are no more elements in the set, return
            false.  If <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>, the value is a
            string in the <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> property.  Otherwise the value is a
            range of one or more code points from <see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> to
            <see cref="P:ICU4N.Text.UnicodeSetIterator.CodepointEnd"/> inclusive.
            </summary>
            <remarks>
            The order of iteration is all code points in sorted order,
            followed by all strings sorted order.  <see cref="P:ICU4N.Text.UnicodeSetIterator.String"/> is
            undefined unless <c><see cref="P:ICU4N.Text.UnicodeSetIterator.Codepoint"/> == <see cref="F:ICU4N.Text.UnicodeSetIterator.IsString"/></c>.  Do not mix
            calls to <see cref="M:ICU4N.Text.UnicodeSetIterator.Next"/> and <see cref="M:ICU4N.Text.UnicodeSetIterator.NextRange"/> without
            calling <see cref="M:ICU4N.Text.UnicodeSetIterator.Reset"/> between them.  The results of doing so
            are undefined.
            </remarks>
            <returns>true if there was another element in the set and this
            object contains the element.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.Reset(ICU4N.Text.UnicodeSet)">
            <summary>
            Sets this iterator to visit the elements of the given set and
            resets it to the start of that set.  The iterator is valid only
            so long as <paramref name="uset"/> is valid.
            </summary>
            <param name="uset">The set to iterate over.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.Reset">
            <summary>
            Resets this iterator to the start of the set.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.GetString">
            <summary>
            Gets the current string from the iterator. Only use after calling <see cref="M:ICU4N.Text.UnicodeSetIterator.Next"/>,
            not <see cref="M:ICU4N.Text.UnicodeSetIterator.NextRange"/>.
            </summary>
            <stable>ICU 4.0</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSetIterator.Set">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.UnicodeSetIterator.endElement">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.UnicodeSetIterator.nextElement">
            <internal/>
        </member>
        <member name="F:ICU4N.Text.UnicodeSetIterator.stringIterator">
            <summary>
            Invariant: stringIterator is null when there are no (more) strings remaining
            </summary>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetIterator.LoadRange(System.Int32)">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.UnicodeSetSpanner">
            <summary>
            A helper class used to count, replace, and trim <see cref="T:ICU4N.Support.Text.ICharSequence"/>s based on <see cref="T:ICU4N.Text.UnicodeSet"/> matches.
            </summary>
            <remarks>
            An instance is immutable (and thus thread-safe) iff the source UnicodeSet is frozen.
            <para/>
            <b>Note:</b> The counting, deletion, and replacement depend on alternating a <see cref="T:ICU4N.Text.SpanCondition"/> with
            its inverse. That is, the code spans, then spans for the inverse, then spans, and so on.
            For the inverse, the following mapping is used:
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.SpanCondition.Simple"/></term><description><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.Contained"/></term><description><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></term><description><see cref="F:ICU4N.Text.SpanCondition.Simple"/></description></item>
            </list>
            These are actually not complete inverses. However, the alternating works because there are no gaps.
            For example, with [a{ab}{bc}], you get the following behavior when scanning forward:
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.SpanCondition.Simple"/></term><description>xxx[ab]cyyy</description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.Contained"/></term><description>xxx[abc]yyy</description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></term><description>[xxx]ab[cyyy]</description></item>
            </list>
            <para/>
            So here is what happens when you alternate:
            <list type="table">
                <item><term><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></term><description>|xxxabcyyy</description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.Contained"/></term><description>xxx|abcyyy</description></item>
                <item><term><see cref="F:ICU4N.Text.SpanCondition.NotContained"/></term><description>xxxabcyyy|</description></item>
            </list>
            <para/>
            The entire string is traversed.
            </remarks>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.#ctor(ICU4N.Text.UnicodeSet)">
            <summary>
            Create a spanner from a <see cref="T:ICU4N.Text.UnicodeSet"/>. For speed and safety, the <see cref="T:ICU4N.Text.UnicodeSet"/> should be frozen. However, this class
            can be used with a non-frozen version to avoid the cost of freezing.
            </summary>
            <param name="source">The original <see cref="T:ICU4N.Text.UnicodeSet"/>.</param>
            <stable>ICU 54</stable>
        </member>
        <member name="P:ICU4N.Text.UnicodeSetSpanner.UnicodeSet">
            <summary>
            Gets the <see cref="T:ICU4N.Text.UnicodeSet"/> used for processing. It is frozen iff the original was.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.GetHashCode">
            <summary>
            Gets a hash code that represents the current object.
            </summary>
            <returns>A hash code for the current object.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.String)">
            <summary>
            Returns the number of matching characters found in a character sequence, 
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Text.StringBuilder)">
            <summary>
            Returns the number of matching characters found in a character sequence, 
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Char[])">
            <summary>
            Returns the number of matching characters found in a character sequence, 
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns the number of matching characters found in a character sequence, 
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.String,ICU4N.Text.CountMethod)">
            <summary>
            Returns the number of matching characters found in a character sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Text.StringBuilder,ICU4N.Text.CountMethod)">
            <summary>
            Returns the number of matching characters found in a character sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Char[],ICU4N.Text.CountMethod)">
            <summary>
            Returns the number of matching characters found in a character sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)">
            <summary>
            Returns the number of matching characters found in a character sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">The sequence to count characters in.</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.String,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Returns the number of matching characters found in a character sequence.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            The sequence to count characters in.
            </summary>
            <param name="sequence"></param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">the spanCondition to use. <see cref="F:ICU4N.Text.SpanCondition.Simple"/> or <see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            means only count the elements in the span; <see cref="F:ICU4N.Text.SpanCondition.NotContained"/> is the reverse.
            <para/>
            <b>WARNING: </b> when a <see cref="T:ICU4N.Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
            </param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Text.StringBuilder,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Returns the number of matching characters found in a character sequence.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            The sequence to count characters in.
            </summary>
            <param name="sequence"></param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">the spanCondition to use. <see cref="F:ICU4N.Text.SpanCondition.Simple"/> or <see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            means only count the elements in the span; <see cref="F:ICU4N.Text.SpanCondition.NotContained"/> is the reverse.
            <para/>
            <b>WARNING: </b> when a <see cref="T:ICU4N.Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
            </param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(System.Char[],ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Returns the number of matching characters found in a character sequence.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            The sequence to count characters in.
            </summary>
            <param name="sequence"></param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">the spanCondition to use. <see cref="F:ICU4N.Text.SpanCondition.Simple"/> or <see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            means only count the elements in the span; <see cref="F:ICU4N.Text.SpanCondition.NotContained"/> is the reverse.
            <para/>
            <b>WARNING: </b> when a <see cref="T:ICU4N.Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
            </param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.CountIn(ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Returns the number of matching characters found in a character sequence.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            The sequence to count characters in.
            </summary>
            <param name="sequence"></param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">the spanCondition to use. <see cref="F:ICU4N.Text.SpanCondition.Simple"/> or <see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            means only count the elements in the span; <see cref="F:ICU4N.Text.SpanCondition.NotContained"/> is the reverse.
            <para/>
            <b>WARNING: </b> when a <see cref="T:ICU4N.Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
            </param>
            <returns>The count. Zero if there are none.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.String)">
            <summary>
            Delete all the matching spans in sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.Text.StringBuilder)">
            <summary>
            Delete all the matching spans in sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.Char[])">
            <summary>
            Delete all the matching spans in sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Delete all the matching spans in sequence, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.String,ICU4N.Text.SpanCondition)">
            <summary>
            Delete all matching spans in sequence, according to the spanCondition.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="spanCondition">Specify whether to modify the matching spans 
            (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) 
            or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>).</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.Text.StringBuilder,ICU4N.Text.SpanCondition)">
            <summary>
            Delete all matching spans in sequence, according to the spanCondition.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="spanCondition">Specify whether to modify the matching spans 
            (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) 
            or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>).</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(System.Char[],ICU4N.Text.SpanCondition)">
            <summary>
            Delete all matching spans in sequence, according to the spanCondition.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="spanCondition">Specify whether to modify the matching spans 
            (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) 
            or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>).</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.DeleteFrom(ICU4N.Support.Text.ICharSequence,ICU4N.Text.SpanCondition)">
            <summary>
            Delete all matching spans in sequence, according to the spanCondition.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="spanCondition">Specify whether to modify the matching spans 
            (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) 
            or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>).</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.String)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Text.StringBuilder)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Char[])">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.String)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Char[])">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.String)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Text.StringBuilder)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Char[])">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],ICU4N.Support.Text.ICharSequence)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.String)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Char[])">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Replace all matching spans in sequence by the replacement,
            counting by <see cref="F:ICU4N.Text.CountMethod.MinElements"/> using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.String,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Text.StringBuilder,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Char[],ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.String,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Char[],ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.String,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Text.StringBuilder,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Char[],ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.String,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Char[],ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <see cref="T:ICU4N.Text.CountMethod"/>, using <see cref="F:ICU4N.Text.SpanCondition.Simple"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.String,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Text.StringBuilder,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,System.Char[],ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.String,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.String,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Text.StringBuilder,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,System.Char[],ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Text.StringBuilder,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.String,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Text.StringBuilder,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],System.Char[],ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(System.Char[],ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.String,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Text.StringBuilder,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,System.Char[],ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod,ICU4N.Text.SpanCondition)">
            <summary>
            Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
            The code alternates spans; see the class doc for <see cref="T:ICU4N.Text.UnicodeSetSpanner"/> for a note about boundary conditions.
            </summary>
            <param name="sequence">Character sequence to replace matching spans in.</param>
            <param name="replacement">Replacement sequence. To delete, use "".</param>
            <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
            <param name="spanCondition">specify whether to modify the matching spans (<see cref="F:ICU4N.Text.SpanCondition.Contained"/> 
            or <see cref="F:ICU4N.Text.SpanCondition.Simple"/>) or the non-matching (<see cref="F:ICU4N.Text.SpanCondition.NotContained"/>)</param>
            <returns>Modified string.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.String)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start and
            end of the string, using <see cref="F:ICU4N.Text.TrimOption.Both"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab")
            </code>
            ... returns <c>"cat"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Text.StringBuilder)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start and
            end of the string, using <see cref="F:ICU4N.Text.TrimOption.Both"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab")
            </code>
            ... returns <c>"cat"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Char[])">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start and
            end of the string, using <see cref="F:ICU4N.Text.TrimOption.Both"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab")
            </code>
            ... returns <c>"cat"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start and
            end of the string, using <see cref="F:ICU4N.Text.TrimOption.Both"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab")
            </code>
            ... returns <c>"cat"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.String,ICU4N.Text.TrimOption)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, using the <paramref name="trimOption"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Text.StringBuilder,ICU4N.Text.TrimOption)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, using the <paramref name="trimOption"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Char[],ICU4N.Text.TrimOption)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, using the <paramref name="trimOption"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(ICU4N.Support.Text.ICharSequence,ICU4N.Text.TrimOption)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, using the <paramref name="trimOption"/> and <see cref="F:ICU4N.Text.SpanCondition.Simple"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.String,ICU4N.Text.TrimOption,ICU4N.Text.SpanCondition)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <param name="spanCondition"><see cref="F:ICU4N.Text.SpanCondition.Simple"/>, <see cref="F:ICU4N.Text.SpanCondition.Contained"/> or 
            <see cref="F:ICU4N.Text.SpanCondition.NotContained"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Text.StringBuilder,ICU4N.Text.TrimOption,ICU4N.Text.SpanCondition)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <param name="spanCondition"><see cref="F:ICU4N.Text.SpanCondition.Simple"/>, <see cref="F:ICU4N.Text.SpanCondition.Contained"/> or 
            <see cref="F:ICU4N.Text.SpanCondition.NotContained"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(System.Char[],ICU4N.Text.TrimOption,ICU4N.Text.SpanCondition)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <param name="spanCondition"><see cref="F:ICU4N.Text.SpanCondition.Simple"/>, <see cref="F:ICU4N.Text.SpanCondition.Contained"/> or 
            <see cref="F:ICU4N.Text.SpanCondition.NotContained"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UnicodeSetSpanner.Trim(ICU4N.Support.Text.ICharSequence,ICU4N.Text.TrimOption,ICU4N.Text.SpanCondition)">
            <summary>
            Returns a trimmed sequence (using <see cref="M:ICU4N.Support.Text.ICharSequence.SubSequence(System.Int32,System.Int32)"/>), that omits matching elements at the start or
            end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
            <code>
                new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
            </code>
            ... returns <c>"catbab"</c>.
            </summary>
            <param name="sequence">The sequence to trim.</param>
            <param name="trimOption"><see cref="F:ICU4N.Text.TrimOption.Leading"/>, <see cref="F:ICU4N.Text.TrimOption.Trailing"/>, 
            or <see cref="F:ICU4N.Text.TrimOption.Both"/>.</param>
            <param name="spanCondition"><see cref="F:ICU4N.Text.SpanCondition.Simple"/>, <see cref="F:ICU4N.Text.SpanCondition.Contained"/> or 
            <see cref="F:ICU4N.Text.SpanCondition.NotContained"/>.</param>
            <returns>A subsequence.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="T:ICU4N.Text.CountMethod">
            <summary>
            Options for <see cref="M:ICU4N.Text.UnicodeSetSpanner.ReplaceFrom(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)"/> 
            and <see cref="M:ICU4N.Text.UnicodeSetSpanner.CountIn(ICU4N.Support.Text.ICharSequence,ICU4N.Text.CountMethod)"/> to control how to treat each matched span. 
            It is similar to whether one is replacing [abc] by x, or [abc]* by x.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.CountMethod.WholeSpan">
            <summary>
            Collapse spans. That is, modify/count the entire matching span as a single item, instead of separate
            set elements.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.CountMethod.MinElements">
            <summary>
            Use the smallest number of elements in the spanned range for counting and modification,
            based on the <see cref="T:ICU4N.Text.SpanCondition"/>.
            If the set has no strings, this will be the same as the number of spanned code points.
            <para/>
            For example, in the string "abab" with <see cref="F:ICU4N.Text.SpanCondition.Simple"/>:
            <list type="bullet">
                <item><description>spanning with [ab] will count four <see cref="F:ICU4N.Text.CountMethod.MinElements"/>.</description></item>
                <item><description>spanning with [{ab}] will count two <see cref="F:ICU4N.Text.CountMethod.MinElements"/>.</description></item>
                <item><description>spanning with [ab{ab}] will also count two <see cref="F:ICU4N.Text.CountMethod.MinElements"/>.</description></item>
            </list>
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="T:ICU4N.Text.TrimOption">
            <summary>
            Options for the <see cref="M:ICU4N.Text.UnicodeSetSpanner.Trim(ICU4N.Support.Text.ICharSequence,ICU4N.Text.TrimOption,ICU4N.Text.SpanCondition)"/> method.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.TrimOption.Leading">
            <summary>
            Trim leading spans.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.TrimOption.Both">
            <summary>
            Trim leading and trailing spans.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Text.TrimOption.Trailing">
            <summary>
            Trim trailing spans.
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="T:ICU4N.Text.UTF16">
            <summary>
            Standalone utility class providing UTF16 character conversions and indexing conversions.
            </summary>
            <remarks>
            Code that uses strings alone rarely need modification. By design, UTF-16 does not allow overlap,
            so searching for strings is a safe operation. Similarly, concatenation is always safe.
            Substringing is safe if the start and end are both on UTF-32 boundaries. In normal code, the
            values for start and end are on those boundaries, since they arose from operations like
            searching. If not, the nearest UTF-32 boundaries can be determined using <see cref="M:ICU4N.Text.UTF16.Bounds(System.String,System.Int32)"/>.
            <para/>
            <strong>Examples:</strong>
            <para/>
            The following examples illustrate use of some of these methods.
            <code>
            // iteration forwards: Original
            for (int i = 0; i &lt; s.Length; ++i)
            {
                char ch = s[i];
                DoSomethingWith(ch);
            }
            
            // iteration forwards: Changes for UTF-32
            int ch;
            for (int i = 0; i &lt; s.Length; i += UTF16.GetCharCount(ch))
            {
                ch = UTF16.CharAt(s, i);
                DoSomethingWith(ch);
            }
            
            // iteration backwards: Original
            for (int i = s.Length - 1; i &gt;= 0; --i)
            {
                char ch = s[i];
                DoSomethingWith(ch);
            }
            
            // iteration backwards: Changes for UTF-32
            int ch;
            for (int i = s.Length - 1; i &gt; 0; i -= UTF16.GetCharCount(ch))
            {
                ch = UTF16.CharAt(s, i);
                DoSomethingWith(ch);
            }
            </code>
            <strong>Notes:</strong>
            <list type="bullet">
                <item><description>
                    <strong>Naming:</strong> For clarity, High and Low surrogates are called <c>Lead</c>
                    and <c>Trail</c> in the API, which gives a better sense of their ordering in a string.
                    <c>offset16</c> and <c>offset32</c> are used to distinguish offsets to UTF-16
                    boundaries vs offsets to UTF-32 boundaries. <c>int char32</c> is used to contain UTF-32
                    characters, as opposed to <c>char16</c>, which is a UTF-16 code unit.
                </description></item>
                <item><description>
                    <strong>Roundtripping Offsets:</strong> You can always roundtrip from a UTF-32 offset to a
                    UTF-16 offset and back. Because of the difference in structure, you can roundtrip from a UTF-16
                    offset to a UTF-32 offset and back if and only if <c>Bounds(string, offset16) != TRAIL</c>.
                </description></item>
                <item><description>
                    <strong>Exceptions:</strong> The error checking will throw an exception if indices are out
                    of bounds. Other than than that, all methods will behave reasonably, even if unmatched surrogates
                    or out-of-bounds UTF-32 values are present. <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> can be used to
                    check for validity if desired.
                </description></item>
                <item><description>
                    <strong>Unmatched Surrogates:</strong> If the string contains unmatched surrogates, then
                    these are counted as one UTF-32 value. This matches their iteration behavior, which is vital. It
                    also matches common display practice as missing glyphs (see the Unicode Standard Section 5.4,
                    5.5).
                </description></item>
                <item><description>
                    <strong>Optimization:</strong> The method implementations may need optimization if the
                    compiler doesn't fold static final methods. Since surrogate pairs will form an exceeding small
                    percentage of all the text in the world, the singleton case should always be optimized for.
                </description></item>
            </list>
            </remarks>
            <author>Mark Davis, with help from Markus Scherer</author>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.SingleCharBoundary">
            <summary>
            Value returned in <see cref="M:ICU4N.Text.UTF16.Bounds(System.String,System.Int32)"/>.
            These values are chosen specifically so that it actually represents the position of the
            character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.LeadSurrogateBoundary">
            <summary>
            Value returned in <see cref="M:ICU4N.Text.UTF16.Bounds(System.String,System.Int32)"/>.
            These values are chosen specifically so that it actually represents the position of the
            character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.TrailSurrogateBoundary">
            <summary>
            Value returned in <see cref="M:ICU4N.Text.UTF16.Bounds(System.String,System.Int32)"/>.
            These values are chosen specifically so that it actually represents the position of the
            character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.CodePointMinValue">
            <summary>
            The lowest Unicode code point value.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.CodePointMaxValue">
            <summary>
            The highest Unicode code point value (scalar value) according to the Unicode Standard.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.SupplementaryMinValue">
            <summary>
            The minimum value for Supplementary code points
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.LeadSurrogateMinValue">
            <summary>
            Lead surrogate minimum value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.TrailSurrogateMinValue">
            <summary>
            Trail surrogate minimum value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.LeadSurrogateMaxValue">
            <summary>
            Lead surrogate maximum value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.TrailSurrogateMaxValue">
            <summary>
            Trail surrogate maximum value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.SurrogateMinValue">
            <summary>
            Surrogate minimum value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.SurrogateMaxValue">
            <summary>
            Maximum surrogate value
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.LeadSurrogateBitmask">
            <summary>
            Lead surrogate bitmask
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.TrailSurrogateBitmask">
            <summary>
            Trail surrogate bitmask
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.SurrogateBitmask">
            <summary>
            Surrogate bitmask
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.LeadSurrogateBits">
            <summary>
            Lead surrogate bits
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.TrailSurrogateBits">
            <summary>
            Trail surrogate bits
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.SurrogateBits">
            <summary>
            Surrogate bits
            </summary>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Extract a single UTF-32 value from a substring. Used when iterating forwards or backwards
            (with <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the return value. If the char retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">Array of UTF-16 chars.</param>
            <param name="start">Offset to substring in the source array for analyzing.</param>
            <param name="limit">Offset to substring in the source array for analyzing.</param>
            <param name="offset16">UTF-16 offset relative to start.</param>
            <returns>UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <see cref="M:ICU4N.Text.UTF16.Bounds(System.Char[],System.Int32,System.Int32,System.Int32)"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is not within the range of start and limit.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(ICU4N.Text.IReplaceable,System.Int32)">
            <summary>
            Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
            <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on the return value. If the char 
            retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">UTF-16 chars string buffer.</param>
            <param name="offset16">UTF-16 offset to the start of the character.</param>
            <returns>UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <see cref="M:ICU4N.Text.UTF16.Bounds(System.Char[],System.Int32,System.Int32,System.Int32)"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is not within the range of start and limit.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)">
            <summary>
            Determines how many chars this <paramref name="char32"/> requires. If a validity check is required, use 
            <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on <paramref name="char32"/> before calling.
            </summary>
            <param name="char32">The input codepoint.</param>
            <returns>2 if is in supplementary space, otherwise 1.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Bounds(System.String,System.Int32)">
            <summary>
            Returns the type of the boundaries around the char at <paramref name="offset16"/>. Used for random access.
            </summary>
            <param name="source">Text to analyze.</param>
            <param name="offset16">UTF-16 offset.</param>
            <returns>
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Text.UTF16.SingleCharBoundary"/> : a single char; the bounds are [offset16, offset16+1]</description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.LeadSurrogateBoundary"/> : a surrogate pair starting at offset16; the bounds
                    are [offset16, offset16 + 2]
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.TrailSurrogateBoundary"/> : a surrogate pair starting at offset16 - 1; the
                    bounds are [offset16 - 1, offset16 + 1]
                </description></item>
            </list>
            For bit-twiddlers, the return values for these are chosen so that the boundaries
            can be gotten by: [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)].
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Bounds(System.Text.StringBuilder,System.Int32)">
            <summary>
            Returns the type of the boundaries around the char at <paramref name="offset16"/>. Used for random access.
            </summary>
            <param name="source">String buffer to analyze.</param>
            <param name="offset16">UTF16 offset.</param>
            <returns>
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Text.UTF16.SingleCharBoundary"/> : a single char; the bounds are [offset16, offset16+1]</description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.LeadSurrogateBoundary"/> : a surrogate pair starting at offset16; the bounds
                    are [offset16, offset16 + 2]
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.TrailSurrogateBoundary"/> : a surrogate pair starting at offset16 - 1; the
                    bounds are [offset16 - 1, offset16 + 1]
                </description></item>
            </list>
            For bit-twiddlers, the return values for these are chosen so that the boundaries
            can be gotten by: [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)].
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Bounds(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the type of the boundaries around the char at <paramref name="offset16"/>. Used for random access. Note
            that the boundaries are determined with respect to the subarray, hence the char array
            {0xD800, 0xDC00} has the result <see cref="F:ICU4N.Text.UTF16.SingleCharBoundary"/> for start = offset16 = 0 and limit = 1.
            </summary>
            <param name="source">Char array to analyze.</param>
            <param name="start">Offset to substring in the source array for analyzing.</param>
            <param name="limit">Offset to substring in the source array for analyzing.</param>
            <param name="offset16">UTF16 offset relative to start.</param>
            <returns>
            <list type="bullet">
                <item><description><see cref="F:ICU4N.Text.UTF16.SingleCharBoundary"/> : a single char; the bounds are [offset16, offset16+1]</description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.LeadSurrogateBoundary"/> : a surrogate pair starting at offset16; the bounds
                    are [offset16, offset16 + 2]
                </description></item>
                <item><description>
                    <see cref="F:ICU4N.Text.UTF16.TrailSurrogateBoundary"/> : a surrogate pair starting at offset16 - 1; the
                    bounds are [offset16 - 1, offset16 + 1]
                </description></item>
            </list>
            For bit-twiddlers, the return values for these are chosen so that the boundaries
            can be gotten by: [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)].
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IsSurrogate(System.Char)">
            <summary>
            Determines whether the code value is a surrogate.
            </summary>
            <param name="char16">The input character.</param>
            <returns>true if the input character is a surrogate.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IsTrailSurrogate(System.Char)">
            <summary>
            Determines whether the character is a trail surrogate.
            </summary>
            <param name="char16">The input character.</param>
            <returns>true if the input character is a trail surrogate.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IsLeadSurrogate(System.Char)">
            <summary>
            Determines whether the character is a lead surrogate.
            </summary>
            <param name="char16">The input character.</param>
            <returns>true if the input character is a lead surrogate.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetLeadSurrogate(System.Int32)">
            <summary>
            Returns the lead surrogate. If a validity check is required, use
            <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on <paramref name="char32"/> before calling.
            </summary>
            <param name="char32">The input character.</param>
            <returns>Lead surrogate if the <c>GetCharCount(ch)</c> is 2;
            and 0 otherwise (note: 0 is not a valid lead surrogate).</returns>
            
        </member>
        <member name="M:ICU4N.Text.UTF16.GetTrailSurrogate(System.Int32)">
            <summary>
            Returns the trail surrogate. If a validity check is required, use
            <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on <paramref name="char32"/> before calling.
            </summary>
            <param name="char32">The input character.</param>
            <returns>The trail surrogate if the <c>GetCharCount(ch)</c> is 2;
            otherwise the character itself.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.ValueOf(System.Int32)">
            <summary>
            Convenience method corresponding to <c>char + ""</c>. Returns a one or two char string
            containing the UTF-32 value in UTF16 format. If a validity check is required, use
            <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on <paramref name="char32"/> before calling.
            </summary>
            <param name="char32">The input character.</param>
            <returns>String value of <paramref name="char32"/> in UTF16 format.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="char32"/> is a invalid codepoint.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.ValueOf(System.String,System.Int32)">
            <summary>
            Convenience method corresponding to <c>(codepoint at <paramref name="offset16"/>) + ""</c>. Returns a one or
            two char string containing the UTF-32 value in UTF16 format. If <paramref name="offset16"/> indexes a surrogate
            character, the whole supplementary codepoint will be returned. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on the codepoint at 
            <paramref name="offset16"/> before calling. The result returned will be a newly created string
            obtained by calling <c><paramref name="source"/>.Substring(..)</c> with the appropriate index and length.
            </summary>
            <param name="source">The input string.</param>
            <param name="offset16">The UTF16 index to the codepoint in source.</param>
            <returns>String value of the codepoint at <paramref name="offset16"/> in UTF16 format.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.ValueOf(System.Text.StringBuilder,System.Int32)">
            <summary>
            Convenience method corresponding to <c>(codepoint at <paramref name="offset16"/>) + ""</c>. Returns a
            one or two char string containing the UTF-32 value in UTF16 format. If <paramref name="offset16"/> indexes a
            surrogate character, the whole supplementary codepoint will be returned. If a validity check
            is required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on the codepoint at 
            <paramref name="offset16"/> before calling. The result returned will be a newly created string
            obtained by calling <c><paramref name="source"/>.Substring(..)</c> with the appropriate index and length.
            </summary>
            <param name="source">The input string builder.</param>
            <param name="offset16">The UTF16 index to the codepoint in source.</param>
            <returns>String value of the codepoint at <paramref name="offset16"/> in UTF16 format.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.ValueOf(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Convenience method. Returns a one or two char string containing the UTF-32 value in UTF16
            format. If <paramref name="offset16"/> indexes a surrogate character, the whole supplementary codepoint will be
            returned, except when either the leading or trailing surrogate character lies out of the
            specified subarray. In the latter case, only the surrogate character within bounds will be
            returned. If a validity check is required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the codepoint at <paramref name="offset16"/> before calling. The result returned will 
            be a newly created string containing the relevant characters.
            </summary>
            <param name="source">The input char array.</param>
            <param name="start">Start index of the subarray.</param>
            <param name="limit">End index of the subarray.</param>
            <param name="offset16">The UTF16 index to the codepoint in source relative to start.</param>
            <returns>String value of the codepoint at <paramref name="offset16"/> in UTF16 format.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindOffsetFromCodePoint(System.String,System.Int32)">
            <summary>
            Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
            the <see cref="T:ICU4N.Text.UTF16"/> class description for notes on roundtripping.
            </summary>
            <param name="source">The UTF-16 string.</param>
            <param name="offset32">UTF-32 offset.</param>
            <returns>UTF-16 offset.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset32"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindOffsetFromCodePoint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
            the <see cref="T:ICU4N.Text.UTF16"/> class description for notes on roundtripping.
            </summary>
            <param name="source">The UTF-16 string buffer.</param>
            <param name="offset32">UTF-32 offset.</param>
            <returns>UTF-16 offset.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset32"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindOffsetFromCodePoint(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
            the <see cref="T:ICU4N.Text.UTF16"/> class description for notes on roundtripping.
            </summary>
            <param name="source">The UTF-16 char array whose substring is to be analyzed.</param>
            <param name="start">Offset of the substring to be analyzed.</param>
            <param name="limit">Offset of the substring to be analyzed.</param>
            <param name="offset32">UTF-32 offset relative to <paramref name="start"/>.</param>
            <returns>UTF-16 offset relative to <paramref name="start"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset32"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindCodePointOffset(System.String,System.Int32)">
            <summary>
            Returns the UTF-32 offset corresponding to the first UTF-32 boundary at or after the given
            UTF-16 offset. Used for random access. See the <see cref="T:ICU4N.Text.UTF16"/> class description for
            notes on roundtripping.
            <para/>
            <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset
            of the <strong>lead</strong> of the pair is returned. </i>
            <para/>
            To find the UTF-32 length of a string, use:
            <code>
            len32 = UTF16.CountCodePoint(source, source.Length);
            </code>
            </summary>
            <param name="source">Text to analyze.</param>
            <param name="offset16">UTF-16 offset &lt; source text length.</param>
            <returns>UTF-32 offset.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindCodePointOffset(System.Text.StringBuilder,System.Int32)">
            <summary>
            Returns the UTF-32 offset corresponding to the first UTF-32 boundary at the given UTF-16
            offset. Used for random access. See the <see cref="T:ICU4N.Text.UTF16"/> class description for notes on
            roundtripping.
            <para/>
            <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset
            of the <strong>lead</strong> of the pair is returned. </i>
            <para/>
            To find the UTF-32 length of a string, use:
            <code>
            len32 = UTF16.CountCodePoint(source);
            </code>
            </summary>
            <param name="source">Text to analyze.</param>
            <param name="offset16">UTF-16 offset &lt; source text length.</param>
            <returns>UTF-32 offset.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.FindCodePointOffset(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the UTF-32 offset corresponding to the first UTF-32 boundary at the given UTF-16
            offset. Used for random access. See the <see cref="T:ICU4N.Text.UTF16"/> class description for notes on
            roundtripping.
            <para/>
            <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset
            of the <strong>lead</strong> of the pair is returned. </i>
            <para/>
            To find the UTF-32 length of a substring, use:
            <code>
            len32 = UTF16.CountCodePoint(source, start, limit);
            </code>
            </summary>
            <param name="source">Text to analyze.</param>
            <param name="start">Offset of the substring.</param>
            <param name="limit">Offset of the substring.</param>
            <param name="offset16">UTF-16 relative to <paramref name="start"/>.</param>
            <returns>UTF-32 offset relative to <paramref name="start"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is not within 
            the range of <paramref name="start"/> and <paramref name="limit"/>.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Append(System.Text.StringBuilder,System.Int32)">
            <summary>
            Append a single UTF-32 value to the end of a <see cref="T:System.Text.StringBuilder"/>. If a validity check is required,
            use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/> on <paramref name="char32"/> before calling.
            </summary>
            <param name="target">The buffer to append to.</param>
            <param name="char32">Value to append.</param>
            <returns>The updated <see cref="T:System.Text.StringBuilder"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="char32"/> does not 
            lie within the range of the Unicode codepoints.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.AppendCodePoint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Cover JDK 1.5 APIs. Append the code point to the buffer and return the buffer as a
            convenience.
            </summary>
            <param name="target">The buffer to append to.</param>
            <param name="cp">The code point to append.</param>
            <returns>The updated <see cref="T:System.Text.StringBuilder"/>.</returns>
            <exception cref="T:System.ArgumentException">If cp is not a valid code point.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Adds a codepoint to offset16 position of the argument char array.
            </summary>
            <param name="target">Char array to be append with the new code point.</param>
            <param name="limit">UTF16 offset which the codepoint will be appended.</param>
            <param name="char32">Code point to be appended.</param>
            <returns>Offset after <paramref name="char32"/> in the array.</returns>
            <exception cref="T:System.ArgumentException">Thrown if there is not enough space for the append, or when 
            <paramref name="char32"/> does not lie within the range of the Unicode codepoints.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CountCodePoint(System.String)">
            <summary>
            Number of codepoints in a UTF16 string.
            </summary>
            <param name="source">UTF16 string.</param>
            <returns>Number of codepoint in string.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CountCodePoint(System.Text.StringBuilder)">
            <summary>
            Number of codepoints in a UTF16 string buffer.
            </summary>
            <param name="source">UTF16 string buffer.</param>
            <returns>Number of codepoint in string.</returns>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CountCodePoint(System.Char[],System.Int32,System.Int32)">
            <summary>
            Number of codepoints in a UTF16 char array substring.
            </summary>
            <param name="source">UTF16 char array.</param>
            <param name="start">Offset of the substring.</param>
            <param name="limit">Offset of the substring.</param>
            <returns>Number of codepoint in the substring.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If start and limit are not valid.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.SetCharAt(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Set a code point into a UTF16 position. Adjusts target according if we are replacing a
            non-supplementary codepoint with a supplementary and vice versa.
            </summary>
            <param name="target">Target <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="offset16">UTF16 position to insert into.</param>
            <param name="char32">Code point.</param>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.SetCharAt(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Set a code point into a UTF16 position in a char array. Adjusts target according if we are
            replacing a non-supplementary codepoint with a supplementary and vice versa.
            </summary>
            <param name="target">Target char array.</param>
            <param name="limit">Numbers of valid chars in <paramref name="target"/>, different from target.Length. Limit counts the
            number of chars in target that represents a string, not the size of array target.</param>
            <param name="offset16">UTF16 position to insert into.</param>
            <param name="char32">Code point.</param>
            <returns>New number of chars in target that represents a string.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="offset16"/> is out of range.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.MoveCodePointOffset(System.String,System.Int32,System.Int32)">
            <summary>
            Shifts <paramref name="offset16"/> by the argument number of codepoints.
            </summary>
            <param name="source">Source string.</param>
            <param name="offset16">UTF16 position to shift.</param>
            <param name="shift32">Number of codepoints to shift.</param>
            <returns>New shifted <paramref name="offset16"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the new <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.MoveCodePointOffset(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Shifts <paramref name="offset16"/> by the argument number of codepoints.
            </summary>
            <param name="source">Source string buffer.</param>
            <param name="offset16">UTF16 position to shift.</param>
            <param name="shift32">Number of codepoints to shift.</param>
            <returns>New shifted <paramref name="offset16"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the new <paramref name="offset16"/> is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.MoveCodePointOffset(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shifts <paramref name="offset16"/> by the argument number of codepoints within a subarray.
            </summary>
            <param name="source">Char array.</param>
            <param name="start">Position of the subarray to be performed on.</param>
            <param name="limit">Position of the subarray to be performed on.</param>
            <param name="offset16">UTF16 position to shift relative to <paramref name="start"/>.</param>
            <param name="shift32">Number of codepoints to shift.</param>
            <returns>New shifted <paramref name="offset16"/> relative to start.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the new <paramref name="offset16"/> is out of bounds with respect to the subarray or the
            subarray bounds are out of range.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Insert(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Inserts <paramref name="char32"/> codepoint into target at the argument offset16. If the offset16 is in the
            middle of a supplementary codepoint, <paramref name="char32"/> will be inserted after the supplementary
            codepoint. The length of target increases by one if codepoint is non-supplementary, 2
            otherwise.
            <para/>
            The overall effect is exactly as if the argument were converted to a string by
            appending an empty string to a <see cref="T:System.Char"/> and the characters in that string 
            were then inserted into target at the position indicated by <paramref name="offset16"/>.
            <para/>
            The <paramref name="offset16"/> argument must be greater than or equal to 0, and less than or equal to the length
            of source.
            </summary>
            <param name="target">String buffer to insert to.</param>
            <param name="offset16">Offset which <paramref name="char32"/> will be inserted in.</param>
            <param name="char32">Codepoint to be inserted.</param>
            <returns>A reference to <paramref name="target"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="offset16"/> is invalid.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Insert(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Inserts <paramref name="char32"/> codepoint into target at the argument <paramref name="offset16"/>. 
            If the <paramref name="offset16"/> is in the middle of a supplementary codepoint, 
            <paramref name="char32"/> will be inserted after the supplementary
            codepoint. Limit increases by one if codepoint is non-supplementary, 2 otherwise.
            <para/>
            The overall effect is exactly as if the argument were converted to a string by the appending an empty
            string to a <see cref="T:System.Char"/> and the characters in that string were then inserted into target at the
            position indicated by <paramref name="offset16"/>.
            <para/>
            The offset argument must be greater than or equal to 0, and less than or equal to the <paramref name="limit"/>.
            </summary>
            <param name="target">Char array to insert to.</param>
            <param name="limit">End index of the char array, limit &lt;= <paramref name="target"/>.Length.</param>
            <param name="offset16">Offset which <paramref name="char32"/> will be inserted in.</param>
            <param name="char32">Codepoint to be inserted.</param>
            <returns>New limit size.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="offset16"/> is invalid.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Delete(System.Text.StringBuilder,System.Int32)">
            <summary>
            Removes the codepoint at the specified position in this target (shortening target by 1
            character if the codepoint is a non-supplementary, 2 otherwise).
            </summary>
            <param name="target">String buffer to remove codepoint from.</param>
            <param name="offset16">Offset which the codepoint will be removed.</param>
            <returns>A reference to target.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="offset16"/> is invalid.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Delete(System.Char[],System.Int32,System.Int32)">
            <summary>
            Removes the codepoint at the specified position in this target (shortening target by 1
            character if the codepoint is a non-supplementary, 2 otherwise).
            </summary>
            <param name="target">String buffer to remove codepoint from.</param>
            <param name="limit">End index of the char array, limit &lt;= <paramref name="target"/>.Length.</param>
            <param name="offset16">Offset which the codepoint will be removed.</param>
            <returns>A new limit size.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="offset16"/> is invalid.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument codepoint. I.e., the smallest index <c>i</c> such that
            <c>UTF16.CharAt(source, i) == char32</c> is true.
            <para/>
            If no such character occurs in this string, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", 'a') returns 0</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", 0x10000) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="char32">Codepoint to search for.</param>
            <returns>The index of the first occurrence of the codepoint in the argument Unicode string, or
            -1 if the codepoint does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.String)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument string <paramref name="str"/>. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity. Hence if the <paramref name="str"/>
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before <paramref name="str"/> found at in source will not have a valid match. Vice versa for lead
            surrogates that ends <paramref name="str"/>.
            <para/>
            If no such string <paramref name="str"/> occurs in this <paramref name="source"/>, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", "ab") returns 0</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00") returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800") returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <returns>the index of the first occurrence of the codepoint in the argument Unicode string, or
            -1 if the codepoint does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.String,System.StringComparison)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument string <paramref name="str"/>. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity. Hence if the <paramref name="str"/>
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before <paramref name="str"/> found at in source will not have a valid match. Vice versa for lead
            surrogates that ends <paramref name="str"/>.
            <para/>
            If no such string <paramref name="str"/> occurs in this <paramref name="source"/>, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", "ab") returns 0</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00") returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800") returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <returns>the index of the first occurrence of the codepoint in the argument Unicode string, or
            -1 if the codepoint does not occur.</returns>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument codepoint. I.e., the smallest index i such that:
            <para/>
            (UTF16.CharAt(source, i) == char32 &amp;&amp; i &gt;= <paramref name="startIndex"/>) is true.
            <para/>
            If no such character occurs in this string, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", 'a', 1) returns -1</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", 0x10000, 1) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", 0xd800, 1) returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="char32">Codepoint to search for.</param>
            <param name="startIndex">The index to start the search from.</param>
            <returns>The index of the first occurrence of the codepoint in the argument Unicode string at
            or after <paramref name="startIndex"/>, or -1 if the codepoint does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.String,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument string <paramref name="str"/>. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity.e Hence if the <paramref name="str"/>
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before <paramref name="str"/> found at in source will not have a valid match. Vice versa for lead
            surrogates that ends <paramref name="str"/>.
            <para/>
            If no such string <paramref name="str"/> occurs in this <paramref name="source"/>, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", "ab", 0) returns 0</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00", 0) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00", 2) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800", 0) returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="startIndex">The index to start the search from.</param>
            <returns>The index of the first occurrence of the codepoint in the argument Unicode string, or
            -1 if the codepoint does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.IndexOf(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the first occurrence of
            the argument string <paramref name="str"/>. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity.e Hence if the <paramref name="str"/>
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before <paramref name="str"/> found at in source will not have a valid match. Vice versa for lead
            surrogates that ends <paramref name="str"/>.
            <para/>
            If no such string <paramref name="str"/> occurs in this <paramref name="source"/>, then -1 is returned.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.IndexOf("abc", "ab", 0) returns 0</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00", 0) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800\udc00", 2) returns 3</description></item>
                <item><description>UTF16.IndexOf("abc\ud800\udc00", "\ud800", 0) returns -1</description></item>
            </list>
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="startIndex">The index to start the search from.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <returns>The index of the first occurrence of the codepoint in the argument Unicode string, or
            -1 if the codepoint does not occur.</returns>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument codepoint. I.e., the index returned is the largest value i such that:
            UTF16.CharAt(source, i) == char32 is true.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", 'a') returns 0</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="char32">Codepoint to search for.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.String)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument string str. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity.e Hence if the str
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before str found at in source will not have a valid match. Vice versa for lead
            surrogates that ends str.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", "a") returns 0</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.String,System.StringComparison)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument string str. This method is implemented based on codepoints, hence a "lead
            surrogate character + trail surrogate character" is treated as one entity.e Hence if the str
            starts with trail surrogate character at index 0, a source with a leading a surrogate
            character before str found at in source will not have a valid match. Vice versa for lead
            surrogates that ends str.
            </summary>
            <remarks>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", "a") returns 0</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.SafeLastIndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument codepoint, where the result is less than or equals to <paramref name="startIndex"/>.
            </summary>
            <remarks>
            This method is implemented based on codepoints, hence a single surrogate character will not
            match a supplementary character.
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character starting at the specified index.
            <para/>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", 'c', 2) returns 2</description></item>
                <item><description>UTF16.LastIndexOf("abc", 'c', 1) returns -1</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000, 5) returns 3.</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000, 3) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            <para/>
            Note this method is similar to the ICU4J lastIndexOf() implementation in that it does not throw an <see cref="T:System.ArgumentOutOfRangeException"/>
            if <paramref name="startIndex"/> is negative or >= the length of <paramref name="source"/>.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="char32">Codepoint to search for.</param>
            <param name="startIndex">The index to start the search from. There is no restriction on the value of
            fromIndex. If it is greater than or equal to the length of this string, it has the
            same effect as if it were equal to one less than the length of this string: this
            entire string may be searched. If it is negative, it has the same effect as if it
            were -1: -1 is returned.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument codepoint, where the result is less than or equals to <paramref name="startIndex"/>.
            </summary>
            <remarks>
            This method is implemented based on codepoints, hence a single surrogate character will not
            match a supplementary character.
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character starting at the specified index.
            <para/>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", 'c', 2) returns 2</description></item>
                <item><description>UTF16.LastIndexOf("abc", 'c', 1) returns -1</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000, 5) throws <see cref="T:System.ArgumentOutOfRangeException"/>.</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0x10000, 3) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", 0xd800) returns -1</description></item>
            </list>
            <para/>
            Note this method differs from the ICU4J implementation in that it throws an <see cref="T:System.ArgumentOutOfRangeException"/>
            if <paramref name="startIndex"/> is negative or >= the length of <paramref name="source"/>.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="char32">Codepoint to search for.</param>
            <param name="startIndex">The index to start the search from. 
            The search proceeds from startIndex toward the beginning of <paramref name="source"/>.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex"/> is negative or greater than 
            <paramref name="source"/>.Length - 1.</exception>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.SafeLastIndexOf(System.String,System.String,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument string <paramref name="str"/>, where the result is less than or equals to <paramref name="startIndex"/>.
            </summary>
            <remarks>
            This method is implemented based on codepoints, hence a "lead surrogate character + trail
            surrogate character" is treated as one entity. Hence if the <paramref name="str"/> starts with trail surrogate
            character at index 0, a source with a leading a surrogate character before <paramref name="str"/> found at in
            source will not have a valid match. Vice versa for lead surrogates that ends <paramref name="str"/>.
            <para/>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", "c", 2) returns 2</description></item>
                <item><description>UTF16.LastIndexOf("abc", "c", 1) returns -1</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 5) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 3) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800", 4) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            <para/>
            Note this method is similar to the ICU4J implementation in that it does not throw an <see cref="T:System.ArgumentOutOfRangeException"/>
            if <paramref name="startIndex"/> is negative or >= the length of <paramref name="source"/>.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="startIndex">The index to start the search from.  There is no restriction on the value of
            fromIndex. If it is greater than or equal to the length of this string, it has the
            same effect as if it were equal to one less than the length of this string: this
            entire string may be searched. If it is negative, it has the same effect as if it
            were -1: -1 is returned.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.String,System.Int32)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument string <paramref name="str"/>, where the result is less than or equals to <paramref name="startIndex"/>.
            </summary>
            <remarks>
            This method is implemented based on codepoints, hence a "lead surrogate character + trail
            surrogate character" is treated as one entity. Hence if the <paramref name="str"/> starts with trail surrogate
            character at index 0, a source with a leading a surrogate character before <paramref name="str"/> found at in
            source will not have a valid match. Vice versa for lead surrogates that ends <paramref name="str"/>.
            <para/>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", "c", 2) returns 2</description></item>
                <item><description>UTF16.LastIndexOf("abc", "c", 1) returns -1</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 5) throws <see cref="T:System.ArgumentOutOfRangeException"/>.</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 3) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800", 4) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            <para/>
            Note this method differs from the ICU4J implementation in that it throws an <see cref="T:System.ArgumentOutOfRangeException"/>
            if <paramref name="startIndex"/> is negative or >= the length of <paramref name="source"/>.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="startIndex">The index to start the search from. 
            The search proceeds from <paramref name="startIndex"/> toward the beginning of <paramref name="source"/>.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex"/> is negative or greater than 
            <paramref name="source"/>.Length - 1.</exception>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.LastIndexOf(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>
            Returns the index within the argument UTF16 format Unicode string of the last occurrence of
            the argument string <paramref name="str"/>, where the result is less than or equals to <paramref name="startIndex"/>.
            </summary>
            <remarks>
            This method is implemented based on codepoints, hence a "lead surrogate character + trail
            surrogate character" is treated as one entity. Hence if the <paramref name="str"/> starts with trail surrogate
            character at index 0, a source with a leading a surrogate character before <paramref name="str"/> found at in
            source will not have a valid match. Vice versa for lead surrogates that ends <paramref name="str"/>.
            <para/>
            Examples:
            <list type="table">
                <item><description>UTF16.LastIndexOf("abc", "c", 2) returns 2</description></item>
                <item><description>UTF16.LastIndexOf("abc", "c", 1) returns -1</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 5) throws <see cref="T:System.ArgumentOutOfRangeException"/>.</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800\udc00", 3) returns 3</description></item>
                <item><description>UTF16.LastIndexOf("abc\ud800\udc00", "\ud800", 4) returns -1</description></item>
            </list>
            <para/>
            <paramref name="source"/> is searched backwards starting at the last character.
            <para/>
            Note this method differs from the ICU4J implementation in that it throws an <see cref="T:System.ArgumentOutOfRangeException"/>
            if <paramref name="startIndex"/> is negative or >= the length of <paramref name="source"/>.
            </remarks>
            <param name="source">UTF16 format Unicode string that will be searched.</param>
            <param name="str">UTF16 format Unicode string to search for.</param>
            <param name="startIndex">The index to start the search from. 
            The search proceeds from <paramref name="startIndex"/> toward the beginning of <paramref name="source"/>.</param>
            <returns>The index of the last occurrence of the codepoint in source, or -1 if the codepoint
            does not occur.</returns>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex"/> is negative or greater than 
            <paramref name="source"/>.Length - 1.</exception>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Replace(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a new UTF16 format Unicode string resulting from replacing all occurrences of
            <paramref name="oldChar32"/> in source with <paramref name="newChar32"/>. If the character 
            <paramref name="oldChar32"/> does not occur in the UTF16 format Unicode string source, then 
            source will be returned. Otherwise, a new string object is created that represents a codepoint 
            sequence identical to the codepoint sequence represented by source, except that every occurrence 
            of <paramref name="oldChar32"/> is replaced by an occurrence of <paramref name="newChar32"/>.
            </summary>
            <remarks>
            Examples:
            <code>
            UTF16.Replace("mesquite in your cellar", 'e', 'o'); // returns "mosquito in your collar"
            UTF16.Replace("JonL", 'q', 'x'); // returns "JonL" (no change)
            UTF16.Replace("Supplementary character \ud800\udc00", 0x10000, '!'); // returns "Supplementary character !"
            UTF16.Replace("Supplementary character \ud800\udc00", 0xd800, '!'); // returns "Supplementary character \ud800\udc00"
            </code>
            <para/>
            Note this method is provided as support to jdk 1.3, which does not support supplementary
            characters to its fullest.
            </remarks>
            <param name="source">UTF16 format Unicode string which the codepoint replacements will be based on.</param>
            <param name="oldChar32">Non-zero old codepoint to be replaced.</param>
            <param name="newChar32">The new codepoint to replace <paramref name="oldChar32"/>.</param>
            <returns>new string derived from source by replacing every occurrence of <paramref name="oldChar32"/> with
            <paramref name="newChar32"/>, unless when no <paramref name="oldChar32"/> is found in source then source will be returned.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Replace(System.String,System.String,System.String)">
            <summary>
            Returns a new UTF16 format Unicode string resulting from replacing all occurrences of <paramref name="oldStr"/>
            in <paramref name="source"/> with <paramref name="newStr"/>. If the string <paramref name="oldStr"/> does not 
            occur in the UTF16 format Unicode string <paramref name="source"/>, then source will be returned. Otherwise, a new 
            string object is created that represents a codepoint sequence identical to the codepoint sequence 
            represented by <paramref name="source"/>, except that every occurrence of <paramref name="oldStr"/> is replaced by 
            an occurrence of <paramref name="newStr"/>.
            </summary>
            <remarks>
            Examples:
            <code>
            UTF16.Replace("mesquite in your cellar", "e", "o"); // returns "mosquito in your collar"
            UTF16.Replace("mesquite in your cellar", "mesquite", "cat"); // returns "cat in your cellar"
            UTF16.Replace("JonL", "q", "x"); // returns "JonL" (no change)
            UTF16.Replace("Supplementary character \ud800\udc00", "\ud800\udc00", '!'); // returns "Supplementary character !"
            UTF16.Replace("Supplementary character \ud800\udc00", "\ud800", '!'); // returns "Supplementary character \ud800\udc00"
            </code>
            <para/>
            Note this method is provided as support to jdk 1.3, which does not support supplementary
            characters to its fullest.
            </remarks>
            <param name="source">UTF16 format Unicode string which the replacements will be based on.</param>
            <param name="oldStr">Non-zero-length string to be replaced.</param>
            <param name="newStr">The new string to replace <paramref name="oldStr"/>.</param>
            <returns>New string derived from <paramref name="source"/> by replacing every occurrence of 
            <paramref name="oldStr"/> with <paramref name="newStr"/>.
            When no <paramref name="oldStr"/> is found in <paramref name="source"/>, then source will be returned.
            </returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.Reverse(System.Text.StringBuilder)">
            <summary>
            Reverses a UTF16 format Unicode string and replaces source's content with it. This method
            will reverse surrogate characters correctly, instead of blindly reversing every character.
            </summary>
            <remarks>
            Examples:
            <code>
            UTF16.Reverse(new StringBuilder( "Supplementary characters \ud800\udc00\ud801\udc01")) // returns "\ud801\udc01\ud800\udc00 sretcarahc yratnemelppuS"
            </code>
            </remarks>
            <param name="source">The source <see cref="T:System.Text.StringBuilder"/> that contains UTF16 format Unicode string to be reversed.</param>
            <returns>A modified source with reversed UTF16 format Unicode string.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.HasMoreCodePointsThan(System.String,System.Int32)">
            <summary>
            Check if the string contains more Unicode code points than a certain <paramref name="number"/>. This is more
            efficient than counting all code points in the entire string and comparing that <paramref name="number"/> with a
            threshold. This function may not need to scan the string at all if the length is within a
            certain range, and never needs to count more than '<paramref name="number"/> + 1' code points. Logically
            equivalent to (UTF16.CountCodePoint(s) &gt; <paramref name="number"/>). A Unicode code point may occupy either one or two
            code units.
            </summary>
            <param name="source">The input string.</param>
            <param name="number">The number of code points in the string is compared against the '<paramref name="number"/>' parameter.</param>
            <returns>Boolean value for whether the string contains more Unicode code points than '<paramref name="number"/>'.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.HasMoreCodePointsThan(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Check if the sub-range of char array, from argument <paramref name="start"/> to <paramref name="limit"/>, contains more Unicode
            code points than a certain <paramref name="number"/>. This is more efficient than counting all code points in
            the entire char array range and comparing that number with a threshold. This function may not
            need to scan the char array at all if <paramref name="start"/> and <paramref name="limit"/> is within a certain range, and never
            needs to count more than '<paramref name="number"/> + 1' code points. Logically equivalent to
            (UTF16.CountCodePoint(source, start, limit) &gt; <paramref name="number"/>). A Unicode code point may occupy either one
            or two code units.
            </summary>
            <param name="source">Array of UTF-16 chars.</param>
            <param name="start">Offset to substring in the <paramref name="source"/> array for analyzing.</param>
            <param name="limit">Offset to substring in the <paramref name="source"/> array for analyzing.</param>
            <param name="number">The number of code points in the string is compared against the '<paramref name="number"/>' parameter.</param>
            <returns>Boolean value for whether the string contains more Unicode code points than '<paramref name="number"/>'.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when <paramref name="limit"/> &lt; <paramref name="start"/>.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.HasMoreCodePointsThan(System.Text.StringBuilder,System.Int32)">
            <summary>
            Check if the string buffer contains more Unicode code points than a certain <paramref name="number"/>. This is
            more efficient than counting all code points in the entire string buffer and comparing that
            number with a threshold. This function may not need to scan the string buffer at all if the
            length is within a certain range, and never needs to count more than '<paramref name="number"/> + 1' code
            points. Logically equivalent to (UTF16.CountCodePoint(s) &gt; <paramref name="number"/>). A Unicode code point may
            occupy either one or two code units.
            </summary>
            <param name="source">The input string buffer.</param>
            <param name="number">The number of code points in the string buffer is compared against the '<paramref name="number"/>' parameter.</param>
            <returns>Boolean value for whether the string buffer contains more Unicode code points than '<paramref name="number"/>'.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.NewString(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Create a string from an array of <paramref name="codePoints"/>.
            </summary>
            <param name="codePoints">The code point array.</param>
            <param name="offset">The start of the text in the code point array.</param>
            <param name="count">The number of code points.</param>
            <returns>A string representing the code points between <paramref name="offset"/> and <paramref name="count"/>.</returns>
            <exception cref="T:System.ArgumentException">If an invalid code point is encountered.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If the <paramref name="offset"/> or <paramref name="count"/> are out of bounds.</exception>
            <stable>ICU 3.0</stable>
        </member>
        <member name="T:ICU4N.Text.UTF16.StringComparer">
            <summary>
            UTF16 string comparer class. Allows UTF16 string comparison to be done with the various
            modes.
            <list type="bullet">
                <item><description>
                    Code point comparison or code unit comparison.
                </description></item>
                <item><description>
                    Case sensitive comparison, case insensitive comparison or case insensitive comparison
                    with special handling for character 'i'.
                </description></item>
            </list>
            <para/>
            The code unit or code point comparison differ only when comparing supplementary code points
            (&#92;u10000..&#92;u10ffff) to BMP code points near the end of the BMP (i.e.,
            &#92;ue000..&#92;uffff). In code unit comparison, high BMP code points sort after
            supplementary code points because they are stored as pairs of surrogates which are at
            &#92;ud800..&#92;udfff.
            </summary>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault"/>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI"/>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.StringComparer.#ctor">
            <summary>
            Default constructor that does code unit comparison and case sensitive comparison.
            </summary>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.StringComparer.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Constructor that does comparison based on the argument options.
            </summary>
            <param name="codepointcompare">Flag to indicate true for code point comparison or false for code unit comparison.</param>
            <param name="ignorecase">False for case sensitive comparison, true for case-insensitive comparison.</param>
            <param name="foldcaseoption"><see cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault"/> or <see cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI"/>. This option is used only
            when ignorecase is set to true. If ignorecase is false, this option is
            ignored.
            </param>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault"/>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI"/>
            <exception cref="T:System.ArgumentException">If <paramref name="foldcaseoption"/> is out of range.</exception>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault">
            <summary>
            Option value for case folding comparison:
            <para/>
            Comparison is case insensitive, strings are folded using default mappings defined in
            Unicode data file CaseFolding.txt, before comparison.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI">
            <summary>
            Option value for case folding:
            Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
            and dotless i appropriately for Turkic languages (tr, az).
            <para/>
            Comparison is case insensitive, strings are folded using modified mappings defined in
            Unicode data file CaseFolding.txt, before comparison.
            </summary>
            <seealso cref="F:ICU4N.UChar.FoldCaseExcludeSpecialI"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UTF16.StringComparer.CodePointCompare">
            <summary>
            Gets or Sets the comparison mode to code point compare if flag is true. 
            Default comparison mode is set to code unit compare (false).
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UTF16.StringComparer.IgnoreCase">
            <summary>
            Gets or sets whether <see cref="T:ICU4N.Text.UTF16.StringComparer"/> is in the case insensitive mode.
            </summary>
            <remarks>
            <b>true</b> if <see cref="T:ICU4N.Text.UTF16.StringComparer"/> performs case insensitive comparison, <b>false</b> otherwise
            </remarks>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.UTF16.StringComparer.IgnoreCaseOption">
            <summary>
            Gets or sets the fold case options set in <see cref="T:ICU4N.Text.UTF16.StringComparer"/> to be used with case insensitive comparison.
            </summary>
            <remarks>
            <see cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault"/> or <see cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI"/>. This option is used only
            when ignorecase is set to true. If ignorecase is false, this option is
            ignored.
            </remarks>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseDefault"/>
            <seealso cref="F:ICU4N.Text.UTF16.StringComparer.FoldCaseExcludeSpecialI"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.StringComparer.Compare(System.String,System.String)">
            <summary>
            Compare two strings depending on the options selected during construction.
            </summary>
            <param name="a">First source string.</param>
            <param name="b">Second source string.</param>
            <returns>0 returned if <paramref name="a"/> == <paramref name="b"/>. If <paramref name="a"/> &lt; <paramref name="b"/>, 
            a negative value is returned. Otherwise if <paramref name="a"/> &gt; <paramref name="b"/>, a positive value is returned.</returns>
            <exception cref="T:System.InvalidCastException">Thrown when either <paramref name="a"/> or <paramref name="b"/> is not a string object.</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.m_codePointCompare_">
            <summary>
            Code unit comparison flag. True if code unit comparison is required. False if code point
            comparison is required.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.m_foldCase_">
            <summary>
            Fold case comparison option.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.m_ignoreCase_">
            <summary>
            Flag indicator if ignore case is to be used during comparison
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.StringComparer.CODE_POINT_COMPARE_SURROGATE_OFFSET_">
            <summary>
            Code point order offset for surrogate characters
            </summary>
        </member>
        <member name="M:ICU4N.Text.UTF16.StringComparer.CompareCaseInsensitive(System.String,System.String)">
            <summary>
            Compares case insensitive. This is a direct port of ICU4C, to make maintainence life
            easier.
            </summary>
            <param name="s1">First string to compare.</param>
            <param name="s2">Second string to compare.</param>
            <returns>-1 if <paramref name="s1"/> &lt; <paramref name="s2"/>, 0 if equal, 
            1 if <paramref name="s1"/> &gt; <paramref name="s2"/>.</returns>
        </member>
        <member name="M:ICU4N.Text.UTF16.StringComparer.CompareCaseSensitive(System.String,System.String)">
            <summary>
            Compares case sensitive. This is a direct port of ICU4C, to make maintainence life
            easier.
            </summary>
            <param name="s1">First string to compare.</param>
            <param name="s2">Second string to compare.</param>
            <returns>-1 if <paramref name="s1"/> &lt; <paramref name="s2"/>, 0 if equal, 
            1 if <paramref name="s1"/> &gt; <paramref name="s2"/>.</returns>
        </member>
        <member name="F:ICU4N.Text.UTF16.LEAD_SURROGATE_SHIFT_">
            <summary>
            Shift value for lead surrogate to form a supplementary character.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.TRAIL_SURROGATE_MASK_">
            <summary>
            Mask to retrieve the significant value from a trail surrogate.
            </summary>
        </member>
        <member name="F:ICU4N.Text.UTF16.LEAD_SURROGATE_OFFSET_">
            <summary>
            Value that all lead surrogate starts with
            </summary>
        </member>
        <member name="M:ICU4N.Text.UTF16.ToString(System.Int32)">
            <summary>
            Converts argument code point and returns a string object representing the code point's value
            in UTF16 format.
            <para/>
            This method does not check for the validity of the codepoint, the results are not guaranteed
            if a invalid codepoint is passed as argument.
            <para/>
            The result is a string whose length is 1 for non-supplementary code points, 2 otherwise.
            </summary>
            <param name="ch">Code point.</param>
            <returns>String representation of the code point.</returns>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(System.String,System.Int32)">
            <summary>
            Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
            <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the return value. If the char retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">Array of UTF-16 chars</param>
            <param name="offset16">UTF-16 offset to the start of the character.</param>
            <returns>
            UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <c>Bounds32()</c>.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(System.Text.StringBuilder,System.Int32)">
            <summary>
            Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
            <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the return value. If the char retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">Array of UTF-16 chars</param>
            <param name="offset16">UTF-16 offset to the start of the character.</param>
            <returns>
            UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <c>Bounds32()</c>.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(System.Char[],System.Int32)">
            <summary>
            Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
            <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the return value. If the char retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">Array of UTF-16 chars</param>
            <param name="offset16">UTF-16 offset to the start of the character.</param>
            <returns>
            UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <c>Bounds32()</c>.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CharAt(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
            <see cref="M:ICU4N.Text.UTF16.GetCharCount(System.Int32)"/>, as well as random access. If a validity check is
            required, use <see cref="M:ICU4N.UChar.IsLegal(System.Int32)"/>
            on the return value. If the char retrieved is part of a surrogate pair, its supplementary
            character will be returned. If a complete supplementary character is not found the incomplete
            character will be returned.
            </summary>
            <param name="source">Array of UTF-16 chars</param>
            <param name="offset16">UTF-16 offset to the start of the character.</param>
            <returns>
            UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
            of that codepoint are the same as in <c>Bounds32()</c>.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if offset16 is out of bounds.</exception>
            <stable>ICU 2.1</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.String)">
            <summary>
            Utility for getting a code point from a character sequence that contains exactly one code point.
            </summary>
            <param name="s">to test</param>
            <returns>The code point IF the string is non-null and consists of a single code point. Otherwise returns -1.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.Text.StringBuilder)">
            <summary>
            Utility for getting a code point from a character sequence that contains exactly one code point.
            </summary>
            <param name="s">to test</param>
            <returns>The code point IF the string is non-null and consists of a single code point. Otherwise returns -1.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetSingleCodePoint(System.Char[])">
            <summary>
            Utility for getting a code point from a character sequence that contains exactly one code point.
            </summary>
            <param name="s">to test</param>
            <returns>The code point IF the string is non-null and consists of a single code point. Otherwise returns -1.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.GetSingleCodePoint(ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for getting a code point from a character sequence that contains exactly one code point.
            </summary>
            <param name="s">to test</param>
            <returns>The code point IF the string is non-null and consists of a single code point. Otherwise returns -1.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CompareCodePoint(System.Int32,System.String)">
            <summary>
            Utility for comparing a code point to a string without having to create a new string. Returns the same results
            as a code point comparison of UTF16.ValueOf(codePoint) and s.ToString(). More specifically, if
            <code>
               sc = new StringComparer(true,false,0);
               fast = UTF16.CompareCodePoint(codePoint, charSequence)
               slower = sc.Compare(UTF16.ValueOf(codePoint), charSequence == null ? "" : charSequence.ToString())
            </code>
            then
            <code>
               Math.Sign(fast) == Math.Sign(slower)
            </code>
            </summary>
            <param name="codePoint">CodePoint to test.</param>
            <param name="s">String to test.</param>
            <returns>Equivalent of code point comparator comparing two strings.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CompareCodePoint(System.Int32,System.Text.StringBuilder)">
            <summary>
            Utility for comparing a code point to a string without having to create a new string. Returns the same results
            as a code point comparison of UTF16.ValueOf(codePoint) and s.ToString(). More specifically, if
            <code>
               sc = new StringComparer(true,false,0);
               fast = UTF16.CompareCodePoint(codePoint, charSequence)
               slower = sc.Compare(UTF16.ValueOf(codePoint), charSequence == null ? "" : charSequence.ToString())
            </code>
            then
            <code>
               Math.Sign(fast) == Math.Sign(slower)
            </code>
            </summary>
            <param name="codePoint">CodePoint to test.</param>
            <param name="s">String to test.</param>
            <returns>Equivalent of code point comparator comparing two strings.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CompareCodePoint(System.Int32,System.Char[])">
            <summary>
            Utility for comparing a code point to a string without having to create a new string. Returns the same results
            as a code point comparison of UTF16.ValueOf(codePoint) and s.ToString(). More specifically, if
            <code>
               sc = new StringComparer(true,false,0);
               fast = UTF16.CompareCodePoint(codePoint, charSequence)
               slower = sc.Compare(UTF16.ValueOf(codePoint), charSequence == null ? "" : charSequence.ToString())
            </code>
            then
            <code>
               Math.Sign(fast) == Math.Sign(slower)
            </code>
            </summary>
            <param name="codePoint">CodePoint to test.</param>
            <param name="s">String to test.</param>
            <returns>Equivalent of code point comparator comparing two strings.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="M:ICU4N.Text.UTF16.CompareCodePoint(System.Int32,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Utility for comparing a code point to a string without having to create a new string. Returns the same results
            as a code point comparison of UTF16.ValueOf(codePoint) and s.ToString(). More specifically, if
            <code>
               sc = new StringComparer(true,false,0);
               fast = UTF16.CompareCodePoint(codePoint, charSequence)
               slower = sc.Compare(UTF16.ValueOf(codePoint), charSequence == null ? "" : charSequence.ToString())
            </code>
            then
            <code>
               Math.Sign(fast) == Math.Sign(slower)
            </code>
            </summary>
            <param name="codePoint">CodePoint to test.</param>
            <param name="s">String to test.</param>
            <returns>Equivalent of code point comparator comparing two strings.</returns>
            <stable>ICU 54</stable>
        </member>
        <member name="T:ICU4N.Util.ByteArrayWrapper">
            <summary>
            A simple utility class to wrap a byte array.
            <para/>
            Generally passed as an argument object into a method. The method takes
            responsibility of writing into the internal byte array and increasing its
            size when necessary.
            </summary>
            <author>syn wee</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Util.ByteArrayWrapper.Bytes">
            <summary>
            Internal byte array.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Util.ByteArrayWrapper.Length">
            <summary>
            Size of the internal byte array used. 
            Different from bytes.Length, <see cref="P:ICU4N.Util.ByteArrayWrapper.Length"/> will be &lt;= bytes.Length.
            Semantics of <see cref="P:ICU4N.Util.ByteArrayWrapper.Length"/> is similar to <see cref="P:System.Collections.BitArray.Length"/>.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.#ctor">
            <summary>
            Construct a new <see cref="T:ICU4N.Util.ByteArrayWrapper"/> with no data.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.#ctor(System.Byte[],System.Int32)">
            <summary>
            Construct a new <see cref="T:ICU4N.Util.ByteArrayWrapper"/> from a byte array and size. 
            </summary>
            <param name="bytesToAdopt">The byte array to adopt.</param>
            <param name="size">The length of valid data in the byte array.</param>
            <exception cref="T:System.IndexOutOfRangeException">if bytesToAdopt == null and size != 0, or
            size &lt; 0, or size &gt; bytesToAdopt.Length.</exception>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.#ctor(ICU4N.Support.IO.ByteBuffer)">
            <summary>
            Construct a new ByteArrayWrapper from the contents of a <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            </summary>
            <param name="source">The <see cref="T:ICU4N.Support.IO.ByteBuffer"/> from which to get the data.</param>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.EnsureCapacity(System.Int32)">
            <summary>
            Ensure that the internal byte array is at least of length capacity.
            If the byte array is null or its length is less than capacity, a new
            byte array of length capacity will be allocated.
            The contents of the array (between 0 and <see cref="P:ICU4N.Util.ByteArrayWrapper.Length"/>) remain unchanged.
            </summary>
            <param name="capacity">Minimum length of internal byte array.</param>
            <returns>This <see cref="T:ICU4N.Util.ByteArrayWrapper"/>.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.Set(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the internal byte array from offset 0 to count with the 
            contents of src from offset start to limit. If the byte array is null or its length is less than capacity, a new 
            byte array of length (limit - start) will be allocated.
            This resets the size of the internal byte array to count.
            </summary>
            <param name="src">source byte array to copy from</param>
            <param name="start">start offset of <paramref name="src"/> to copy from</param>
            <param name="count">Number of bytes to copy from <paramref name="src"/>.</param>
            <returns>This <see cref="T:ICU4N.Util.ByteArrayWrapper"/>.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Appends the internal byte array from offset size with the 
            contents of src from offset start to limit. This increases the size of
            the internal byte array to (size + count).
            </summary>
            <param name="src">source byte array to copy from.</param>
            <param name="start">start offset of <paramref name="src"/> to copy from.</param>
            <param name="count">number of bytes from <paramref name="src"/> to copy.</param>
            <returns>This ByteArrayWrapper.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.ReleaseBytes">
            <summary>
            Releases the internal byte array to the caller, resets the internal
            byte array to null and its size to 0.
            </summary>
            <returns>internal byte array.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.ToString">
            <summary>
            Returns string value for debugging.
            </summary>
            <returns>ICU 3.2</returns>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.Equals(System.Object)">
            <summary>
            Return true if the bytes in each wrapper are equal.
            </summary>
            <param name="other">the object to compare to.</param>
            <returns>true if the two objects are equal.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.GetHashCode">
            <summary>
            Return the hashcode.
            </summary>
            <returns>the hashcode.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.CompareTo(ICU4N.Util.ByteArrayWrapper)">
            <summary>
            Compare this object to another <see cref="T:ICU4N.Util.ByteArrayWrapper"/>, which must not be null.
            </summary>
            <param name="other">the object to compare to.</param>
            <returns>a value &lt;0, 0, or &gt;0 as this compares less than, equal to, or
            greater than other.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="other"/> is null.</exception>
            <stable>ICU 4.4</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.CompareTo(System.Object)">
            <summary>
            Compare this object to another <see cref="T:ICU4N.Util.ByteArrayWrapper"/>, which must not be null.
            </summary>
            <param name="other">the object to compare to.</param>
            <returns>a value &lt;0, 0, or &gt;0 as this compares less than, equal to, or
            greater than other.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="other"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="other"/> cannot be cast to <see cref="T:ICU4N.Util.ByteArrayWrapper"/>.</exception>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Util.ByteArrayWrapper.CopyBytes(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of <paramref name="src"/> byte array from offset <paramref name="srcoff"/> to the
            target of <paramref name="tgt"/> byte array at the offset <paramref name="tgtoff"/>.
            </summary>
            <param name="src">Source byte array to copy from.</param>
            <param name="srcoff">Start offset of src to copy from.</param>
            <param name="tgt">Target byte array to copy to.</param>
            <param name="tgtoff">Start offset of tgt to copy to.</param>
            <param name="length">Size of contents to copy.</param>
        </member>
        <member name="T:ICU4N.Util.Result">
            <summary>
            Return values for <see cref="M:ICU4N.Util.BytesTrie.Next(System.Int32)"/>, <see cref="M:ICU4N.Util.CharsTrie.Next(System.Int32)"/> and similar methods.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.Result.NoMatch">
            <summary>
            The input unit(s) did not continue a matching string.
            Once <see cref="P:ICU4N.Util.BytesTrie.Current"/>/<see cref="M:ICU4N.Util.BytesTrie.Next(System.Int32)"/> return <see cref="F:ICU4N.Util.Result.NoMatch"/>,
            all further calls to <see cref="P:ICU4N.Util.BytesTrie.Current"/>/<see cref="M:ICU4N.Util.BytesTrie.Next(System.Int32)"/> will also return <see cref="F:ICU4N.Util.Result.NoMatch"/>,
            until the trie is reset to its original state or to a saved state.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.Result.NoValue">
            <summary>
            The input unit(s) continued a matching string
            but there is no value for the string so far.
            (It is a prefix of a longer string.)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.Result.FinalValue">
            <summary>
            The input unit(s) continued a matching string
            and there is a value for the string so far.
            This value will be returned by <see cref="M:ICU4N.Util.BytesTrie.GetValue"/>
            No further input byte/unit can continue a matching string.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.Result.IntermediateValue">
            <summary>
            The input unit(s) continued a matching string
            and there is a value for the string so far.
            This value will be returned by <see cref="M:ICU4N.Util.BytesTrie.GetValue"/>
            Another input byte/unit can continue a matching string.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.ResultExtensions.Matches(ICU4N.Util.Result)">
            <summary>
            Same as (result!=<see cref="F:ICU4N.Util.Result.NoMatch"/>).
            </summary>
            <param name="result">This <see cref="T:ICU4N.Util.Result"/>.</param>
            <returns>true if the input bytes/units so far are part of a matching string/byte sequence.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.ResultExtensions.HasValue(ICU4N.Util.Result)">
            <summary>
            Equivalent to (result==<see cref="F:ICU4N.Util.Result.IntermediateValue"/> || result==<see cref="F:ICU4N.Util.Result.FinalValue"/>).
            </summary>
            <param name="result">This <see cref="T:ICU4N.Util.Result"/>.</param>
            <returns>true if there is a value for the input bytes/units so far.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.ResultExtensions.HasNext(ICU4N.Util.Result)">
            <summary>
            Equivalent to (result==<see cref="F:ICU4N.Util.Result.NoValue"/> || result==<see cref="F:ICU4N.Util.Result.IntermediateValue"/>).
            </summary>
            <param name="result">This <see cref="T:ICU4N.Util.Result"/>.</param>
            <returns>true if another input byte/unit can continue a matching string.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.BytesTrie">
            <summary>
            Light-weight, non-const reader class for a BytesTrie.
            Traverses a byte-serialized data structure with minimal state,
            for mapping byte sequences to non-negative integer values.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <stable>ICU 4.8</stable>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructs a <see cref="T:ICU4N.Util.BytesTrie"/> reader instance.
            </summary>
            <remarks>
            The array must contain a copy of a byte sequence from the <see cref="T:ICU4N.Util.BytesTrieBuilder"/>,
            with the offset indicating the first byte of that sequence.
            The <see cref="T:ICU4N.Util.BytesTrie"/> object will not read more bytes than
            the <see cref="T:ICU4N.Util.BytesTrieBuilder"/> generated in the corresponding <see cref="M:ICU4N.Util.BytesTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> call.
            <para/>
            The array is not copied/cloned and must not be modified while
            the <see cref="T:ICU4N.Util.BytesTrie"/> object is in use.
            </remarks>
            <param name="trieBytes">Bytes array that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the array.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Clone">
            <summary>
            Clones this trie reader object and its state,
            but not the byte array which will be shared.
            </summary>
            <returns>A shallow clone of this trie.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Reset">
            <summary>
            Resets this trie to its initial state.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.BytesTrie.State">
            <summary>
            <see cref="T:ICU4N.Util.BytesTrie"/> state object, for saving a trie's current state
            and resetting the trie back to this state later.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.State.#ctor">
            <summary>
            Constructs an empty <see cref="T:ICU4N.Util.BytesTrie.State"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.SaveState(ICU4N.Util.BytesTrie.State)">
            <summary>
            Saves the state of this trie.
            </summary>
            <param name="state">The State object to hold the trie's state.</param>
            <seealso cref="M:ICU4N.Util.BytesTrie.ResetToState(ICU4N.Util.BytesTrie.State)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.ResetToState(ICU4N.Util.BytesTrie.State)">
            <summary>
            Resets this trie to the saved state.
            </summary>
            <param name="state">The State object which holds a saved trie state.</param>
            <returns>This.</returns>
            <exception cref="T:System.ArgumentException">If the state object contains no state,
            or the state of a different trie.</exception>
            <seealso cref="M:ICU4N.Util.BytesTrie.SaveState(ICU4N.Util.BytesTrie.State)"/>
            <seealso cref="M:ICU4N.Util.BytesTrie.Reset"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.BytesTrie.Current">
            <summary>
            Determines whether the byte sequence so far matches, whether it has a value,
            and whether another input byte can continue a matching byte sequence.
            Returns the match/value <see cref="T:ICU4N.Util.Result"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.First(System.Int32)">
            <summary>
            Traverses the trie from the initial state for this input byte.
            Equivalent to <c>Reset().Next(inByte)</c>.
            </summary>
            <param name="inByte">Input byte value. Values -0x100..-1 are treated like 0..0xff.
            Values below -0x100 and above 0xff will never match.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Next(System.Int32)">
            <summary>
            Traverses the trie from the current state for this input byte.
            </summary>
            <param name="inByte">Input byte value. Values -0x100..-1 are treated like 0..0xff.
            Values below -0x100 and above 0xff will never match.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Next(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Traverses the trie from the current state for this byte sequence.
            Equivalent to
            <code>
            Result result=Current;
            foreach (var c in s)
            {
                if(!result.HasNext()) return Result.NoMatch;
                result=Next(c);
            }
            return result;
            </code>
            </summary>
            <param name="s">Contains a string or byte sequence.</param>
            <param name="sIndex">The start index of the byte sequence in <paramref name="s"/>.</param>
            <param name="sLimit">The (exclusive) end index of the byte sequence in <paramref name="s"/>.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetValue">
            <summary>
            Returns a matching byte sequence's value if called immediately after
            <see cref="P:ICU4N.Util.BytesTrie.Current"/>/<see cref="M:ICU4N.Util.BytesTrie.First(System.Int32)"/>/<see cref="M:ICU4N.Util.BytesTrie.Next(System.Int32)"/>
            returned <see cref="F:ICU4N.Util.Result.IntermediateValue"/> or <see cref="F:ICU4N.Util.Result.FinalValue"/>.
            <see cref="M:ICU4N.Util.BytesTrie.GetValue"/> can be called multiple times.
            <para/>
            Do not call <see cref="M:ICU4N.Util.BytesTrie.GetValue"/> after <see cref="F:ICU4N.Util.Result.NoMatch"/> or <see cref="F:ICU4N.Util.Result.NoValue"/>!
            </summary>
            <returns>The value for the byte sequence so far.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetUniqueValue">
            <summary>
            Determines whether all byte sequences reachable from the current state
            map to the same value, and if so, returns that value.
            </summary>
            <returns>The unique value in bits 32..1 with bit 0 set,
            if all byte sequences reachable from the current state
            map to the same value; otherwise returns 0.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetNextBytes(System.Text.StringBuilder)">
            <summary>
            Finds each byte which continues the byte sequence from the current state.
            That is, each byte b for which it would be Next(b)!=<see cref="F:ICU4N.Util.Result.NoMatch"/> now.
            </summary>
            <param name="output">Each next byte is 0-extended to a char and appended to this object.
            (Only uses the output.Append(c) method.)</param>
            <returns>The number of bytes which continue the byte sequence from here.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetEnumerator">
            <summary>
            Iterates from the current state of this trie.
            </summary>
            <remarks>
            This is equivalent to iterator() in ICU4J.
            </remarks>
            <returns>A new <see cref="T:ICU4N.Util.BytesTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetEnumerator(System.Int32)">
            <summary>
            Iterates from the current state of this trie.
            </summary>
            <remarks>
            This is equivalent to iterator(int) in ICU4J.
            </remarks>
            <param name="maxStringLength">If 0, the enumerator returns full strings/byte sequences.
            Otherwise, the enumerator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.BytesTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.GetEnumerator(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Iterates from the root of a byte-serialized <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <remarks>
            This is equivalent to iterator(byte[], int, int) in ICU4J.
            </remarks>
            <param name="trieBytes">Bytes array that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the array.</param>
            <param name="maxStringLength">If 0, the enumerator returns full strings/byte sequences.
            Otherwise, the enumerator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.BytesTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.BytesTrie.Entry">
            <summary>
            Return value type for the <see cref="T:ICU4N.Util.BytesTrie.Enumerator"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.BytesTrie.Entry.BytesLength">
            <summary>
            Gets the length of the byte sequence.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Entry.ByteAt(System.Int32)">
            <summary>
            Returns a byte of the byte sequence.
            </summary>
            <remarks>
            This was byteAt(int) in ICU4J.
            </remarks>
            <param name="index">An index into the byte sequence.</param>
            <returns>The index-th byte sequence byte.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Entry.CopyBytesTo(System.Byte[],System.Int32)">
            <summary>
            Copies the byte sequence into a byte array.
            </summary>
            <param name="dest">Destination byte array.</param>
            <param name="destOffset">Starting offset to where in dest the byte sequence is copied.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Entry.BytesAsByteBuffer">
            <summary>
            Returns the byte sequence as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.
            </summary>
            <returns>The byte sequence as a read-only <see cref="T:ICU4N.Support.IO.ByteBuffer"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.BytesTrie.Entry.value">
            <summary>
            The value associated with the byte sequence.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.BytesTrie.Enumerator">
            <summary>
            Iterator for all of the (byte sequence, value) pairs in a <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Enumerator.Reset">
            <summary>
            Resets this iterator to its initial state.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Enumerator.HasNext">
            <summary>
            Returns true if there are more elements.
            </summary>
            <returns>true if there are more elements.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Enumerator.Next">
            <summary>
            Finds the next (byte sequence, value) pair if there is one.
            </summary>
            <remarks>
            If the byte sequence is truncated to the maximum length and does not
            have a real value, then the value is set to -1.
            In this case, this "not a real value" is indistinguishable from
            a real value of -1.
            </remarks>
            <returns>An <see cref="T:ICU4N.Util.BytesTrie.Entry"/> with the string and value of the next element.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.BytesTrie.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrie.Enumerator.MoveNext">
            <summary>
            Finds the next (byte sequence, value) pair if there is one.
            </summary>
            <remarks>
            If the byte sequence is truncated to the maximum length and does not
            have a real value, then the value is set to -1.
            In this case, this "not a real value" is indistinguishable from
            a real value of -1.
            </remarks>
            <returns>Returns true if an element has been set to <see cref="P:ICU4N.Util.BytesTrie.Enumerator.Current"/>; otherwise false.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.BytesTrieBuilder">
            <summary>
            Builder class for <see cref="T:ICU4N.Util.BytesTrie"/>.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <stable>ICU 4.8</stable>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.#ctor">
            <summary>
            Constructs an empty builder.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds a (byte sequence, value) pair.
            The byte sequence must be unique.
            Bytes 0..length-1 will be copied; the builder does not keep
            a reference to the input array.
            </summary>
            <param name="sequence">The array that contains the byte sequence, starting at index 0.</param>
            <param name="length">The length of the byte sequence.</param>
            <param name="value">The value associated with this byte sequence.</param>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)">
             <summary>
             Builds a <see cref="T:ICU4N.Util.BytesTrie"/> for the <see cref="M:ICU4N.Util.BytesTrieBuilder.Add(System.Byte[],System.Int32,System.Int32)"/> appended data.
             Once built, no further data can be added until <see cref="M:ICU4N.Util.BytesTrieBuilder.Clear"/> is called.
            
             <para/>A <see cref="T:ICU4N.Util.BytesTrie"/> cannot be empty. At least one (byte sequence, value) pair
             must have been added.
            
             <para/>Multiple calls to <see cref="M:ICU4N.Util.BytesTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> or <see cref="M:ICU4N.Util.BytesTrieBuilder.BuildByteBuffer(ICU4N.Util.StringTrieBuilder.Option)"/> return tries or buffers
             which share the builder's byte array, without rebuilding.
             <em>The byte array must not be modified via the <see cref="M:ICU4N.Util.BytesTrieBuilder.BuildByteBuffer(ICU4N.Util.StringTrieBuilder.Option)"/> result object.</em>
             After <see cref="M:ICU4N.Util.BytesTrieBuilder.Clear"/> has been called, a new array will be used.
             </summary>
             <param name="buildOption">Build option, see <see cref="T:ICU4N.Util.StringTrieBuilder.Option"/>.</param>
             <returns> A new <see cref="T:ICU4N.Util.BytesTrie"/> for the added data.</returns>
             <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.BuildByteBuffer(ICU4N.Util.StringTrieBuilder.Option)">
             <summary>
             Builds a <see cref="T:ICU4N.Util.BytesTrie"/> for the <see cref="M:ICU4N.Util.BytesTrieBuilder.Add(System.Byte[],System.Int32,System.Int32)"/> appended data and byte-serializes it.
             Once built, no further data can be added until <see cref="M:ICU4N.Util.BytesTrieBuilder.Clear"/> is called.
             <para/>A <see cref="T:ICU4N.Util.BytesTrie"/> cannot be empty. At least one (byte sequence, value) pair
             must have been added.
            
             <para/>Multiple calls to <see cref="M:ICU4N.Util.BytesTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> or <see cref="M:ICU4N.Util.BytesTrieBuilder.BuildByteBuffer(ICU4N.Util.StringTrieBuilder.Option)"/> return tries or buffers
             which share the builder's byte array, without rebuilding.
             <em>Do not modify the bytes in the buffer!</em>
             After <see cref="M:ICU4N.Util.BytesTrieBuilder.Clear"/> has been called, a new array will be used.
            
             <para/>The serialized <see cref="T:ICU4N.Util.BytesTrie"/> is accessible via the buffer's
             <see cref="P:ICU4N.Support.IO.ByteBuffer.Array"/>/<see cref="P:ICU4N.Support.IO.ByteBuffer.ArrayOffset"/>+Position or Remaining/Get(byte[]) etc.
             </summary>
             <param name="buildOption">Build option, see <see cref="T:ICU4N.Util.StringTrieBuilder.Option"/>.</param>
             <returns>A <see cref="T:ICU4N.Support.IO.ByteBuffer"/> with the byte-serialized <see cref="T:ICU4N.Util.BytesTrie"/> for the added data.
             The buffer is not read-only and <see cref="P:ICU4N.Support.IO.ByteBuffer.Array"/> can be called.</returns>
             <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.Clear">
            <summary>
            Removes all (byte sequence, value) pairs.
            New data can then be added and a new trie can be built.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.BytesTrieBuilder.MatchNodesCanHaveValues">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.BytesTrieBuilder.MaxBranchLinearSubNodeLength">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.BytesTrieBuilder.MinLinearMatch">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.BytesTrieBuilder.MaxLinearMatchLength">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.Write(System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.Write(System.Int32,System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.WriteValueAndFinal(System.Int32,System.Boolean)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.WriteValueAndType(System.Boolean,System.Int32,System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.BytesTrieBuilder.WriteDeltaTo(System.Int32)">
            <internal/>
        </member>
        <member name="T:ICU4N.Util.CaseInsensitiveString">
            <summary>
            A string used as a key in <see cref="T:System.Collections.Generic.Dictionary`2"/> and other
            collections.  It retains case information, but its <see cref="M:ICU4N.Util.CaseInsensitiveString.Equals(System.Object)"/> and
            <see cref="M:ICU4N.Util.CaseInsensitiveString.GetHashCode"/> methods ignore case.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Util.CaseInsensitiveString.#ctor(System.String)">
            <summary>
            Constructs an <see cref="T:ICU4N.Util.CaseInsensitiveString"/> object from the given string
            </summary>
            <param name="s">The string to construct this object from.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Util.CaseInsensitiveString.String">
            <summary>
            Gets the underlying string.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Util.CaseInsensitiveString.Equals(System.Object)">
            <summary>
            Compare the object with this.
            </summary>
            <param name="o">Object to compare this object with.</param>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Util.CaseInsensitiveString.GetHashCode">
            <summary>
            Returns the hashCode of this object.
            </summary>
            <returns>int hashcode.</returns>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Util.CaseInsensitiveString.ToString">
            <summary>
            Overrides superclass method.
            </summary>
            <stable>ICU 3.6</stable>
        </member>
        <member name="T:ICU4N.Util.CharsTrie">
            <summary>
            Light-weight, non-const reader class for a CharsTrie.
            Traverses a char-serialized data structure with minimal state,
            for mapping strings (16-bit-unit sequences) to non-negative integer values.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <stable>ICU 4.8</stable>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Clone">
            <summary>
            Clones this trie reader object and its state,
            but not the char array which will be shared.
            </summary>
            <returns>A shallow clone of this trie.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Reset">
            <summary>
            Resets this trie to its initial state.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.CharsTrie.State">
            <summary>
            CharsTrie state object, for saving a trie's current state
            and resetting the trie back to this state later.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.State.#ctor">
            <summary>
            Constructs an empty <see cref="T:ICU4N.Util.CharsTrie.State"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.SaveState(ICU4N.Util.CharsTrie.State)">
            <summary>
            Saves the state of this trie.
            </summary>
            <param name="state">The <see cref="T:ICU4N.Util.CharsTrie.State"/> object to hold the trie's state.</param>
            <returns>This.</returns>
            <see cref="M:ICU4N.Util.CharsTrie.ResetToState(ICU4N.Util.CharsTrie.State)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.ResetToState(ICU4N.Util.CharsTrie.State)">
            <summary>
            Resets this trie to the saved state.
            </summary>
            <param name="state">The State object which holds a saved trie state.</param>
            <returns>This.</returns>
            <exception cref="T:System.ArgumentException">If the state object contains no state,
            or the state of a different trie.</exception>
            <seealso cref="M:ICU4N.Util.CharsTrie.SaveState(ICU4N.Util.CharsTrie.State)"/>
            <seealso cref="M:ICU4N.Util.CharsTrie.Reset"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.CharsTrie.Current">
            <summary>
            Determines whether the byte sequence so far matches, whether it has a value,
            and whether another input byte can continue a matching byte sequence.
            Returns the match/value <see cref="T:ICU4N.Util.Result"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.First(System.Int32)">
            <summary>
            Traverses the trie from the initial state for this input char.
            Equivalent to <c>Reset().Next(inByte)</c>.
            </summary>
            <param name="inUnit">Input char value. Values below 0 and above 0xffff will never match.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.FirstForCodePoint(System.Int32)">
            <summary>
            Traverses the trie from the initial state for the
            one or two UTF-16 code units for this input code point.
            Equivalent to <c>Reset().NextForCodePoint(cp)</c>.
            </summary>
            <param name="cp">A Unicode code point 0..0x10ffff.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Next(System.Int32)">
            <summary>
            Traverses the trie from the current state for this input char.
            </summary>
            <param name="inUnit">Input char value. Values below 0 and above 0xffff will never match.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.NextForCodePoint(System.Int32)">
            <summary>
            Traverses the trie from the current state for the
            one or two UTF-16 code units for this input code point.
            </summary>
            <param name="cp">A Unicode code point 0..0x10ffff.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetValue">
            <summary>
            Returns a matching string's value if called immediately after
            <see cref="P:ICU4N.Util.CharsTrie.Current"/>/<see cref="M:ICU4N.Util.CharsTrie.First(System.Int32)"/>/<see cref="M:ICU4N.Util.CharsTrie.Next(System.Int32)"/>
            returned <see cref="F:ICU4N.Util.Result.IntermediateValue"/> or <see cref="F:ICU4N.Util.Result.FinalValue"/>.
            <see cref="M:ICU4N.Util.CharsTrie.GetValue"/> can be called multiple times.
            <para/>
            Do not call <see cref="M:ICU4N.Util.CharsTrie.GetValue"/> after <see cref="F:ICU4N.Util.Result.NoMatch"/> or <see cref="F:ICU4N.Util.Result.NoValue"/>!
            </summary>
            <returns>The value for the string so far.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetUniqueValue">
            <summary>
            Determines whether all strings reachable from the current state
            map to the same value, and if so, returns that value.
            </summary>
            <returns>The unique value in bits 32..1 with bit 0 set,
            if all strings reachable from the current state
            map to the same value; otherwise returns 0.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetNextChars(System.Text.StringBuilder)">
            <summary>
            Finds each char which continues the string from the current state.
            That is, each char c for which it would be Next(c)!=<see cref="F:ICU4N.Util.Result.NoMatch"/> now.
            </summary>
            <param name="output">Each next char is appended to this object.
            (Only uses the output.Append(c) method.)</param>
            <returns>The number of chars which continue the string from here.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator">
            <summary>
            Iterates from the current state of this trie.
            </summary>
            <remarks>
            This is equivalent to iterator() in ICU4J.
            </remarks>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator(System.Int32)">
            <summary>
            Iterates from the current state of this trie.
            </summary>
            <remarks>
            This is equivalent to iterator(int) in ICU4J.
            </remarks>
            <param name="maxStringLength">If 0, the enumerator returns full strings.
            Otherwise, the enumerator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator(System.String,System.Int32,System.Int32)">
            <summary>
            Iterates from the root of a char-serialized <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <remarks>
            This is equivalent to iterator(ICharSequence, int, int) in ICU4J.
            </remarks>
            <param name="trieChars"><see cref="T:System.String"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:System.String"/>.</param>
            <param name="maxStringLength">If 0, the iterator returns full strings.
            Otherwise, the iterator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Iterates from the root of a char-serialized <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <remarks>
            This is equivalent to iterator(ICharSequence, int, int) in ICU4J.
            </remarks>
            <param name="trieChars"><see cref="T:System.Text.StringBuilder"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="maxStringLength">If 0, the iterator returns full strings.
            Otherwise, the iterator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator(System.Char[],System.Int32,System.Int32)">
            <summary>
            Iterates from the root of a char-serialized <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <remarks>
            This is equivalent to iterator(ICharSequence, int, int) in ICU4J.
            </remarks>
            <param name="trieChars"><see cref="T:char[]"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:char[]"/>.</param>
            <param name="maxStringLength">If 0, the iterator returns full strings.
            Otherwise, the iterator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.GetEnumerator(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Iterates from the root of a char-serialized <see cref="T:ICU4N.Util.BytesTrie"/>.
            </summary>
            <remarks>
            This is equivalent to iterator(ICharSequence, int, int) in ICU4J.
            </remarks>
            <param name="trieChars"><see cref="T:ICU4N.Support.Text.ICharSequence"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:ICU4N.Support.Text.ICharSequence"/>.</param>
            <param name="maxStringLength">If 0, the iterator returns full strings.
            Otherwise, the iterator returns strings with this maximum length.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.CharsTrie.Entry">
            <summary>
            Return value type for the <see cref="T:ICU4N.Util.CharsTrie.Enumerator"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.CharsTrie.Entry.Chars">
            <summary>
            The string.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.CharsTrie.Entry.Value">
            <summary>
            Gets or Sets the value associated with the string.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.CharsTrie.Enumerator">
            <summary>
            Iterator for all of the (string, value) pairs in a <see cref="T:ICU4N.Util.CharsTrie"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Enumerator.Reset">
            <summary>
            Resets this iterator to its initial state.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Enumerator.HasNext">
            <summary>
            Returns true if there are more elements.
            </summary>
            <returns>true if there are more elements.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Enumerator.Next">
            <summary>
            Finds the next (string, value) pair if there is one.
            </summary>
            <remarks>
            If the string is truncated to the maximum length and does not
            have a real value, then the value is set to -1.
            In this case, this "not a real value" is indistinguishable from
            a real value of -1.
            </remarks>
            <returns>An <see cref="T:ICU4N.Util.CharsTrie.Entry"/> with the string and value of the next element.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.CharsTrie.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Enumerator.MoveNext">
            <summary>
            Finds the next (string, value) pair if there is one.
            </summary>
            <remarks>
            If the string is truncated to the maximum length and does not
            have a real value, then the value is set to -1.
            In this case, this "not a real value" is indistinguishable from
            a real value of -1.
            </remarks>
            <returns>Returns true if an element has been set to <see cref="P:ICU4N.Util.CharsTrie.Enumerator.Current"/>; otherwise false.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a CharsTrie reader instance.
            </summary>
            <remarks>
            The <see cref="T:System.String"/> must contain a copy of a char sequence from the <see cref="T:ICU4N.Util.CharsTrieBuilder"/>,
            with the offset indicating the first char of that sequence.
            The <see cref="T:ICU4N.Util.CharsTrie"/> object will not read more chars than
            the <see cref="T:ICU4N.Util.CharsTrieBuilder"/> generated in the corresponding 
            <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> call.
            <para/>
            The <see cref="T:System.String"/> is not copied/cloned and must not be modified while
            the <see cref="T:ICU4N.Util.CharsTrie"/> object is in use.
            </remarks>
            <param name="trieChars"><see cref="T:System.String"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:System.String"/>.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.#ctor(System.Text.StringBuilder,System.Int32)">
            <summary>
            Constructs a CharsTrie reader instance.
            </summary>
            <remarks>
            The <see cref="T:System.Text.StringBuilder"/> must contain a copy of a char sequence from the <see cref="T:ICU4N.Util.CharsTrieBuilder"/>,
            with the offset indicating the first char of that sequence.
            The <see cref="T:ICU4N.Util.CharsTrie"/> object will not read more chars than
            the <see cref="T:ICU4N.Util.CharsTrieBuilder"/> generated in the corresponding 
            <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> call.
            <para/>
            The <see cref="T:System.Text.StringBuilder"/> is not copied/cloned and must not be modified while
            the <see cref="T:ICU4N.Util.CharsTrie"/> object is in use.
            </remarks>
            <param name="trieChars"><see cref="T:System.Text.StringBuilder"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:System.Text.StringBuilder"/>.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.#ctor(System.Char[],System.Int32)">
            <summary>
            Constructs a CharsTrie reader instance.
            </summary>
            <remarks>
            The <see cref="T:char[]"/> must contain a copy of a char sequence from the <see cref="T:ICU4N.Util.CharsTrieBuilder"/>,
            with the offset indicating the first char of that sequence.
            The <see cref="T:ICU4N.Util.CharsTrie"/> object will not read more chars than
            the <see cref="T:ICU4N.Util.CharsTrieBuilder"/> generated in the corresponding 
            <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> call.
            <para/>
            The <see cref="T:char[]"/> is not copied/cloned and must not be modified while
            the <see cref="T:ICU4N.Util.CharsTrie"/> object is in use.
            </remarks>
            <param name="trieChars"><see cref="T:char[]"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:char[]"/>.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.#ctor(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Constructs a CharsTrie reader instance.
            </summary>
            <remarks>
            The <see cref="T:ICU4N.Support.Text.ICharSequence"/> must contain a copy of a char sequence from the <see cref="T:ICU4N.Util.CharsTrieBuilder"/>,
            with the offset indicating the first char of that sequence.
            The <see cref="T:ICU4N.Util.CharsTrie"/> object will not read more chars than
            the <see cref="T:ICU4N.Util.CharsTrieBuilder"/> generated in the corresponding 
            <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> call.
            <para/>
            The <see cref="T:ICU4N.Support.Text.ICharSequence"/> is not copied/cloned and must not be modified while
            the <see cref="T:ICU4N.Util.CharsTrie"/> object is in use.
            </remarks>
            <param name="trieChars"><see cref="T:ICU4N.Support.Text.ICharSequence"/> that contains the serialized trie.</param>
            <param name="offset">Root offset of the trie in the <see cref="T:ICU4N.Support.Text.ICharSequence"/>.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Next(System.String,System.Int32,System.Int32)">
            <summary>
            Traverses the trie from the current state for this string.
            Equivalent to
            <code>
                if(!result.HasNext()) return Result.NoMatch;
                result=Next(c);
                return result;
            </code>
            </summary>
            <param name="s">Contains a string.</param>
            <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
            <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Next(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Traverses the trie from the current state for this string.
            Equivalent to
            <code>
                if(!result.HasNext()) return Result.NoMatch;
                result=Next(c);
                return result;
            </code>
            </summary>
            <param name="s">Contains a string.</param>
            <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
            <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Next(System.Char[],System.Int32,System.Int32)">
            <summary>
            Traverses the trie from the current state for this string.
            Equivalent to
            <code>
                if(!result.HasNext()) return Result.NoMatch;
                result=Next(c);
                return result;
            </code>
            </summary>
            <param name="s">Contains a string.</param>
            <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
            <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrie.Next(ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Traverses the trie from the current state for this string.
            Equivalent to
            <code>
                if(!result.HasNext()) return Result.NoMatch;
                result=Next(c);
                return result;
            </code>
            </summary>
            <param name="s">Contains a string.</param>
            <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
            <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
            <returns>The match/value <see cref="T:ICU4N.Util.Result"/>.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.CharsTrieBuilder">
            <summary>
            Builder class for <see cref="T:ICU4N.Util.CharsTrie"/>.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <stable>ICU 4.8</stable>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.#ctor">
            <summary>
            Constructs an empty builder.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)">
            <summary>
            Adds a (string, value) pair.
            The string must be unique.
            The string contents will be copied; the builder does not keep
            a reference to the input <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            </summary>
            <param name="s">The input string.</param>
            <param name="value">The value associated with this char sequence.</param>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Add(System.Text.StringBuilder,System.Int32)">
            <summary>
            Adds a (string, value) pair.
            The string must be unique.
            The string contents will be copied; the builder does not keep
            a reference to the input <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            </summary>
            <param name="s">The input string.</param>
            <param name="value">The value associated with this char sequence.</param>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Add(System.Char[],System.Int32)">
            <summary>
            Adds a (string, value) pair.
            The string must be unique.
            The string contents will be copied; the builder does not keep
            a reference to the input <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            </summary>
            <param name="s">The input string.</param>
            <param name="value">The value associated with this char sequence.</param>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Add(ICU4N.Support.Text.ICharSequence,System.Int32)">
            <summary>
            Adds a (string, value) pair.
            The string must be unique.
            The string contents will be copied; the builder does not keep
            a reference to the input <see cref="T:ICU4N.Support.Text.ICharSequence"/>.
            </summary>
            <param name="s">The input string.</param>
            <param name="value">The value associated with this char sequence.</param>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)">
            <summary>
            Builds a <see cref="T:ICU4N.Util.CharsTrie"/> for the <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed data.
            Once built, no further data can be <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed until <see cref="M:ICU4N.Util.CharsTrieBuilder.Clear"/> is called.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Util.CharsTrie"/> cannot be empty. At least one (string, value) pair
            must have been <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed.
            <para/>
            Multiple calls to <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> or <see cref="M:ICU4N.Util.CharsTrieBuilder.BuildCharSequence(ICU4N.Util.StringTrieBuilder.Option)"/> return tries or sequences
            which share the builder's char array, without rebuilding.
            After <see cref="M:ICU4N.Util.CharsTrieBuilder.Clear"/> has been called, a new array will be used.
            </remarks>
            <param name="buildOption">Build option, see <see cref="T:ICU4N.Util.StringTrieBuilder.Option"/>.</param>
            <returns>A new <see cref="T:ICU4N.Util.CharsTrie"/> for the <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed data.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.BuildCharSequence(ICU4N.Util.StringTrieBuilder.Option)">
            <summary>
            Builds a <see cref="T:ICU4N.Util.CharsTrie"/> for the <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed data and char-serializes it.
            Once built, no further data can be <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed until <see cref="M:ICU4N.Util.CharsTrieBuilder.Clear"/> is called.
            </summary>
            <remarks>
            A <see cref="T:ICU4N.Util.CharsTrie"/> cannot be empty. At least one (string, value) pair
            must have been <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed.
            <para/>
            Multiple calls to <see cref="M:ICU4N.Util.CharsTrieBuilder.Build(ICU4N.Util.StringTrieBuilder.Option)"/> or <see cref="M:ICU4N.Util.CharsTrieBuilder.BuildCharSequence(ICU4N.Util.StringTrieBuilder.Option)"/> return tries or sequences
            which share the builder's char array, without rebuilding.
            After <see cref="M:ICU4N.Util.CharsTrieBuilder.Clear"/> has been called, a new array will be used.
            </remarks>
            <param name="buildOption">Build option, see <see cref="T:ICU4N.Util.StringTrieBuilder.Option"/>.</param>
            <returns>A <see cref="T:ICU4N.Support.Text.ICharSequence"/> with the char-serialized <see cref="T:ICU4N.Util.CharsTrie"/> for the <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed data.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Clear">
            <summary>
            Removes all (string, value) pairs.
            New data can then be <see cref="M:ICU4N.Util.CharsTrieBuilder.Add(System.String,System.Int32)"/>ed and a new trie can be built.
            </summary>
            <returns>This.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Util.CharsTrieBuilder.MatchNodesCanHaveValues">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.CharsTrieBuilder.MaxBranchLinearSubNodeLength">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.CharsTrieBuilder.MinLinearMatch">
            <internal/>
        </member>
        <member name="P:ICU4N.Util.CharsTrieBuilder.MaxLinearMatchLength">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Write(System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.Write(System.Int32,System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.WriteValueAndFinal(System.Int32,System.Boolean)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.WriteValueAndType(System.Boolean,System.Int32,System.Int32)">
            <internal/>
        </member>
        <member name="M:ICU4N.Util.CharsTrieBuilder.WriteDeltaTo(System.Int32)">
            <internal/>
        </member>
        <member name="T:ICU4N.Util.IFreezable`1">
            <summary>
            Provides a flexible mechanism for controlling access, without requiring that
            a class be immutable.
            </summary>
            <remarks>
            Once frozen, an object can never be unfrozen, so it is
            thread-safe from that point onward. Once the object has been frozen, 
            it must guarantee that no changes can be made to it. Any attempt to alter 
            it must raise a <see cref="T:System.NotSupportedException"/> exception. This means that when 
            the object returns internal objects, or if anyone has references to those internal
            objects, that those internal objects must either be immutable, or must also
            raise exceptions if any attempt to modify them is made. Of course, the object
            can return clones of internal objects, since those are safe.
            <para/>
            <h2>Background</h2>
            <para/>
            There are often times when you need objects to be objects 'safe', so that
            they can't be modified. Examples are when objects need to be thread-safe, or
            in writing robust code, or in caches. If you are only creating your own
            objects, you can guarantee this, of course -- but only if you don't make a
            mistake. If you have objects handed into you, or are creating objects using
            others handed into you, it is a different story. It all comes down to whether
            you want to take the Blanche Dubois approach (&quot;depend on the kindness of
            strangers&quot;) or the Andy Grove approach (&quot;Only the Paranoid
            Survive&quot;).
            <para/>
            For example, suppose we have a simple class:
            <code>
            public class A
            {
                public ICollection{string} B { get; protected set; }
                public ICollection{string} C { get; protected set; }
                
                public A(ICollection{string} b, ICollection{string} c)
                {
                    this.B = b;
                    this.C = c;
                }
            }
            </code>
            <para/>
            Since the class doesn't have any public setters, someone might think that it is
            immutable. You know where this is leading, of course; this class is unsafe in
            a number of ways. The following illustrates that.
            <code>
            public Test1(SupposedlyImmutableClass x, SafeStorage y)
            {
                // unsafe getter
                A a = x.A;
                ICollection{string} col = a.B;
                col.Add(something); // a has now been changed, and x too
                
                // unsafe constructor
                a = new A(col, col);
                y.Store(a);
                col.Add(something); // a has now been changed, and y too
            }
            </code>
            <para/>
            There are a few different techniques for having safe classes.
            <para/>
            <list type="number">
                <item><term>Const objects.</term><description>In C++, you can declare parameters const.</description></item>
                <item><term>Immutable wrappers.</term><description>For example, you can put a collection in an immutable wrapper.</description></item>
                <item><term>Always-Immutable objects.</term><description>.NET uses this approach, with a few variations. Examples:
                    <list type="number">
                        <item><term>Simple.</term><description>Once a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> is created it is immutable.</description></item>
                        <item><term>Builder Class.</term><description>
                            There is a separate 'builder' class. For example, modifiable Strings are created using 
                            <see cref="T:System.Text.StringBuilder"/> (which doesn't have the
                            full String API available). Once you want an immutable form, you create one
                            with <see cref="M:System.Text.StringBuilder.ToString"/>.</description></item>
                        <item><term>Primitives.</term><description>These are always safe, since they are copied on input/output from methods.</description></item>
                        <item><term></term><description></description></item>
                        <item><term></term><description></description></item>
                    </list>
                </description></item>
                <item><term>Cloning.</term><description>Where you need an object to be safe, you clone it.</description></item>
            </list>
            <para/>
            There are advantages and disadvantages of each of these.
            <list type="number">
                <item><description>
                    Const provides a certain level of protection, but since const can be and
                    is often cast away, it only protects against most inadvertent mistakes. It
                    also offers no threading protection, since anyone who has a pointer to the
                    (unconst) object in another thread can mess you up.
                </description></item>
                <item><description>
                    Immutable wrappers are safer than const in that the constness can't be
                    cast away. But other than that they have all the same problems: not safe if
                    someone else keeps hold of the original object, or if any of the objects
                    returned by the class are mutable.
                </description></item>
                <item><description>
                    Always-Immutable Objects are safe, but usage can require excessive
                    object creation.
                </description></item>
                <item><description>
                    Cloning is only safe if the object truly has a 'safe' clone; defined as
                    one that <i>ensures that no change to the clone affects the original</i>.
                    Unfortunately, many objects don't have a 'safe' clone, and always cloning can
                    require excessive object creation.
                </description></item>
            </list>
            <para/>
            <h2>Freezable Model</h2>
            <para/>
            The <see cref="T:ICU4N.Util.IFreezable`1"/> model supplements these choices by giving you
            the ability to build up an object by calling various methods, then when it is
            in a final state, you can <i>make</i> it immutable. Once immutable, an
            object cannot <i>ever </i>be modified, and is completely thread-safe: that
            is, multiple threads can have references to it without any synchronization.
            If someone needs a mutable version of an object, they can use
            <see cref="M:ICU4N.Util.IFreezable`1.CloneAsThawed"/>, and modify the copy. This provides a simple,
            effective mechanism for safe classes in circumstances where the alternatives
            are insufficient or clumsy. (If an object is shared before it is immutable,
            then it is the responsibility of each thread to mutex its usage (as with
            other objects).)
            <para/>
            Here is what needs to be done to implement this interface, depending on the
            type of the object.
            <para/>
            <h3><b>Immutable Objects</b></h3>
            <para/>
            These are the easiest. You just use the interface to reflect that, by adding
            the following:
            <code>
            public class A : IFreezable&lt;A&gt;
            {
                public bool IsFrozen { get { return true; } }
                public A Freeze() { return this; }
                public A CloneAsThawed() { return this; }
            }
            </code>
            <para/>
            These can be sealed methods because subclasses of immutable objects must
            themselves be immutable. (Note: <see cref="M:ICU4N.Util.IFreezable`1.Freeze"/> is returning
            <c>this</c> for chaining.)
            <para/>
            <h3><b>Mutable Objects</b></h3>
            <para/>
            Add a protected 'flagging' field:
            <code>
            protected volatile bool frozen; // WARNING: must be volatile
            </code>
            <para/>
            Add the following methods:
            <code>
            public bool IsFrozen()
            {
                return frozen;
            }
            
            public A Freeze()
            {
                frozen = true;  // WARNING: must be final statement before return
                return this;
            }
            </code>
            <para/>
            Add a <see cref="M:ICU4N.Util.IFreezable`1.CloneAsThawed"/> method following the normal pattern for
            <c>ICloneable.Clone()</c>, except that <c>frozen=false</c> in the new
            clone.
            <para/>
            Then take the setters (that is, any member that can change the internal state
            of the object), and add the following as the first statement:
            <code>
            if (IsFrozen)
            {
                throw new NotSupportedException(&quot;Attempt to modify frozen object&quot;);
            }
            </code>
            <para/>
            <h4><b>Subclassing</b></h4>
            <para/>
            Any subclass of a <see cref="T:ICU4N.Util.IFreezable`1"/> will just use its superclass's
            flagging field. It must override <see cref="M:ICU4N.Util.IFreezable`1.Freeze"/> and
            <see cref="M:ICU4N.Util.IFreezable`1.CloneAsThawed"/> to call the superclass, but normally does not
            override <see cref="P:ICU4N.Util.IFreezable`1.IsFrozen"/>. It must then just pay attention to its
            own properties, methods and fields.
            <para/>
            <h4><b>Internal Caches</b></h4>
            <para/>
            Internal caches are cases where the object is logically unmodified, but
            internal state of the object changes. For example, there are const C++
            functions that cast away the const on the &quot;this&quot; pointer in order
            to modify an object cache. These cases are handled by mutexing the internal
            cache to ensure thread-safety. For example, suppose that <see cref="T:ICU4N.Text.UnicodeSet"/> had an
            internal marker to the last code point accessed. In this case, the field is
            not externally visible, so the only thing you need to do is to synchronize
            the field for thread safety.
            <para/>
            <h4>Unsafe Internal Access</h4>
            <para/>
            Internal fields are called <i>safe</i> if they are either
            <c>frozen</c> or immutable (such as string or primitives). If you've
            never allowed internal access to these, then you are all done. For example,
            converting <see cref="T:ICU4N.Text.UnicodeSet"/> to be <see cref="T:ICU4N.Util.IFreezable`1"/> is just accomplished
            with the above steps. But remember that you <i><b>have</b></i> allowed
            access to unsafe internals if you have any code like the following, in a
            getter, setter, or constructor:
            <code>
            ICollection{string} Stuff
            {
                get { return stuff; } // caller could keep reference &amp; modify
                set { stuff = value; } // caller could keep reference &amp; modify
            }
            
            MyClass(ICollection{string} x) // caller could keep reference &amp; modify
            {
                stuff = x;
            }
            </code>
            <para/>
            These also illustrated in the code sample in <b>Background</b> above.
            <para/>
            To deal with unsafe internals, the simplest course of action is to do the
            work in the <see cref="M:ICU4N.Util.IFreezable`1.Freeze"/> function. Just make all of your internal
            fields frozen, and set the frozen flag. Any subsequent getter/setter will
            work properly. Here is an example:
            <para/>
            <b>Warning!</b> The 'frozen' boolean MUST be volatile, and must be set as the last statement
            in the method.
            <para/>
            <code>
            public A Freeze()
            {
                if (!frozen)
                {
                    foo.Freeze();
                    frozen = true;
                }
                return this;
            }
            </code>
            If the field is a collection or dictionary, then to
            make it frozen you have two choices. If you have never allowed access to the
            collection from outside your object, then just wrap it to prevent future
            modification.
            <code>
            zone_to_country = zone_to_country.ToUnmodifiableDictionary();
            </code>
            <para/>
            If you have <i>ever</i> allowed access, then do a <c>Clone()</c>
            before wrapping it.
            <code>
            zone_to_country = ((IDictionary{string, string})zone_to_country.Clone()).ToUnmodifiableDictionary();
            </code>
            <para/>
            If a collection <i>(or any other container of objects)</i> itself can
            contain mutable objects, then for a safe clone you need to recurse through it
            to make the entire collection immutable. The recursing code should pick the
            most specific collection available, to avoid the necessity of later
            downcasing.
            <para/>
            <b>Note: </b>An annoying flaw in .NET is that the generic collections, like
            <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/>, 
            don't have a <c>Clone()</c> operation. When you don't know the type of the collection, the simplest
            course is to just create a new collection:
            <code>
            zone_to_country = new Dictionary(zone_to_country).ToUnmodifiableDictionary();
            </code>
            </remarks>
            <typeparam name="T">Type of item to freeze.</typeparam>
            <stable>ICU 3.8</stable>
        </member>
        <member name="P:ICU4N.Util.IFreezable`1.IsFrozen">
            <summary>
            Determines whether the object has been frozen or not.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.IFreezable`1.Freeze">
            <summary>
            Freezes the object.
            </summary>
            <returns>The object itself.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.IFreezable`1.CloneAsThawed">
            <summary>
            Provides for the clone operation. Any clone is initially unfrozen.
            </summary>
            <returns>The cloned object.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Util.ICUException">
            <summary>
            Base class for unchecked, ICU-specific exceptions.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUException.#ctor">
            <summary>
            Default constructor.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Exception message strings</param>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUException.#ctor(System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="innerException">Original exception.</param>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Exception message string.</param>
            <param name="innerException">Original exception.</param>
            <stable>ICU 53</stable>
        </member>
        <member name="T:ICU4N.Util.ICUUncheckedIOException">
            <summary>
            Unchecked version of <see cref="T:System.IO.IOException"/>.
            Some ICU APIs do not throw the standard exception but instead wrap it
            into this unchecked version.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUUncheckedIOException.#ctor">
            <summary>
            Default constructor.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUUncheckedIOException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">exception message string</param>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUUncheckedIOException.#ctor(System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="innerException">original exception</param>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Util.ICUUncheckedIOException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">exception message string</param>
            <param name="innerException">original exception</param>
            <stable>ICU 53</stable>
        </member>
        <member name="T:ICU4N.Util.IllformedLocaleException">
            <summary>
            Thrown by methods in <see cref="T:ICU4N.Util.ULocale"/> and <see cref="T:ICU4N.Util.ULocale.Builder"/> to
            indicate that an argument is not a well-formed BCP 47 tag.
            </summary>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Util.IllformedLocaleException.#ctor">
            <summary>
            Constructs a new <see cref="T:ICU4N.Util.IllformedLocaleException"/> with no
            detail message and -1 as the error index.
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Util.IllformedLocaleException.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Util.IllformedLocaleException"/> with the
            given message and -1 as the error index.
            </summary>
            <param name="message">The message.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Util.IllformedLocaleException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Util.IllformedLocaleException"/> with the
            given message, inner exception and -1 as the error index.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The original exception.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Util.IllformedLocaleException.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new <see cref="T:ICU4N.Util.IllformedLocaleException"/> with the
            given message and the error index.  The error index is the approximate
            offset from the start of the ill-formed value to the point where the
            parse first detected an error.  A negative error index value indicates
            either the error index is not applicable or unknown.
            </summary>
            <param name="message">The message.</param>
            <param name="errorIndex">The index.</param>
            <stable>ICU 4.2</stable>
        </member>
        <member name="P:ICU4N.Util.IllformedLocaleException.ErrorIndex">
            <summary>
            Returns the index where the error was found. A negative value indicates
            either the error index is not applicable or unknown.
            </summary>
            <returns>the error index</returns>
            <stable>ICU 4.2</stable>
        </member>
        <member name="T:ICU4N.Util.LocaleData">
            <summary>
            A class for accessing miscellaneous data in the locale bundles
            </summary>
            <author>ram</author>
            <stable>2.8</stable>
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_STANDARD">
            EXType for {@link #getExemplarSet(int, int)}.
            Corresponds to the 'main' (aka 'standard') CLDR exemplars in
            <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
              http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_AUXILIARY">
            EXType for {@link #getExemplarSet(int, int)}.
            Corresponds to the 'auxiliary' CLDR exemplars in
            <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
              http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_INDEX">
            EXType for {@link #getExemplarSet(int, int)}.
            Corresponds to the 'index' CLDR exemplars in
            <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
              http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
            @stable ICU 4.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_CURRENCY">
            EXType for {@link #getExemplarSet(int, int)}.
            Corresponds to the 'currencySymbol' CLDR exemplars in
            <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
              http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
            Note: This type is no longer supported.
            @deprecated ICU 51
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_PUNCTUATION">
            Corresponds to the 'punctuation' CLDR exemplars in
            <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
              http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
            EXType for {@link #getExemplarSet(int, int)}.
            @stable ICU 49
        </member>
        <member name="F:ICU4N.Util.LocaleData.ES_COUNT">
            Count of EXTypes for {@link #getExemplarSet(int, int)}.
            @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
        </member>
        <member name="F:ICU4N.Util.LocaleData.QUOTATION_START">
            Delimiter type for {@link #getDelimiter(int)}.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.QUOTATION_END">
            Delimiter type for {@link #getDelimiter(int)}.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.ALT_QUOTATION_START">
            Delimiter type for {@link #getDelimiter(int)}.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.ALT_QUOTATION_END">
            Delimiter type for {@link #getDelimiter(int)}.
            @stable ICU 3.4
        </member>
        <member name="F:ICU4N.Util.LocaleData.DELIMITER_COUNT">
            Count of delimiter types for {@link #getDelimiter(int)}.
            @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
        </member>
        <member name="M:ICU4N.Util.LocaleData.#ctor">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetExemplarSet(ICU4N.Util.ULocale,ICU4N.Text.PatternOptions)">
            CLOVER:ON
             Returns the set of exemplar characters for a locale. Equivalent to calling {@link #getExemplarSet(ULocale, int, int)} with
             the extype == {@link #ES_STANDARD}.
            
             @param locale    Locale for which the exemplar character set
                              is to be retrieved.
             @param options   Bitmask for options to apply to the exemplar pattern.
                              Specify zero to retrieve the exemplar set as it is
                              defined in the locale data.  Specify
                              UnicodeSet.CASE to retrieve a case-folded exemplar
                              set.  See {@link UnicodeSet#applyPattern(String,
                              int)} for a complete list of valid options.  The
                              IGNORE_SPACE bit is always set, regardless of the
                              value of 'options'.
             @return          The set of exemplar characters for the given locale.
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetExemplarSet(ICU4N.Util.ULocale,ICU4N.Text.PatternOptions,System.Int32)">
             Returns the set of exemplar characters for a locale.
             Equivalent to calling new LocaleData(locale).{@link #getExemplarSet(int, int)}.
            
             @param locale    Locale for which the exemplar character set
                              is to be retrieved.
             @param options   Bitmask for options to apply to the exemplar pattern.
                              Specify zero to retrieve the exemplar set as it is
                              defined in the locale data.  Specify
                              UnicodeSet.CASE to retrieve a case-folded exemplar
                              set.  See {@link UnicodeSet#applyPattern(String,
                              int)} for a complete list of valid options.  The
                              IGNORE_SPACE bit is always set, regardless of the
                              value of 'options'.
             @param extype    The type of exemplar character set to retrieve.
             @return          The set of exemplar characters for the given locale.
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetExemplarSet(ICU4N.Text.PatternOptions,System.Int32)">
             Returns the set of exemplar characters for a locale.
            
             @param options   Bitmask for options to apply to the exemplar pattern.
                              Specify zero to retrieve the exemplar set as it is
                              defined in the locale data.  Specify
                              UnicodeSet.CASE to retrieve a case-folded exemplar
                              set.  See {@link UnicodeSet#applyPattern(String,
                              int)} for a complete list of valid options.  The
                              IGNORE_SPACE bit is always set, regardless of the
                              value of 'options'.
             @param extype    The type of exemplar set to be retrieved,
                              ES_STANDARD, ES_INDEX, ES_AUXILIARY, or ES_PUNCTUATION
             @return          The set of exemplar characters for the given locale.
                              If there is nothing available for the locale,
                              then null is returned if {@link #getNoSubstitute()} is true, otherwise the
                              root value is returned (which may be UnicodeSet.EMPTY).
             @exception       RuntimeException if the extype is invalid.
             @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetInstance(ICU4N.Util.ULocale)">
             Gets the LocaleData object associated with the ULocale specified in locale
            
             @param locale    Locale with thich the locale data object is associated.
             @return          A locale data object.
             @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetInstance">
             Gets the LocaleData object associated with the default <code>FORMAT</code> locale
            
             @return          A locale data object.
             @see Category#FORMAT
             @stable ICU 3.4
        </member>
        <member name="P:ICU4N.Util.LocaleData.NoSubstitute">
            **
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetDelimiter(System.Int32)">
             Retrieves a delimiter string from the locale data.
            
             @param type      The type of delimiter string desired.  Currently,
                              the valid choices are QUOTATION_START, QUOTATION_END,
                              ALT_QUOTATION_START, or ALT_QUOTATION_END.
             @return          The desired delimiter string.
             @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.LocaleData.MeasurementTypeBundleForLocale(ICU4N.Util.ULocale,System.String)">
            Utility for getMeasurementSystem and getPaperSize
        </member>
        <member name="T:ICU4N.Util.LocaleData.MeasurementSystem">
            Enumeration for representing the measurement systems.
            @stable ICU 2.8
        </member>
        <member name="F:ICU4N.Util.LocaleData.MeasurementSystem.SI">
            Measurement system specified by Le Syst&#x00E8;me International d'Unit&#x00E9;s (SI)
            otherwise known as Metric system.
            @stable ICU 2.8
        </member>
        <member name="F:ICU4N.Util.LocaleData.MeasurementSystem.US">
            Measurement system followed in the United States of America.
            @stable ICU 2.8
        </member>
        <member name="F:ICU4N.Util.LocaleData.MeasurementSystem.UK">
            Mix of metric and imperial units used in Great Britain.
            @stable ICU 55
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetMeasurementSystem(ICU4N.Util.ULocale)">
             Returns the measurement system used in the locale specified by the locale.
            
             @param locale      The locale for which the measurement system to be retrieved.
             @return MeasurementSystem the measurement system used in the locale.
             @stable ICU 3.0
        </member>
        <member name="T:ICU4N.Util.LocaleData.PaperSize">
            A class that represents the size of letter head
            used in the country
            @stable ICU 2.8
        </member>
        <member name="P:ICU4N.Util.LocaleData.PaperSize.Height">
            Retruns the height of the paper
            @return the height
            @stable ICU 2.8
        </member>
        <member name="P:ICU4N.Util.LocaleData.PaperSize.Width">
            Returns the width of the paper
            @return the width
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetPaperSize(ICU4N.Util.ULocale)">
            Returns the size of paper used in the locale. The paper sizes returned are always in
            <em>milli-meters</em>.
            @param locale The locale for which the measurement system to be retrieved.
            @return The paper size used in the locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetLocaleDisplayPattern">
            Returns LocaleDisplayPattern for this locale, e.g., {0}({1})
            @return locale display pattern as a String.
            @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetLocaleSeparator">
            Returns LocaleDisplaySeparator for this locale.
            @return locale display separator as a char.
            @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.LocaleData.GetCLDRVersion">
            Returns the current CLDR version
            @stable ICU 4.2
        </member>
        <member name="T:ICU4N.Util.RangeValueEnumeratorElement">
            <summary>
            Return result wrapper for <see cref="T:ICU4N.Util.IRangeValueEnumerator"/>.
            Stores the start and limit of the continous result range and the
            common value all integers between [start, limit - 1] has.
            </summary>
            <remarks>
            This is equivalent to RangeValueIterator.Element in ICU4J.
            </remarks>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.RangeValueEnumeratorElement.Start">
            <summary>
            Starting integer of the continuous result range that has the same
            value.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.RangeValueEnumeratorElement.Limit">
            <summary>
            (End + 1) integer of continuous result range that has the same
            value.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.RangeValueEnumeratorElement.Value">
            <summary>
            Gets the common value of the continous result range.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.RangeValueEnumeratorElement.#ctor">
            <summary>
            Empty default constructor.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="T:ICU4N.Util.IRangeValueEnumerator">
            <summary>
            Interface for enabling iteration over sets of &lt;int index, int value&gt;,
            where index is the sorted integer index in ascending order and value, its
            associated integer value.
            </summary>
            <remarks>
            The result for each iteration is the consecutive range of
            &lt;int index, int value&gt; with the same value. Result is represented by
            &lt;start, limit, value&gt; where
            <list type="bullet">
                <item><description>start is the starting integer of the result range</description></item>
                <item><description>
                    limit is 1 after the maximum integer that follows start, such that
                    all integers between start and (limit - 1), inclusive, have the same
                    associated integer value.
                </description></item>
                <item><description>
                    value is the integer value that all integers from start to (limit - 1)
                    share in common.
                </description></item>
            </list>
            <para/>
            Hence value(start) = value(start + 1) = .... = value(start + n) = .... =
            value(limit - 1). However value(start -1) != value(start) and
            value(limit) != value(start).
            <para/>
            Most implementations will be created by factory methods, such as the
            character type iterator in <see cref="M:ICU4N.UChar.GetTypeEnumerator"/>. See example below.
            <para/>
            This is equivalent to RangeValueIterator in ICU4J.
            </remarks>
        </member>
        <member name="P:ICU4N.Util.IRangeValueEnumerator.Current">
            <summary>
            Gets the current <see cref="T:ICU4N.Util.RangeValueEnumeratorElement"/> in the iteration.
            </summary>
        </member>
        <member name="M:ICU4N.Util.IRangeValueEnumerator.MoveNext">
            <summary>
            Returns the next maximal result range with a common value and returns
            true if we are not at the end of the iteration, false otherwise.
            </summary>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.RangeValueEnumeratorElement"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.IRangeValueEnumerator.Reset">
            <summary>
            Resets the iterator to the beginning of the iteration.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Util.StringTrieBuilder">
            <summary>
            Base class for string trie builder classes.
            <para/>
            This class is not intended for public subclassing.
            </summary>
            <author>Markus W. Scherer</author>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Util.StringTrieBuilder.Option">
            <summary>
            Build options for <see cref="T:ICU4N.Util.BytesTrieBuilder"/> and <see cref="T:ICU4N.Util.CharsTrieBuilder"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.StringTrieBuilder.Option.FAST">
            <summary>
            Builds a trie quickly.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Util.StringTrieBuilder.Option.SMALL">
            <summary>
            Builds a trie more slowly, attempting to generate
            a shorter but equivalent serialization.
            This build option also uses more memory.
            <para/>
            This option can be effective when many integer values are the same
            and string/byte sequence suffixes can be shared.
            Runtime speed is not expected to improve.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Util.StringTrieBuilder.RegisterNode(ICU4N.Util.StringTrieBuilder.Node)">
            <summary>
            Makes sure that there is only one unique node registered that is
            equivalent to <paramref name="newNode"/>, unless <see cref="F:ICU4N.Util.StringTrieBuilder.State.BUILDING_FAST"/>.
            </summary>
            <param name="newNode">Input node. The builder takes ownership.</param>
            <returns><paramref name="newNode"/> if it is the first of its kind, or
            an equivalent node if <paramref name="newNode"/> is a duplicate.</returns>
        </member>
        <member name="M:ICU4N.Util.StringTrieBuilder.RegisterFinalValue(System.Int32)">
            <summary>
            Makes sure that there is only one unique <see cref="T:ICU4N.Util.StringTrieBuilder.ValueNode"/> registered
            with this value.
            Avoids creating a node if the value is a duplicate.
            </summary>
            <param name="value">A final value.</param>
            <returns>A <see cref="T:ICU4N.Util.StringTrieBuilder.ValueNode"/> with the given value.</returns>
        </member>
        <member name="M:ICU4N.Util.StringTrieBuilder.Node.Add(ICU4N.Util.StringTrieBuilder,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Recursive method for adding a new (string, value) pair.
            Matches the remaining part of <paramref name="s"/> from <paramref name="start"/>,
            and adds a new node where there is a mismatch.
            </summary>
            <returns>This or a replacement <see cref="T:ICU4N.Util.StringTrieBuilder.Node"/>.</returns>
        </member>
        <member name="M:ICU4N.Util.StringTrieBuilder.Node.Register(ICU4N.Util.StringTrieBuilder)">
            <summary>
            Recursive method for registering unique nodes,
            after all (string, value) pairs have been added.
            Final-value nodes are pre-registered while 
            <see cref="M:ICU4N.Util.StringTrieBuilder.Node.Add(ICU4N.Util.StringTrieBuilder,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)"/>ing 
            (string, value) pairs. Other nodes created while 
            <see cref="M:ICU4N.Util.StringTrieBuilder.Node.Add(ICU4N.Util.StringTrieBuilder,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32)"/>ing 
            <see cref="M:ICU4N.Util.StringTrieBuilder.RegisterNode(ICU4N.Util.StringTrieBuilder.Node)"/> themselves later and might replace 
            themselves with new types of nodes for <see cref="M:ICU4N.Util.StringTrieBuilder.Node.Write(ICU4N.Util.StringTrieBuilder)"/>ing.
            </summary>
            <returns>The registered version of this node which implements <see cref="M:ICU4N.Util.StringTrieBuilder.Node.Write(ICU4N.Util.StringTrieBuilder)"/>.</returns>
        </member>
        <member name="M:ICU4N.Util.StringTrieBuilder.Node.MarkRightEdgesFirst(System.Int32)">
            <summary>
            Traverses the <see cref="T:ICU4N.Util.StringTrieBuilder.Node"/> graph and numbers branch edges, with rightmost edges first.
            This is to avoid writing a duplicate node twice.
            </summary>
            <remarks>
            Branch nodes in this trie data structure are not symmetric.
            Most branch edges "jump" to other nodes but the rightmost branch edges
            just continue without a jump.
            Therefore, <see cref="M:ICU4N.Util.StringTrieBuilder.Node.Write(ICU4N.Util.StringTrieBuilder)"/> must write the rightmost branch edge last
            (trie units are written backwards), and must write it at that point even if
            it is a duplicate of a node previously written elsewhere.
            <para/>
            This function visits and marks right branch edges first.
            Edges are numbered with increasingly negative values because we share the
            offset field which gets positive values when nodes are written.
            A branch edge also remembers the first number for any of its edges.
            <para/>
            When a further-left branch edge has a number in the range of the rightmost
            edge's numbers, then it will be written as part of the required right edge
            and we can avoid writing it first.
            <para/>
            After root.MarkRightEdgesFirst(-1) the offsets of all nodes are negative
            edge numbers.
            </remarks>
            <param name="edgeNumber">The first edge number for this node and its sub-nodes.</param>
            <returns>An edge number that is at least the maximum-negative
            of the input edge number and the numbers of this node and all of its sub-nodes.</returns>
        </member>
        <member name="F:ICU4N.Util.ULocale.ENGLISH">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.FRENCH">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.GERMAN">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.ITALIAN">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.JAPANESE">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.KOREAN">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.CHINESE">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.SIMPLIFIED_CHINESE">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.TRADITIONAL_CHINESE">
            Useful constant for language.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.FRANCE">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.GERMANY">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.ITALY">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.JAPAN">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.KOREA">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.CHINA">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.PRC">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.TAIWAN">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.UK">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.US">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.CANADA">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.CANADA_FRENCH">
            Useful constant for country/region.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.EMPTY_STRING">
            Handy constant.
        </member>
        <member name="F:ICU4N.Util.ULocale.ROOT">
            The root ULocale.
            @stable ICU 2.8
        </member>
        <member name="T:ICU4N.Util.ULocale.Category">
            Enum for locale categories. These locale categories are used to get/set the default locale for
            the specific functionality represented by the category.
            @stable ICU 49
        </member>
        <member name="F:ICU4N.Util.ULocale.Category.DISPLAY">
            Category used to represent the default locale for displaying user interfaces.
            @stable ICU 49
        </member>
        <member name="F:ICU4N.Util.ULocale.Category.FORMAT">
            Category used to represent the default locale for formatting date, number and/or currency.
            @stable ICU 49
        </member>
        <member name="F:ICU4N.Util.ULocale.locale">
            Cache the locale.
        </member>
        <member name="F:ICU4N.Util.ULocale.localeID">
            The raw localeID that we were passed in.
        </member>
        <member name="F:ICU4N.Util.ULocale.baseLocale">
            Cache the locale data container fields.
            In future, we want to use them as the primary locale identifier storage.
        </member>
        <member name="F:ICU4N.Util.ULocale.CANONICALIZE_MAP">
            This table lists pairs of locale ids for canonicalization.  The
            The 1st item is the normalized id. The 2nd item is the
            canonicalized id. The 3rd is the keyword. The 4th is the keyword value.
        </member>
        <member name="F:ICU4N.Util.ULocale.variantsToKeywords">
            This table lists pairs of locale ids for canonicalization.
            The first item is the normalized variant id.
        </member>
        <member name="M:ICU4N.Util.ULocale.#ctor(System.String,System.Globalization.CultureInfo)">
            Private constructor used by static initializers.
        </member>
        <member name="M:ICU4N.Util.ULocale.#ctor(System.Globalization.CultureInfo)">
            Construct a ULocale object from a {@link java.util.Locale}.
            @param loc a {@link java.util.Locale}
        </member>
        <member name="M:ICU4N.Util.ULocale.ForLocale(System.Globalization.CultureInfo)">
            {@icu} Returns a ULocale object for a {@link java.util.Locale}.
            The ULocale is canonicalized.
            @param loc a {@link java.util.Locale}
            @stable ICU 3.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.#ctor(System.String)" -->
        <member name="M:ICU4N.Util.ULocale.#ctor(System.String,System.String)">
            Convenience overload of ULocale(string, string, string) for
            compatibility with java.util.Locale.
            @see #ULocale(string, string, string)
            @stable ICU 3.4
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.#ctor(System.String,System.String,System.String)" -->
        <member name="M:ICU4N.Util.ULocale.CreateCanonical(System.String)">
            {@icu} Creates a ULocale from the id by first canonicalizing the id.
            @param nonCanonicalID the locale id to canonicalize
            @return the locale created from the canonical version of the ID.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.ToLocale">
            {@icu} Converts this ULocale object to a {@link java.util.Locale}.
            @return a {@link java.util.Locale} that either exactly represents this object
            or is the closest approximation.
            @stable ICU 2.8
        </member>
        <member name="F:ICU4N.Util.ULocale.defaultLocale">
            Keep our own default ULocale.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.GetDefault" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.SetDefault(ICU4N.Util.ULocale)" -->
        <member name="M:ICU4N.Util.ULocale.GetDefault(ICU4N.Util.ULocale.Category)">
             Returns the current default ULocale for the specified category.
            
             @param category the category
             @return the default ULocale for the specified category.
             @stable ICU 49
        </member>
        <member name="M:ICU4N.Util.ULocale.SetDefault(ICU4N.Util.ULocale.Category,ICU4N.Util.ULocale)">
             Sets the default <code>ULocale</code> for the specified <code>Category</code>.
             This also sets the default <code>Locale</code> for the specified <code>Category</code>
             of the JVM. If the caller does not have write permission to the
             user.language property, a security exception will be thrown,
             and the default ULocale for the specified Category will remain unchanged.
            
             @param category the specified category to set the default locale
             @param newLocale the new default locale
             @see SecurityManager#checkPermission(java.security.Permission)
             @see java.util.PropertyPermission
             @stable ICU 49
        </member>
        <member name="M:ICU4N.Util.ULocale.Clone">
            This is for compatibility with Locale-- in actuality, since ULocale is
            immutable, there is no reason to clone it, so this API returns 'this'.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetHashCode">
            Returns the hashCode.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.Equals(System.Object)">
             Returns true if the other object is another ULocale with the
             same full name.
             Note that since names are not canonicalized, two ULocales that
             function identically might not compare equal.
            
             @return true if this Locale is equal to the specified object.
             @stable ICU 3.0
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.CompareTo(ICU4N.Util.ULocale)" -->
        <member name="M:ICU4N.Util.ULocale.GetAvailableLocales">
            {@icunote} Unlike the Locale API, this returns an array of <code>ULocale</code>,
            not <code>Locale</code>.  Returns a list of all installed locales.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetISOCountries">
            Returns a list of all 2-letter country codes defined in ISO 3166.
            Can be used to create Locales.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetISOLanguages">
            Returns a list of all 2-letter language codes defined in ISO 639.
            Can be used to create Locales.
            [NOTE:  ISO 639 is not a stable standard-- some languages' codes have changed.
            The list this function returns includes both the new and the old codes for the
            languages whose codes have changed.]
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetLanguage">
            Returns the language code for this locale, which will either be the empty string
            or a lowercase ISO 639 code.
            @see #getDisplayLanguage()
            @see #getDisplayLanguage(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetLanguage(System.String)">
            Returns the language code for the locale ID,
            which will either be the empty string
            or a lowercase ISO 639 code.
            @see #getDisplayLanguage()
            @see #getDisplayLanguage(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetScript">
            Returns the script code for this locale, which might be the empty string.
            @see #getDisplayScript()
            @see #getDisplayScript(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetScript(System.String)">
            {@icu} Returns the script code for the specified locale, which might be the empty
            string.
            @see #getDisplayScript()
            @see #getDisplayScript(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetCountry">
            Returns the country/region code for this locale, which will either be the empty string
            or an uppercase ISO 3166 2-letter code.
            @see #getDisplayCountry()
            @see #getDisplayCountry(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetCountry(System.String)">
            {@icu} Returns the country/region code for this locale, which will either be the empty string
            or an uppercase ISO 3166 2-letter code.
            @param localeID The locale identification string.
            @see #getDisplayCountry()
            @see #getDisplayCountry(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetRegionForSupplementalData(ICU4N.Util.ULocale,System.Boolean)">
             {@icu} Get the region to use for supplemental data lookup.
             Uses
             (1) any region specified by locale tag "rg"; if none then
             (2) any unicode_region_tag in the locale ID; if none then
             (3) if inferRegion is TRUE, the region suggested by
                 getLikelySubtags on the localeID.
             If no region is found, returns empty string ""
            
             @param locale
                 The locale (includes any keywords) from which
                 to get the region to use for supplemental data.
             @param inferRegion
                 If TRUE, will try to infer region from other
                 locale elements if not found any other way.
             @return
                 string with region to use ("" if none found).
             @internal ICU 57
             @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetVariant">
            Returns the variant code for this locale, which might be the empty string.
            @see #getDisplayVariant()
            @see #getDisplayVariant(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetVariant(System.String)">
            {@icu} Returns the variant code for the specified locale, which might be the empty string.
            @see #getDisplayVariant()
            @see #getDisplayVariant(ULocale)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetFallback(System.String)">
            {@icu} Returns the fallback locale for the specified locale, which might be the
            empty string.
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Util.ULocale.GetFallback">
            {@icu} Returns the fallback locale for this locale.  If this locale is root,
            returns null.
            @stable ICU 3.2
        </member>
        <member name="M:ICU4N.Util.ULocale.GetFallbackString(System.String)">
            Returns the given (canonical) locale id minus the last part before the tags.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetBaseName">
             {@icu} Returns the (normalized) base name for this locale,
             like {@link #getName()}, but without keywords.
            
             @return the base name as a string.
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetBaseName(System.String)">
             {@icu} Returns the (normalized) base name for the specified locale,
             like {@link #getName(string)}, but without keywords.
            
             @param localeID the locale ID as a string
             @return the base name as a string.
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetName">
             {@icu} Returns the (normalized) full name for this locale.
            
             @return string the full name of the localeID
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetShortestSubtagLength(System.String)">
             Gets the shortest length subtag's size.
            
             @param localeID
             @return The size of the shortest length subtag
            
        </member>
        <member name="M:ICU4N.Util.ULocale.GetName(System.String)">
             {@icu} Returns the (normalized) full name for the specified locale.
            
             @param localeID the localeID as a string
             @return string the full name of the localeID
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.ToString">
            Returns a string representation of this object.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetKeywords">
            {@icu} Returns an iterator over keywords for this locale.  If there
            are no keywords, returns null.
            @return iterator over keywords, or null if there are no keywords.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetKeywords(System.String)">
            {@icu} Returns an iterator over keywords for the specified locale.  If there
            are no keywords, returns null.
            @return an iterator over the keywords in the specified locale, or null
            if there are no keywords.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetKeywordValue(System.String)">
            {@icu} Returns the value for a keyword in this locale. If the keyword is not
            defined, returns null.
            @param keywordName name of the keyword whose value is desired. Case insensitive.
            @return the value of the keyword, or null.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetKeywordValue(System.String,System.String)">
            {@icu} Returns the value for a keyword in the specified locale. If the keyword is
            not defined, returns null.  The locale name does not need to be normalized.
            @param keywordName name of the keyword whose value is desired. Case insensitive.
            @return string the value of the keyword as a string
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.Canonicalize(System.String)">
            {@icu} Returns the canonical name for the specified locale ID.  This is used to
            convert POSIX and other grandfathered IDs to standard ICU form.
            @param localeID the locale id
            @return the canonicalized id
            @stable ICU 3.0
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.SetKeywordValue(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.SetKeywordValue(System.String,System.String,System.String)" -->
        <member name="M:ICU4N.Util.ULocale.GetISO3Language">
            Returns a three-letter abbreviation for this locale's language.  If the locale
            doesn't specify a language, returns the empty string.  Otherwise, returns
            a lowercase ISO 639-2/T language code.
            The ISO 639-2 language codes can be found on-line at
              <a href="ftp://dkuug.dk/i18n/iso-639-2.txt"><code>ftp://dkuug.dk/i18n/iso-639-2.txt</code></a>
            @exception MissingResourceException Throws MissingResourceException if the
            three-letter language abbreviation is not available for this locale.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetISO3Language(System.String)">
            {@icu} Returns a three-letter abbreviation for this locale's language.  If the locale
            doesn't specify a language, returns the empty string.  Otherwise, returns
            a lowercase ISO 639-2/T language code.
            The ISO 639-2 language codes can be found on-line at
              <a href="ftp://dkuug.dk/i18n/iso-639-2.txt"><code>ftp://dkuug.dk/i18n/iso-639-2.txt</code></a>
            @exception MissingResourceException Throws MissingResourceException if the
            three-letter language abbreviation is not available for this locale.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetISO3Country">
            Returns a three-letter abbreviation for this locale's country/region.  If the locale
            doesn't specify a country, returns the empty string.  Otherwise, returns
            an uppercase ISO 3166 3-letter country code.
            @exception MissingResourceException Throws MissingResourceException if the
            three-letter country abbreviation is not available for this locale.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetISO3Country(System.String)">
            {@icu} Returns a three-letter abbreviation for this locale's country/region.  If the locale
            doesn't specify a country, returns the empty string.  Otherwise, returns
            an uppercase ISO 3166 3-letter country code.
            @exception MissingResourceException Throws MissingResourceException if the
            three-letter country abbreviation is not available for this locale.
            @stable ICU 3.0
        </member>
        <member name="F:ICU4N.Util.ULocale.LANG_DIR_STRING">
            Pairs of (language subtag, + or -) for finding out fast if common languages
            are LTR (minus) or RTL (plus).
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.IsRightToLeft" -->
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguage">
            Returns this locale's language localized for display in the default <code>DISPLAY</code> locale.
            @return the localized language name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguage(ICU4N.Util.ULocale)">
            Returns this locale's language localized for display in the provided locale.
            @param displayLocale the locale in which to display the name.
            @return the localized language name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguage(System.String,System.String)">
            {@icu} Returns a locale's language localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose language will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized language name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguage(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's language localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose language will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized language name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguageWithDialect">
            {@icu} Returns this locale's language localized for display in the default <code>DISPLAY</code> locale.
            If a dialect name is present in the data, then it is returned.
            @return the localized language name.
            @see Category#DISPLAY
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguageWithDialect(ICU4N.Util.ULocale)">
            {@icu} Returns this locale's language localized for display in the provided locale.
            If a dialect name is present in the data, then it is returned.
            @param displayLocale the locale in which to display the name.
            @return the localized language name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguageWithDialect(System.String,System.String)">
            {@icu} Returns a locale's language localized for display in the provided locale.
            If a dialect name is present in the data, then it is returned.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose language will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized language name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayLanguageWithDialect(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's language localized for display in the provided locale.
            If a dialect name is present in the data, then it is returned.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose language will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized language name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScript">
            Returns this locale's script localized for display in the default <code>DISPLAY</code> locale.
            @return the localized script name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScriptInContext">
            {@icu} Returns this locale's script localized for display in the default <code>DISPLAY</code> locale.
            @return the localized script name.
            @see Category#DISPLAY
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScript(ICU4N.Util.ULocale)">
            Returns this locale's script localized for display in the provided locale.
            @param displayLocale the locale in which to display the name.
            @return the localized script name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScriptInContext(ICU4N.Util.ULocale)">
            {@icu} Returns this locale's script localized for display in the provided locale.
            @param displayLocale the locale in which to display the name.
            @return the localized script name.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScript(System.String,System.String)">
            {@icu} Returns a locale's script localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose script will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized script name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScriptInContext(System.String,System.String)">
            {@icu} Returns a locale's script localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose script will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized script name.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScript(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's script localized for display in the provided locale.
            @param localeID the id of the locale whose script will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized script name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayScriptInContext(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's script localized for display in the provided locale.
            @param localeID the id of the locale whose script will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized script name.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayCountry">
            Returns this locale's country localized for display in the default <code>DISPLAY</code> locale.
            <b>Warning: </b>this is for the region part of a valid locale ID; it cannot just be the region code (like "FR").
            To get the display name for a region alone, or for other options, use {@link LocaleDisplayNames} instead.
            @return the localized country name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayCountry(ICU4N.Util.ULocale)">
            Returns this locale's country localized for display in the provided locale.
            <b>Warning: </b>this is for the region part of a valid locale ID; it cannot just be the region code (like "FR").
            To get the display name for a region alone, or for other options, use {@link LocaleDisplayNames} instead.
            @param displayLocale the locale in which to display the name.
            @return the localized country name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayCountry(System.String,System.String)">
            {@icu} Returns a locale's country localized for display in the provided locale.
            <b>Warning: </b>this is for the region part of a valid locale ID; it cannot just be the region code (like "FR").
            To get the display name for a region alone, or for other options, use {@link LocaleDisplayNames} instead.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose country will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized country name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayCountry(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's country localized for display in the provided locale.
            <b>Warning: </b>this is for the region part of a valid locale ID; it cannot just be the region code (like "FR").
            To get the display name for a region alone, or for other options, use {@link LocaleDisplayNames} instead.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose country will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized country name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayVariant">
            Returns this locale's variant localized for display in the default <code>DISPLAY</code> locale.
            @return the localized variant name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayVariant(ICU4N.Util.ULocale)">
            Returns this locale's variant localized for display in the provided locale.
            @param displayLocale the locale in which to display the name.
            @return the localized variant name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayVariant(System.String,System.String)">
            {@icu} Returns a locale's variant localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose variant will be displayed
            @param displayLocaleID the id of the locale in which to display the name.
            @return the localized variant name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayVariant(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a locale's variant localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose variant will be displayed.
            @param displayLocale the locale in which to display the name.
            @return the localized variant name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeyword(System.String)">
            {@icu} Returns a keyword localized for display in the default <code>DISPLAY</code> locale.
            @param keyword the keyword to be displayed.
            @return the localized keyword name.
            @see #getKeywords()
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeyword(System.String,System.String)">
            {@icu} Returns a keyword localized for display in the specified locale.
            @param keyword the keyword to be displayed.
            @param displayLocaleID the id of the locale in which to display the keyword.
            @return the localized keyword name.
            @see #getKeywords(string)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeyword(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a keyword localized for display in the specified locale.
            @param keyword the keyword to be displayed.
            @param displayLocale the locale in which to display the keyword.
            @return the localized keyword name.
            @see #getKeywords(string)
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeywordValue(System.String)">
            {@icu} Returns a keyword value localized for display in the default <code>DISPLAY</code> locale.
            @param keyword the keyword whose value is to be displayed.
            @return the localized value name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeywordValue(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a keyword value localized for display in the specified locale.
            @param keyword the keyword whose value is to be displayed.
            @param displayLocale the locale in which to display the value.
            @return the localized value name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeywordValue(System.String,System.String,System.String)">
            {@icu} Returns a keyword value localized for display in the specified locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose keyword value is to be displayed.
            @param keyword the keyword whose value is to be displayed.
            @param displayLocaleID the id of the locale in which to display the value.
            @return the localized value name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayKeywordValue(System.String,System.String,ICU4N.Util.ULocale)">
            {@icu} Returns a keyword value localized for display in the specified locale.
            This is a cover for the ICU4C API.
            @param localeID the id of the locale whose keyword value is to be displayed.
            @param keyword the keyword whose value is to be displayed.
            @param displayLocale the id of the locale in which to display the value.
            @return the localized value name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayName">
            Returns this locale name localized for display in the default <code>DISPLAY</code> locale.
            @return the localized locale name.
            @see Category#DISPLAY
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayName(ICU4N.Util.ULocale)">
            Returns this locale name localized for display in the provided locale.
            @param displayLocale the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayName(System.String,System.String)">
            {@icu} Returns the locale ID localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the locale whose name is to be displayed.
            @param displayLocaleID the id of the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayName(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns the locale ID localized for display in the provided locale.
            This is a cover for the ICU4C API.
            @param localeID the locale whose name is to be displayed.
            @param displayLocale the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayNameWithDialect">
            {@icu} Returns this locale name localized for display in the default <code>DISPLAY</code> locale.
            If a dialect name is present in the locale data, then it is returned.
            @return the localized locale name.
            @see Category#DISPLAY
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayNameWithDialect(ICU4N.Util.ULocale)">
            {@icu} Returns this locale name localized for display in the provided locale.
            If a dialect name is present in the locale data, then it is returned.
            @param displayLocale the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayNameWithDialect(System.String,System.String)">
            {@icu} Returns the locale ID localized for display in the provided locale.
            If a dialect name is present in the locale data, then it is returned.
            This is a cover for the ICU4C API.
            @param localeID the locale whose name is to be displayed.
            @param displayLocaleID the id of the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetDisplayNameWithDialect(System.String,ICU4N.Util.ULocale)">
            {@icu} Returns the locale ID localized for display in the provided locale.
            If a dialect name is present in the locale data, then it is returned.
            This is a cover for the ICU4C API.
            @param localeID the locale whose name is to be displayed.
            @param displayLocale the locale in which to display the locale name.
            @return the localized locale name.
            @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetCharacterOrientation">
            {@icu} Returns this locale's layout orientation for characters.  The possible
            values are "left-to-right", "right-to-left", "top-to-bottom" or
            "bottom-to-top".
            @return The locale's layout orientation for characters.
            @stable ICU 4.0
        </member>
        <member name="M:ICU4N.Util.ULocale.GetLineOrientation">
            {@icu} Returns this locale's layout orientation for lines.  The possible
            values are "left-to-right", "right-to-left", "top-to-bottom" or
            "bottom-to-top".
            @return The locale's layout orientation for lines.
            @stable ICU 4.0
        </member>
        <member name="F:ICU4N.Util.ULocale.ACTUAL_LOCALE">
             {@icu} Selector for <tt>getLocale()</tt> indicating the locale of the
             resource containing the data.  This is always at or above the
             valid locale.  If the valid locale does not contain the
             specific data being requested, then the actual locale will be
             above the valid locale.  If the object was not constructed from
             locale data, then the valid locale is <i>null</i>.
            
             @draft ICU 2.8 (retain)
             @provisional This API might change or be removed in a future release.
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Util.ULocale.VALID_LOCALE" -->
        <member name="T:ICU4N.Util.ULocale.Type">
            Opaque selector enum for <tt>getLocale()</tt>.
            @see com.ibm.icu.util.ULocale
            @see com.ibm.icu.util.ULocale#ACTUAL_LOCALE
            @see com.ibm.icu.util.ULocale#VALID_LOCALE
            @draft ICU 2.8 (retainAll)
            @provisional This API might change or be removed in a future release.
        </member>
        <member name="M:ICU4N.Util.ULocale.AcceptLanguage(System.String,ICU4N.Util.ULocale[],System.Boolean[])">
            {@icu} Based on a HTTP formatted list of acceptable locales, determine an available
            locale for the user.  NullPointerException is thrown if acceptLanguageList or
            availableLocales is null.  If fallback is non-null, it will contain true if a
            fallback locale (one not in the acceptLanguageList) was returned.  The value on
            entry is ignored.  ULocale will be one of the locales in availableLocales, or the
            ROOT ULocale if if a ROOT locale was used as a fallback (because nothing else in
            availableLocales matched).  No ULocale array element should be null; behavior is
            undefined if this is the case.
            @param acceptLanguageList list in HTTP "Accept-Language:" format of acceptable locales
            @param availableLocales list of available locales. One of these will be returned.
            @param fallback if non-null, a 1-element array containing a bool to be set with
            the fallback status
            @return one of the locales from the availableLocales list, or null if none match
            @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.ULocale.AcceptLanguage(ICU4N.Util.ULocale[],ICU4N.Util.ULocale[],System.Boolean[])">
            {@icu} Based on a list of acceptable locales, determine an available locale for the
            user.  NullPointerException is thrown if acceptLanguageList or availableLocales is
            null.  If fallback is non-null, it will contain true if a fallback locale (one not
            in the acceptLanguageList) was returned.  The value on entry is ignored.  ULocale
            will be one of the locales in availableLocales, or the ROOT ULocale if if a ROOT
            locale was used as a fallback (because nothing else in availableLocales matched).
            No ULocale array element should be null; behavior is undefined if this is the case.
            @param acceptLanguageList list of acceptable locales
            @param availableLocales list of available locales. One of these will be returned.
            @param fallback if non-null, a 1-element array containing a bool to be set with
            the fallback status
            @return one of the locales from the availableLocales list, or null if none match
            @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.ULocale.AcceptLanguage(System.String,System.Boolean[])">
            {@icu} Based on a HTTP formatted list of acceptable locales, determine an available
            locale for the user.  NullPointerException is thrown if acceptLanguageList or
            availableLocales is null.  If fallback is non-null, it will contain true if a
            fallback locale (one not in the acceptLanguageList) was returned.  The value on
            entry is ignored.  ULocale will be one of the locales in availableLocales, or the
            ROOT ULocale if if a ROOT locale was used as a fallback (because nothing else in
            availableLocales matched).  No ULocale array element should be null; behavior is
            undefined if this is the case.  This function will choose a locale from the
            ULocale.getAvailableLocales() list as available.
            @param acceptLanguageList list in HTTP "Accept-Language:" format of acceptable locales
            @param fallback if non-null, a 1-element array containing a bool to be set with
            the fallback status
            @return one of the locales from the ULocale.getAvailableLocales() list, or null if
            none match
            @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.ULocale.AcceptLanguage(ICU4N.Util.ULocale[],System.Boolean[])">
            {@icu} Based on an ordered array of acceptable locales, determine an available
            locale for the user.  NullPointerException is thrown if acceptLanguageList or
            availableLocales is null.  If fallback is non-null, it will contain true if a
            fallback locale (one not in the acceptLanguageList) was returned.  The value on
            entry is ignored.  ULocale will be one of the locales in availableLocales, or the
            ROOT ULocale if if a ROOT locale was used as a fallback (because nothing else in
            availableLocales matched).  No ULocale array element should be null; behavior is
            undefined if this is the case.  This function will choose a locale from the
            ULocale.getAvailableLocales() list as available.
            @param acceptLanguageList ordered array of acceptable locales (preferred are listed first)
            @param fallback if non-null, a 1-element array containing a bool to be set with
            the fallback status
            @return one of the locales from the ULocale.getAvailableLocales() list, or null if none match
            @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Util.ULocale.ParseAcceptLanguage(System.String,System.Boolean)">
            Package local method used for parsing Accept-Language string
        </member>
        <member name="M:ICU4N.Util.ULocale.AddLikelySubtags(ICU4N.Util.ULocale)">
             {@icu} Adds the likely subtags for a provided locale ID, per the algorithm
             described in the following CLDR technical report:
            
               http://www.unicode.org/reports/tr35/#Likely_Subtags
            
             If the provided ULocale instance is already in the maximal form, or there is no
             data available available for maximization, it will be returned.  For example,
             "und-Zzzz" cannot be maximized, since there is no reasonable maximization.
             Otherwise, a new ULocale instance with the maximal form is returned.
            
             Examples:
            
             "en" maximizes to "en_Latn_US"
            
             "de" maximizes to "de_Latn_US"
            
             "sr" maximizes to "sr_Cyrl_RS"
            
             "sh" maximizes to "sr_Latn_RS" (Note this will not reverse.)
            
             "zh_Hani" maximizes to "zh_Hans_CN" (Note this will not reverse.)
            
             @param loc The ULocale to maximize
             @return The maximized ULocale instance.
             @stable ICU 4.0
        </member>
        <member name="M:ICU4N.Util.ULocale.MinimizeSubtags(ICU4N.Util.ULocale)">
             {@icu} Minimizes the subtags for a provided locale ID, per the algorithm described
             in the following CLDR technical report:<blockquote>
            
               <a href="http://www.unicode.org/reports/tr35/#Likely_Subtags"
            >http://www.unicode.org/reports/tr35/#Likely_Subtags</a></blockquote>
            
             If the provided ULocale instance is already in the minimal form, or there
             is no data available for minimization, it will be returned.  Since the
             minimization algorithm relies on proper maximization, see the comments
             for addLikelySubtags for reasons why there might not be any data.
            
             Examples:<pre>
            
             "en_Latn_US" minimizes to "en"
            
             "de_Latn_US" minimizes to "de"
            
             "sr_Cyrl_RS" minimizes to "sr"
            
             "zh_Hant_TW" minimizes to "zh_TW" (The region is preferred to the
             script, and minimizing to "zh" would imply "zh_Hans_CN".) </pre>
            
             @param loc The ULocale to minimize
             @return The minimized ULocale instance.
             @stable ICU 4.0
        </member>
        <member name="T:ICU4N.Util.ULocale.Minimize">
            Options for minimizeSubtags.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="F:ICU4N.Util.ULocale.Minimize.FAVOR_SCRIPT">
            Favor including the script, when either the region <b>or</b> the script could be suppressed, but not both.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="F:ICU4N.Util.ULocale.Minimize.FAVOR_REGION">
            Favor including the region, when either the region <b>or</b> the script could be suppressed, but not both.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.MinimizeSubtags(ICU4N.Util.ULocale,ICU4N.Util.ULocale.Minimize)">
             {@icu} Minimizes the subtags for a provided locale ID, per the algorithm described
             in the following CLDR technical report:<blockquote>
            
               <a href="http://www.unicode.org/reports/tr35/#Likely_Subtags"
            >http://www.unicode.org/reports/tr35/#Likely_Subtags</a></blockquote>
            
             If the provided ULocale instance is already in the minimal form, or there
             is no data available for minimization, it will be returned.  Since the
             minimization algorithm relies on proper maximization, see the comments
             for addLikelySubtags for reasons why there might not be any data.
            
             Examples:<pre>
            
             "en_Latn_US" minimizes to "en"
            
             "de_Latn_US" minimizes to "de"
            
             "sr_Cyrl_RS" minimizes to "sr"
            
             "zh_Hant_TW" minimizes to "zh_TW" if fieldToFavor == {@link Minimize#FAVOR_REGION}
             "zh_Hant_TW" minimizes to "zh_Hant" if fieldToFavor == {@link Minimize#FAVOR_SCRIPT}
             </pre>
             The fieldToFavor only has an effect if either the region or the script could be suppressed, but not both.
             @param loc The ULocale to minimize
             @param fieldToFavor Indicate which should be preferred, when either the region <b>or</b> the script could be suppressed, but not both.
             @return The minimized ULocale instance.
             @internal
             @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.ULocale.AppendTag(System.String,System.Text.StringBuilder)">
             Append a tag to a StringBuilder, adding the separator if necessary.The tag must
             not be a zero-length string.
            
             @param tag The tag to add.
             @param buffer The output buffer.
            
        </member>
        <member name="M:ICU4N.Util.ULocale.CreateTagString(System.String,System.String,System.String,System.String,System.String)">
             Create a tag string from the supplied parameters.  The lang, script and region
             parameters may be null references.
            
             If any of the language, script or region parameters are empty, and the alternateTags
             parameter is not null, it will be parsed for potential language, script and region tags
             to be used when constructing the new tag.  If the alternateTags parameter is null, or
             it contains no language tag, the default tag for the unknown language is used.
            
             @param lang The language tag to use.
             @param script The script tag to use.
             @param region The region tag to use.
             @param trailing Any trailing data to append to the new tag.
             @param alternateTags A string containing any alternate tags.
             @return The new tag string.
            
        </member>
        <member name="M:ICU4N.Util.ULocale.CreateTagString(System.String,System.String,System.String,System.String)">
             Create a tag string from the supplied parameters.  The lang, script and region
             parameters may be null references.If the lang parameter is an empty string, the
             default value for an unknown language is written to the output buffer.
            
             @param lang The language tag to use.
             @param script The script tag to use.
             @param region The region tag to use.
             @param trailing Any trailing data to append to the new tag.
             @return The new string.
            
        </member>
        <member name="M:ICU4N.Util.ULocale.ParseTagString(System.String,System.String[])">
             Parse the language, script, and region subtags from a tag string, and return the results.
            
             This function does not return the canonical strings for the unknown script and region.
            
             @param localeID The locale ID to parse.
             @param tags An array of three string references to return the subtag strings.
             @return The number of chars of the localeID parameter consumed.
            
        </member>
        <member name="F:ICU4N.Util.ULocale.PRIVATE_USE_EXTENSION">
             The key for the private use locale extension ('x').
            
             @see #getExtension(char)
             @see Builder#setExtension(char, string)
            
             @stable ICU 4.2
        </member>
        <member name="F:ICU4N.Util.ULocale.UNICODE_LOCALE_EXTENSION">
             The key for Unicode locale extension ('u').
            
             @see #getExtension(char)
             @see Builder#setExtension(char, string)
            
             @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.ULocale.GetExtension(System.Char)">
             Returns the extension (or private use) value associated with
             the specified key, or null if there is no extension
             associated with the key. To be well-formed, the key must be one
             of <code>[0-9A-Za-z]</code>. Keys are case-insensitive, so
             for example 'z' and 'Z' represent the same extension.
            
             @param key the extension key
             @return The extension, or null if this locale defines no
             extension for the specified key.
             @throws IllegalArgumentException if key is not well-formed
             @see #PRIVATE_USE_EXTENSION
             @see #UNICODE_LOCALE_EXTENSION
            
             @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.ULocale.GetExtensionKeys">
             Returns the set of extension keys associated with this locale, or the
             empty set if it has no extensions. The returned set is unmodifiable.
             The keys will all be lower-case.
            
             @return the set of extension keys, or the empty set if this locale has
             no extensions
             @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.ULocale.GetUnicodeLocaleAttributes">
             Returns the set of unicode locale attributes associated with
             this locale, or the empty set if it has no attributes. The
             returned set is unmodifiable.
            
             @return The set of attributes.
             @stable ICU 4.6
        </member>
        <member name="M:ICU4N.Util.ULocale.GetUnicodeLocaleType(System.String)">
             Returns the Unicode locale type associated with the specified Unicode locale key
             for this locale. Returns the empty string for keys that are defined with no type.
             Returns null if the key is not defined. Keys are case-insensitive. The key must
             be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
             thrown.
            
             @param key the Unicode locale key
             @return The Unicode locale type associated with the key, or null if the
             locale does not define the key.
             @throws IllegalArgumentException if the key is not well-formed
             @throws NullPointerException if <code>key</code> is null
            
             @stable ICU 4.4
        </member>
        <member name="M:ICU4N.Util.ULocale.GetUnicodeLocaleKeys">
             Returns the set of Unicode locale keys defined by this locale, or the empty set if
             this locale has none.  The returned set is immutable.  Keys are all lower case.
            
             @return The set of Unicode locale keys, or the empty set if this locale has
             no Unicode locale keywords.
            
             @stable ICU 4.4
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.ToLanguageTag" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.ForLanguageTag(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.ToUnicodeLocaleKey(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.ToUnicodeLocaleType(System.String,System.String)" -->
        <member name="M:ICU4N.Util.ULocale.ToLegacyKey(System.String)">
             {@icu} Converts the specified keyword (BCP 47 Unicode locale extension key, or
             legacy key) to the legacy key. For example, legacy key "collation" is
             returned for the input BCP 47 Unicode locale extension key "co".
            
             @param keyword       the input locale keyword (either BCP 47 Unicode locale
                                  extension key or legacy key).
             @return              the well-formed legacy key, or null if the specified
                                  keyword cannot be mapped to a well-formed legacy key.
             @see #toUnicodeLocaleKey(string)
             @stable ICU 54
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.ToLegacyType(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Util.ULocale.Builder" -->
        <member name="M:ICU4N.Util.ULocale.Builder.#ctor">
             Constructs an empty Builder. The default value of all
             fields, extensions, and private use information is the
             empty string.
            
             @stable ICU 4.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetLocale(ICU4N.Util.ULocale)" -->
        <member name="M:ICU4N.Util.ULocale.Builder.SetLanguageTag(System.String)">
             Resets the Builder to match the provided IETF BCP 47
             language tag.  Discards the existing state.  Null and the
             empty string cause the builder to be reset, like {@link
             #clear}.  Grandfathered tags (see {@link
             ULocale#forLanguageTag}) are converted to their canonical
             form before being processed.  Otherwise, the language tag
             must be well-formed (see {@link ULocale}) or an exception is
             thrown (unlike <code>ULocale.forLanguageTag</code>, which
             just discards ill-formed and following portions of the
             tag).
            
             @param languageTag the language tag
             @return This builder.
             @throws IllformedLocaleException if <code>languageTag</code> is ill-formed
             @see ULocale#forLanguageTag(string)
            
             @stable ICU 4.2
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetLanguage(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetScript(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetRegion(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetVariant(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetExtension(System.Char,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.SetUnicodeLocaleKeyword(System.String,System.String)" -->
        <member name="M:ICU4N.Util.ULocale.Builder.AddUnicodeLocaleAttribute(System.String)">
             Adds a unicode locale attribute, if not already present, otherwise
             has no effect.  The attribute must not be null and must be well-formed
             or an exception is thrown.
            
             @param attribute the attribute
             @return This builder.
             @throws NullPointerException if <code>attribute</code> is null
             @throws IllformedLocaleException if <code>attribute</code> is ill-formed
             @see #setExtension(char, string)
            
             @stable ICU 4.6
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.ULocale.Builder.RemoveUnicodeLocaleAttribute(System.String)" -->
        <member name="M:ICU4N.Util.ULocale.Builder.Clear">
             Resets the builder to its initial, empty state.
            
             @return this builder
            
             @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.ULocale.Builder.ClearExtensions">
             Resets the extensions to their initial, empty state.
             Language, script, region and variant are unchanged.
            
             @return this builder
             @see #setExtension(char, string)
            
             @stable ICU 4.2
        </member>
        <member name="M:ICU4N.Util.ULocale.Builder.Build">
             Returns an instance of <code>ULocale</code> created from the fields set
             on this builder.
            
             @return a new Locale
            
             @stable ICU 4.4
        </member>
        <member name="T:ICU4N.Util.ULocale.DotNetLocaleHelper">
            <summary>
            .NET Locale Helper
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Util.ULocale.DotNetLocaleHelper.NET_MAPDATA" -->
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,System.String)">
            {@icu} Creates a resource bundle using the specified base name and locale.
            ICU_DATA_CLASS is used as the default root.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @param localeName the locale for which a resource bundle is desired
            @throws MissingResourceException If no resource bundle for the specified base name
            can be found
            @return a resource bundle for the given base name and locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly)">
             {@icu} Creates a resource bundle using the specified base name, locale, and class root.
            
             @param baseName string containing the name of the data package.
                                If null the default ICU package name is used.
             @param localeName the locale for which a resource bundle is desired
             @param root the class object from which to load the resource bundle
             @throws MissingResourceException If no resource bundle for the specified base name
             can be found
             @return a resource bundle for the given base name and locale
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,System.String,System.Reflection.Assembly,System.Boolean)">
             {@icu} Creates a resource bundle using the specified base name, locale, and class
             root.
            
             @param baseName string containing the name of the data package.
                                If null the default ICU package name is used.
             @param localeName the locale for which a resource bundle is desired
             @param root the class object from which to load the resource bundle
             @param disableFallback Option to disable locale inheritence.
                                      If true the fallback chain will not be built.
             @throws MissingResourceException
                 if no resource bundle for the specified base name can be found
             @return a resource bundle for the given base name and locale
             @stable ICU 3.0
            
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.#ctor">
            {@icu} Sole constructor.  (For invocation by subclass constructors, typically
            implicit.)  This is public for compatibility with Java, whose compiler
            will generate public default constructors for an abstract class.
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(ICU4N.Util.ULocale)">
            {@icu} Creates a UResourceBundle for the locale specified, from which users can extract
            resources by using their corresponding keys.
            @param locale  specifies the locale for which we want to open the resource.
                           If null the bundle for default locale is opened.
            @return a resource bundle for the given locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String)">
            {@icu} Creates a UResourceBundle for the default locale and specified base name,
            from which users can extract resources by using their corresponding keys.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @return a resource bundle for the given base name and default locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,System.Globalization.CultureInfo)">
            {@icu} Creates a UResourceBundle for the specified locale and specified base name,
            from which users can extract resources by using their corresponding keys.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @param locale  specifies the locale for which we want to open the resource.
                           If null the bundle for default locale is opened.
            @return a resource bundle for the given base name and locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,ICU4N.Util.ULocale)">
            {@icu} Creates a UResourceBundle, from which users can extract resources by using
            their corresponding keys.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @param locale  specifies the locale for which we want to open the resource.
                           If null the bundle for default locale is opened.
            @return a resource bundle for the given base name and locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            {@icu} Creates a UResourceBundle for the specified locale and specified base name,
            from which users can extract resources by using their corresponding keys.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @param locale  specifies the locale for which we want to open the resource.
                           If null the bundle for default locale is opened.
            @param loader  the loader to use
            @return a resource bundle for the given base name and locale
            @stable ICU 3.8
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Util.UResourceBundle.GetBundleInstance(System.String,ICU4N.Util.ULocale,System.Reflection.Assembly)" -->
        <member name="M:ICU4N.Util.UResourceBundle.GetULocale">
             {@icu} Returns the RFC 3066 conformant locale id of this resource bundle.
             This method can be used after a call to getBundleInstance() to
             determine whether the resource bundle returned really
             corresponds to the requested locale or is a fallback.
            
             @return the locale of this resource bundle
             @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetLocaleID">
            {@icu} Returns the localeID
            @return The string representation of the localeID
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBaseName">
            {@icu} Returns the base name of the resource bundle
            @return The string representation of the base name
            @stable ICU 3.0
        </member>
        <member name="P:ICU4N.Util.UResourceBundle.Parent">
            {@icu} Returns the parent bundle
            @return The parent bundle
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetLocale">
            Returns the locale of this bundle
            @return the locale of this resource bundle
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.InstantiateBundle(System.String,System.String,System.Reflection.Assembly,System.Boolean)">
            {@icu} Loads a new resource bundle for the given base name, locale and class loader.
            Optionally will disable loading of fallback bundles.
            @param baseName string containing the name of the data package.
                               If null the default ICU package name is used.
            @param localeName the locale for which a resource bundle is desired
            @param root the class object from which to load the resource bundle
            @param disableFallback disables loading of fallback lookup chain
            @throws MissingResourceException If no resource bundle for the specified base name
            can be found
            @return a resource bundle for the given base name and locale
            @stable ICU 3.0
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBinary">
             {@icu} Returns a binary data item from a binary resource, as a read-only ByteBuffer.
            
             @return a pointer to a chunk of unsigned bytes which live in a memory mapped/DLL
             file.
             @see #getIntVector
             @see #getInt
             @throws MissingResourceException If no resource bundle can be found.
             @throws UResourceTypeMismatchException If the resource has a type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetString">
             Returns a string from a string resource type
            
             @return a string
             @see #getBinary()
             @see #getIntVector
             @see #getInt
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle has a type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetStringArray">
             Returns a string array from a array resource type
            
             @return a string
             @see #getString()
             @see #getIntVector
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle has a type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetBinary(System.Byte[])">
             {@icu} Returns a binary data from a binary resource, as a byte array with a copy
             of the bytes from the resource bundle.
            
             @param ba  The byte array to write the bytes to. A null variable is OK.
             @return an array of bytes containing the binary data from the resource.
             @see #getIntVector
             @see #getInt
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle has a type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetInt32Vector">
             {@icu} Returns a 32 bit integer array from a resource.
            
             @return a pointer to a chunk of unsigned bytes which live in a memory mapped/DLL file.
             @see #getBinary()
             @see #getInt
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle has a type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetInt32">
             {@icu} Returns a signed integer from a resource.
            
             @return an integer value
             @see #getIntVector
             @see #getBinary()
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetUInt32">
             {@icu} Returns a unsigned integer from a resource.
             This integer is originally 28 bit and the sign gets propagated.
            
             @return an integer value
             @see #getIntVector
             @see #getBinary()
             @throws MissingResourceException If resource bundle is missing.
             @throws UResourceTypeMismatchException If resource bundle type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.Get(System.String)">
             {@icu} Returns a resource in a given resource that has a given key.
            
             @param aKey               a key associated with the wanted resource
             @return                  a resource bundle object representing the resource
             @throws MissingResourceException If resource bundle is missing.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.FindTopLevel(System.String)">
             Returns a resource in a given resource that has a given key, or null if the
             resource is not found.
            
             @param aKey the key associated with the wanted resource
             @return the resource, or null
             @see #get(String)
             @internal
             @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetString(System.Int32)">
             Returns the string in a given resource at the specified index.
            
             @param index an index to the wanted string.
             @return a string which lives in the resource.
             @throws IndexOutOfBoundsException If the index value is out of bounds of accepted values.
             @throws UResourceTypeMismatchException If resource bundle type mismatch.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.Get(System.Int32)">
             {@icu} Returns the resource in a given resource at the specified index.
            
             @param index an index to the wanted resource.
             @return the sub resource UResourceBundle object
             @throws IndexOutOfBoundsException If the index value is out of bounds of accepted values.
             @throws MissingResourceException If the resource bundle is missing.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.FindTopLevel(System.Int32)">
             Returns a resource in a given resource that has a given index, or null if the
             resource is not found.
            
             @param index the index of the resource
             @return the resource, or null
             @see #get(int)
             @internal
             @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetKeys">
            Returns the keys in this bundle as an enumeration
            @return an enumeration containing key strings,
                    which is empty if this is not a bundle or a table resource
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.KeySet">
            Returns a Set of all keys contained in this ResourceBundle and its parent bundles.
            @return a Set of all keys contained in this ResourceBundle and its parent bundles,
                    which is empty if this is not a bundle or a table resource
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleKeySet">
            Returns a Set of the keys contained <i>only</i> in this ResourceBundle.
            This does not include further keys from parent bundles.
            @return a Set of the keys contained only in this ResourceBundle,
                    which is empty if this is not a bundle or a table resource
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Util.UResourceBundle.Length" -->
        <member name="P:ICU4N.Util.UResourceBundle.Type">
             {@icu} Returns the type of a resource.
             Available types are {@link #INT INT}, {@link #ARRAY ARRAY},
             {@link #BINARY BINARY}, {@link #INT_VECTOR INT_VECTOR},
             {@link #STRING STRING}, {@link #TABLE TABLE}.
            
             @return type of the given resource.
             @stable ICU 3.8
        </member>
        <member name="P:ICU4N.Util.UResourceBundle.Version">
            {@icu} Return the version number associated with this UResourceBundle as an
            VersionInfo object.
            @return VersionInfo object containing the version of the bundle
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.GetEnumerator">
            {@icu} Returns the iterator which iterates over this
            resource bundle
            @return UResourceBundleIterator that iterates over the resources in the bundle
            @stable ICU 3.8
        </member>
        <member name="P:ICU4N.Util.UResourceBundle.Key">
            {@icu} Returns the key associated with a given resource. Not all the resources have
            a key - only those that are members of a table.
            @return a key associated to this resource, or null if it doesn't have a key
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.NONE">
            {@icu} Resource type constant for "no resource".
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.STRING">
            {@icu} Resource type constant for strings.
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.BINARY">
            {@icu} Resource type constant for binary data.
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.TABLE">
            {@icu} Resource type constant for tables of key-value pairs.
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.INT32">
            {@icu} Resource type constant for a single 28-bit integer, interpreted as
            signed or unsigned by the getInt() function.
            @see #getInt
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.ARRAY">
            {@icu} Resource type constant for arrays of resources.
            @stable ICU 3.8
        </member>
        <member name="F:ICU4N.Util.UResourceBundle.INT32_VECTOR">
            Resource type constant for vectors of 32-bit integers.
            @see #getIntVector
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGet(System.String,System.Collections.Generic.IDictionary{System.String,System.String},ICU4N.Util.UResourceBundle)">
            {@icu} Actual worker method for fetching a resource based on the given key.
            Sub classes must override this method if they support resources with keys.
            @param aKey the key string of the resource to be fetched
            @param aliasesVisited hashtable object to hold references of resources already seen
            @param requested the original resource bundle object on which the get method was invoked.
                             The requested bundle and the bundle on which this method is invoked
                             are the same, except in the cases where aliases are involved.
            @return UResourceBundle a resource associated with the key
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGet(System.Int32,System.Collections.Generic.IDictionary{System.String,System.String},ICU4N.Util.UResourceBundle)">
            {@icu} Actual worker method for fetching a resource based on the given index.
            Sub classes must override this method if they support arrays of resources.
            @param index the index of the resource to be fetched
            @param aliasesVisited hashtable object to hold references of resources already seen
            @param requested the original resource bundle object on which the get method was invoked.
                             The requested bundle and the bundle on which this method is invoked
                             are the same, except in the cases where aliases are involved.
            @return UResourceBundle a resource associated with the index
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGetStringArray">
            {@icu} Actual worker method for fetching the array of strings in a resource.
            Sub classes must override this method if they support arrays of strings.
            @return String[] An array of strings containing strings
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGetKeys">
             {@icu} Actual worker method for fetching the keys of resources contained in the resource.
             Sub classes must override this method if they support keys and associated resources.
            
             @return Enumeration An enumeration of all the keys in this resource.
             @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGetObject(System.String)">
            {@inheritDoc}
            @stable ICU 3.8
        </member>
        <member name="M:ICU4N.Util.UResourceBundle.HandleGetObjectImpl(System.String,ICU4N.Util.UResourceBundle)">
            Override the superclass method
        </member>
        <member name="P:ICU4N.Util.UResourceBundle.IsTopLevelResource">
            Is this a top-level resource, that is, a whole bundle?
            @return true if this is a top-level resource
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="F:ICU4N.Util.ResourceBundle.parent">
            The parent bundle of this bundle.
            The parent bundle is searched by {@link #getObject getObject}
            when this bundle does not contain a particular resource.
        </member>
        <member name="T:ICU4N.Util.UResourceBundleEnumerator">
            <summary>
            Class for enabling iteration over <see cref="T:ICU4N.Util.UResourceBundle"/> objects.
            </summary>
            <remarks>
            Example of use:
            <code>
            ICUResourceBundleEnumerator iterator = resB.GetEnumerator();
            ICUResourceBundle temp;
            while (iterator.MoveNext())
            {
                temp = iterator.Current;
                int type = temp.Type;
                switch (type)
                {
                    case UResourceBundle.STRING:
                        str = temp.GetString();
                        break;
                    case UResourceBundle.INT32:
                        integer = temp.GetInt32();
                        break;
                    .....
                }
                // do something interesting with data collected
            }
            </code>
            </remarks>
            <author>ram</author>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.UResourceBundleEnumerator.#ctor(ICU4N.Util.UResourceBundle)">
            <summary>
            Construct a resource bundle iterator for the
            given resource bundle.
            </summary>
            <param name="bndl">The resource bundle to iterate over.</param>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.UResourceBundleEnumerator.Next">
            <summary>
            Returns the next element of this iterator if this iterator object has at least one more element to provide.
            </summary>
            <returns>The UResourceBundle object.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.UResourceBundleEnumerator.Reset">
            <summary>
            Resets the internal context of a resource so that iteration starts from the first element.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="P:ICU4N.Util.UResourceBundleEnumerator.HasNext">
            <summary>
            Checks whether the given resource has another element to iterate over.
            TRUE if there are more elements, FALSE if there is no more elements.
            </summary>
            <stable>ICU 3.8</stable>
        </member>
        <member name="M:ICU4N.Util.UResourceBundleEnumerator.MoveNext">
            <summary>
            Advances to the next element of this enumerator if this enumerator object has at least one more element to provide.
            </summary>
            <returns>true if another bundle is available; otherwise false.</returns>
            <stable>ICU 3.8</stable>
        </member>
        <member name="T:ICU4N.Util.UResourceTypeMismatchException">
            <summary>
            Exception thrown when the requested resource type 
            is not the same type as the available resource
            </summary>
            <author>ram</author>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Util.UResourceTypeMismatchException.#ctor(System.String)">
            <summary>
            Constuct the exception with the given message
            </summary>
            <param name="message">The error message for this exception.</param>
            <stable>ICU 3.0</stable>
        </member>
        <member name="T:ICU4N.Util.ValueEnumeratorElement">
            <summary>
            The return result container of each iteration. Stores the next
            integer index and its associated value Object.
            </summary>
            <remarks>
            NOTE: This is equivelent to ValueIterator.Element in ICU4J.
            </remarks>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.ValueEnumeratorElement.Integer">
            <summary>
            Integer index of the current iteration.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.ValueEnumeratorElement.Value">
            <summary>
            Gets the <see cref="T:System.Object"/> value associated with the integer index.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.ValueEnumeratorElement.#ctor">
            <summary>
            Empty default constructor.
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="T:ICU4N.Util.IValueEnumerator">
            <summary>
            Interface for enabling iteration over sets of &lt;int, object&gt;, where
            int is the sorted integer index in ascending order, and object its
            associated value.
            </summary>
            <remarks>
            The <see cref="T:ICU4N.Util.IValueEnumerator"/> allows iterations over integer indexes in the range
            of <see cref="F:System.Int32.MinValue"/> to <see cref="F:System.Int32.MaxValue"/> inclusive. Implementations of
            <see cref="T:ICU4N.Util.IValueEnumerator"/> should specify their own maximum subrange within the above
            range that is meaningful to its applications.
            <para/>
            Most implementations will be created by factory methods, such as the
            character name iterator in <see cref="M:ICU4N.UChar.GetNameEnumerator"/>. See example below.
            <para/>
            Example of use:
            <code>
            IValueEnumerator iterator = UChar.GetNameIterator();
            iterator.SetRange(UChar.MinValue, UChar.MaxValue);
            while (iterator.MoveNext())
            {
                Console.WriteLine("Codepoint \\u" +
                                    iterator.Current.Integer.ToHexString() +
                                    " has the character name " + (string)iterator.Current.Value);
            }
            </code>
            <para/>
            NOTE: This is equivalent to ValueIterator in ICU4J.
            </remarks>
            <author>synwee</author>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.IValueEnumerator.MoveNext">
            <summary>
            Returns the next result for this iteration and returns
            true if we are not at the end of the iteration, false otherwise.
            </summary>
            <returns>true if we are not at the end of the iteration, false otherwise.</returns>
            <seealso cref="T:ICU4N.Util.ValueEnumeratorElement"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.IValueEnumerator.Reset">
            <summary>
            Resets the iterator to start iterating from the integer index
            <see cref="F:System.Int32.MinValue"/> or X if a <c>SetRange(X, Y)</c> has been called previously.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.IValueEnumerator.SetRange(System.Int32,System.Int32)">
            <summary>
            Restricts the range of integers to iterate and resets the iteration
            to begin at the index argument start.
            </summary>
            <remarks>
            If <see cref="M:ICU4N.Util.IValueEnumerator.SetRange(System.Int32,System.Int32)"/> is not performed before <see cref="M:ICU4N.Util.IValueEnumerator.MoveNext"/> is
            called, the iteration will start from the integer index
            <see cref="F:System.Int32.MinValue"/> and end at <see cref="F:System.Int32.MaxValue"/>.
            <para/>
            If this range is set outside the meaningful range specified by the
            implementation, <see cref="M:ICU4N.Util.IValueEnumerator.MoveNext"/> will always return false.
            </remarks>
            <param name="start">First integer in the range to iterate.</param>
            <param name="limit">One more than the last integer in the range.</param>
            <exception cref="T:System.ArgumentException">Thrown when attempting to set an
            illegal range. E.g limit &lt;= start.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Util.VersionInfo">
            <summary>
            Class to store version numbers of the form major.minor.milli.micro.
            </summary>
            <author>synwee</author>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_1_0">
            <summary>
            Unicode 1.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_1_0_1">
            <summary>
            Unicode 1.0.1 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_1_1_0">
            <summary>
            Unicode 1.1.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_1_1_5">
            <summary>
            Unicode 1.1.5 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_2_0">
            <summary>
            Unicode 2.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_2_1_2">
            <summary>
            Unicode 2.1.2 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_2_1_5">
            <summary>
            Unicode 2.1.5 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_2_1_8">
            <summary>
            Unicode 2.1.8 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_2_1_9">
            <summary>
            Unicode 2.1.9 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_3_0">
            <summary>
            Unicode 3.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_3_0_1">
            <summary>
            Unicode 3.0.1 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_3_1_0">
            <summary>
            Unicode 3.1.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_3_1_1">
            <summary>
            Unicode 3.1.1 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_3_2">
            <summary>
            Unicode 3.2 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_4_0">
            <summary>
            Unicode 4.0 version
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_4_0_1">
            <summary>
            Unicode 4.0.1 version
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_4_1">
            <summary>
            Unicode 4.1 version
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_5_0">
            <summary>
            Unicode 5.0 version
            </summary>
            <stable>ICU 3.4</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_5_1">
            <summary>
            Unicode 5.1 version
            </summary>
            <stable>ICU 4.2</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_5_2">
            <summary>
            Unicode 5.2 version
            </summary>
            <stable>ICU 4.4</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_6_0">
            <summary>
            Unicode 6.0 version
            </summary>
            <stable>ICU 4.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_6_1">
            <summary>
            Unicode 6.1 version
            </summary>
            <stable>ICU 49</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_6_2">
            <summary>
            Unicode 6.2 version
            </summary>
            <stable>ICU 50</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_6_3">
            <summary>
            Unicode 6.3 version
            </summary>
            <stable>ICU 52</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_7_0">
            <summary>
            Unicode 7.0 version
            </summary>
            <stable>ICU 54</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_8_0">
            <summary>
            Unicode 8.0 version
            </summary>
            <stable>ICU 56</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_9_0">
            <summary>
            Unicode 9.0 version
            </summary>
            <stable>ICU 58</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_10_0">
            <summary>
            Unicode 10.0 version
            </summary>
            <stable>ICU 60</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.ICU_VERSION">
            <summary>
            ICU4N current release version
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.ICU_DATA_VERSION_PATH">
            <summary>
            Data version string for ICU's internal data.
            Used for appending to data path (e.g. icudt43b)
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.ICU_DATA_VERSION">
            <summary>
            Data version in ICU4N.
            </summary>
            <internal/>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UCOL_RUNTIME_VERSION">
            <summary>
            Collation runtime version (sort key generator, string comparisons).
            If the version is different, sort keys for the same string could be different.
            This value may change in subsequent releases of ICU.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UCOL_BUILDER_VERSION">
            <summary>
             Collation builder code version.
             When this is different, the same tailoring might result
             in assigning different collation elements to code points.
             This value may change in subsequent releases of ICU.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UCOL_TAILORINGS_VERSION">
            <summary>
            Constant version 1.
            This was intended to be the version of collation tailorings,
            but instead the tailoring data carries a version number.
            </summary>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInstance(System.String)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.
            or "major.minor.milli" or "major.minor" or "major",
            where major, minor, milli, micro are non-negative numbers
            &lt;= 255. If the trailing version numbers are
            not specified they are taken as 0s. E.g. Version "3.1" is
            equivalent to "3.1.0.0".</summary>
            <param name="version">Version string in the format of "major.minor.milli.micro"
            </param>
            <returns>An instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.</returns>
            <exception cref="T:System.ArgumentException">When the argument version is not in the right format.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInstance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.
            </summary>
            <param name="major">Major version, non-negative number &lt;= 255.</param>
            <param name="minor">Minor version, non-negative number &lt;= 255.</param>
            <param name="milli">Milli version, non-negative number &lt;= 255.</param>
            <param name="micro">Micro version, non-negative number &lt;= 255.</param>
            <returns>An instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the arguments' version.</returns>
            <exception cref="T:System.ArgumentException">When any argument is negative or &gt; 255.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInstance(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.
            Equivalent to <c>GetInstance(major, minor, milli, 0)</c>.
            </summary>
            <param name="major">Major version, non-negative number &lt;= 255.</param>
            <param name="minor">Minor version, non-negative number &lt;= 255.</param>
            <param name="milli">Milli version, non-negative number &lt;= 255.</param>
            <returns>An instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the arguments' version.</returns>
            <exception cref="T:System.ArgumentException">When any argument is negative or &gt; 255.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInstance(System.Int32,System.Int32)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.
            Equivalent to <c>GetInstance(major, minor, 0, 0)</c>.
            </summary>
            <param name="major">Major version, non-negative number &lt;= 255.</param>
            <param name="minor">Minor version, non-negative number &lt;= 255.</param>
            <returns>An instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the arguments' version.</returns>
            <exception cref="T:System.ArgumentException">When any argument is negative or &gt; 255.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInstance(System.Int32)">
            <summary>
            Returns an instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument version.
            Equivalent to <c>GetInstance(major, 0, 0, 0)</c>.
            </summary>
            <param name="major">Major version, non-negative number &lt;= 255.</param>
            <returns>An instance of <see cref="T:ICU4N.Util.VersionInfo"/> with the argument's version.</returns>
            <exception cref="T:System.ArgumentException">When any argument is negative or &gt; 255.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> representative of <see cref="T:ICU4N.Util.VersionInfo"/> in the format of
            "major.minor.milli.micro"
            </summary>
            <returns><see cref="T:System.String"/> representative of <see cref="T:ICU4N.Util.VersionInfo"/>.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.VersionInfo.Major">
            <summary>
            Gets the major version number.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.VersionInfo.Minor">
            <summary>
            Gets the minor version number.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.VersionInfo.Milli">
            <summary>
            Gets the milli version number.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Util.VersionInfo.Micro">
            <summary>
            Gets the micro version number.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.Equals(System.Object)">
            <summary>
            Checks if this version information is equals to the argument version
            </summary>
            <param name="other">Object to be compared.</param>
            <returns>true if other is equals to this object's version information,
            false otherwise.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetHashCode">
            <summary>
            Returns the hash code value for this set.
            </summary>
            <returns>The hash code value for this set.</returns>
            <seealso cref="M:System.Object.GetHashCode"/>
            <stable>ICU 58</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.CompareTo(ICU4N.Util.VersionInfo)">
            <summary>
            Compares other with this <see cref="T:ICU4N.Util.VersionInfo"/>.
            </summary>
            <param name="other"><see cref="T:ICU4N.Util.VersionInfo"/> to be compared.</param>
            <returns>
            0 if the argument is a <see cref="T:ICU4N.Util.VersionInfo"/> object that has version
            information equal to this object.
            Less than 0 if the argument is a <see cref="T:ICU4N.Util.VersionInfo"/> object that has
            version information greater than this object.
            Greater than 0 if the argument is a <see cref="T:ICU4N.Util.VersionInfo"/> object that
            has version information less than this object.
            </returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.UNICODE_VERSION">
            <summary>
            Unicode data version used by the current release.
            Defined here privately for printing by the <see cref="M:ICU4N.Util.VersionInfo.PrintVersionInfo(System.String[])"/> method in this class.
            Should be the same as <see cref="P:ICU4N.UChar.UnicodeVersion"/>
            which gets the version number from a data file.
            We do not want <see cref="T:ICU4N.Util.VersionInfo"/> to have an import dependency on <see cref="T:ICU4N.UChar"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.m_version_">
            <summary>
            Version number stored as a byte for each of the major, minor, milli and
            micro numbers in the 32 bit int.
            Most significant for the major and the least significant contains the
            micro numbers.
            </summary>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.MAP_">
            <summary>
            Map of singletons
            </summary>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.LAST_BYTE_MASK_">
            <summary>
            Last byte mask
            </summary>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.INVALID_VERSION_NUMBER_">
            <summary>
            Error statement string
            </summary>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.#cctor">
            <summary>
            Initialize versions only after <see cref="F:ICU4N.Util.VersionInfo.MAP_"/> has been created
            </summary>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.#ctor(System.Int32)">
            <summary>
            Constructor with <see cref="T:System.Int32"/>.
            </summary>
            <param name="compactversion">A 32 bit int with each byte representing a number.</param>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetInt32(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Int32"/> from the version numbers.
            </summary>
            <param name="major">Non-negative version number.</param>
            <param name="minor">Non-negative version number.</param>
            <param name="milli">Non-negative version number.</param>
            <param name="micro">Non-negative version number.</param>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.PrintVersionInfo(System.String[])">
            CLOVER:OFF
             <summary>
             Main method prints out ICU version information
             </summary>
             <param name="args">Arguments (currently not used).</param>
             <stable>ICU 4.6</stable>
        </member>
        <member name="M:ICU4N.Util.VersionInfo.GetVersionString(System.Int32,System.Int32)">
            <summary>
            Generate version string separated by dots with
            the specified digit width.  Version digit 0
            after <paramref name="minDigits"/> will be trimmed off.
            </summary>
            <param name="minDigits">Minimum number of version digits.</param>
            <param name="maxDigits">Maximum number of version digits.</param>
            <returns>A tailored version string.</returns>
            <internal/>
        </member>
        <member name="F:ICU4N.Util.VersionInfo.TZDATA_VERSION">
            CLOVER:ON
        </member>
    </members>
</doc>
